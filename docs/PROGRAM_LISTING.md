# Program Listing (By Module)

_Just the list. Generated on 2026-01-19._

## Root

- debug-routes.js
- FILE_STATUS_REPORT.txt
- package.json
- README.md
- render.yaml
- START_OLMS.bat
- tmp_replace.py
- vercel.json

## Backend - Core

- backend/app.js
- backend/diagnostic.js
- backend/fix-all-data.js
- backend/fix-json.js
- backend/recreate-transactions.js
- backend/server.js
- backend/test-login.ps1

## Backend - Adapters

- backend/adapters/DatabaseAdapter.js
- backend/adapters/MongoAdapter.js
- backend/adapters/OfflineMongoAdapter.js

## Backend - Data

- backend/data/annualSets.json
- backend/data/audit.json
- backend/data/bookCategories.json
- backend/data/books.json
- backend/data/notificationReads.json
- backend/data/notifications.json
- backend/data/settings.json
- backend/data/transactions.json
- backend/data/users.json
- backend/data/users.json.bak.1761951782238

## Backend - Middleware

- backend/middleware/customAuth.js

## Backend - Routes

- backend/routes/annualSets.js
- backend/routes/audit.js
- backend/routes/books.js
- backend/routes/curriculum.js
- backend/routes/customAuth.js
- backend/routes/departments.js
- backend/routes/locations.js
- backend/routes/notifications.js
- backend/routes/reports.js
- backend/routes/search.js
- backend/routes/settings.js
- backend/routes/students.js
- backend/routes/transactions.js
- backend/routes/transactions_fixed.js
- backend/routes/users.js

## Backend - Scripts

- backend/scripts/cleanup-email-verification.js
- backend/scripts/init-settings.js
- backend/scripts/migrate-offline-data-to-mongo.js
- backend/scripts/reset-and-seed-mongo.js
- backend/scripts/reset-offline-data.js
- backend/scripts/upload-sample-data.js

## Backend - Tests

- backend/test/qr.search.test.js
- backend/test/transactions.approve.test.js
- backend/test/transactions.filters.test.js
- backend/test/transactions.reject.test.js
- backend/test/transactions.request.test.js
- backend/test/users.test.js

## Backend - Utils

- backend/utils/auditLogger.js
- backend/utils/inventoryNotifications.js
- backend/utils/notificationChannels.js
- backend/utils/notificationCopy.js
- backend/utils/notificationUtils.js
- backend/utils/psgcClient.js
- backend/utils/settingsCache.js
- backend/utils/transactionIds.js
- backend/utils/userAttributes.js

## Frontend - Root

- frontend/craco.config.js
- frontend/orig_StudentImportDialog.js
- frontend/package.json

## Frontend - Public

- frontend/public/index.html
- frontend/public/manifest.json

## Frontend - Src (Core)

- frontend/src/App.js
- frontend/src/index.css
- frontend/src/index.js

## Frontend - Src Components

- frontend/src/components/Loading.js
- frontend/src/components/MobileScanButton.js
- frontend/src/components/MobileScanDialog.js
- frontend/src/components/QRScanner.js
- frontend/src/components/SplashScreen.js

### Frontend - Src Components/Auth

- frontend/src/components/Auth/ProtectedRoute.js

### Frontend - Src Components/Layout

- frontend/src/components/Layout/Layout.js
- frontend/src/components/Layout/MobileNavBar.js
- frontend/src/components/Layout/Sidebar.js

### Frontend - Src Components/Transactions

- frontend/src/components/Transactions/ApproveRequestDialog.js

## Frontend - Src Contexts

- frontend/src/contexts/AuthContext.js
- frontend/src/contexts/SettingsContext.js

## Frontend - Src Data

- frontend/src/data/addressOptions.js

## Frontend - Src Pages/Auth

- frontend/src/pages/Auth/LoginPage.js

## Frontend - Src Pages/Books

- frontend/src/pages/Books/BookCopies.js
- frontend/src/pages/Books/BookDetails.js
- frontend/src/pages/Books/BookForm.js
- frontend/src/pages/Books/BookImportDialog.js
- frontend/src/pages/Books/BooksList.js

## Frontend - Src Pages/Dashboard

- frontend/src/pages/Dashboard/AdminDashboard.js
- frontend/src/pages/Dashboard/LibrarianDashboard.js
- frontend/src/pages/Dashboard/StaffDashboard.js
- frontend/src/pages/Dashboard/StudentDashboard.js

## Frontend - Src Pages/Error

- frontend/src/pages/Error/NotFoundPage.js
- frontend/src/pages/Error/UnauthorizedPage.js

## Frontend - Src Pages/Notifications

- frontend/src/pages/Notifications/NotificationsPage.js

## Frontend - Src Pages/Reports

- frontend/src/pages/Reports/AuditLogs.js
- frontend/src/pages/Reports/ReportsPage.js

## Frontend - Src Pages/Search

- frontend/src/pages/Search/SearchResults.js

## Frontend - Src Pages/Settings

- frontend/src/pages/Settings/SettingsPage.js

## Frontend - Src Pages/Students

- frontend/src/pages/Students/StudentForm.js
- frontend/src/pages/Students/StudentImportDialog.js
- frontend/src/pages/Students/StudentsList.js

## Frontend - Src Pages/Transactions

- frontend/src/pages/Transactions/AnnualBorrowing.js
- frontend/src/pages/Transactions/BorrowForm.js
- frontend/src/pages/Transactions/RequestsPage.js
- frontend/src/pages/Transactions/ReturnForm.js
- frontend/src/pages/Transactions/TransactionDetails.js
- frontend/src/pages/Transactions/TransactionsList.js

## Frontend - Src Pages/Users

- frontend/src/pages/Users/UserForm.js
- frontend/src/pages/Users/UserProfile.js
- frontend/src/pages/Users/UsersList.js

## Frontend - Src Theme

- frontend/src/theme/actionButtons.js
- frontend/src/theme/customTheme.js

## Frontend - Src Utils

- frontend/src/utils/addressService.js
- frontend/src/utils/api.js
- frontend/src/utils/authorDisplay.js
- frontend/src/utils/currency.js
- frontend/src/utils/media.js
- frontend/src/utils/pdfGenerator.js
- frontend/src/utils/scanEvents.js
- frontend/src/utils/userAttributes.js

### Frontend - Src Utils Tests

- frontend/src/utils/__tests__/userAttributes.test.js

## Docs

- docs/COMPOSITION.md
- docs/INSTALLATION_GUIDE.md
- docs/MODULE_PROGRAMS_TABLE.md
- docs/PROGRAM_LISTING.generated.md
- docs/PROGRAM_LISTING.md

## Scripts

- scripts/generate_program_listing.py
- scripts/keep-alive.js

<!--
_Formatted to match the program-listing template. Generated on 2026-01-19 09:09:50Z UTC._

# Backend - Adapters

## DatabaseAdapter.js

| Field | Details |
| --- | --- |
| Program Name | DatabaseAdapter.js |
| Description | Database adapter layer for storage operations. |
| Called by | app.js, cleanup-email-verification.js, init-settings.js, migrate-offline-data-to-mongo.js, server.js |
| Table used | None |
|  |  |
| Programmer | Nazel Asca√±o |
| Date created | 12/14/2025 |
| Revision Date | TBD |
| Revision / description of change | None |

```javascript
const OfflineMongoAdapter = require('./OfflineMongoAdapter');
const MongoAdapter = require('./MongoAdapter');

class DatabaseAdapter {
  constructor() {
    const useOfflineFlag = (process.env.USE_OFFLINE_DB || '').trim().toLowerCase();
    const forceOffline = useOfflineFlag === 'true' || useOfflineFlag === '1' || useOfflineFlag === 'yes';
    const mongoUri = process.env.MONGO_URI || process.env.MONGODB_URI || '';
    const mongoDbName = process.env.MONGO_DB_NAME || process.env.MONGODB_DB_NAME || process.env.DB_NAME || undefined;
    const hasMongoUri = Boolean(mongoUri);

    if (!forceOffline && hasMongoUri) {
      this.adapter = new MongoAdapter(mongoUri, mongoDbName);
      this.adapterType = 'mongo';
    } else {
      this.adapter = new OfflineMongoAdapter();
      this.adapterType = 'offline';
    }

    this.initialized = false;
  }

  getType() {
    return this.adapterType;
  }

  async connect() {

    try {
      const result = await this.adapter.connect();
      return result;
    } catch (err) {

      if (this.adapterType === 'offline') {
        throw err;
      }

      console.warn('‚ö†Ô∏è MongoDB connection failed, switching to offline datastore.');
      console.warn('Mongo error:', err && err.message ? err.message : err);

      try {
        this.adapter = new OfflineMongoAdapter();
        this.adapterType = 'offline';
        const fallbackResult = await this.adapter.connect();
        console.log('‚úÖ Switched to offline datastore');
        return fallbackResult;
      } catch (fallbackErr) {
        console.error('‚ùå Failed to initialize offline datastore after Mongo failure:', fallbackErr && fallbackErr.message ? fallbackErr.message : fallbackErr);

        throw fallbackErr || err;
      }
    }
  }

  async initialize() {
    if (this.initialized) return;
    if (typeof this.adapter.initialize === 'function') {
      await this.adapter.initialize();
    }
    this.initialized = true;
  }

  async findUserByUsername(username) {
    return await this.adapter.findUserByUsername(username);
  }

  async findUserByEmail(email) {
    return await this.adapter.findUserByEmail(email);
  }

  async findUserById(id) {
    return await this.adapter.findUserById(id);
  }

  async createUser(userData) {
    return await this.adapter.createUser(userData);
  }

  async updateUser(id, updates) {
    return await this.adapter.updateUser(id, updates);
  }

  async deleteUser(id) {
    return await this.adapter.deleteUser(id);
  }

  async getAllUsers(filters = {}) {
    return await this.adapter.getAllUsers(filters);
  }

  async getUsers(filters = {}) {
    return await this.adapter.getUsers(filters);
  }

  async findInCollection(collectionName, query = {}) {
    return await this.adapter.findInCollection(collectionName, query);
  }

  async findOneInCollection(collectionName, query) {
    return await this.adapter.findOneInCollection(collectionName, query);
  }

  async insertIntoCollection(collectionName, document) {
    return await this.adapter.insertIntoCollection(collectionName, document);
  }

  async updateInCollection(collectionName, query, update) {
    return await this.adapter.updateInCollection(collectionName, query, update);
  }

  async deleteFromCollection(collectionName, query) {
    return await this.adapter.deleteFromCollection(collectionName, query);
  }

  async createAuditLog(logData) {
    if (typeof this.adapter.createAuditLog !== 'function') {
      throw new Error('Audit logging not supported by current adapter');
    }
    return await this.adapter.createAuditLog(logData);
  }

  async getUserStats() {
    return await this.adapter.getUserStats();
  }

  async testConnection() {
    return await this.adapter.testConnection();
  }
}

module.exports = DatabaseAdapter;
```

## MongoAdapter.js

| Field | Details |
| --- | --- |
| Program Name | MongoAdapter.js |
| Description | Database adapter layer for storage operations. |
| Called by | DatabaseAdapter.js |
| Table used | None |
|  |  |
| Programmer | Nazel Asca√±o |
| Date created | 12/14/2025 |
| Revision Date | TBD |
| Revision / description of change | None |

```javascript
const { MongoClient, ObjectId } = require('mongodb');
const bcrypt = require('bcrypt');

class MongoAdapter {
	constructor(uri, dbName) {
		this.uri = uri;
		this.dbName = this.resolveDatabaseName(uri, dbName);
		this.client = null;
		this.db = null;
		this.initialized = false;
		this.requiredCollections = [
			'users',
			'books',
			'transactions',
			'settings',
			'audit',
			'annualSets',
			'notificationReads'
		];
	}

	resolveDatabaseName(uri, providedName) {
		if (providedName) {
			return providedName;
		}

		if (!uri) {
			return 'olms';
		}

		const sanitized = uri.replace(/^mongodb(\+srv)?:\/\//i, '');
		const slashIndex = sanitized.indexOf('/');
		if (slashIndex === -1) {
			return 'olms';
		}

		const path = sanitized.substring(slashIndex + 1);
		if (!path) {
			return 'olms';
		}

		const dbName = path.split('?')[0].trim();
		return dbName || 'olms';
	}

	async connect() {
		if (this.db) {
			return this.db;
		}

		if (!this.uri) {
			throw new Error('MONGO_URI is not configured. Set it in the environment to enable MongoDB mode.');
		}

		const timeout = Number(process.env.MONGO_CONNECT_TIMEOUT_MS || 0) || 5000;
		this.client = new MongoClient(this.uri, {
			serverSelectionTimeoutMS: timeout
		});

		await this.client.connect();
		this.db = this.client.db(this.dbName);
		await this.ensureCollections();
		return this.db;
	}

	async ensureCollections() {
		if (!this.db) {
			return;
		}

		const existing = new Set(
			(await this.db.listCollections({}, { nameOnly: true }).toArray()).map(entry => entry.name)
		);

		for (const name of this.requiredCollections) {
			if (!existing.has(name)) {
				await this.db.createCollection(name);
			}
		}
	}

	normalizeDocument(doc) {
		if (!doc) {
			return null;
		}

		const normalized = { ...doc };
		if (normalized._id instanceof ObjectId) {
			normalized._id = normalized._id.toString();
		}
		if (normalized.id instanceof ObjectId) {
			normalized.id = normalized.id.toString();
		}
		return normalized;
	}

	buildFilter(query = {}) {
		const filter = {};

			Object.entries(query || {}).forEach(([key, value]) => {
			if (value === undefined) {
				return;
			}

				if (key === '$or' || key === '$and') {
					if (Array.isArray(value)) {
						filter[key] = value
							.filter(Boolean)
							.map(condition => this.buildFilter(condition));
					}
					return;
				}

			if (key === '_id') {
				if (ObjectId.isValid(value)) {
					filter._id = new ObjectId(value);
				} else {
					filter._id = value;
				}
				return;
			}

			filter[key] = value;
		});

		return filter;
	}

	buildIdFilter(id) {
		if (!id) {
			return null;
		}

		const candidates = [];

		if (typeof id === 'string') {
			candidates.push({ _id: id });
			candidates.push({ id });
			if (ObjectId.isValid(id)) {
				candidates.push({ _id: new ObjectId(id) });
			}
		} else if (id instanceof ObjectId) {
			candidates.push({ _id: id });
			candidates.push({ id: id.toString() });
		}

			if (candidates.length === 0) {
				return null;
			}

			return { $or: candidates };
	}

	prepareUpdatePayload(update = {}) {
		const payload = { ...update };
		if (!Object.prototype.hasOwnProperty.call(payload, 'updatedAt')) {
			payload.updatedAt = new Date();
		}
		return payload;
	}

	ensureDateFields(document) {
		const prepared = { ...document };
		if (prepared.createdAt && !(prepared.createdAt instanceof Date)) {
			prepared.createdAt = new Date(prepared.createdAt);
		}
		if (prepared.updatedAt && !(prepared.updatedAt instanceof Date)) {
			prepared.updatedAt = new Date(prepared.updatedAt);
		}
		return prepared;
	}

	async initialize() {
		if (this.initialized) {
			return;
		}

		await this.connect();

		const usersCollection = this.db.collection('users');

		await usersCollection.createIndex({ username: 1 }, { unique: true, sparse: true }).catch(() => {});
		await usersCollection.createIndex({ email: 1 }, { sparse: true }).catch(() => {});

		const adminUser = await usersCollection.findOne({ username: 'admin' });
		if (!adminUser) {
			const hashedPassword = await bcrypt.hash('admin123456', 10);
			const adminDocument = {
				_id: new ObjectId(),
				id: undefined,
				username: 'admin',
				email: 'admin@olms.com',
				password: hashedPassword,
				firstName: 'System',
				lastName: 'Administrator',
				role: 'admin',
				isActive: true,
				profile: {
					phone: '000-000-0000',
					address: 'System',
					dateOfBirth: new Date('1990-01-01T00:00:00.000Z')
				},
				library: {
					cardNumber: 'ADMIN-001',
					membershipDate: new Date(),
					borrowingLimit: 999,
					fineBalance: 0
				},
				borrowingStats: {
					totalBorrowed: 0,
					currentlyBorrowed: 0,
					totalFines: 0,
					totalReturned: 0
				},
				createdAt: new Date(),
				updatedAt: new Date()
			};

			adminDocument.id = adminDocument._id.toString();

			await usersCollection.insertOne(adminDocument);
			console.log('‚úÖ Default admin user created for MongoDB: admin/admin123456');
		}

		this.initialized = true;
	}

	async findInCollection(collectionName, query = {}) {
		await this.connect();
		const filter = this.buildFilter(query);
		const documents = await this.db.collection(collectionName).find(filter).toArray();
		return documents.map(doc => this.normalizeDocument(doc));
	}

	async findOneInCollection(collectionName, query) {
		await this.connect();
		const filter = this.buildFilter(query);
		const document = await this.db.collection(collectionName).findOne(filter);
		return this.normalizeDocument(document);
	}

	async insertIntoCollection(collectionName, document) {
		await this.connect();
		const payload = this.ensureDateFields({ ...document });

		if (payload._id && typeof payload._id === 'string' && ObjectId.isValid(payload._id)) {
			payload._id = new ObjectId(payload._id);
		}

		if (!payload._id) {
			payload._id = new ObjectId();
		}

		if (!Object.prototype.hasOwnProperty.call(payload, 'createdAt')) {
			payload.createdAt = new Date();
		}

		payload.updatedAt = payload.updatedAt ? new Date(payload.updatedAt) : new Date();

		if (!payload.id) {
			payload.id = payload._id instanceof ObjectId ? payload._id.toString() : String(payload._id);
		}

		await this.db.collection(collectionName).insertOne(payload);
		return this.normalizeDocument(payload);
	}

	async updateInCollection(collectionName, query, update) {
		await this.connect();
		const filter = this.buildFilter(query);
		const payload = this.prepareUpdatePayload(update);
		const options = { returnDocument: 'after' };

		const result = await this.db.collection(collectionName).findOneAndUpdate(
			filter,
			{ $set: this.ensureDateFields(payload) },
			options
		);

		return this.normalizeDocument(result.value);
	}

	async deleteFromCollection(collectionName, query) {
		await this.connect();
		const filter = this.buildFilter(query);
		const result = await this.db.collection(collectionName).findOneAndDelete(filter);
		return this.normalizeDocument(result ? result.value : null);
	}

	async findUserByUsername(username) {
		await this.connect();
		const user = await this.db.collection('users').findOne({ username });
		return this.normalizeDocument(user);
	}

	async findUserByEmail(email) {
		await this.connect();
		const user = await this.db.collection('users').findOne({ email });
		return this.normalizeDocument(user);
	}

	async findUserById(id) {
		await this.connect();
		const filter = this.buildIdFilter(id);
		if (!filter) {
			return null;
		}
		const user = await this.db.collection('users').findOne(filter);
		return this.normalizeDocument(user);
	}

	async createUser(userData) {
		return await this.insertIntoCollection('users', userData);
	}

	async updateUser(id, updates) {
		const filter = this.buildIdFilter(id) || this.buildFilter({ _id: id });
		return await this.updateInCollection('users', filter.$or ? filter : { _id: id }, updates);
	}

	async deleteUser(id) {
		const filter = this.buildIdFilter(id) || this.buildFilter({ _id: id });
		return await this.deleteFromCollection('users', filter.$or ? filter : { _id: id });
	}

	async getAllUsers(filters = {}) {
		return await this.findInCollection('users', filters);
	}

	async getUsers(filters = {}) {
		return await this.getAllUsers(filters);
	}

	async createAuditLog(logData) {
		await this.connect();
		if (!logData || typeof logData !== 'object') {
			throw new Error('Invalid audit log payload');
		}

		const entry = { ...logData };
		entry.timestamp = entry.timestamp ? new Date(entry.timestamp) : new Date();
		entry.createdAt = entry.createdAt ? new Date(entry.createdAt) : new Date();
		entry.updatedAt = entry.updatedAt ? new Date(entry.updatedAt) : new Date();

		if (entry._id && typeof entry._id === 'string' && ObjectId.isValid(entry._id)) {
			entry._id = new ObjectId(entry._id);
		}

		if (!entry._id) {
			entry._id = new ObjectId();
		}

		if (!entry.id) {
			entry.id = entry._id.toString();
		}

		await this.db.collection('audit').insertOne(entry);
		return this.normalizeDocument(entry);
	}

	async getUserStats() {
		await this.connect();
		const results = await this.db.collection('users').aggregate([
			{
				$group: {
					_id: '$role',
					count: { $sum: 1 },
					active: {
						$sum: {
							$cond: [{ $eq: ['$isActive', true] }, 1, 0]
						}
					}
				}
			}
		]).toArray();

		const total = results.reduce((acc, entry) => acc + entry.count, 0);
		const active = results.reduce((acc, entry) => acc + (entry.active || 0), 0);
		const inactive = total - active;

		return {
			total,
			active,
			inactive,
			byRole: results.map(entry => ({
				_id: entry._id || 'unknown',
				count: entry.count,
				active: entry.active || 0
			}))
		};
	}

	async testConnection() {
		try {
			await this.connect();
			const commandResult = await this.db.command({ ping: 1 });
			const userCount = await this.db.collection('users').countDocuments();
			return {
				success: Boolean(commandResult && commandResult.ok === 1),
				type: 'MongoDB',
				userCount,
				database: this.dbName,
				uri: this.uri,
				timestamp: new Date()
			};
		} catch (error) {
			return {
				success: false,
				type: 'MongoDB',
				error: error.message,
				timestamp: new Date()
			};
		}
	}

	async close() {
		if (this.client) {
			await this.client.close();
			this.client = null;
			this.db = null;
			this.initialized = false;
		}
	}
}

module.exports = MongoAdapter;
```

## OfflineMongoAdapter.js

| Field | Details |
| --- | --- |
| Program Name | OfflineMongoAdapter.js |
| Description | Database adapter layer for storage operations. |
| Called by | DatabaseAdapter.js |
| Table used | None |
|  |  |
| Programmer | Nazel Asca√±o |
| Date created | 12/14/2025 |
| Revision Date | TBD |
| Revision / description of change | None |

```javascript
const fs = require('fs').promises;
const path = require('path');

const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

class OfflineMongoAdapter {
  constructor() {
    this.dataDir = path.join(__dirname, '../data');
    this.collections = {
      users: 'users.json',
      books: 'books.json',
      bookCategories: 'bookCategories.json',
      transactions: 'transactions.json',
      notifications: 'notifications.json',
      notificationReads: 'notificationReads.json',
      settings: 'settings.json',
      audit: 'audit.json',
      annualSets: 'annualSets.json'
    };
    this.initialized = false;
    this.collectionLocks = new Map();
  }

  async connect() {
    try {
      console.log('üîÑ Initializing offline MongoDB-compatible database...');

      await this.ensureDataDirectory();

      await this.initializeCollections();

      console.log('‚úÖ Offline database connected successfully');
      console.log('üìÅ Database location:', this.dataDir);

      return true;
    } catch (error) {
      console.error('‚ùå Offline database initialization failed:', error.message);
      throw error;
    }
  }

  async ensureDataDirectory() {
    try {
      await fs.access(this.dataDir);
    } catch (error) {

      await fs.mkdir(this.dataDir, { recursive: true });
      console.log('üìÅ Created database directory:', this.dataDir);
    }
  }

  async initializeCollections() {
    for (const [collectionName, fileName] of Object.entries(this.collections)) {
      const filePath = path.join(this.dataDir, fileName);
      try {
        await fs.access(filePath);
        console.log(`‚úÖ Collection '${collectionName}' already exists`);
      } catch (error) {

        await fs.writeFile(filePath, JSON.stringify([], null, 2));
        console.log(`üìÑ Created collection '${collectionName}'`);
      }
    }
  }

  async initialize() {
    if (this.initialized) return;

    try {

      const users = await this.findInCollection('users', { username: 'admin' });

      if (users.length === 0) {

        const bcrypt = require('bcrypt');
        const hashedPassword = await bcrypt.hash('admin123456', 10);

        const adminUser = {
          _id: this.generateObjectId(),
          username: 'admin',
          email: 'admin@olms.com',
          password: hashedPassword,
          firstName: 'System',
          lastName: 'Administrator',
          role: 'admin',
          isActive: true,
          profile: {
            phone: '000-000-0000',
            address: 'System',
            dateOfBirth: new Date('1990-01-01')
          },
          library: {
            cardNumber: 'ADMIN-001',
            membershipDate: new Date(),
            borrowingLimit: 999,
            fineBalance: 0
          },
          borrowingStats: {
            totalBorrowed: 0,
            currentlyBorrowed: 0,
            totalFines: 0,
            totalReturned: 0
          },
          createdAt: new Date(),
          updatedAt: new Date()
        };

        await this.insertIntoCollection('users', adminUser);
        console.log('‚úÖ Default admin user created: admin/admin123456');
      } else {
        console.log('‚úÖ Admin user already exists');
      }

      this.initialized = true;
    } catch (error) {
      console.error('‚ùå Error initializing offline database:', error);
      throw error;
    }
  }

  async withCollectionLock(collectionName, handler) {
    if (typeof handler !== 'function') {
      throw new Error('withCollectionLock requires a handler function');
    }

    const key = this.collections[collectionName] || collectionName;
    const previous = this.collectionLocks.get(key) || Promise.resolve();
    const runPromise = previous
      .catch(() => {})
      .then(() => handler());

    const trackingPromise = runPromise
      .catch(() => {})
      .finally(() => {
        if (this.collectionLocks.get(key) === trackingPromise) {
          this.collectionLocks.delete(key);
        }
      });

    this.collectionLocks.set(key, trackingPromise);
    return runPromise;
  }

  async readCollection(collectionName) {
    const fileName = this.collections[collectionName];
    if (!fileName) throw new Error(`Unknown collection: ${collectionName}`);

    const filePath = path.join(this.dataDir, fileName);
    try {
      return await this.readJsonFileSafely(filePath);
    } catch (error) {
      console.error(`Error reading collection ${collectionName}:`, error);
      return [];
    }
  }

  async readJsonFileSafely(filePath, attempts = 4, initialDelayMs = 10) {
    let lastError = null;
    for (let attempt = 0; attempt < attempts; attempt += 1) {
      try {
        const raw = await fs.readFile(filePath, 'utf8');
        const trimmed = typeof raw === 'string' ? raw.trim() : '';
        if (!trimmed) {
          return [];
        }
        return JSON.parse(trimmed);
      } catch (error) {
        lastError = error;
        if (error && error.code === 'ENOENT') {
          return [];
        }
        const isParseError = error instanceof SyntaxError || /JSON/i.test(error?.message || '');
        if (!isParseError || attempt === attempts - 1) {
          throw error;
        }
        const delay = initialDelayMs * (attempt + 1);
        await sleep(delay);
      }
    }
    throw lastError;
  }

  async writeCollection(collectionName, data) {
    const fileName = this.collections[collectionName];
    if (!fileName) throw new Error(`Unknown collection: ${collectionName}`);

    const filePath = path.join(this.dataDir, fileName);
    const tempPath = `${filePath}.tmp-${process.pid}-${Date.now()}`;
    const payload = JSON.stringify(data, null, 2);

    try {
      await fs.writeFile(tempPath, payload, 'utf8');
      await fs.rename(tempPath, filePath);
    } catch (error) {
      console.error(`Error writing collection ${collectionName}:`, error);
      try {
        await fs.unlink(tempPath);
      } catch (cleanupError) {

      }
      throw error;
    }
  }

  async findInCollection(collectionName, query = {}) {
    const data = await this.readCollection(collectionName);

    if (Object.keys(query).length === 0) {
      return data; // Return all if no query
    }

    return data.filter(item => {
      return Object.keys(query).every(key => {
        if (key.includes('.')) {

          const keys = key.split('.');
          let value = item;
          for (const k of keys) {
            value = value && value[k];
          }
          return value === query[key];
        }
        return item[key] === query[key];
      });
    });
  }

  async findOneInCollection(collectionName, query) {
    const results = await this.findInCollection(collectionName, query);
    return results.length > 0 ? results[0] : null;
  }

  async insertIntoCollection(collectionName, document) {
    return this.withCollectionLock(collectionName, async () => {
      const data = await this.readCollection(collectionName);

      if (!document._id) {
        document._id = this.generateObjectId();
      }

      document.createdAt = document.createdAt || new Date();
      document.updatedAt = new Date();

      data.push(document);
      await this.writeCollection(collectionName, data);

      return document;
    });
  }

  async updateInCollection(collectionName, query, update) {
    return this.withCollectionLock(collectionName, async () => {
      const data = await this.readCollection(collectionName);
      let updated = null;

      for (let i = 0; i < data.length; i++) {
        const item = data[i];
        const matches = Object.keys(query).every(key => item[key] === query[key]);

        if (matches) {
          data[i] = { ...item, ...update, updatedAt: new Date() };
          updated = data[i];
          break;
        }
      }

      if (updated) {
        await this.writeCollection(collectionName, data);
      }

      return updated;
    });
  }

  async deleteFromCollection(collectionName, query) {
    return this.withCollectionLock(collectionName, async () => {
      const data = await this.readCollection(collectionName);
      let deleted = null;

      for (let i = 0; i < data.length; i++) {
        const item = data[i];
        const matches = Object.keys(query).every(key => item[key] === query[key]);

        if (matches) {
          deleted = data.splice(i, 1)[0];
          break;
        }
      }

      if (deleted) {
        await this.writeCollection(collectionName, data);
      }

      return deleted;
    });
  }

  async findUserByUsername(username) {
    return await this.findOneInCollection('users', { username });
  }

  async findUserByEmail(email) {
    return await this.findOneInCollection('users', { email });
  }

  async findUserById(id) {
    return await this.findOneInCollection('users', { _id: id });
  }

  async createUser(userData) {
    return await this.insertIntoCollection('users', userData);
  }

  async updateUser(id, updates) {
    return await this.updateInCollection('users', { _id: id }, updates);
  }

  async deleteUser(id) {
    return await this.deleteFromCollection('users', { _id: id });
  }

  async getAllUsers(filters = {}) {
    return await this.findInCollection('users', filters);
  }

  async getUsers(filters = {}) {
    return this.getAllUsers(filters);
  }

  generateObjectId() {
    return Date.now().toString(36) + Math.random().toString(36).substr(2, 5);
  }

  async createAuditLog(logData) {
    if (!logData || typeof logData !== 'object') {
      throw new Error('Invalid audit log payload');
    }

    const objectId = logData._id || this.generateObjectId();
    const entryId = logData.id || objectId;

    const entry = {
      ...logData,
      id: entryId,
      _id: objectId,
      timestamp: logData.timestamp ? new Date(logData.timestamp) : new Date(),
      createdAt: new Date(),
      updatedAt: new Date()
    };

    return this.withCollectionLock('audit', async () => {
      const logs = await this.readCollection('audit');
      logs.push(entry);

      logs.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

      const MAX_LOGS = 1000;
      const trimmed = logs.slice(-MAX_LOGS);

      await this.writeCollection('audit', trimmed);

      return entry;
    });
  }

  async testConnection() {
    try {
      const userCount = (await this.readCollection('users')).length;
      return {
        success: true,
        type: 'Offline MongoDB-Compatible',
        userCount,
        dataLocation: this.dataDir,
        timestamp: new Date()
      };
    } catch (error) {
      return {
        success: false,
        type: 'Offline MongoDB-Compatible',
        error: error.message,
        timestamp: new Date()
      };
    }
  }

  async getUserStats() {
    try {
      const users = await this.readCollection('users');
      const stats = {};

      users.forEach(user => {
        const role = user.role || 'unknown';
        if (!stats[role]) {
          stats[role] = { count: 0, active: 0 };
        }
        stats[role].count++;
        if (user.isActive) {
          stats[role].active++;
        }
      });

      return {
        total: users.length,
        active: users.filter(u => u.isActive).length,
        inactive: users.filter(u => !u.isActive).length,
        byRole: Object.keys(stats).map(role => ({
          _id: role,
          count: stats[role].count,
          active: stats[role].active
        }))
      };
    } catch (error) {
      console.error('Error getting user stats:', error);
      throw error;
    }
  }
}

module.exports = OfflineMongoAdapter;
```

# Backend - Core

## app.js

| Field | Details |
| --- | --- |
| Program Name | app.js |
| Description | Express application configuration and middleware setup. |
| Called by | server.js |
| Table used | None |
|  |  |
| Programmer | Nazel Asca√±o |
| Date created | 12/14/2025 |
| Revision Date | TBD |
| Revision / description of change | None |

```javascript
const express = require('express');
const cors = require('cors');
const cookieParser = require('cookie-parser');
const morgan = require('morgan');
const path = require('path');
const os = require('os');
const DatabaseAdapter = require('./adapters/DatabaseAdapter');
require('dotenv').config();

const app = express();

const dbAdapter = new DatabaseAdapter();
app.set('dbAdapter', dbAdapter);

app.use((req, res, next) => {
  req.dbAdapter = dbAdapter;
  next();
});

const frontendPort = Number(process.env.FRONTEND_PORT || process.env.DEV_SERVER_PORT || 3001);

const getLanOrigins = (port) => {
  const interfaces = os.networkInterfaces();
  const lanOrigins = new Set();

  Object.values(interfaces).forEach((addresses = []) => {
    addresses.forEach((address) => {
      if (!address || address.internal || address.family !== 'IPv4') {
        return;
      }
      lanOrigins.add(`http://${address.address}:${port}`);
    });
  });

  return Array.from(lanOrigins);
};

const devFallbackOrigins = [
  'http://localhost:3000',
  'http://localhost:3001',
  'http://127.0.0.1:3000',
  'http://127.0.0.1:3001',
  ...getLanOrigins(frontendPort),
];
const explicitOriginList = (process.env.CORS_ORIGINS || '')
  .split(',')
  .map((origin) => origin.trim())
  .filter(Boolean);

const derivedFallbackOrigins = [];
if (process.env.FRONTEND_URL) {
  derivedFallbackOrigins.push(process.env.FRONTEND_URL.trim());
}

const resolvedOrigins = Array.from(new Set([
  ...explicitOriginList,
  ...derivedFallbackOrigins,
  ...devFallbackOrigins,
])).filter(Boolean);

const allowAllInDev = (process.env.NODE_ENV || '').trim() !== 'production';

const escapeRegex = (value = '') => value.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');

const originMatchers = resolvedOrigins.map((entry) => {
  if (!entry) {
    return null;
  }
  if (entry.includes('*')) {
    const regexPattern = `^${escapeRegex(entry).replace(/\\\*/g, '.*')}$`;
    return { type: 'wildcard', regex: new RegExp(regexPattern) };
  }
  return { type: 'exact', value: entry };
}).filter(Boolean);

const isOriginAllowed = (origin) => {
  if (!originMatchers.length) {
    return false;
  }
  return originMatchers.some((matcher) => {
    if (matcher.type === 'wildcard') {
      return matcher.regex.test(origin);
    }
    return matcher.value === origin;
  });
};

app.use(cors({
  origin(origin, callback) {
    if (!origin) {
      return callback(null, true);
    }
    if (isOriginAllowed(origin)) {
      return callback(null, true);
    }
    if (allowAllInDev) {
      return callback(null, true);
    }
    return callback(new Error(`Not allowed by CORS: ${origin}`));
  },
  credentials: true,
  exposedHeaders: ['x-session-refresh', 'x-session-refresh-lifetime'],
}));

app.use(cookieParser());

app.use(morgan('combined'));
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true, limit: '10mb' }));

app.use('/uploads', express.static(path.join(__dirname, 'uploads')));

const authRoutes = require('./routes/customAuth');
const userRoutes = require('./routes/users');
const studentRoutes = require('./routes/students');
const bookRoutes = require('./routes/books');
const transactionRoutes = require('./routes/transactions');
const reportRoutes = require('./routes/reports');
const settingsRoutes = require('./routes/settings');
const auditRoutes = require('./routes/audit');
const curriculumRoutes = require('./routes/curriculum');
const annualSetsRoutes = require('./routes/annualSets');
const searchRoutes = require('./routes/search');
const notificationRoutes = require('./routes/notifications');
const locationRoutes = require('./routes/locations');

app.use('/api/auth', authRoutes);
app.use('/api/users', userRoutes);
app.use('/api/students', studentRoutes);
app.use('/api/books', bookRoutes);
app.use('/api/transactions', transactionRoutes);
app.use('/api/reports', reportRoutes);
app.use('/api/settings', settingsRoutes);
app.use('/api/audit', auditRoutes);
app.use('/api/curriculum', curriculumRoutes);
app.use('/api/annual-sets', annualSetsRoutes);
app.use('/api/search', searchRoutes);
app.use('/api/notifications', notificationRoutes);
app.use('/api/locations', locationRoutes);

app.get('/health', async(req, res) => {
  try {
    const dbStatus = await dbAdapter.testConnection();
    res.json({ status: 'OK', timestamp: new Date(), database: dbStatus });
  } catch (error) {
    res.status(500).json({ status: 'ERROR', error: error.message, timestamp: new Date() });
  }
});

app.get('/', (req, res) => {
  res.json({ message: 'OLMS Backend API', status: 'Running', timestamp: new Date() });
});

app.use((err, req, res, next) => {
  console.error(err.stack);
  res.status(500).json({ message: 'Something went wrong!', error: process.env.NODE_ENV === 'development' ? err.message : {} });
});

app.use('*', (req, res) => {
  res.status(404).json({ message: 'Route not found' });
});

module.exports = app;
module.exports.dbAdapter = dbAdapter;
```

## diagnostic.js

| Field | Details |
| --- | --- |
| Program Name | diagnostic.js |
| Description | Source file located at backend/diagnostic.js. |
| Called by | None |
| Table used | None |
|  |  |
| Programmer | Nazel Asca√±o |
| Date created | 12/14/2025 |
| Revision Date | TBD |
| Revision / description of change | None |

```javascript
const express = require('express');
const app = express();
const PORT = 5001;

console.log('Starting diagnostic server...');

app.use(express.json());

app.get('/', (req, res) => {
    console.log('GET / request received');
    res.json({ message: 'Diagnostic server working!' });
});

app.post('/test', (req, res) => {
    console.log('POST /test request received:', req.body);
    res.json({ received: req.body });
});

const server = app.listen(PORT, '0.0.0.0', () => {
    console.log(`‚úÖ Diagnostic server listening on ALL interfaces at port ${PORT}`);
    console.log(`Test at: http://localhost:${PORT}`);
});

server.on('error', (err) => {
    console.error('‚ùå Server error:', err);
});

process.on('SIGTERM', () => {
    console.log('Received SIGTERM, shutting down gracefully');
    server.close();
});

process.on('SIGINT', () => {
    console.log('Received SIGINT, shutting down gracefully');
    server.close();
});

console.log('Server setup complete');
```

## fix-all-data.js

| Field | Details |
| --- | --- |
| Program Name | fix-all-data.js |
| Description | Source file located at backend/fix-all-data.js. |
| Called by | None |
| Table used | None |
|  |  |
| Programmer | Nazel Asca√±o |
| Date created | 12/14/2025 |
| Revision Date | TBD |
| Revision / description of change | None |

```javascript
const fs = require('fs');
const path = require('path');

const dataDir = path.join(__dirname, 'data');

try {
    console.log('üìö Reading current data...');

    const books = JSON.parse(fs.readFileSync(path.join(dataDir, 'books.json'), 'utf8'));
    const users = JSON.parse(fs.readFileSync(path.join(dataDir, 'users.json'), 'utf8'));

    console.log(`‚úÖ Found ${books.length} books`);
    console.log(`‚úÖ Found ${users.length} users`);

    const students = users.filter(u => u.role === 'student');
    console.log(`‚úÖ Found ${students.length} students`);

    const booksWithCopies = books.filter(b => b.copies && b.copies.length > 0);
    console.log(`‚úÖ Found ${booksWithCopies.length} books with copies`);

    if (students.length < 10 || booksWithCopies.length < 15) {
        console.error('‚ùå Not enough students or books to create proper test data');
        console.error(`   Need at least 10 students and 15 books, have ${students.length} students and ${booksWithCopies.length} books`);
        process.exit(1);
    }

    const generateId = (prefix) => {
        return `${prefix}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    };

    const transactions = [];
    let copyIndex = 0;

    console.log('\nüìñ Creating 10 borrowed transactions...');
    for (let i = 0; i < 10; i++) {
        const student = students[i];
        const book = booksWithCopies[copyIndex];
        const copy = book.copies[0];

        const borrowDate = new Date('2025-10-05');
        borrowDate.setDate(borrowDate.getDate() + i); // Stagger dates

        const dueDate = new Date(borrowDate);
        dueDate.setDate(dueDate.getDate() + 14); // Due in 14 days

        transactions.push({
            id: generateId('trans'),
            userId: student._id,
            items: [{
                copyId: copy.copyId,
                bookId: book._id,
                isbn: book.isbn,
                status: 'borrowed'
            }],
            type: 'regular',
            status: 'borrowed',
            borrowDate: borrowDate.toISOString(),
            dueDate: dueDate.toISOString(),
            returnDate: null,
            fineAmount: 0,
            notes: 'Currently borrowed - not overdue',
            renewalCount: 0,
            createdAt: borrowDate.toISOString(),
            updatedAt: borrowDate.toISOString(),
            createdBy: users.find(u => u.role === 'admin')._id,
            _id: generateId('mg')
        });

        copyIndex++;
    }

    console.log('‚è∞ Creating 3 overdue transactions...');
    for (let i = 0; i < 3; i++) {
        const student = students[(10 + i) % students.length]; // Use modulo to wrap around
        const book = booksWithCopies[copyIndex];
        const copy = book.copies[0];

        const borrowDate = new Date('2025-09-15');
        borrowDate.setDate(borrowDate.getDate() + i * 3); // Stagger dates

        const dueDate = new Date(borrowDate);
        dueDate.setDate(dueDate.getDate() + 14); // Due 14 days after borrow

        transactions.push({
            id: generateId('trans'),
            userId: student._id,
            items: [{
                copyId: copy.copyId,
                bookId: book._id,
                isbn: book.isbn,
                status: 'borrowed'
            }],
            type: 'regular',
            status: 'borrowed',
            borrowDate: borrowDate.toISOString(),
            dueDate: dueDate.toISOString(),
            returnDate: null,
            fineAmount: 0,
            notes: 'OVERDUE - past due date',
            renewalCount: 0,
            createdAt: borrowDate.toISOString(),
            updatedAt: borrowDate.toISOString(),
            createdBy: users.find(u => u.role === 'admin')._id,
            _id: generateId('mg')
        });

        copyIndex++;
    }

    console.log('‚úÖ Creating 3 returned transactions...');
    for (let i = 0; i < 3; i++) {
        const student = students[(13 + i) % students.length]; // Use modulo to wrap around
        const book = booksWithCopies[copyIndex];
        const copy = book.copies[0];

        const borrowDate = new Date('2025-09-20');
        borrowDate.setDate(borrowDate.getDate() + i * 2);

        const dueDate = new Date(borrowDate);
        dueDate.setDate(dueDate.getDate() + 14);

        const returnDate = new Date(borrowDate);
        returnDate.setDate(returnDate.getDate() + 10); // Returned after 10 days

        transactions.push({
            id: generateId('trans'),
            userId: student._id,
            items: [{
                copyId: copy.copyId,
                bookId: book._id,
                isbn: book.isbn,
                status: 'returned'
            }],
            type: 'regular',
            status: 'returned',
            borrowDate: borrowDate.toISOString(),
            dueDate: dueDate.toISOString(),
            returnDate: returnDate.toISOString(),
            fineAmount: 0,
            notes: 'Returned on time',
            renewalCount: 0,
            createdAt: borrowDate.toISOString(),
            updatedAt: returnDate.toISOString(),
            createdBy: users.find(u => u.role === 'admin')._id,
            _id: generateId('mg')
        });

        copyIndex++;
    }

    console.log('‚ùå Creating 2 missing transactions...');
    for (let i = 0; i < 2; i++) {
        const student = students[i % students.length]; // Reuse students
        const book = booksWithCopies[copyIndex % booksWithCopies.length]; // Wrap around if needed
        const copy = book.copies[0];

        const borrowDate = new Date('2025-08-01');
        borrowDate.setDate(borrowDate.getDate() + i * 5);

        const dueDate = new Date(borrowDate);
        dueDate.setDate(dueDate.getDate() + 14);

        transactions.push({
            id: generateId('trans'),
            userId: student._id,
            items: [{
                copyId: copy.copyId,
                bookId: book._id,
                isbn: book.isbn,
                status: 'missing'
            }],
            type: 'regular',
            status: 'missing',
            borrowDate: borrowDate.toISOString(),
            dueDate: dueDate.toISOString(),
            returnDate: null,
            fineAmount: 50,
            notes: 'Book reported as lost/missing',
            renewalCount: 0,
            createdAt: borrowDate.toISOString(),
            updatedAt: new Date().toISOString(),
            createdBy: users.find(u => u.role === 'admin')._id,
            _id: generateId('mg')
        });

        copyIndex++;
    }

    const transPath = path.join(dataDir, 'transactions.json');
    if (fs.existsSync(transPath)) {
        fs.copyFileSync(transPath, path.join(dataDir, 'transactions.json.backup-' + Date.now()));
        console.log('\nüíæ Backed up old transactions');
    }

    fs.writeFileSync(transPath, JSON.stringify(transactions, null, 2), 'utf8');

    console.log('\n‚úÖ SUCCESS! Created clean transaction data:');
    console.log(`   - 10 borrowed books (not overdue)`);
    console.log(`   - 3 overdue books (past due date)`);
    console.log(`   - 3 returned books`);
    console.log(`   - 2 missing books`);
    console.log(`   = ${transactions.length} total transactions`);

    console.log('\nüìä All transactions have valid book and student IDs!');
    console.log('üîÑ Restart the server to see the updated data.');

} catch (error) {
    console.error('‚ùå Error:', error.message);
    console.error(error.stack);
    process.exit(1);
}
```

## fix-json.js

| Field | Details |
| --- | --- |
| Program Name | fix-json.js |
| Description | Source file located at backend/fix-json.js. |
| Called by | None |
| Table used | None |
|  |  |
| Programmer | Nazel Asca√±o |
| Date created | 12/14/2025 |
| Revision Date | TBD |
| Revision / description of change | None |

```javascript
const fs = require('fs');
const path = require('path');

const filePath = path.join(__dirname, 'data', 'transactions.json');

try {

    let content = fs.readFileSync(filePath, 'utf8');

    console.log('Original file size:', content.length);

    content = content.replace(/:\s\s+/g, ': ');

    console.log('Fixed file size:', content.length);

    const data = JSON.parse(content);
    console.log('‚úÖ Valid JSON! Contains', data.length, 'transactions');

    fs.writeFileSync(filePath, JSON.stringify(data, null, 2), 'utf8');

    console.log('‚úÖ File fixed and reformatted!');
} catch (error) {
    console.error('‚ùå Error:', error.message);
}
```

## package.json

| Field | Details |
| --- | --- |
| Program Name | package.json |
| Description | Project configuration or data file. |
| Called by | None |
| Table used | None |
|  |  |
| Programmer | Nazel Asca√±o |
| Date created | 12/14/2025 |
| Revision Date | TBD |
| Revision / description of change | None |

```json
{
    "name": "olms-backend",
    "version": "1.0.0",
    "description": "OLMS Backend API with Express.js and MongoDB",
    "main": "server.js",
    "keywords": [
        "express",
        "mongodb",
        "library-api"
    ],
    "author": "OLMS Backend Team",
    "license": "MIT",
    "dependencies": {
        "bcrypt": "^6.0.0",
        "cors": "^2.8.5",
        "cookie-parser": "^1.4.6",
        "csv-parser": "^3.0.0",
        "dotenv": "^16.3.1",
        "express": "^4.18.2",
        "express-rate-limit": "^6.10.0",
        "helmet": "^7.0.0",
        "jsonwebtoken": "^9.0.2",
        "moment": "^2.29.4",
        "mongodb": "^6.3.0",
        "morgan": "^1.10.0",
        "multer": "^1.4.5-lts.1",
        "pdf-lib": "^1.17.1",
        "qrcode": "^1.5.3",
        "validator": "^13.11.0"
    },
    "scripts": {
        "start": "node server.js",
        "dev": "nodemon server.js",
        "dev:offline": "cross-env USE_OFFLINE_DB=true nodemon server.js",
        "offline:reset": "node scripts/reset-offline-data.js",
        "test": "cross-env USE_OFFLINE_DB=true jest --runInBand"
    },
    "devDependencies": {
        "nodemon": "^3.0.1",
        "cross-env": "^7.0.3",
        "jest": "^29.6.1",
        "supertest": "^6.3.3"
    }
}
```

## recreate-transactions.js

| Field | Details |
| --- | --- |
| Program Name | recreate-transactions.js |
| Description | Source file located at backend/recreate-transactions.js. |
| Called by | None |
| Table used | transactions |
|  |  |
| Programmer | Nazel Asca√±o |
| Date created | 12/14/2025 |
| Revision Date | TBD |
| Revision / description of change | None |

```javascript
const fs = require('fs');
const path = require('path');

const filePath = path.join(__dirname, 'data', 'transactions.json');
const backupPath = path.join(__dirname, 'data', 'transactions.json.corrupted');

try {

    if (fs.existsSync(filePath)) {
        fs.renameSync(filePath, backupPath);
        console.log('‚úÖ Backed up corrupted file to transactions.json.corrupted');
    }

    const transactions = [{
            "id": "trans_1760075048750_rjn1s97q3",
            "userId": "mgfdmmif38s76",
            "items": [{
                "copyId": "978-0132350884-MGKEV9OH-8QTV",
                "bookId": "book_1760074424513_m9yw6i6kn",
                "isbn": "978-0132350884",
                "status": "borrowed"
            }],
            "type": "regular",
            "status": "borrowed",
            "borrowDate": "2025-10-07T13:50:40.919Z",
            "dueDate": "2025-10-21T13:50:40.919Z",
            "returnDate": null,
            "fineAmount": 0,
            "notes": "Sample transaction created for testing",
            "renewalCount": 0,
            "createdAt": "2025-10-07T13:50:40.919Z",
            "updatedAt": "2025-10-07T13:50:40.919Z",
            "createdBy": "mgex1wgwp3019",
            "_id": "mgkf8nch5g0jh"
        },
        {
            "id": "trans_1760075049000_ezuxu940e",
            "userId": "mgfg021jvftif",
            "items": [{
                "copyId": "978-0262033848-MGKEV9K8-I074",
                "bookId": "book_1760074424360_iiue297m0",
                "isbn": "978-0262033848",
                "status": "borrowed"
            }],
            "type": "regular",
            "status": "borrowed",
            "borrowDate": "2025-10-05T13:50:40.930Z",
            "dueDate": "2025-10-19T13:50:40.930Z",
            "returnDate": null,
            "fineAmount": 0,
            "notes": "Sample transaction created for testing",
            "renewalCount": 0,
            "createdAt": "2025-10-05T13:50:40.930Z",
            "updatedAt": "2025-10-05T13:50:40.930Z",
            "createdBy": "mgex1wgwp3019",
            "_id": "mgkf8njdoz9fo"
        },
        {
            "id": "trans_1760075049180_u7flqmwbz",
            "userId": "mgfg0hpq7olld",
            "items": [{
                "copyId": "978-0134685991-MGKEV9KE-02TW",
                "bookId": "book_1760074424665_uw74ovqe9",
                "isbn": "978-0134685991",
                "status": "borrowed"
            }],
            "type": "regular",
            "status": "borrowed",
            "borrowDate": "2025-09-20T13:50:40.957Z",
            "dueDate": "2025-10-04T13:50:40.957Z",
            "returnDate": null,
            "fineAmount": 0,
            "notes": "Sample transaction created for testing",
            "renewalCount": 0,
            "createdAt": "2025-09-20T13:50:40.957Z",
            "updatedAt": "2025-09-20T13:50:40.957Z",
            "createdBy": "mgex1wgwp3019",
            "_id": "mgkf8np8vmvtq"
        },
        {
            "id": "trans_1760075049352_9hxgqtqje",
            "userId": "mgfg1bbx76iq2",
            "items": [{
                "copyId": "978-0134757599-MGKEV9KP-KIQY",
                "bookId": "book_1760074425018_l9hh9ovex",
                "isbn": "978-0134757599",
                "status": "borrowed"
            }],
            "type": "regular",
            "status": "borrowed",
            "borrowDate": "2025-10-02T13:50:40.977Z",
            "dueDate": "2025-10-16T13:50:40.977Z",
            "returnDate": null,
            "fineAmount": 0,
            "notes": "Sample transaction created for testing",
            "renewalCount": 0,
            "createdAt": "2025-10-02T13:50:40.977Z",
            "updatedAt": "2025-10-02T13:50:40.977Z",
            "createdBy": "mgex1wgwp3019",
            "_id": "mgkf8nqjgcg3j"
        },
        {
            "id": "trans_1760075049532_a51y9hfcm",
            "userId": "mgfg2ggdtljgo",
            "items": [{
                "copyId": "978-0596007126-MGKEV9LX-K5SO",
                "bookId": "book_1760074425576_adfx9owoo",
                "isbn": "978-0596007126",
                "status": "borrowed"
            }],
            "type": "regular",
            "status": "borrowed",
            "borrowDate": "2025-10-01T13:50:40.997Z",
            "dueDate": "2025-10-15T13:50:40.997Z",
            "returnDate": null,
            "fineAmount": 0,
            "notes": "Sample transaction created for testing",
            "renewalCount": 0,
            "createdAt": "2025-10-01T13:50:40.997Z",
            "updatedAt": "2025-10-01T13:50:40.997Z",
            "createdBy": "mgex1wgwp3019",
            "_id": "mgkf8nrzaqgpz"
        },
        {
            "id": "trans_1760075049713_qghxnjqbh",
            "userId": "mgfg2y0kzx0fg",
            "items": [{
                "copyId": "978-0596517748-MGKEV9M9-D6TL",
                "bookId": "book_1760074425941_wkqbp97co",
                "isbn": "978-0596517748",
                "status": "borrowed"
            }],
            "type": "regular",
            "status": "borrowed",
            "borrowDate": "2025-09-22T13:50:41.019Z",
            "dueDate": "2025-10-06T13:50:41.019Z",
            "returnDate": null,
            "fineAmount": 0,
            "notes": "Sample transaction created for testing",
            "renewalCount": 0,
            "createdAt": "2025-09-22T13:50:41.019Z",
            "updatedAt": "2025-09-22T13:50:41.019Z",
            "createdBy": "mgex1wgwp3019",
            "_id": "mgkf8nta80bsm"
        },
        {
            "id": "trans_1760075049885_5qe63l0xh",
            "userId": "mgfg3kqzb3yq2",
            "items": [{
                "copyId": "978-1449355739-MGKEV9MO-F6CE",
                "bookId": "book_1760074426277_cxfyp96q2",
                "isbn": "978-1449355739",
                "status": "borrowed"
            }],
            "type": "regular",
            "status": "borrowed",
            "borrowDate": "2025-09-15T13:50:41.041Z",
            "dueDate": "2025-09-29T13:50:41.041Z",
            "returnDate": null,
            "fineAmount": 0,
            "notes": "Sample transaction created for testing",
            "renewalCount": 0,
            "createdAt": "2025-09-15T13:50:41.041Z",
            "updatedAt": "2025-09-15T13:50:41.041Z",
            "createdBy": "mgex1wgwp3019",
            "_id": "mgkf8numcmzim"
        },
        {
            "id": "trans_1760075050058_yyqsf4uyy",
            "userId": "mgfg417qlbj08",
            "items": [{
                "copyId": "978-1491904244-MGKEV9N2-6TQV",
                "bookId": "book_1760074426666_n9c2i96fy",
                "isbn": "978-1491904244",
                "status": "borrowed"
            }],
            "type": "regular",
            "status": "borrowed",
            "borrowDate": "2025-09-28T13:50:41.061Z",
            "dueDate": "2025-10-12T13:50:41.061Z",
            "returnDate": null,
            "fineAmount": 0,
            "notes": "Sample transaction created for testing",
            "renewalCount": 0,
            "createdAt": "2025-09-28T13:50:41.061Z",
            "updatedAt": "2025-09-28T13:50:41.061Z",
            "createdBy": "mgex1wgwp3019",
            "_id": "mgkf8nw6rkrx4"
        },
        {
            "id": "trans_1760075050235_a8akjhjtg",
            "userId": "mgfg4nypjvqhr",
            "items": [{
                "copyId": "978-1491950296-MGKEV9NE-4YJ8",
                "bookId": "book_1760074427010_wqscq96rz",
                "isbn": "978-1491950296",
                "status": "borrowed"
            }],
            "type": "regular",
            "status": "borrowed",
            "borrowDate": "2025-10-03T13:50:41.081Z",
            "dueDate": "2025-10-17T13:50:41.081Z",
            "returnDate": null,
            "fineAmount": 0,
            "notes": "Sample transaction created for testing",
            "renewalCount": 0,
            "createdAt": "2025-10-03T13:50:41.081Z",
            "updatedAt": "2025-10-03T13:50:41.081Z",
            "createdBy": "mgex1wgwp3019",
            "_id": "mgkf8nxlcb5je"
        },
        {
            "id": "trans_1760075050419_bfhvlzrwj",
            "userId": "mgfg54ppgfuec",
            "items": [{
                "copyId": "978-1593275846-MGKEV9NU-T25X",
                "bookId": "book_1760074427324_dvj0a96r7",
                "isbn": "978-1593275846",
                "status": "borrowed"
            }],
            "type": "regular",
            "status": "borrowed",
            "borrowDate": "2025-10-08T13:50:41.103Z",
            "dueDate": "2025-10-22T13:50:41.103Z",
            "returnDate": null,
            "fineAmount": 0,
            "notes": "Sample transaction created for testing",
            "renewalCount": 0,
            "createdAt": "2025-10-08T13:50:41.103Z",
            "updatedAt": "2025-10-08T13:50:41.103Z",
            "createdBy": "mgex1wgwp3019",
            "_id": "mgkf8nz2g2jhs"
        }
    ];

    fs.writeFileSync(filePath, JSON.stringify(transactions, null, 2), 'utf8');

    console.log('‚úÖ Created fresh transactions.json with', transactions.length, 'transactions');
    console.log('üìä Transaction summary:');
    console.log('  - All status: borrowed');
    console.log('  - 3 overdue (due dates before Oct 10)');
    console.log('  - 7 not overdue yet');

} catch (error) {
    console.error('‚ùå Error:', error.message);
}
```

## server.js

| Field | Details |
| --- | --- |
| Program Name | server.js |
| Description | Backend server entry point and HTTP listener. |
| Called by | None |
| Table used | None |
|  |  |
| Programmer | Nazel Asca√±o |
| Date created | 12/14/2025 |
| Revision Date | TBD |
| Revision / description of change | None |

```javascript
require('dotenv').config();
const app = require('./app');
const DatabaseAdapter = require('./adapters/DatabaseAdapter');

const PORT = process.env.PORT || 5001;

const exportedAdapter = app && app.dbAdapter ? app.dbAdapter : null;
const dbAdapter = exportedAdapter || new DatabaseAdapter();

if (!exportedAdapter) {
    app.dbAdapter = dbAdapter;
    if (typeof app.set === 'function') {
        app.set('dbAdapter', dbAdapter);
    }
}

const server = app.listen(PORT, async () => {
    console.log(`üöÄ Server running on port ${PORT}`);

    try {
        await dbAdapter.connect();
        await dbAdapter.initialize();

        const adapterType = typeof dbAdapter.getType === 'function' ? dbAdapter.getType() : 'unknown';
        const adapterLabel = adapterType === 'mongo' ? 'MongoDB Atlas' : adapterType === 'offline' ? 'Offline datastore' : adapterType;

        console.log(`‚úÖ Database initialization complete using ${adapterLabel}`);
        console.log('üîó Backend ready for connections');
    } catch (error) {
        console.error('‚ùå Server initialization failed:', error.message);
        console.log('‚ö†Ô∏è Server running without database connection');
    }
});

server.on('error', (error) => {
    console.error('‚ùå Server error:', error?.message || error);
});

server.on('close', () => {
    console.warn('‚ö†Ô∏è HTTP server closed');
});

process.on('SIGINT', () => {
    console.warn('‚ö†Ô∏è Received SIGINT, shutting down server');
    server.close(() => process.exit(0));
});

process.on('SIGTERM', () => {
    console.warn('‚ö†Ô∏è Received SIGTERM, shutting down server');
    server.close(() => process.exit(0));
});

process.on('exit', (code) => {
    console.warn(`‚ö†Ô∏è Process exiting with code ${code}`);
});
```

## test-login.ps1

| Field | Details |
| --- | --- |
| Program Name | test-login.ps1 |
| Description | Automation or startup script. |
| Called by | None |
| Table used | None |
|  |  |
| Programmer | Nazel Asca√±o |
| Date created | 12/14/2025 |
| Revision Date | TBD |
| Revision / description of change | None |

```powershell
$ProgressPreference = 'SilentlyContinue'
$body = @{ usernameOrEmail = 'admin'; password = 'admin123456' } | ConvertTo-Json
$response = Invoke-RestMethod -Uri 'http://localhost:5001/api/auth/login' -Method Post -Body $body -ContentType 'application/json'
$response | ConvertTo-Json -Depth 4
```

# Backend - Middleware

## customAuth.js

| Field | Details |
| --- | --- |
| Program Name | customAuth.js |
| Description | Express middleware for request handling and access control. |
| Called by | annualSets.js, app.js, audit.js, books.js, curriculum.js, customAuth.js, locations.js, notifications.js, reports.js, search.js, settings.js, students.js, transactions.js, transactions_fixed.js, users.js |
| Table used | None |
|  |  |
| Programmer | Nazel Asca√±o |
| Date created | 12/14/2025 |
| Revision Date | TBD |
| Revision / description of change | None |

```javascript
const jwt = require('jsonwebtoken');
const {
  recordAuditEvent,
  captureRequestSnapshot,
  setAuditContext,
} = require('../utils/auditLogger');
const { getSettingsSnapshot } = require('../utils/settingsCache');

const JWT_SECRET = process.env.JWT_SECRET || 'your-super-secret-jwt-key-change-in-production';
const JWT_EXPIRES_IN = process.env.JWT_EXPIRES_IN || '7d';
const MAX_SESSION_TIMEOUT_MINUTES = parseInt(process.env.MAX_SESSION_TIMEOUT_MINUTES, 10) || 60 * 24 * 30; // 30 days cap
const SLIDING_SESSION_THRESHOLD_SECONDS = parseInt(process.env.SLIDING_SESSION_THRESHOLD_SECONDS, 10) || 300; // default refresh window 5 minutes
const MIN_REFRESH_THRESHOLD_SECONDS = parseInt(process.env.MIN_REFRESH_THRESHOLD_SECONDS, 10) || 60;
const AUTH_COOKIE_NAME = process.env.AUTH_COOKIE_NAME || 'olms_session';
const AUTH_COOKIE_PATH = process.env.AUTH_COOKIE_PATH || '/';
const AUTH_COOKIE_DOMAIN = process.env.AUTH_COOKIE_DOMAIN || '';
const AUTH_COOKIE_SAMESITE = process.env.AUTH_COOKIE_SAMESITE || 'lax';
const AUTH_COOKIE_SECURE = ((process.env.AUTH_COOKIE_SECURE || (process.env.NODE_ENV === 'production' ? 'true' : 'false')).toString().toLowerCase() === 'true');
const AUTH_COOKIE_MAX_AGE_SECONDS = parseInt(process.env.AUTH_COOKIE_MAX_AGE_SECONDS, 10) || 60 * 60 * 24 * 7;

const normalizeRole = (role) => {
  if (!role && role !== 0) {
    return '';
  }
  const value = String(role).trim().toLowerCase();
  if (!value) {
    return '';
  }

  switch (value) {
    case 'super admin':
    case 'super-admin':
    case 'superadmin':
    case 'administrator':
      return 'admin';
    default:
      return value;
  }
};
const isAdminUser = (user) => normalizeRole(user && (user.role || user.roleLabel || user.roleOriginal)) === 'admin';

const buildRequestUser = (userData) => {
  if (!userData || typeof userData !== 'object') {
    return null;
  }

  const safePreferences = userData.preferences && typeof userData.preferences === 'object'
    ? userData.preferences
    : {};

  const normalizedRole = normalizeRole(userData.role);
  const resolvedRole = normalizedRole || (userData.role ? String(userData.role).trim().toLowerCase() : 'student');
  const roleLabel = userData.role || resolvedRole || 'student';

  return {
    ...userData,
    id: userData._id,
    email: userData.email,
    username: userData.username,
    role: resolvedRole,
    roleLabel,
    roleOriginal: userData.role,
    preferences: safePreferences,
  };
};

const resolveSessionExpiration = (systemSettings) => {
  const rawMinutes = Number(systemSettings?.sessionTimeoutMinutes);
  if (!Number.isFinite(rawMinutes) || rawMinutes <= 0) {
    return JWT_EXPIRES_IN;
  }

  const boundedMinutes = Math.min(rawMinutes, MAX_SESSION_TIMEOUT_MINUTES);
  const seconds = Math.round(boundedMinutes * 60);
  if (!Number.isFinite(seconds) || seconds <= 0) {
    return JWT_EXPIRES_IN;
  }

  return seconds;
};

const getSessionTimeoutSeconds = (systemSettings) => {
  const expiresIn = resolveSessionExpiration(systemSettings);
  if (typeof expiresIn === 'number' && Number.isFinite(expiresIn)) {
    return expiresIn;
  }
  const minutes = Number(systemSettings?.sessionTimeoutMinutes);
  if (!Number.isFinite(minutes) || minutes <= 0) {
    return null;
  }
  return Math.round(Math.min(minutes, MAX_SESSION_TIMEOUT_MINUTES) * 60);
};

const getCookieMaxAgeSeconds = (systemSettings) => {
  const sessionSeconds = getSessionTimeoutSeconds(systemSettings);
  if (Number.isFinite(sessionSeconds) && sessionSeconds > 0) {
    return sessionSeconds;
  }
  return AUTH_COOKIE_MAX_AGE_SECONDS;
};

const buildCookieOptions = (maxAgeSeconds) => {
  const options = {
    httpOnly: true,
    secure: AUTH_COOKIE_SECURE,
    sameSite: AUTH_COOKIE_SAMESITE,
    path: AUTH_COOKIE_PATH,
  };
  if (AUTH_COOKIE_DOMAIN) {
    options.domain = AUTH_COOKIE_DOMAIN;
  }
  if (Number.isFinite(maxAgeSeconds) && maxAgeSeconds > 0) {
    options.maxAge = maxAgeSeconds * 1000;
  }
  return options;
};

const setSessionCookie = (res, token, maxAgeSeconds = AUTH_COOKIE_MAX_AGE_SECONDS) => {
  if (!res || typeof res.cookie !== 'function' || !token) {
    return;
  }
  res.cookie(AUTH_COOKIE_NAME, token, buildCookieOptions(maxAgeSeconds));
};

const clearSessionCookie = (res) => {
  if (!res || typeof res.clearCookie !== 'function') {
    return;
  }
  const options = buildCookieOptions();
  delete options.maxAge;
  res.clearCookie(AUTH_COOKIE_NAME, options);
};

const deriveSlidingThresholdSeconds = (sessionSeconds) => {
  if (!Number.isFinite(sessionSeconds) || sessionSeconds <= 0) {
    return Math.max(SLIDING_SESSION_THRESHOLD_SECONDS, MIN_REFRESH_THRESHOLD_SECONDS);
  }

  const ratioThreshold = Math.floor(sessionSeconds * 0.5); // refresh once half the lifetime elapsed
  const upperBound = Math.max(sessionSeconds - MIN_REFRESH_THRESHOLD_SECONDS, MIN_REFRESH_THRESHOLD_SECONDS);
  const desired = Math.max(ratioThreshold, SLIDING_SESSION_THRESHOLD_SECONDS, MIN_REFRESH_THRESHOLD_SECONDS);
  return Math.min(desired, upperBound);
};

const shouldRefreshToken = (decoded, thresholdSeconds = SLIDING_SESSION_THRESHOLD_SECONDS) => {
  if (!decoded || !Number.isFinite(decoded.exp)) {
    return false;
  }
  const now = Math.floor(Date.now() / 1000);
  const timeLeft = decoded.exp - now;
  return Number.isFinite(timeLeft) && timeLeft > 0 && timeLeft <= thresholdSeconds;
};

const maybeRefreshSessionToken = async (req, res, user, decoded, snapshot) => {
  if (!res || typeof res.setHeader !== 'function') {
    return;
  }

  try {
    const systemSettings = snapshot?.system || req.systemSettings;
    const sessionSeconds = getSessionTimeoutSeconds(systemSettings);
    const refreshThreshold = deriveSlidingThresholdSeconds(sessionSeconds);
    if (!shouldRefreshToken(decoded, refreshThreshold)) {
      return;
    }
    const expiresIn = resolveSessionExpiration(systemSettings);
    const tokenSubject = user && user.roleOriginal
      ? { ...user, role: user.roleOriginal }
      : user;
    const refreshedToken = generateToken(tokenSubject, expiresIn);
    res.setHeader('x-session-refresh', refreshedToken);
    res.setHeader('x-session-refresh-lifetime', String(expiresIn));
    const cookieMaxAge = getCookieMaxAgeSeconds(systemSettings);
    setSessionCookie(res, refreshedToken, cookieMaxAge);
  } catch (error) {
    console.warn('Session refresh failed:', error?.message || error);
  }
};

const loadAndAttachSettingsSnapshot = async (req) => {
  if (!req || !req.dbAdapter || typeof req.dbAdapter.findInCollection !== 'function') {
    return null;
  }

  try {
    const snapshot = await getSettingsSnapshot(req.dbAdapter);
    req.settingsSnapshot = snapshot;
    req.systemSettings = snapshot.system;
    return snapshot;
  } catch (error) {
    console.error('Settings snapshot load error:', error);
    return null;
  }
};

const verifyToken = async (req, res, next) => {
  try {

    if (process.env.NODE_ENV === 'test' || process.env.DISABLE_AUTH === 'true') {
      try {
        const users = await req.dbAdapter.findInCollection('users', {});
        const userData = (users && users.length > 0) ? users[0] : null;
        if (!userData) {
          return res.status(500).json({ message: 'No users available for test auth' });
        }

        const decoratedUser = buildRequestUser(userData);
        if (!decoratedUser) {
          return res.status(500).json({ message: 'Failed to decorate user payload for test auth' });
        }

        req.user = decoratedUser;

        await loadAndAttachSettingsSnapshot(req);
        return next();
      } catch (err) {
        console.error('Test auth bypass failed:', err);
        return res.status(500).json({ message: 'Test auth setup failed' });
      }
    }

    const headerToken = req.headers.authorization?.split(' ')[1];
    const cookieToken = req.cookies?.[AUTH_COOKIE_NAME];

    const respondToJwtError = (jwtError) => {
      clearSessionCookie(res);
      if (jwtError.message === 'No token provided') {
        return res.status(401).json({ message: 'No token provided' });
      }
      if (jwtError.name === 'JsonWebTokenError') {
        return res.status(401).json({ message: 'Invalid token' });
      }
      if (jwtError.name === 'TokenExpiredError') {
        return res.status(401).json({ message: 'Token expired' });
      }
      return res.status(401).json({ message: 'Authentication failed' });
    };

    if (!headerToken && !cookieToken) {
      const missingTokenError = new Error('No token provided');
      missingTokenError.name = 'JsonWebTokenError';
      return respondToJwtError(missingTokenError);
    }

    const verifyJwt = (candidate) => {
      if (!candidate) {
        const error = new Error('Missing token');
        error.name = 'JsonWebTokenError';
        throw error;
      }
      return jwt.verify(candidate, JWT_SECRET);
    };

    let token = headerToken || cookieToken;
    let decoded;

    try {
      decoded = verifyJwt(token);
    } catch (primaryError) {
      if (headerToken && cookieToken && cookieToken !== headerToken) {
        try {
          decoded = verifyJwt(cookieToken);
          token = cookieToken;
          console.info('Auth token fallback: header token rejected, cookie token accepted for user session');
        } catch (cookieError) {
          return respondToJwtError(cookieError);
        }
      } else {
        return respondToJwtError(primaryError);
      }
    }

    const userData = await req.dbAdapter.findUserById(decoded.userId);

    if (!userData) {
      clearSessionCookie(res);
      return res.status(401).json({ message: 'User not found' });
    }

    if (!userData.isActive) {
      clearSessionCookie(res);
      return res.status(401).json({ message: 'Account is deactivated' });
    }

    try {
      await req.dbAdapter.updateUser(userData._id, {
        lastActivityAt: new Date(),
        lastLoginAt: userData.lastLoginAt || new Date(), // Keep original login time, update activity
      });
    } catch (activityError) {
      console.warn('Failed to record user activity:', activityError?.message || activityError);
    }

    const decoratedUser = buildRequestUser(userData);
    if (!decoratedUser) {
      clearSessionCookie(res);
      return res.status(401).json({ message: 'Authentication failed' });
    }

    req.user = decoratedUser;

    const snapshot = await loadAndAttachSettingsSnapshot(req);
    if (snapshot && snapshot.system && snapshot.system.maintenanceMode && !isAdminUser(req.user)) {
      return res.status(503).json({ message: 'System is currently in maintenance mode' });
    }

    await maybeRefreshSessionToken(req, res, req.user, decoded, snapshot);

    const refreshHeaderAlreadySet = typeof res.getHeader === 'function' ? res.getHeader('x-session-refresh') : undefined;
    const nowSeconds = Math.floor(Date.now() / 1000);
    if (!refreshHeaderAlreadySet && token && !headerToken) {
      try {
        res.setHeader('x-session-refresh', token);
        if (decoded?.exp) {
          const lifetime = Math.max(decoded.exp - nowSeconds, 0);
          res.setHeader('x-session-refresh-lifetime', String(lifetime));
        }
      } catch (headerError) {
        console.warn('Failed to mirror cookie session token in headers:', headerError?.message || headerError);
      }
    }

    next();
  } catch (error) {
    console.error('Token verification error:', error);
    clearSessionCookie(res);
    if (error.name === 'JsonWebTokenError') {
      return res.status(401).json({ message: 'Invalid token' });
    }
    if (error.name === 'TokenExpiredError') {
      return res.status(401).json({ message: 'Token expired' });
    }
    res.status(401).json({ message: 'Authentication failed' });
  }
};

const requireRole = (roles) => {
  const entries = Array.isArray(roles) ? roles : [roles];
  const normalizedRoles = entries
    .map((role) => normalizeRole(role))
    .filter(Boolean);

  return (req, res, next) => {
    if (!req.user) {
      return res.status(401).json({ message: 'Authentication required' });
    }

    const userRole = normalizeRole(req.user.role || req.user.roleLabel || req.user.roleOriginal);

    if (!normalizedRoles.includes(userRole)) {
      return res.status(403).json({ message: 'Insufficient permissions' });
    }

    next();
  };
};

function generateToken(user, expiresIn = JWT_EXPIRES_IN) {
  const payload = {
    userId: user._id,
    email: user.email,
    username: user.username,
    role: user.role
  };

  return jwt.sign(payload, JWT_SECRET, { expiresIn });
}

const hashPassword = async (password) => {
  const bcrypt = require('bcrypt');

  const SALT_ROUNDS = 10;
  return await bcrypt.hash(password, SALT_ROUNDS);
};

const verifyPassword = async (password, storedPassword) => {
  try {
    const bcrypt = require('bcrypt');
    if (!storedPassword) return false;

    if (typeof storedPassword === 'string' && /^\$2[aby]\$/.test(storedPassword)) {
      return await bcrypt.compare(password, storedPassword);
    }

    return password === storedPassword;
  } catch (error) {
    console.error('Password verification error:', error);
    return false;
  }
};

const logAction = (action, entity, options = {}) => {
  return (req, res, next) => {
    const startedAt = Date.now();

    res.once('finish', async() => {
      try {
        const context = req.auditContext || {};
        const success = context.success !== undefined ? Boolean(context.success) : res.statusCode < 400;

        const metadata = {
          statusCode: res.statusCode,
          durationMs: Date.now() - startedAt,
          ...(options.metadata || {}),
          ...(context.metadata || {}),
        };

        const details = context.details !== undefined
          ? context.details
          : options.includeRequest === false
            ? undefined
            : { request: captureRequestSnapshot(req) };

        const description =
          context.description ||
          options.description ||
          (success
            ? `${action} ${entity}`
            : `${action} ${entity} failed (status ${res.statusCode})`);

        await recordAuditEvent(req, {
          action: context.action || action,
          entity: context.entity || entity,
          entityId:
            context.entityId ??
            context.resourceId ??
            options.entityId ??
            req.params?.id ??
            req.body?.id ??
            req.body?._id ??
            null,
          resource: context.resource || context.entity || entity,
          resourceId:
            context.resourceId ??
            context.entityId ??
            options.entityId ??
            req.params?.id ??
            req.body?.id ??
            req.body?._id ??
            null,
          description,
          details,
          metadata,
          success,
          status: context.status,
          statusCode: res.statusCode,
          user: context.user || req.user,
          userId: context.userId,
          userEmail: context.userEmail,
          userRole: context.userRole,
          userName: context.userName,
          username: context.username,
          ipAddress: context.ipAddress,
          userAgent: context.userAgent,
        });
      } catch (error) {
        console.error('Audit logging error:', error);
      }
    });

    next();
  };
};

const requireAdmin = requireRole(['admin']);
const requireLibrarian = requireRole(['admin', 'librarian']);
const requireStaff = requireRole(['admin', 'librarian', 'staff']);
const requireCirculation = requireRole(['admin', 'librarian', 'staff']);

module.exports = {
  verifyToken,
  requireRole,
  requireAdmin,
  requireLibrarian,
  requireStaff,
  requireCirculation,
  logAction,
  generateToken,
  hashPassword,
  verifyPassword,
  recordAuditEvent,
  setAuditContext,
  JWT_SECRET,
  JWT_EXPIRES_IN,
  resolveSessionExpiration,
  getSessionTimeoutSeconds,
  setSessionCookie,
  clearSessionCookie,
  getCookieMaxAgeSeconds,
  normalizeRole,
  AUTH_COOKIE_NAME,
};
```

# Backend - Routes

## annualSets.js

| Field | Details |
| --- | --- |
| Program Name | annualSets.js |
| Description | API route handler for annualSets resources. |
| Called by | app.js |
| Table used | annualsets |
|  |  |
| Programmer | Nazel Asca√±o |
| Date created | 12/14/2025 |
| Revision Date | TBD |
| Revision / description of change | None |

```javascript
const express = require('express');
const { verifyToken, requireStaff, logAction, setAuditContext } = require('../middleware/customAuth');
const { generateTransactionId } = require('../utils/transactionIds');

const router = express.Router();

const safeLower = (value) => {
    if (value === null || value === undefined) {
        return '';
    }
    return String(value).trim().toLowerCase();
};

const normalizeAcademicYear = (value) => {
    if (!value) {
        const now = new Date();
        const start = now.getMonth() >= 5 ? now.getFullYear() : now.getFullYear() - 1;
        return `${start}-${start + 1}`;
    }

    const trimmed = String(value).trim();
    if (/^\d{4}\s*-\s*\d{4}$/.test(trimmed)) {
        const [start, end] = trimmed.split('-').map(part => part.trim());
        return `${start}-${end}`;
    }

    const numeric = parseInt(trimmed, 10);
    if (!Number.isNaN(numeric) && trimmed.length === 4) {
        return `${numeric}-${numeric + 1}`;
    }

    return trimmed;
};

const normalizeBooks = (books = []) => {
    if (!Array.isArray(books)) {
        return [];
    }

    const map = new Map();

    books.forEach(rawEntry => {
        const entry = rawEntry || {};
        const id = entry.bookId || entry.id || entry._id || entry.isbn;
        if (!id) {
            return;
        }

        const key = String(id).trim();
        if (!key) {
            return;
        }

        const quantity = Math.max(parseInt(entry.quantity, 10) || 1, 1);
        const copyIds = Array.isArray(entry.copyIds)
            ? entry.copyIds.filter(Boolean).map(value => String(value).trim())
            : [];

        const record = map.get(key) || { bookId: key, quantity: 0, copyIds: [], required: true, notes: '' };

        record.quantity += quantity;
        record.required = entry.required === false ? false : record.required;
        record.notes = entry.notes || record.notes;

        if (copyIds.length > 0) {
            const merged = new Set([...(record.copyIds || []), ...copyIds]);
            record.copyIds = Array.from(merged);
        }

        map.set(key, record);
    });

    return Array.from(map.values());
};

const buildBookLookup = (books = []) => {
    const map = new Map();
    books.forEach(book => {
        const key = book.id || book._id || book.bookId || book.isbn;
        if (!key) {
            return;
        }
        map.set(String(key), book);
    });
    return map;
};

const enrichSetsWithBooks = (sets = [], allBooks = [], issueMetrics = new Map()) => {
    const lookup = buildBookLookup(allBooks);

    return sets.map(set => {
        const entries = (set.books || []).map(entry => {
            const book = lookup.get(entry.bookId) || null;

            if (!book) {
                return { ...entry, book: null };
            }

            const totalCopies = Array.isArray(book.copies) ? book.copies.length : 0;
            const availableCopies = Array.isArray(book.copies)
                ? book.copies.filter(copy => copy.status === 'available').length
                : 0;

            return {
                ...entry,
                book: {
                    id: book.id || book._id,
                    title: book.title,
                    author: book.author,
                    isbn: book.isbn,
                    totalCopies,
                    availableCopies
                }
            };
        });

        const stats = {
            totalTitles: entries.length,
            totalRequired: entries.filter(item => item.required !== false).length,
            totalQuantity: entries.reduce((sum, item) => sum + (item.quantity || 0), 0)
        };

        const metrics = issueMetrics.get(set.id) || issueMetrics.get(String(set.id)) || {
            total: 0,
            active: 0
        };

        return {
            ...set,
            books: entries,
            stats,
            issuedCount: metrics.total || 0,
            activeIssues: metrics.active || 0
        };
    });
};

const buildIssueMetrics = (transactions = []) => {
    const map = new Map();

    (transactions || []).forEach(transaction => {
        if (!transaction || !transaction.annualSetId) {
            return;
        }

        const key = String(transaction.annualSetId);
        const entry = map.get(key) || { total: 0, active: 0 };
        entry.total += 1;
        if (transaction.status !== 'returned') {
            entry.active += 1;
        }
        map.set(key, entry);
    });

    return map;
};

const buildAnnualSetDocument = (payload, user) => {
    const now = new Date();

    return {
        id: payload.id || `annual_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`,
        name: (payload.name || '').trim() || 'Untitled Annual Set',
        gradeLevel: (payload.gradeLevel || '').trim(),
        section: (payload.section || '').trim(),
    curriculum: (payload.curriculum || '').trim(),
        academicYear: normalizeAcademicYear(payload.academicYear),
        description: (payload.description || '').trim(),
        books: normalizeBooks(payload.books),
        createdAt: now,
        updatedAt: now,
        createdBy: user?.id || user?._id || null,
        updatedBy: user?.id || user?._id || null
    };
};

const applyEditableFields = (record, payload) => {
    if (payload.name !== undefined) {
        record.name = String(payload.name || '').trim();
    }
    if (payload.gradeLevel !== undefined) {
        record.gradeLevel = String(payload.gradeLevel || '').trim();
    }
    if (payload.section !== undefined) {
        record.section = String(payload.section || '').trim();
    }
    if (payload.curriculum !== undefined) {
        record.curriculum = String(payload.curriculum || '').trim();
    }
    if (payload.academicYear !== undefined) {
        record.academicYear = normalizeAcademicYear(payload.academicYear);
    }
    if (payload.description !== undefined) {
        record.description = String(payload.description || '').trim();
    }
    if (payload.books !== undefined) {
        record.books = normalizeBooks(payload.books);
    }
};

const buildFiltersFromQuery = (query = {}) => {
    const filters = {};

    if (query.academicYear) {
        filters.academicYear = normalizeAcademicYear(query.academicYear);
    }

    if (query.gradeLevel) {
        filters.gradeLevel = String(query.gradeLevel).trim();
    }

    if (query.section) {
        filters.section = String(query.section).trim();
    }

    if (query.curriculum) {
        filters.curriculum = String(query.curriculum).trim();
    }

    return filters;
};

const findMatchingStudents = async(dbAdapter, { gradeLevel, section, curriculum }) => {
    const students = await dbAdapter.findInCollection('users', { role: 'student' });

    const normalizedGrade = safeLower(gradeLevel);
    const normalizedSection = safeLower(section);
    const normalizedCurriculum = safeLower(curriculum);

    return (students || []).filter(student => {
        if (!student || student.isActive === false) {
            return false;
        }

        if (normalizedGrade) {
            const studentGrade = safeLower(student.grade || student.gradeLevel || student.profile?.gradeLevel);
            if (studentGrade !== normalizedGrade) {
                return false;
            }
        }

        if (normalizedSection) {
            const studentSection = safeLower(student.section || student.sectionName || student.profile?.section);
            if (studentSection !== normalizedSection) {
                return false;
            }
        }

        if (normalizedCurriculum) {
            const studentCurriculum = safeLower(student.curriculum || student.profile?.curriculum || student.academic?.curriculum);
            if (studentCurriculum !== normalizedCurriculum) {
                return false;
            }
        }

        return true;
    });
};

const findUserByAnyIdentifier = async(dbAdapter, identifier) => {
    if (identifier === null || identifier === undefined) {
        return null;
    }

    const normalized = String(identifier).trim();
    if (!normalized) {
        return null;
    }

    const searchFields = [
        'id',
        '_id',
        'userId',
        'libraryCardNumber',
        'library.cardNumber',
        'lrn'
    ];

    for (const field of searchFields) {
        const query = {};
        query[field] = normalized;
        const user = await dbAdapter.findOneInCollection('users', query);
        if (user) {
            return user;
        }
    }

    return null;
};

router.get('/', verifyToken, requireStaff, async(req, res) => {
    try {
        const { search } = req.query || {};
        const filters = buildFiltersFromQuery(req.query || {});

        let sets = await req.dbAdapter.findInCollection('annualSets', filters);

        if (search) {
            const needle = safeLower(search);
            sets = (sets || []).filter(set => {
                return [
                    set.name,
                    set.description,
                    set.gradeLevel,
                    set.section,
                    set.academicYear
                ].some(value => safeLower(value).includes(needle));
            });
        }

        sets.sort((a, b) => {
            const yearCompare = String(a.academicYear || '').localeCompare(String(b.academicYear || ''));
            if (yearCompare !== 0) {
                return yearCompare;
            }
            const gradeCompare = String(a.gradeLevel || '').localeCompare(String(b.gradeLevel || ''));
            if (gradeCompare !== 0) {
                return gradeCompare;
            }
            return String(a.section || '').localeCompare(String(b.section || ''));
        });

    const books = await req.dbAdapter.findInCollection('books', {});
    const transactions = await req.dbAdapter.findInCollection('transactions', {});
    const issueMetrics = buildIssueMetrics(transactions);
    const enriched = enrichSetsWithBooks(sets, books, issueMetrics);

        res.json(enriched);
    } catch (error) {
        console.error('Annual sets list error:', error);
        res.status(500).json({ message: 'Failed to fetch annual borrowing sets' });
    }
});

router.post('/preview', verifyToken, requireStaff, async(req, res) => {
    try {
    const { academicYear, gradeLevel, section, curriculum, setId } = req.body || {};

        let targetSet = null;

        if (setId) {
            targetSet = await req.dbAdapter.findOneInCollection('annualSets', { id: setId });
            if (!targetSet) {
                return res.status(404).json({ message: 'Annual set not found for preview' });
            }
        }

        if (!targetSet) {
            const filters = buildFiltersFromQuery({ academicYear, gradeLevel, section, curriculum });
            const sets = await req.dbAdapter.findInCollection('annualSets', filters);
            targetSet = Array.isArray(sets) && sets.length > 0 ? sets[0] : null;
        }

        if (!targetSet) {
            return res.status(404).json({ message: 'No annual set matches the preview filters' });
        }

        const students = await findMatchingStudents(req.dbAdapter, {
            gradeLevel: gradeLevel || targetSet.gradeLevel,
            section: section || targetSet.section,
            curriculum: curriculum || targetSet.curriculum
        });

        const books = await req.dbAdapter.findInCollection('books', {});
        const allTransactions = await req.dbAdapter.findInCollection('transactions', {});
        const metrics = buildIssueMetrics(allTransactions.filter(txn => String(txn.annualSetId || '') === String(targetSet.id)));
        const [enriched] = enrichSetsWithBooks([targetSet], books, metrics);

        res.json({
            academicYear: enriched.academicYear,
            gradeLevel: enriched.gradeLevel,
            section: enriched.section,
            curriculum: enriched.curriculum,
            targetSet: enriched,
            studentCount: students.length,
            studentSample: students.slice(0, 10).map(student => ({
                id: student.id || student._id,
                name: student.fullName || `${student.firstName || ''} ${student.lastName || ''}`.trim(),
                grade: student.grade || student.gradeLevel || student.profile?.gradeLevel || '',
                section: student.section || student.profile?.section || '',
                curriculum: student.curriculum || student.profile?.curriculum || ''
            }))
        });
    } catch (error) {
        console.error('Annual plan preview error:', error);
        res.status(500).json({ message: 'Failed to generate annual plan preview' });
    }
});

router.get('/:id/issue-context', verifyToken, requireStaff, async(req, res) => {
    try {
        const set = await req.dbAdapter.findOneInCollection('annualSets', { id: req.params.id });

        if (!set) {
            return res.status(404).json({ message: 'Annual set not found' });
        }

        const books = await req.dbAdapter.findInCollection('books', {});
        const allTransactions = await req.dbAdapter.findInCollection('transactions', {});
        const metrics = buildIssueMetrics(allTransactions.filter(txn => String(txn.annualSetId || '') === String(set.id)));
        const [enriched] = enrichSetsWithBooks([set], books, metrics);

        const borrowedStudentIds = new Set();
        (allTransactions || []).forEach(txn => {
            if (String(txn.annualSetId || '') === String(set.id) && txn.status !== 'returned') {
                borrowedStudentIds.add(String(txn.userId));
            }
        });

        const entries = (set.books || []).map((entry, index) => {
            const quantity = Math.max(parseInt(entry.quantity, 10) || 1, 1);
            const allowedCopyIds = Array.isArray(entry.copyIds) && entry.copyIds.length > 0
                ? new Set(entry.copyIds.map(value => String(value)))
                : null;

            const bookRecord = books.find(book => {
                const identifiers = [book.id, book._id, book.bookId, book.isbn]
                    .filter(Boolean)
                    .map(value => String(value));
                return identifiers.includes(String(entry.bookId));
            }) || null;

            const availableCopies = Array.isArray(bookRecord?.copies)
                ? bookRecord.copies.filter(copy => {
                    if (!copy || copy.status !== 'available') {
                        return false;
                    }
                    if (allowedCopyIds && !allowedCopyIds.has(String(copy.copyId))) {
                        return false;
                    }
                    return true;
                })
                : [];

            const copyOptions = availableCopies.map(copy => ({
                copyId: copy.copyId,
                condition: copy.condition || '',
                location: copy.location || '',
                status: copy.status,
                updatedAt: copy.updatedAt || null
            }));

            const suggestedCopies = copyOptions.slice(0, quantity).map(option => option.copyId);

            return {
                entryKey: `${set.id}_${index}`,
                bookId: bookRecord?.id || bookRecord?._id || entry.bookId,
                quantity,
                required: entry.required !== false,
                notes: entry.notes || '',
                book: bookRecord
                    ? {
                        id: bookRecord.id || bookRecord._id,
                        title: bookRecord.title,
                        author: bookRecord.author,
                        isbn: bookRecord.isbn,
                        totalCopies: bookRecord.totalCopies || (bookRecord.copies ? bookRecord.copies.length : 0),
                        availableCopies: copyOptions.length
                    }
                    : {
                        id: entry.bookId,
                        title: entry.bookId,
                        author: '',
                        isbn: ''
                    },
                availableCopies: copyOptions,
                suggestedCopies,
                shortage: Math.max(0, quantity - copyOptions.length)
            };
        });

        const matchingStudents = await findMatchingStudents(req.dbAdapter, {
            gradeLevel: enriched.gradeLevel,
            section: enriched.section,
            curriculum: enriched.curriculum
        });

        const { q } = req.query || {};
        let students = Array.isArray(matchingStudents) ? matchingStudents : [];

        if (q) {
            const needle = safeLower(q);
            students = students.filter(student => {
                const name = safeLower(student.fullName || `${student.firstName || ''} ${student.lastName || ''}`);
                const identifiers = [
                    student.id,
                    student._id,
                    student.libraryCardNumber,
                    student.library?.cardNumber,
                    student.lrn,
                    student.email,
                    student.username
                ]
                    .filter(Boolean)
                    .map(value => safeLower(value));

                if (name.includes(needle)) {
                    return true;
                }

                return identifiers.some(idValue => idValue.includes(needle));
            });
        }

        const studentSummaries = students
            .slice(0, 150)
            .map(student => {
                const identifier = String(student.id || student._id || student.libraryCardNumber || '');
                return {
                    id: identifier,
                    name: student.fullName || `${student.firstName || ''} ${student.lastName || ''}`.trim() || student.username || student.email || 'Unnamed student',
                    grade: student.grade || student.gradeLevel || student.profile?.gradeLevel || '',
                    section: student.section || student.sectionName || student.profile?.section || '',
                    curriculum: student.curriculum || student.profile?.curriculum || '',
                    libraryCardNumber: student.libraryCardNumber || student.library?.cardNumber || '',
                    email: student.email || '',
                    isActive: student.isActive !== false,
                    hasBorrowedSet: borrowedStudentIds.has(identifier)
                };
            })
            .sort((a, b) => String(a.name || '').localeCompare(String(b.name || '')));

        res.json({
            set: enriched,
            entries,
            students: studentSummaries,
            metrics: {
                issuedCount: enriched.issuedCount || 0,
                activeIssues: enriched.activeIssues || 0
            }
        });
    } catch (error) {
        console.error('Annual set issue context error:', error);
        res.status(500).json({ message: 'Failed to load annual set issuance data' });
    }
});

router.get('/:id', verifyToken, requireStaff, async(req, res) => {
    try {
        const set = await req.dbAdapter.findOneInCollection('annualSets', { id: req.params.id });

        if (!set) {
            return res.status(404).json({ message: 'Annual set not found' });
        }

    const books = await req.dbAdapter.findInCollection('books', {});
    const allTransactions = await req.dbAdapter.findInCollection('transactions', {});
    const metrics = buildIssueMetrics(allTransactions.filter(txn => String(txn.annualSetId || '') === String(set.id)));
    const [enriched] = enrichSetsWithBooks([set], books, metrics);

        res.json(enriched);
    } catch (error) {
        console.error('Annual set detail error:', error);
        res.status(500).json({ message: 'Failed to fetch annual set' });
    }
});

router.post('/:id/issue', verifyToken, requireStaff, logAction('BORROW', 'annual_set'), async(req, res) => {
    try {
	const { studentReference, libraryCardNumber, items = [], notes = '', allowPartial = false, dueDate } = req.body || {};
	const sanitizedNotes = typeof notes === 'string' ? notes : '';
        const resolvedStudentReference = (studentReference || libraryCardNumber || '').toString().trim();

        setAuditContext(req, {
            entityId: req.params.id,
            metadata: {
                issueRequest: {
                    studentReference: resolvedStudentReference || null,
                    itemsRequested: Array.isArray(items) ? items.length : 0,
                    allowPartial,
                    dueDate: dueDate || null
                }
            },
            details: {
                notes: sanitizedNotes
            }
        });

        const recordFailure = (status, description, context = {}) => {
            setAuditContext(req, {
                success: false,
                status,
                description,
                ...(context.metadata ? { metadata: context.metadata } : {}),
                ...(context.details ? { details: context.details } : {})
            });
        };

        if (!resolvedStudentReference) {
            recordFailure('ValidationError', 'Annual set issuance failed: student identifier is required');
            return res.status(400).json({ message: 'Student identifier is required' });
        }

        const set = await req.dbAdapter.findOneInCollection('annualSets', { id: req.params.id });
        if (!set) {
            recordFailure('SetNotFound', `Annual set issuance failed: set ${req.params.id} not found`);
            return res.status(404).json({ message: 'Annual set not found' });
        }

        if (!Array.isArray(set.books) || set.books.length === 0) {
            recordFailure('ValidationError', 'Annual set issuance failed: set has no books');
            return res.status(400).json({ message: 'Annual set does not contain any books' });
        }

        let student = await req.dbAdapter.findUserById(resolvedStudentReference);
        if (!student) {
            student = await findUserByAnyIdentifier(req.dbAdapter, resolvedStudentReference);
        }

        if (!student) {
            recordFailure('StudentNotFound', `Annual set issuance failed: student ${resolvedStudentReference} not found`);
            return res.status(404).json({ message: 'Student not found' });
        }

        if (student.role && student.role !== 'student') {
            recordFailure('ValidationError', 'Annual set issuance failed: selected user is not a student');
            return res.status(400).json({ message: 'Selected user is not a student' });
        }

        if (student.isActive === false) {
            recordFailure('ValidationError', 'Annual set issuance failed: student account inactive');
            return res.status(400).json({ message: 'Student account is inactive' });
        }

        const allTransactions = await req.dbAdapter.findInCollection('transactions', {});
        const hasBorrowedSet = (allTransactions || []).some(txn => {
            if (!txn || txn.status === 'returned') {
                return false;
            }
            return String(txn.annualSetId || '') === String(set.id) && String(txn.userId || '') === String(student.id || student._id || '');
        });

        if (hasBorrowedSet) {
            recordFailure('Conflict', 'Annual set issuance failed: student already borrowed this set');
            return res.status(400).json({ message: 'Student already borrowed this annual set' });
        }

        const books = await req.dbAdapter.findInCollection('books', {});
        if (!Array.isArray(books) || books.length === 0) {
            recordFailure('ValidationError', 'Annual set issuance failed: no books available in catalogue');
            return res.status(400).json({ message: 'No books found in catalogue' });
        }

        const bookLookup = new Map();
        books.forEach(book => {
            if (!book) {
                return;
            }
            [book.id, book._id, book.bookId, book.isbn]
                .filter(Boolean)
                .map(value => String(value))
                .forEach(key => {
                    if (!bookLookup.has(key)) {
                        bookLookup.set(key, book);
                    }
                });
        });

        const providedItems = Array.isArray(items)
            ? items
                .filter(item => item && item.bookId && item.copyId)
                .map(item => ({
                    bookId: String(item.bookId),
                    copyId: String(item.copyId)
                }))
            : [];

        const providedMap = new Map();
        providedItems.forEach(item => {
            const list = providedMap.get(item.bookId) || [];
            list.push(item.copyId);
            providedMap.set(item.bookId, list);
        });

        const assignments = [];
        const errors = [];
        const actorId = req.user?.id || req.user?._id || null;
        const usedCopyIds = new Set();

        for (let index = 0; index < set.books.length; index += 1) {
            const entry = set.books[index] || {};
            const baseQuantity = Math.max(parseInt(entry.quantity, 10) || 1, 1);
            const quantity = baseQuantity;
            const allowedCopyIds = Array.isArray(entry.copyIds) && entry.copyIds.length > 0
                ? new Set(entry.copyIds.map(value => String(value)))
                : null;

            const book = bookLookup.get(String(entry.bookId));
            if (!book) {
                if (entry.required !== false) {
                    errors.push(`Book not found for entry index ${index + 1}`);
                }
                continue;
            }

            const candidates = Array.isArray(book.copies)
                ? book.copies.filter(copy => {
                    if (!copy || copy.status !== 'available') {
                        return false;
                    }
                    if (allowedCopyIds && !allowedCopyIds.has(String(copy.copyId))) {
                        return false;
                    }
                    return true;
                })
                : [];

            const entryAssignments = [];
            const availableQueue = [...candidates];
            const identifierCandidates = [
                String(entry.bookId),
                String(book.id || ''),
                String(book._id || ''),
                String(book.bookId || ''),
                String(book.isbn || '')
            ].filter(Boolean);

            const providedForEntry = [];
            identifierCandidates.forEach(key => {
                if (providedMap.has(key)) {
                    providedForEntry.push(...providedMap.get(key));
                    providedMap.delete(key);
                }
            });

            const invalidProvided = [];

            providedForEntry.forEach(copyId => {
                const idx = availableQueue.findIndex(copy => String(copy.copyId) === copyId);
                if (idx === -1) {
                    invalidProvided.push(copyId);
                    return;
                }

                const copy = availableQueue.splice(idx, 1)[0];
                if (usedCopyIds.has(String(copy.copyId))) {
                    invalidProvided.push(copy.copyId);
                    return;
                }

                entryAssignments.push({ book, copy, entry });
                usedCopyIds.add(String(copy.copyId));
            });

            if (invalidProvided.length > 0) {
                errors.push(`Selected copy ${invalidProvided[0]} is not available for ${book.title || entry.bookId}`);
            }

            while (entryAssignments.length < quantity && availableQueue.length > 0) {
                const copy = availableQueue.shift();
                if (!copy) {
                    break;
                }
                if (usedCopyIds.has(String(copy.copyId))) {
                    continue;
                }
                entryAssignments.push({ book, copy, entry });
                usedCopyIds.add(String(copy.copyId));
            }

            if (entryAssignments.length < quantity) {
                if (entry.required !== false && !allowPartial) {
                    errors.push(`Not enough available copies for ${book.title || entry.bookId}`);
                }
            }

            assignments.push(...entryAssignments);
        }

        if (errors.length > 0) {
            recordFailure('ValidationError', `Annual set issuance failed: ${errors[0]}`, { details: { errors } });
            return res.status(400).json({
                message: errors[0],
                details: errors
            });
        }

        if (assignments.length === 0) {
            recordFailure('ValidationError', 'Annual set issuance failed: no copies assigned');
            return res.status(400).json({ message: 'No book copies could be assigned' });
        }

        const borrowDate = new Date();
        const providedDueDate = dueDate ? new Date(dueDate) : null;
        const dueDateValue = null;

        const updatesByBook = new Map();
        assignments.forEach(assignment => {
            const book = assignment.book;
            const key = String(book.id || book._id);
            const record = updatesByBook.get(key) || { book, copyIds: [] };
            record.copyIds.push(String(assignment.copy.copyId));
            updatesByBook.set(key, record);
        });

        const transactionItems = [];

        for (const record of updatesByBook.values()) {
            const { book, copyIds } = record;
            const updatedCopies = (book.copies || []).map(copy => {
                if (copyIds.includes(String(copy.copyId))) {
                    return {
                        ...copy,
                        status: 'borrowed',
                        updatedAt: new Date(),
                        updatedBy: actorId
                    };
                }
                return copy;
            });

            const bookQuery = book.id ? { id: book.id } : { _id: book._id };
            await req.dbAdapter.updateInCollection('books', bookQuery, {
                copies: updatedCopies,
                availableCopies: updatedCopies.filter(copy => copy.status === 'available').length,
                updatedAt: new Date()
            });

            copyIds.forEach(copyId => {
                transactionItems.push({
                    copyId,
                    bookId: book.id || book._id,
                    isbn: book.isbn,
                    status: 'borrowed'
                });
            });
        }

    const transactionId = generateTransactionId('annual');
        const studentRecordKey = student.id || student._id;

        const transactionData = {
            id: transactionId,
            userId: studentRecordKey,
            items: transactionItems,
            type: 'annual-set',
            status: 'borrowed',
            borrowDate,
            dueDate: dueDateValue,
            returnDate: null,
            fineAmount: 0,
            notes: sanitizedNotes,
            renewalCount: 0,
            createdAt: new Date(),
            updatedAt: new Date(),
            createdBy: actorId,
            annualSetId: set.id,
            annualSetName: set.name || '',
            metadata: {
                academicYear: set.academicYear || '',
                gradeLevel: set.gradeLevel || '',
                section: set.section || '',
                curriculum: set.curriculum || '',
                providedDueDate: providedDueDate && !Number.isNaN(providedDueDate.getTime()) ? providedDueDate.toISOString() : null
            }
        };

        await req.dbAdapter.insertIntoCollection('transactions', transactionData);

        const stats = student.borrowingStats || {};
        const updatedStats = {
            totalBorrowed: (stats.totalBorrowed || 0) + transactionItems.length,
            currentlyBorrowed: (stats.currentlyBorrowed || 0) + transactionItems.length,
            totalFines: stats.totalFines || 0,
            totalReturned: stats.totalReturned || 0
        };

        const userQuery = student.id ? { id: student.id } : { _id: student._id };
        await req.dbAdapter.updateInCollection('users', userQuery, {
            borrowingStats: updatedStats,
            updatedAt: new Date()
        });

        const updatedTransactions = await req.dbAdapter.findInCollection('transactions', {});
        const metrics = buildIssueMetrics(updatedTransactions.filter(txn => String(txn.annualSetId || '') === String(set.id)));
        const metricEntry = metrics.get(String(set.id)) || { total: 0, active: 0 };

        await req.dbAdapter.updateInCollection('annualSets', { id: set.id }, {
            updatedAt: new Date(),
            updatedBy: actorId
        });

        setAuditContext(req, {
            success: true,
            status: 'Issued',
            entityId: set.id,
            resourceId: transactionId,
            description: `Issued annual set ${set.name || set.id} to student ${studentRecordKey}`,
            metadata: {
                actorId,
                transactionId,
                assignedCopies: transactionItems.length,
                dueDate: null,
                providedDueDate: providedDueDate && !Number.isNaN(providedDueDate.getTime()) ? providedDueDate.toISOString() : null
            },
            details: {
                student: {
                    id: studentRecordKey,
                    name: student.firstName ? `${student.firstName} ${student.lastName || ''}`.trim() : student.username || student.email || ''
                },
                items: transactionItems
            }
        });

        res.status(201).json({
            message: 'Annual set issued successfully',
            transaction: {
                id: transactionData.id,
                borrowDate: transactionData.borrowDate,
                dueDate: transactionData.dueDate,
                items: transactionData.items
            },
            issuedCount: metricEntry.total || 0,
            activeIssues: metricEntry.active || 0
        });
    } catch (error) {
        console.error('Annual set issue error:', error);
        setAuditContext(req, {
            success: false,
            status: 'Error',
            description: `Annual set issuance failed: ${error.message}`,
            details: {
                error: error.message
            }
        });
        res.status(500).json({ message: 'Failed to issue annual set to student' });
    }
});

router.post('/', verifyToken, requireStaff, logAction('CREATE', 'annual_set'), async(req, res) => {
    try {
        const payload = req.body || {};

        setAuditContext(req, {
            metadata: {
                createRequest: {
                    name: payload.name || null,
                    academicYear: payload.academicYear || null,
                    gradeLevel: payload.gradeLevel || null,
                    section: payload.section || null,
                    bookCount: Array.isArray(payload.books) ? payload.books.length : 0
                }
            }
        });

        const fail = (status, description) => {
            setAuditContext(req, {
                success: false,
                status,
                description
            });
        };

        if (!payload.gradeLevel) {
            fail('ValidationError', 'Annual set creation failed: gradeLevel is required');
            return res.status(400).json({ message: 'gradeLevel is required' });
        }

        if (!Array.isArray(payload.books) || payload.books.length === 0) {
            fail('ValidationError', 'Annual set creation failed: at least one book required');
            return res.status(400).json({ message: 'At least one book is required for the annual set' });
        }

        const document = buildAnnualSetDocument(payload, req.user || {});
        await req.dbAdapter.insertIntoCollection('annualSets', document);

    const books = await req.dbAdapter.findInCollection('books', {});
    const [enriched] = enrichSetsWithBooks([document], books, new Map());

        setAuditContext(req, {
            success: true,
            status: 'Created',
            entityId: document.id,
            resourceId: document.id,
            description: `Created annual set ${document.name || document.id}`,
            metadata: {
                actorId: req.user?.id || req.user?._id || null,
                bookCount: document.books ?.length || 0
            }
        });

        res.status(201).json(enriched);
    } catch (error) {
        console.error('Annual set create error:', error);
        setAuditContext(req, {
            success: false,
            status: 'Error',
            description: `Annual set creation failed: ${error.message}`,
            details: {
                error: error.message
            }
        });
        res.status(500).json({ message: 'Failed to create annual borrowing set' });
    }
});

router.put('/:id', verifyToken, requireStaff, logAction('UPDATE', 'annual_set'), async(req, res) => {
    try {
        setAuditContext(req, {
            entityId: req.params.id,
            metadata: {
                updateRequest: {
                    setId: req.params.id,
                    fields: Object.keys(req.body || {})
                }
            }
        });
        const existing = await req.dbAdapter.findOneInCollection('annualSets', { id: req.params.id });

        if (!existing) {
            setAuditContext(req, {
                success: false,
                status: 'SetNotFound',
                description: `Annual set update failed: set ${req.params.id} not found`
            });
            return res.status(404).json({ message: 'Annual set not found' });
        }

        applyEditableFields(existing, req.body || {});
        existing.updatedAt = new Date();
        existing.updatedBy = req.user?.id || req.user?._id || existing.updatedBy || null;

        await req.dbAdapter.updateInCollection('annualSets', { id: req.params.id }, existing);

    const books = await req.dbAdapter.findInCollection('books', {});
    const allTransactions = await req.dbAdapter.findInCollection('transactions', {});
    const metrics = buildIssueMetrics(allTransactions.filter(txn => String(txn.annualSetId || '') === String(existing.id)));
    const [enriched] = enrichSetsWithBooks([existing], books, metrics);

        setAuditContext(req, {
            success: true,
            status: 'Updated',
            entityId: req.params.id,
            resourceId: req.params.id,
            description: `Updated annual set ${existing.name || req.params.id}`,
            metadata: {
                actorId: req.user?.id || req.user?._id || null
            }
        });

        res.json(enriched);
    } catch (error) {
        console.error('Annual set update error:', error);
        setAuditContext(req, {
            success: false,
            status: 'Error',
            description: `Annual set update failed: ${error.message}`,
            details: {
                error: error.message
            }
        });
        res.status(500).json({ message: 'Failed to update annual borrowing set' });
    }
});

router.delete('/:id', verifyToken, requireStaff, logAction('DELETE', 'annual_set'), async(req, res) => {
    try {
        setAuditContext(req, {
            entityId: req.params.id
        });
        const existing = await req.dbAdapter.findOneInCollection('annualSets', { id: req.params.id });

        if (!existing) {
            setAuditContext(req, {
                success: false,
                status: 'SetNotFound',
                description: `Annual set deletion failed: set ${req.params.id} not found`
            });
            return res.status(404).json({ message: 'Annual set not found' });
        }

        await req.dbAdapter.deleteFromCollection('annualSets', { id: req.params.id });

        setAuditContext(req, {
            success: true,
            status: 'Deleted',
            entityId: req.params.id,
            resourceId: req.params.id,
            description: `Deleted annual set ${existing.name || req.params.id}`,
            metadata: {
                actorId: req.user?.id || req.user?._id || null
            }
        });

        res.json({ message: 'Annual set removed successfully' });
    } catch (error) {
        console.error('Annual set delete error:', error);
        setAuditContext(req, {
            success: false,
            status: 'Error',
            description: `Annual set deletion failed: ${error.message}`,
            details: {
                error: error.message
            }
        });
        res.status(500).json({ message: 'Failed to remove annual borrowing set' });
    }
});

module.exports = router;
```

## audit.js

| Field | Details |
| --- | --- |
| Program Name | audit.js |
| Description | API route handler for audit resources. |
| Called by | app.js |
| Table used | audit |
|  |  |
| Programmer | Nazel Asca√±o |
| Date created | 12/14/2025 |
| Revision Date | TBD |
| Revision / description of change | None |

```javascript
const express = require('express');
const { verifyToken, requireAdmin } = require('../middleware/customAuth');
const router = express.Router();

const toPlainObject = (value) =>
    value && typeof value === 'object' && !Array.isArray(value) ? value : {};

const collectUserSearchCandidates = (log = {}) => {
    const details = toPlainObject(log.details);
    const metadata = toPlainObject(log.metadata);
    const nestedUser = toPlainObject(log.user);
    const detailStudent = toPlainObject(details.student);
    const metadataStudent = toPlainObject(metadata.student);
    const detailUser = toPlainObject(details.user);
    const metadataUser = toPlainObject(metadata.user);
    const detailLibrary = toPlainObject(details.library);
    const metadataLibrary = toPlainObject(metadata.library);
    const nestedLibrary = toPlainObject(nestedUser.library);
    const detailUserLibrary = toPlainObject(detailUser.library);
    const metadataUserLibrary = toPlainObject(metadataUser.library);
    const detailProfile = toPlainObject(details.profile);
    const metadataProfile = toPlainObject(metadata.profile);
    const profileLibrary = toPlainObject(detailProfile.library);
    const metadataProfileLibrary = toPlainObject(metadataProfile.library);
    const request = toPlainObject(metadata.createRequest || metadata.request);
    const requestStudent = toPlainObject(request.student);
    const requestLibrary = toPlainObject(request.library);

    const buildName = (source) => {
        if (!source) return '';
        return [source.firstName, source.middleName, source.lastName]
            .filter(Boolean)
            .join(' ');
    };

    return [
        log.userId,
        details.userId,
        metadata.userId,
        detailUser.userId,
        metadataUser.userId,
        detailUser.id,
        metadataUser.id,
        nestedUser.id,
        nestedUser.userId,
        log.studentName,
        details.studentName,
        metadata.studentName,
        detailStudent.name,
        metadataStudent.name,
        detailUser.name,
        metadataUser.name,
        detailProfile.name,
        metadataProfile.name,
        request.studentName,
        request.name,
        buildName(detailProfile),
        buildName(metadataProfile),
        buildName(request),
        buildName(requestStudent),
        buildName(detailStudent),
        buildName(metadataStudent),
        buildName(detailUser),
        buildName(metadataUser),
        buildName(nestedUser),
        log.username,
        details.username,
        metadata.username,
        detailUser.username,
        metadataUser.username,
        nestedUser.username,
        log.userName,
        log.userEmail,
        nestedUser.email,
        detailUser.email,
        metadataUser.email,
        log.libraryId,
        log.libraryCardNumber,
        details.libraryId,
        details.libraryCardNumber,
        detailLibrary.cardNumber,
        detailStudent.libraryCardNumber,
        metadataStudent.libraryCardNumber,
        detailProfile.libraryCardNumber,
        metadataProfile.libraryCardNumber,
        profileLibrary.cardNumber,
        metadataProfileLibrary.cardNumber,
        request.libraryId,
        request.libraryCardNumber,
        requestStudent.libraryCardNumber,
        requestLibrary.cardNumber,
        metadata.libraryId,
        metadata.libraryCardNumber,
        metadataLibrary.cardNumber,
        detailUserLibrary.cardNumber,
        metadataUserLibrary.cardNumber,
        nestedUser.libraryCardNumber,
        nestedLibrary.cardNumber,
    ].filter(Boolean);
};

const collectUserRecordCandidates = (user = {}) => {
    const library = toPlainObject(user.library);
    return [
        user._id,
        user.id,
        user.userId,
        user.username,
        user.email,
        user.firstName,
        user.middleName,
        user.lastName,
        [user.firstName, user.middleName, user.lastName].filter(Boolean).join(' '),
        library.cardNumber,
        library.cardId,
        user.libraryCardNumber,
    ].filter(Boolean);
};

const matchesUserRecord = (user, term) => {
    if (!term) return false;
    const normalized = term.trim().toLowerCase();
    if (!normalized) return false;
    return collectUserRecordCandidates(user).some((candidate) =>
        String(candidate).toLowerCase().includes(normalized)
    );
};

const collectLogIdentifierSet = (log) => {
    const candidates = collectUserSearchCandidates(log);
    return new Set(
        candidates.map((candidate) => String(candidate).toLowerCase())
    );
};

const matchesUserQuery = (log, term) => {
    if (!term) return true;
    const normalized = term.trim().toLowerCase();
    if (!normalized) return true;
    return collectUserSearchCandidates(log).some((candidate) =>
        String(candidate).toLowerCase().includes(normalized)
    );
};

router.get('/', verifyToken, requireAdmin, async(req, res) => {
    try {
        const {
            page = 1,
                limit = 50,
                action,
                entity,
                userId,
                role,
                userQuery,
                startDate,
                endDate
        } = req.query;
        const normalizedUserQuery = typeof userQuery === 'string' ? userQuery.trim() : '';

        let filters = {};
        if (action) filters.action = action;
        if (entity) filters.entity = entity;
        if (userId) filters.userId = userId;
        if (role) filters.userRole = role;

        let auditLogs = await req.dbAdapter.findInCollection('audit', filters);

        if (startDate || endDate) {
            auditLogs = auditLogs.filter(log => {
                const logDate = new Date(log.timestamp);
                if (startDate && logDate < new Date(startDate)) return false;
                if (endDate && logDate > new Date(endDate)) return false;
                return true;
            });
        }

        let matchedUserIdentifiers = null;

        if (normalizedUserQuery) {
            const users = await req.dbAdapter.findInCollection('users', {});
            matchedUserIdentifiers = new Set();

            users.forEach((user) => {
                if (matchesUserRecord(user, normalizedUserQuery)) {
                    collectUserRecordCandidates(user).forEach((identifier) =>
                        matchedUserIdentifiers.add(String(identifier).toLowerCase()),
                    );
                }
            });

            auditLogs = auditLogs.filter((log) => {
                if (matchesUserQuery(log, normalizedUserQuery)) {
                    return true;
                }

                if (matchedUserIdentifiers && matchedUserIdentifiers.size > 0) {
                    const logIdentifiers = collectLogIdentifierSet(log);
                    for (const identifier of logIdentifiers) {
                        if (matchedUserIdentifiers.has(identifier)) {
                            return true;
                        }
                    }
                }
                return false;
            });
        }

        auditLogs.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));

        const skip = (page - 1) * limit;
        const total = auditLogs.length;
        const paginatedLogs = auditLogs.slice(skip, skip + parseInt(limit));

        res.json({
            logs: paginatedLogs,
            pagination: {
                page: parseInt(page),
                limit: parseInt(limit),
                total,
                pages: Math.ceil(total / limit)
            }
        });

    } catch (error) {
        console.error('Get audit logs error:', error);
        res.status(500).json({ message: 'Failed to fetch audit logs' });
    }
});

router.get('/user/:userId', verifyToken, requireAdmin, async(req, res) => {
    try {
        const userId = req.params.userId;
        const { limit = 100 } = req.query;

        let userLogs = await req.dbAdapter.findInCollection('audit', { userId });

        userLogs.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));

        userLogs = userLogs.slice(0, parseInt(limit));

        res.json(userLogs);
    } catch (error) {
        console.error('Get user audit logs error:', error);
        res.status(500).json({ message: 'Failed to fetch user audit logs' });
    }
});

router.get('/action/:action', verifyToken, requireAdmin, async(req, res) => {
    try {
        const action = req.params.action;
        const { limit = 100, startDate, endDate } = req.query;

        let actionLogs = await req.dbAdapter.findInCollection('audit', { action });

        if (startDate || endDate) {
            actionLogs = actionLogs.filter(log => {
                const logDate = new Date(log.timestamp);
                if (startDate && logDate < new Date(startDate)) return false;
                if (endDate && logDate > new Date(endDate)) return false;
                return true;
            });
        }

        actionLogs.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));

        if (limit) {
            actionLogs = actionLogs.slice(0, parseInt(limit));
        }

        res.json(actionLogs);
    } catch (error) {
        console.error('Get action audit logs error:', error);
        res.status(500).json({ message: 'Failed to fetch action audit logs' });
    }
});

router.get('/stats', verifyToken, requireAdmin, async(req, res) => {
    try {
        const { days = 7 } = req.query;
        const startDate = new Date();
        startDate.setDate(startDate.getDate() - parseInt(days));

        const allLogs = await req.dbAdapter.findInCollection('audit', {});

        const recentLogs = allLogs.filter(log => {
            const logDate = new Date(log.timestamp);
            return logDate >= startDate;
        });

        const actionCounts = {};
        recentLogs.forEach(log => {
            actionCounts[log.action] = (actionCounts[log.action] || 0) + 1;
        });

        res.json({
            totalLogs: recentLogs.length,
            actionCounts,
            dateRange: { startDate, endDate: new Date() }
        });
    } catch (error) {
        console.error('Get audit stats error:', error);
        res.status(500).json({ message: 'Failed to fetch audit statistics' });
    }
});

router.get('/stats/summary', verifyToken, requireAdmin, async(req, res) => {
    try {
        const {
            days = 7,
            action,
            entity,
            role,
            userQuery,
            startDate,
            endDate,
        } = req.query;

        const normalizedUserQuery = typeof userQuery === 'string' ? userQuery.trim() : '';
        const parsedDays = Number.isNaN(parseInt(days, 10)) ? 7 : parseInt(days, 10);

        let filters = {};
        if (action) filters.action = action;
        if (entity) filters.entity = entity;
        if (role) filters.userRole = role;

        let filteredLogs = await req.dbAdapter.findInCollection('audit', filters);

        const parseDate = (value) => {
            if (!value) return null;
            const parsed = new Date(value);
            return Number.isNaN(parsed.getTime()) ? null : parsed;
        };

        const rangeStart = parseDate(startDate) || (() => {
            const fallback = new Date();
            fallback.setDate(fallback.getDate() - parsedDays);
            return fallback;
        })();

        const rangeEnd = parseDate(endDate) || new Date();

        let normalizedStart = rangeStart;
        let normalizedEnd = rangeEnd;
        if (normalizedStart > normalizedEnd) {
            const temp = normalizedStart;
            normalizedStart = normalizedEnd;
            normalizedEnd = temp;
        }

        filteredLogs = filteredLogs.filter((log) => {
            const timestamp = new Date(log.timestamp);
            if (Number.isNaN(timestamp.getTime())) {
                return false;
            }
            return timestamp >= normalizedStart && timestamp <= normalizedEnd;
        });

        if (normalizedUserQuery) {
            const users = await req.dbAdapter.findInCollection('users', {});
            const matchedUserIdentifiers = new Set();

            users.forEach((user) => {
                if (matchesUserRecord(user, normalizedUserQuery)) {
                    collectUserRecordCandidates(user).forEach((identifier) =>
                        matchedUserIdentifiers.add(String(identifier).toLowerCase()),
                    );
                }
            });

            filteredLogs = filteredLogs.filter((log) => {
                if (matchesUserQuery(log, normalizedUserQuery)) {
                    return true;
                }

                if (matchedUserIdentifiers.size > 0) {
                    const logIdentifiers = collectLogIdentifierSet(log);
                    for (const identifier of logIdentifiers) {
                        if (matchedUserIdentifiers.has(identifier)) {
                            return true;
                        }
                    }
                }
                return false;
            });
        }

        const stats = {
            totalLogs: filteredLogs.length,
            actionCounts: {},
            entityCounts: {},
            userCounts: {},
            dailyActivity: {},
        };

        filteredLogs.forEach((log) => {
            const actionKey = log?.action || 'unknown';
            stats.actionCounts[actionKey] = (stats.actionCounts[actionKey] || 0) + 1;

            const entityKey = log?.entity || log?.resource || 'unknown';
            stats.entityCounts[entityKey] = (stats.entityCounts[entityKey] || 0) + 1;

            const userKey = log?.userId || log?.userEmail || log?.userName || 'unknown';
            stats.userCounts[userKey] = (stats.userCounts[userKey] || 0) + 1;

            const dayKey = new Date(log.timestamp).toDateString();
            stats.dailyActivity[dayKey] = (stats.dailyActivity[dayKey] || 0) + 1;
        });

        res.json({
            ...stats,
            dateRange: {
                startDate: normalizedStart,
                endDate: normalizedEnd,
            },
            filtersApplied: {
                action: action || null,
                entity: entity || null,
                role: role || null,
                userQuery: normalizedUserQuery || null,
            },
        });
    } catch (error) {
        console.error('Get audit stats error:', error);
        res.status(500).json({ message: 'Failed to fetch audit statistics' });
    }
});

router.get('/recent/activity', verifyToken, requireAdmin, async(req, res) => {
    try {
        const { limit = 20 } = req.query;

        let recentActivity = await req.dbAdapter.findInCollection('audit', {});

        recentActivity.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));

        recentActivity = recentActivity.slice(0, parseInt(limit));

        res.json(recentActivity);
    } catch (error) {
        console.error('Get recent activity error:', error);
        res.status(500).json({ message: 'Failed to fetch recent activity' });
    }
});

router.get('/export/csv', verifyToken, requireAdmin, async(req, res) => {
    try {
        const { startDate, endDate } = req.query;

        let allLogs = await req.dbAdapter.findInCollection('audit', {});

        if (startDate || endDate) {
            allLogs = allLogs.filter(log => {
                const logDate = new Date(log.timestamp);
                if (startDate && logDate < new Date(startDate)) return false;
                if (endDate && logDate > new Date(endDate)) return false;
                return true;
            });
        }

        allLogs.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));

        const headers = ['Timestamp', 'User Email', 'User Role', 'Action', 'Entity', 'Entity ID', 'IP Address', 'Status'];
        let csvContent = headers.join(',') + '\n';

        allLogs.forEach(log => {
            const row = [
                new Date(log.timestamp).toISOString(),
                log.userEmail || '',
                log.userRole || '',
                log.action || '',
                log.entity || '',
                log.entityId || '',
                log.ipAddress || '',
                log.status || ''
            ];
            csvContent += row.map(field => `"${field}"`).join(',') + '\n';
        });

        res.setHeader('Content-Type', 'text/csv');
        res.setHeader('Content-Disposition', 'attachment; filename="audit_logs.csv"');
        res.send(csvContent);

    } catch (error) {
        console.error('Export audit logs error:', error);
        res.status(500).json({ message: 'Failed to export audit logs' });
    }
});

router.get('/:id', verifyToken, requireAdmin, async(req, res) => {
    try {
        const log = await req.dbAdapter.findOneInCollection('audit', { id: req.params.id });

        if (!log) {
            return res.status(404).json({ message: 'Audit log not found' });
        }

        res.json(log);
    } catch (error) {
        console.error('Get audit log error:', error);
        res.status(500).json({ message: 'Failed to fetch audit log' });
    }
});

module.exports = router;
```

## books.js

| Field | Details |
| --- | --- |
| Program Name | books.js |
| Description | API route handler for books resources. |
| Called by | app.js |
| Table used | books |
|  |  |
| Programmer | Nazel Asca√±o |
| Date created | 12/14/2025 |
| Revision Date | TBD |
| Revision / description of change | None |

```javascript
const express = require('express');
const { PDFDocument, StandardFonts, rgb } = require('pdf-lib');
const QRCode = require('qrcode');
const { ObjectId } = require('mongodb');
const { verifyToken, requireStaff, requireLibrarian, logAction, setAuditContext } = require('../middleware/customAuth');
const { maybeNotifyLowInventory } = require('../utils/inventoryNotifications');
const router = express.Router();

const allowedCopyStatuses = new Set(['available', 'borrowed', 'lost', 'damaged', 'maintenance']);

const toFiniteNumber = (value) => {
    if (typeof value === 'number' && Number.isFinite(value)) {
        return value;
    }
    if (typeof value === 'string') {
        const trimmed = value.trim();
        if (trimmed !== '') {
            const parsed = Number(trimmed);
            if (Number.isFinite(parsed)) {
                return parsed;
            }
        }
    }
    return null;
};

const notifyInventoryState = async (req, bookSnapshot, source) => {
    if (!req || !bookSnapshot) {
        return;
    }
    try {
        await maybeNotifyLowInventory(req.dbAdapter, bookSnapshot, { source });
    } catch (error) {
        console.error('Inventory notification error:', error.message || error);
    }
};

const computePublishedYear = (explicitYear, dateValue) => {
    if (explicitYear !== undefined && explicitYear !== null && String(explicitYear).trim() !== '') {
        const parsedYear = parseInt(explicitYear, 10);
        if (Number.isNaN(parsedYear) || `${parsedYear}`.length !== 4) {
            throw new Error('Invalid published year');
        }
        return { shouldUpdate: true, value: parsedYear };
    }

    if (dateValue) {
        const parsedDate = new Date(dateValue);
        if (!Number.isNaN(parsedDate.getTime())) {
            return { shouldUpdate: true, value: parsedDate.getFullYear() };
        }
    }

    return { shouldUpdate: false };
};

const generateCopyId = (isbn) => {
    const timestamp = Date.now().toString(36);
    const random = Math.random().toString(36).substr(2, 4);
    return `${isbn}-${timestamp}-${random}`.toUpperCase();
};

const normalizeStatus = (status) => {
    if (!status) return 'pending';
    return status === 'borrowed' ? 'active' : status;
};

const buildLookupMap = (records, keysResolver) => {
    const map = new Map();
    records.forEach(record => {
        const keys = keysResolver(record) || [];
        keys.filter(Boolean).forEach(key => {
            map.set(String(key).toLowerCase(), record);
        });
    });
    return map;
};

const getBorrowerName = (user) => {
    if (!user) return 'Unknown Borrower';
    if (user.fullName) return user.fullName;
    const nameParts = [user.firstName, user.middleName, user.lastName].filter(Boolean).join(' ').trim();
    if (nameParts) return nameParts;
    return user.username || user.email || 'Unknown Borrower';
};

const normalizeString = (value) => {
    if (!value) return '';
    return String(value).toLowerCase().trim();
};

const availableCopiesCount = (copies = []) =>
    copies.filter((copy) => normalizeString(copy.status) === 'available').length;

const getAvailableQuantity = (book = {}) => {
    if (!book || typeof book !== 'object') {
        return 0;
    }
    const directValue = toFiniteNumber(
        book.availableCopiesCount !== undefined ? book.availableCopiesCount : book.availableCopies
    );
    if (directValue !== null && directValue >= 0) {
        return directValue;
    }
    if (Array.isArray(book.copies)) {
        return availableCopiesCount(book.copies);
    }
    return 0;
};

const sanitizeAuthorName = (value) => {
    if (value === undefined || value === null) {
        return null;
    }
    const normalized = String(value).replace(/\s+/g, ' ').trim();
    return normalized || null;
};

const splitDelimitedAuthors = (value) => {
    if (typeof value !== 'string') {
        return [];
    }
    if (/[;,|]/.test(value)) {
        return value.split(/[,;|]/).map(sanitizeAuthorName).filter(Boolean);
    }
    const normalized = sanitizeAuthorName(value);
    return normalized ? [normalized] : [];
};

const mergeAuthorSources = (...sources) => {
    const seen = new Set();
    const authors = [];
    sources.forEach((source) => {
        if (source === undefined || source === null) {
            return;
        }
        if (Array.isArray(source)) {
            source.forEach((entry) => {
                const normalized = sanitizeAuthorName(entry);
                if (normalized && !seen.has(normalized.toLowerCase())) {
                    seen.add(normalized.toLowerCase());
                    authors.push(normalized);
                }
            });
            return;
        }
        if (typeof source === 'string') {
            splitDelimitedAuthors(source).forEach((entry) => {
                if (entry && !seen.has(entry.toLowerCase())) {
                    seen.add(entry.toLowerCase());
                    authors.push(entry);
                }
            });
        }
    });
    return authors;
};

const deriveAuthorsFromPayload = (payload = {}) => {
    const authors = mergeAuthorSources(payload.authors, payload.author);
    return {
        authors,
        authorDisplay: authors.length > 0 ? authors.join(', ') : '',
        hasAuthors: authors.length > 0
    };
};

const ensureAuthorMetadata = (record) => {
    if (!record || typeof record !== 'object') {
        return record;
    }
    const merged = mergeAuthorSources(record.authors, record.author);
    record.authors = merged;
    if (merged.length > 0) {
        record.author = merged.join(', ');
    } else if (typeof record.author !== 'string') {
        record.author = '';
    }
    return record;
};

const matchesBookSearch = (book, term) => {
    if (!term) return true;
    if (typeof term === 'string' && term.trim() === '') return true;
    const searchTerm = normalizeString(term);
    if (!searchTerm) return true;
    const fields = [
        book.title,
        book.author,
        book.isbn,
        book.publisher,
        book.category,
        book.description,
        book.id,
        book._id
    ];

    if (fields.some((field) => normalizeString(field).includes(searchTerm))) {
        return true;
    }

    if (Array.isArray(book.authors) && book.authors.some((author) => normalizeString(author).includes(searchTerm))) {
        return true;
    }

    if (Array.isArray(book.copies)) {
        for (const copy of book.copies) {
            const copyFields = [
                copy.copyId,
                copy.location,
                copy.status,
                copy.condition,
                copy.barcode
            ];
            if (copyFields.some((value) => normalizeString(value).includes(searchTerm))) {
                return true;
            }
        }
    }

    return false;
};

const buildBookSummary = (book) => {
    const copies = Array.isArray(book.copies) ? book.copies : [];
    const availableCopies = copies.filter((copy) => normalizeString(copy.status) === 'available');
    const primaryId = book.id || book._id;

    if (!primaryId) {
        return null;
    }

    return {
        id: String(primaryId),
        _id: book._id,
        title: book.title || 'Untitled',
        author: book.author || 'Unknown Author',
        authors: Array.isArray(book.authors) ? book.authors : [],
        isbn: book.isbn || '',
        category: book.category || '',
        publisher: book.publisher || '',
        publishedYear: book.publishedYear || book.publicationYear || null,
        availableCopies: availableCopies.length,
        totalCopies: copies.length,
        copies,
    };
};

const sanitizeFileName = (value, fallback = 'labels') => {
    if (!value || typeof value !== 'string') {
        return fallback;
    }
    return value
        .trim()
        .replace(/\s+/g, '_')
        .replace(/[^a-zA-Z0-9_\-]/g, '')
        .slice(0, 80) || fallback;
};

const normalizeIdentifierValue = (value) => {
    if (value === undefined || value === null) {
        return '';
    }
    return String(value).trim();
};

const getAdapterType = (req) => {
    if (!req?.dbAdapter || typeof req.dbAdapter.getType !== 'function') {
        return null;
    }
    try {
        return req.dbAdapter.getType();
    } catch (error) {
        return null;
    }
};

const buildBookLookupFilters = (identifier, adapterType) => {
    const normalized = normalizeIdentifierValue(identifier);
    if (!normalized) {
        return [];
    }

    const filters = [];
    const seen = new Set();
    const addFilter = (filter) => {
        if (!filter) return;
        const signature = JSON.stringify(filter);
        if (seen.has(signature)) {
            return;
        }
        seen.add(signature);
        filters.push(filter);
    };

    if (adapterType === 'mongo' && ObjectId.isValid(normalized)) {
        addFilter({ _id: new ObjectId(normalized) });
    }

    ['id', '_id', 'bookId', 'documentId'].forEach((key) => addFilter({ [key]: normalized }));

    return filters;
};

const findBookByIdentifier = async (req, identifier) => {
    const adapterType = getAdapterType(req);
    const filters = buildBookLookupFilters(identifier, adapterType);
    if (filters.length === 0) {
        return null;
    }

    for (const filter of filters) {
        try {
            const book = await req.dbAdapter.findOneInCollection('books', filter);
            if (book) {
                return ensureAuthorMetadata(book);
            }
        } catch (error) {
            console.warn(`Book lookup failed for filter ${JSON.stringify(filter)}`, error.message);
        }
    }

    return null;
};

const resolveBookPersistenceFilter = (req, book) => {
    if (!book) {
        return null;
    }

    const adapterType = getAdapterType(req);
    if (book.id) {
        return { id: book.id };
    }
    if (book._id) {
        if (adapterType === 'mongo' && ObjectId.isValid(book._id)) {
            return { _id: new ObjectId(book._id) };
        }
        return { _id: book._id };
    }
    if (book.bookId) {
        return { bookId: book.bookId };
    }
    return null;
};

const wrapTextLines = (text, maxCharsPerLine, maxLines) => {
    if (!text) {
        return [];
    }

    const words = String(text).split(/\s+/).filter(Boolean);
    const lines = [];
    let currentLine = '';

    words.forEach((word) => {
        if (!currentLine) {
            currentLine = word;
            return;
        }

        const next = `${currentLine} ${word}`;
        if (next.length <= maxCharsPerLine) {
            currentLine = next;
        } else {
            lines.push(currentLine);
            currentLine = word;
        }
    });

    if (currentLine) {
        lines.push(currentLine);
    }

    return lines.slice(0, maxLines);
};

const BOOK_CATEGORIES_COLLECTION = 'bookCategories';

const normalizeCategoryDisplayName = (value) => {
    if (value === undefined || value === null) {
        return '';
    }
    return String(value).replace(/\s+/g, ' ').trim();
};

const slugifyCategoryName = (value) => {
    const normalized = normalizeCategoryDisplayName(value).toLowerCase();
    if (!normalized) {
        return '';
    }
    return normalized
        .replace(/[^a-z0-9]+/g, '-')
        .replace(/-{2,}/g, '-')
        .replace(/^-+/, '')
        .replace(/-+$/, '');
};

const sortCategoriesByName = (records = []) =>
    [...records].sort((a, b) => (a.name || '').localeCompare(b.name || '', undefined, { sensitivity: 'base' }));

const getStoredCategories = async (dbAdapter) => {
    const records = await dbAdapter.findInCollection(BOOK_CATEGORIES_COLLECTION, {});
    if (!Array.isArray(records)) {
        return [];
    }
    return sortCategoriesByName(records);
};

const deriveCategoriesFromBooks = async (dbAdapter) => {
    const books = await dbAdapter.findInCollection('books', {});
    const names = new Set();
    books.forEach((book) => {
        const categoryName = normalizeCategoryDisplayName(book?.category);
        if (categoryName) {
            names.add(categoryName);
        }
    });
    return Array.from(names).sort((a, b) => a.localeCompare(b, undefined, { sensitivity: 'base' }));
};

const seedCategoriesFromBooks = async (dbAdapter) => {
    const derivedNames = await deriveCategoriesFromBooks(dbAdapter);
    if (!derivedNames.length) {
        return [];
    }

    for (const name of derivedNames) {
        const slug = slugifyCategoryName(name);
        if (!slug) {
            continue;
        }
        const existing = await dbAdapter.findOneInCollection(BOOK_CATEGORIES_COLLECTION, { slug });
        if (existing) {
            continue;
        }
        await dbAdapter.insertIntoCollection(BOOK_CATEGORIES_COLLECTION, {
            name,
            slug,
            source: 'auto-import'
        });
    }

    return getStoredCategories(dbAdapter);
};

const ensureStoredCategories = async (dbAdapter) => {
    const stored = await getStoredCategories(dbAdapter);
    if (stored.length) {
        return stored;
    }
    return seedCategoriesFromBooks(dbAdapter);
};

const buildBarcodePdf = async({
    book,
    copies,
    requestedCopyIds,
    generatedBy,
}) => {
    const pdfDoc = await PDFDocument.create();
    const pageWidth = 612; // 8.5in * 72
    const pageHeight = 792; // 11in * 72
    const marginX = 36;
    const marginY = 36;
    const columns = 3;
    const rows = 4;
    const cardWidth = (pageWidth - marginX * 2) / columns;
    const cardHeight = (pageHeight - marginY * 2) / rows;
    const fontRegular = await pdfDoc.embedFont(StandardFonts.Helvetica);
    const fontBold = await pdfDoc.embedFont(StandardFonts.HelveticaBold);

    let page = pdfDoc.addPage([pageWidth, pageHeight]);
    let columnIndex = 0;
    let rowIndex = 0;

    const drawLabel = async(copy) => {
        const qrDataUrl = await QRCode.toDataURL(copy.copyId, {
            errorCorrectionLevel: 'M',
            margin: 1,
            width: 256,
        });

        const pngBase64 = qrDataUrl.split(',')[1];
        const qrImage = await pdfDoc.embedPng(Buffer.from(pngBase64, 'base64'));

        if (columnIndex >= columns) {
            columnIndex = 0;
            rowIndex += 1;
        }

        if (rowIndex >= rows) {
            page = pdfDoc.addPage([pageWidth, pageHeight]);
            rowIndex = 0;
            columnIndex = 0;
        }

        const originX = marginX + columnIndex * cardWidth;
        const originY = pageHeight - marginY - (rowIndex + 1) * cardHeight;

        page.drawRectangle({
            x: originX,
            y: originY,
            width: cardWidth,
            height: cardHeight,
            borderColor: rgb(0.8, 0.8, 0.8),
            borderWidth: 0.5,
        });

        const copyIdLines = wrapTextLines(copy.copyId || 'N/A', 28, 2);
        const copyLineHeight = 11;
        const bottomPadding = 10;
        const locationBlockHeight = 12;
        const generatedByHeight = generatedBy ? 10 : 0;
        const bottomAreaHeight = bottomPadding + generatedByHeight + locationBlockHeight + copyIdLines.length * copyLineHeight;

    const bottomGaps = [8, 6, 4];
        const topMargins = [18, 16, 14, 12];
        const titleOptions = [
            { size: 12, maxChars: 26, lineHeight: 17 },
            { size: 11, maxChars: 28, lineHeight: 16 },
            { size: 10, maxChars: 32, lineHeight: 15 },
        ];
        const isbnGap = 6;
        const isbnToQrGap = 12;
        const desiredQrSize = Math.min(cardWidth - 48, 88);
        const minPreferredQr = 48;
        const minQrSize = 34;

        let layout = null;
        let lastLayout = null;
        let layoutFound = false;

        for (const gap of bottomGaps) {
            const qrAreaBottom = originY + bottomAreaHeight + gap;
            for (const margin of topMargins) {
                const titleStartY = originY + cardHeight - margin;
                for (const option of titleOptions) {
                    const lines = wrapTextLines(book.title || 'Untitled', option.maxChars, 3);
                    const titleHeight = lines.length * option.lineHeight;
                    const isbnY = titleStartY - titleHeight - isbnGap;
                    const qrTop = isbnY - isbnToQrGap;
                    const availableHeight = qrTop - qrAreaBottom;

                    lastLayout = {
                        lines,
                        fontSize: option.size,
                        lineHeight: option.lineHeight,
                        titleStartY,
                        isbnY,
                        qrTop,
                        availableHeight,
                        qrAreaBottom,
                    };

                    if (availableHeight >= minPreferredQr) {
                        layout = lastLayout;
                        layoutFound = true;
                        break;
                    }
                }
                if (layoutFound) break;
            }
            if (layoutFound) break;
        }

        if (!layout) {
            layout = lastLayout;
        }

        const qrAvailableHeight = Math.max(layout?.availableHeight || minPreferredQr, minQrSize);
        let qrSize = Math.min(desiredQrSize, qrAvailableHeight);
        if (layout && layout.availableHeight < minPreferredQr) {
            qrSize = Math.min(desiredQrSize, Math.max(layout.availableHeight, minQrSize));
        }
        if (layout && layout.availableHeight > 0) {
            qrSize = Math.min(qrSize, layout.availableHeight);
        }
        const qrAreaBottom = layout ? layout.qrAreaBottom : originY + bottomAreaHeight + bottomGaps[0];
        const qrY = qrAreaBottom + Math.max(((layout?.availableHeight || qrSize) - qrSize) / 2, 0);
        const qrX = originX + (cardWidth - qrSize) / 2;

        const titleLines = layout ? layout.lines : wrapTextLines(book.title || 'Untitled', 26, 3);
        const titleFontSize = layout ? layout.fontSize : 12;
        const titleLineHeight = layout ? layout.lineHeight : 17;
        let titleCursorY = layout ? layout.titleStartY : originY + cardHeight - 18;

        titleLines.forEach((line) => {
            page.drawText(line, {
                x: originX + 12,
                y: titleCursorY,
                size: titleFontSize,
                font: fontBold,
                color: rgb(0, 0, 0),
                maxWidth: cardWidth - 24,
            });
            titleCursorY -= titleLineHeight;
        });

        const isbnY = layout ? layout.isbnY : titleCursorY - 10;
        page.drawText(`ISBN: ${book.isbn || 'N/A'}`, {
            x: originX + 12,
            y: isbnY,
            size: 9,
            font: fontRegular,
            color: rgb(0.2, 0.2, 0.2),
            maxWidth: cardWidth - 24,
        });

        page.drawImage(qrImage, {
            x: qrX,
            y: qrY,
            width: qrSize,
            height: qrSize,
        });

        let bottomCursor = originY + bottomPadding;

        if (generatedBy) {
            page.drawText(`Printed by: ${generatedBy}`, {
                x: originX + 12,
                y: bottomCursor,
                size: 7,
                font: fontRegular,
                color: rgb(0.45, 0.45, 0.45),
                maxWidth: cardWidth - 24,
            });
            bottomCursor += generatedByHeight;
        }

        const locationText = `Location: ${copy.location || 'Main Library'}`;
        page.drawText(locationText, {
            x: originX + 12,
            y: bottomCursor,
            size: 9,
            font: fontRegular,
            color: rgb(0.2, 0.2, 0.2),
            maxWidth: cardWidth - 24,
        });
        bottomCursor += locationBlockHeight;

        copyIdLines.slice().reverse().forEach((line) => {
            page.drawText(line, {
                x: originX + 12,
                y: bottomCursor,
                size: 10,
                font: fontRegular,
                color: rgb(0, 0, 0),
                maxWidth: cardWidth - 24,
            });
            bottomCursor += copyLineHeight;
        });

        columnIndex += 1;
    };

    for (const copy of copies) {

        await drawLabel(copy);
    }

    const pdfBytes = await pdfDoc.save();
    const safeName = sanitizeFileName(`${book.title || 'book'}_${requestedCopyIds.length}_barcodes`);

    return {
        filename: `${safeName}.pdf`,
        buffer: Buffer.from(pdfBytes),
    };
};

router.get('/', verifyToken, async(req, res) => {
    try {
        const {
            page = 1,
            limit = 20,
            search,
            category,
            status,
            sortBy = 'title',
            sortOrder = 'asc'
        } = req.query;
        let filters = {};
        if (category) filters.category = category;
        if (status) filters.status = status;
        let books = await req.dbAdapter.findInCollection('books', filters);
        books = books.map((book) => {
            const normalized = ensureAuthorMetadata(book);
            const copiesArray = Array.isArray(normalized.copies) ? normalized.copies : [];
            const availableCount = getAvailableQuantity(normalized);
            return {
                ...normalized,
                copiesCount: copiesArray.length,
                availableCopiesCount: availableCount
            };
        });
        if (search) {
            books = books.filter(book => matchesBookSearch(book, search));
        }
        const resolvedSortBy = sortBy || 'title';
        const resolvedSortOrder = sortOrder === 'desc' ? 'desc' : 'asc';
        const isNumeric = (value) => typeof value === 'number' && Number.isFinite(value);
        books.sort((a, b) => {
            const aVal = a[resolvedSortBy];
            const bVal = b[resolvedSortBy];
            let comparison = 0;
            if (isNumeric(aVal) && isNumeric(bVal)) {
                comparison = aVal - bVal;
            } else {
                const aStr = aVal === undefined || aVal === null ? '' : String(aVal);
                const bStr = bVal === undefined || bVal === null ? '' : String(bVal);
                comparison = aStr.localeCompare(bStr, undefined, { sensitivity: 'base' });
            }
            return resolvedSortOrder === 'desc' ? -comparison : comparison;
        });
        const totalBooks = books.length;
        const normalizedPage = Math.max(parseInt(page, 10) || 1, 1);
        const limitString = typeof limit === 'string' ? limit.toLowerCase() : limit;
        const wantsAll = limitString === 'all' || parseInt(limit, 10) === -1;
        const resolvedLimit = wantsAll ? totalBooks : Math.max(parseInt(limit, 10) || 20, 1);
        const startIndex = wantsAll ? 0 : (normalizedPage - 1) * resolvedLimit;
        const endIndex = wantsAll ? totalBooks : startIndex + resolvedLimit;
        const paginatedBooks = wantsAll ? books : books.slice(startIndex, endIndex);
        const booksWithCopies = paginatedBooks.map((book) => {
            const copiesArray = Array.isArray(book.copies) ? book.copies : [];
            return {
                ...book,
                copiesCount: copiesArray.length,
                availableCopiesCount: getAvailableQuantity(book)
            };
        });
        const totalPages = wantsAll ? (totalBooks > 0 ? 1 : 0) : Math.ceil(totalBooks / resolvedLimit);
        res.json({
            books: booksWithCopies,
            total: totalBooks,
            pagination: {
                currentPage: normalizedPage,
                totalPages,
                totalBooks,
                hasMore: !wantsAll && endIndex < totalBooks,
                limit: resolvedLimit,
                mode: wantsAll ? 'all' : 'paged'
            }
        });
    } catch (error) {
        console.error('Get books error:', error);
        res.status(500).json({ message: 'Failed to fetch books' });
    }
});

router.get('/search', verifyToken, async(req, res) => {
    try {
        const {
            q = '',
                available,
                limit = 20
        } = req.query;

        const searchTerm = String(q || '').trim();
        if (!searchTerm) {
            return res.json([]);
        }

        const books = await req.dbAdapter.findInCollection('books', {});
        books.forEach(ensureAuthorMetadata);
        const onlyAvailable = String(available).toLowerCase() === 'true';
        const limitNumber = Math.max(parseInt(limit, 10) || 20, 1);

        const results = books
            .filter((book) => matchesBookSearch(book, searchTerm))
            .filter((book) => {
                if (!onlyAvailable) return true;
                const copies = Array.isArray(book.copies) ? book.copies : [];
                return copies.some((copy) => normalizeString(copy.status) === 'available');
            })
            .sort((a, b) => {
                const dateA = new Date(a.updatedAt || a.createdAt || 0);
                const dateB = new Date(b.updatedAt || b.createdAt || 0);
                return dateB - dateA;
            })
            .slice(0, limitNumber)
            .map(buildBookSummary)
            .filter(Boolean)
            .map((book) => ({
                ...book,
                copies: book.copies?.map((copy) => ({
                    copyId: copy.copyId,
                    status: copy.status,
                    condition: copy.condition,
                    location: copy.location,
                })) || []
            }));

        res.json(results);
    } catch (error) {
        console.error('Search books error:', error);
        res.status(500).json({ message: 'Failed to search books' });
    }
});

router.post('/bulk-import', verifyToken, requireLibrarian, logAction('BULK_IMPORT', 'books'), async(req, res) => {
    try {
        const { books } = req.body;
        if (!Array.isArray(books) || books.length === 0) {
            return res.status(400).json({ message: 'Books array is required' });
        }

        const allExistingBooks = await req.dbAdapter.findInCollection('books', {});
        allExistingBooks.forEach(ensureAuthorMetadata);
        const existingBooksByIsbn = new Map(
            allExistingBooks.map(book => [(book.isbn || '').toLowerCase(), book])
        );

        const normalizeRowIndex = (value, fallback = null) => {
            if (typeof value === 'number' && Number.isFinite(value)) {
                return value;
            }
            if (typeof value === 'string' && value.trim() !== '') {
                const parsed = Number(value);
                if (Number.isFinite(parsed)) {
                    return parsed;
                }
            }
            return fallback;
        };

        const results = { successful: [], failed: [] };

        for (const [index, bookData] of books.entries()) {
            const rowIndex = normalizeRowIndex(bookData?.rowIndex, index + 1);
            const rawIsbn = typeof bookData?.isbn === 'string' ? bookData.isbn.trim() : bookData?.isbn;
            const baseRecord = {
                isbn: rawIsbn || null,
                title: typeof bookData?.title === 'string' ? bookData.title.trim() : bookData?.title || '',
                rowIndex
            };
            const validationIssues = [];

            if (!rawIsbn) {
                validationIssues.push('ISBN is required');
            }

            const normalizedIsbn = rawIsbn ? rawIsbn.toLowerCase() : '';
            const existingBook = normalizedIsbn ? existingBooksByIsbn.get(normalizedIsbn) : null;

            const rawTitle = typeof bookData?.title === 'string' ? bookData.title.trim() : bookData?.title;
            const rawAuthor = typeof bookData?.author === 'string' ? bookData.author.trim() : bookData?.author;
            const authorMeta = deriveAuthorsFromPayload({
                author: rawAuthor,
                authors: bookData?.authors
            });

            if (!existingBook) {
                if (!rawTitle) {
                    validationIssues.push('Title is required for new books');
                }
                if (!authorMeta.hasAuthors) {
                    validationIssues.push('Author is required for new books');
                }
            }

            let numberOfCopies = 1;
            if (bookData?.numberOfCopies !== undefined && bookData.numberOfCopies !== null && String(bookData.numberOfCopies).trim() !== '') {
                const parsedCopies = parseInt(bookData.numberOfCopies, 10);
                if (Number.isNaN(parsedCopies) || parsedCopies < 1) {
                    validationIssues.push('Invalid number of copies');
                } else {
                    numberOfCopies = parsedCopies;
                }
            }

            let parsedPublishedYear = null;
            if (bookData?.publishedYear !== undefined && bookData.publishedYear !== null && String(bookData.publishedYear).trim() !== '') {
                const candidateYear = parseInt(bookData.publishedYear, 10);
                if (Number.isNaN(candidateYear) || `${candidateYear}`.length !== 4) {
                    validationIssues.push('Invalid published year');
                } else {
                    parsedPublishedYear = candidateYear;
                }
            }

            if (validationIssues.length > 0) {
                results.failed.push({
                    ...baseRecord,
                    status: 'error',
                    message: validationIssues.join('; '),
                    issues: validationIssues
                });
                continue;
            }

            const isbn = rawIsbn;
            const location = bookData?.location || existingBook?.location || 'main-library';

            try {
                if (existingBook) {
                    const copies = Array.from({ length: numberOfCopies }, () => ({
                        copyId: generateCopyId(isbn),
                        status: 'available',
                        condition: 'good',
                        location,
                        createdAt: new Date(),
                        updatedAt: new Date(),
                        createdBy: req.user.id
                    }));

                    const newCopyIds = copies.map((copy) => copy.copyId);
                    const updatedCopies = [...(existingBook.copies || []), ...copies];
                    const availableCopies = updatedCopies.filter(c => c.status === 'available').length;
                    const updatePayload = {
                        copies: updatedCopies,
                        totalCopies: updatedCopies.length,
                        availableCopies,
                        updatedAt: new Date(),
                        updatedBy: req.user.id
                    };

                    if (authorMeta.hasAuthors) {
                        updatePayload.author = authorMeta.authorDisplay;
                        updatePayload.authors = authorMeta.authors;
                    }

                    await req.dbAdapter.updateInCollection('books', { id: existingBook.id }, updatePayload);
                    await notifyInventoryState(req, { ...existingBook, ...updatePayload }, 'book-bulk-import');

                    existingBooksByIsbn.set(normalizedIsbn, {
                        ...existingBook,
                        ...updatePayload
                    });

                    results.successful.push({
                        ...baseRecord,
                        title: rawTitle || existingBook.title || 'Untitled',
                        message: `Added ${numberOfCopies} copies to existing book`,
                        bookId: existingBook.id,
                        copyIds: newCopyIds,
                        duplicate: true
                    });
                    continue;
                }

                const title = rawTitle;
                const bookId = `book_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

                const copies = [];
                for (let i = 0; i < numberOfCopies; i++) {
                    const copyId = generateCopyId(isbn);
                    copies.push({
                        copyId,
                        status: 'available',
                        condition: 'good',
                        location,
                        createdAt: new Date(),
                        updatedAt: new Date(),
                        createdBy: req.user.id
                    });
                }

                const newBook = {
                    id: bookId,
                    title,
                    author: authorMeta.authorDisplay,
                    authors: authorMeta.authors,
                    isbn,
                    publisher: bookData?.publisher || '',
                    publishedYear: parsedPublishedYear,
                    category: bookData?.category || 'General',
                    description: bookData?.description || '',
                    coverImage: bookData?.coverImage || '',
                    status: 'active',
                    totalCopies: numberOfCopies,
                    availableCopies: numberOfCopies,
                    copies,
                    createdAt: new Date(),
                    updatedAt: new Date(),
                    createdBy: req.user.id
                };

                await req.dbAdapter.insertIntoCollection('books', newBook);
                await notifyInventoryState(req, newBook, 'book-bulk-import');
                existingBooksByIsbn.set(normalizedIsbn, newBook);
                results.successful.push({
                    ...baseRecord,
                    title,
                    message: 'Imported successfully',
                    bookId,
                    copyIds: copies.map((copy) => copy.copyId),
                    duplicate: false
                });
            } catch (error) {
                const issues = error?.details?.issues;
                results.failed.push({
                    ...baseRecord,
                    status: 'error',
                    message: error.message || 'Failed to import book',
                    ...(Array.isArray(issues) && issues.length > 0 ? { issues } : { issues: error.message ? [error.message] : [] })
                });
            }
        }

        setAuditContext(req, {
            description: `Bulk imported ${results.successful.length} books (${results.failed.length} failed)`,
            details: {
                success: results.successful.length,
                errors: results.failed.length,
            },
        });

        res.json({
            message: `Bulk import completed. ${results.successful.length} successful, ${results.failed.length} failed.`,
            results: {
                success: results.successful.length,
                errors: results.failed.length,
                details: [
                    ...results.successful.map(book => ({
                        isbn: book.isbn,
                        title: book.title,
                        status: 'success',
                        message: book.message || 'Imported successfully',
                        bookId: book.bookId,
                        copyIds: book.copyIds,
                        duplicate: book.duplicate || false,
                        rowIndex: book.rowIndex ?? null
                    })),
                    ...results.failed.map(book => ({
                        isbn: book.isbn,
                        title: book.title,
                        status: 'error',
                        message: book.message,
                        issues: Array.isArray(book.issues) && book.issues.length > 0 ? book.issues : undefined,
                        rowIndex: book.rowIndex ?? null
                    }))
                ]
            }
        });
    } catch (error) {
        console.error('Bulk import books error:', error);
        setAuditContext(req, {
            success: false,
            status: 'Failed',
            description: 'Bulk book import failed',
            details: { error: error.message },
        });
        res.status(500).json({ message: 'Failed to import books' });
    }
});

router.get('/categories', verifyToken, async(req, res) => {
    try {
        const categories = await ensureStoredCategories(req.dbAdapter);
        res.json(categories);
    } catch (error) {
        console.error('Get categories error:', error);
        res.status(500).json({ message: 'Failed to fetch categories' });
    }
});

router.post('/categories', verifyToken, requireLibrarian, logAction('CREATE', 'book-category'), async(req, res) => {
    try {
        const displayName = normalizeCategoryDisplayName(req.body?.name);
        if (!displayName) {
            return res.status(400).json({ message: 'Category name is required' });
        }

        const slug = slugifyCategoryName(displayName);
        if (!slug) {
            return res.status(400).json({ message: 'Category name is invalid' });
        }

        const existing = await req.dbAdapter.findOneInCollection(BOOK_CATEGORIES_COLLECTION, { slug });
        if (existing) {
            return res.status(409).json({ message: 'Category already exists' });
        }

        const payload = {
            name: displayName,
            slug,
            source: 'manual',
            createdBy: req.user?.id || null,
            updatedBy: req.user?.id || null,
        };

        const saved = await req.dbAdapter.insertIntoCollection(BOOK_CATEGORIES_COLLECTION, payload);

        setAuditContext(req, {
            success: true,
            status: 'Created',
            description: `Created book category ${displayName}`,
            entityId: saved?._id,
            resourceId: saved?._id,
        });

        res.status(201).json(saved);
    } catch (error) {
        console.error('Create category error:', error);
        setAuditContext(req, {
            success: false,
            status: 'Error',
            description: `Create category failed: ${error.message}`,
        });
        res.status(500).json({ message: 'Failed to create category' });
    }
});

router.delete('/categories/:id', verifyToken, requireLibrarian, logAction('DELETE', 'book-category'), async(req, res) => {
    try {
        const identifier = (req.params.id || '').trim();
        if (!identifier) {
            return res.status(400).json({ message: 'Category identifier is required' });
        }

        const lookupFilters = [
            { _id: identifier },
            { id: identifier },
            { slug: identifier }
        ];

        let deleted = null;
        for (const filter of lookupFilters) {
            deleted = await req.dbAdapter.deleteFromCollection(BOOK_CATEGORIES_COLLECTION, filter);
            if (deleted) {
                break;
            }
        }

        if (!deleted) {
            return res.status(404).json({ message: 'Category not found' });
        }

        setAuditContext(req, {
            success: true,
            status: 'Deleted',
            description: `Deleted book category ${deleted.name || identifier}`,
            entityId: deleted._id || identifier,
            resourceId: deleted._id || identifier,
        });

        res.json({ message: 'Category deleted successfully', category: deleted });
    } catch (error) {
        console.error('Delete category error:', error);
        setAuditContext(req, {
            success: false,
            status: 'Error',
            description: `Delete category failed: ${error.message}`,
            entityId: req.params.id,
        });
        res.status(500).json({ message: 'Failed to delete category' });
    }
});

router.get('/:id', verifyToken, async(req, res) => {
    try {
        const book = await findBookByIdentifier(req, req.params.id);
        if (!book) {
            setAuditContext(req, {
                success: false,
                status: 'Failed',
                description: `Get book failed: book ${req.params.id} not found`,
            });
            return res.status(404).json({ message: 'Book not found' });
        }
        book.copiesCount = book.copies?.length || 0;
        book.availableCopiesCount = book.copies?.filter(c => c.status === 'available').length || 0;
        res.json(book);
    } catch (error) {
        console.error('Get book error:', error);
        res.status(500).json({ message: 'Failed to fetch book' });
    }
});

router.post('/', verifyToken, requireLibrarian, logAction('CREATE', 'book'), async(req, res) => {
    try {
        const {
            title,
            author: authorValue,
            authors: authorsValue,
            isbn,
            publisher,
            publishedYear,
            category,
            description,
            coverImage,
            numberOfCopies = 1,
            location = 'main-library',
            copies: incomingCopies = [],
            status = 'active',
            language,
            pages,
            deweyDecimal,
            publicationDate
        } = req.body;

        const authorMeta = deriveAuthorsFromPayload({ author: authorValue, authors: authorsValue });

        setAuditContext(req, {
            metadata: {
                createRequest: {
                    isbn: isbn || null,
                    title: title || null,
                    author: authorMeta.authorDisplay || null,
                    incomingCopies: Array.isArray(incomingCopies) ? incomingCopies.length : 0,
                    numberOfCopies: numberOfCopies
                }
            }
        });

        if (!isbn) {
            setAuditContext(req, {
                success: false,
                status: 'ValidationError',
                description: 'Create book failed: ISBN is required',
            });
            return res.status(400).json({ message: 'ISBN is required' });
        }

        const sanitizedPages = pages !== undefined && pages !== null && `${pages}`.trim() !== '' ? parseInt(pages, 10) : null;
        if (sanitizedPages !== null && Number.isNaN(sanitizedPages)) {
            setAuditContext(req, {
                success: false,
                status: 'ValidationError',
                description: 'Create book failed: invalid page count',
                metadata: {
                    pages
                }
            });
            return res.status(400).json({ message: 'Invalid number of pages' });
        }

        const publishedYearMeta = computePublishedYear(publishedYear, publicationDate);

        const existingBook = await req.dbAdapter.findOneInCollection('books', { isbn });
        if (existingBook) {
            ensureAuthorMetadata(existingBook);
        }

        const baseLocation = location || 'main-library';

        const buildCopies = () => {
            const rawCopies = Array.isArray(incomingCopies) && incomingCopies.length > 0
                ? incomingCopies
                : Array.from({ length: Math.max(parseInt(numberOfCopies, 10) || 1, 1) }).map(() => ({}));

            const seenCopyIds = new Set();
            const preparedCopies = [];

            for (const raw of rawCopies) {
                const copyId = (raw.copyId || generateCopyId(isbn)).toUpperCase();
                if (seenCopyIds.has(copyId)) {
                    throw new Error(`Duplicate reference ID ${copyId} in request payload`);
                }
                seenCopyIds.add(copyId);

                const statusValue = String(raw.status || 'available').toLowerCase();
                const normalizedStatus = allowedCopyStatuses.has(statusValue) ? statusValue : 'available';

                preparedCopies.push({
                    copyId,
                    status: normalizedStatus,
                    condition: raw.condition || 'good',
                    location: raw.location || baseLocation,
                    createdAt: new Date(),
                    updatedAt: new Date(),
                    createdBy: req.user.id
                });
            }

            return preparedCopies;
        };

        let copiesToAdd;
        try {
            copiesToAdd = buildCopies();
        } catch (error) {
            setAuditContext(req, {
                success: false,
                status: 'ValidationError',
                description: `Create book failed: ${error.message}`,
                details: {
                    error: error.message
                }
            });
            return res.status(400).json({ message: error.message });
        }

        if (!copiesToAdd || copiesToAdd.length === 0) {
            setAuditContext(req, {
                success: false,
                status: 'ValidationError',
                description: 'Create book failed: at least one copy required'
            });
            return res.status(400).json({ message: 'At least one book copy is required' });
        }
        if (existingBook) {
            const existingCopyIds = new Set((existingBook.copies || []).map(copy => copy.copyId));
            for (const copy of copiesToAdd) {
                if (existingCopyIds.has(copy.copyId)) {
                    setAuditContext(req, {
                        success: false,
                        status: 'Conflict',
                        description: `Create book failed: duplicate reference ID ${copy.copyId}`,
                        metadata: {
                            copyId: copy.copyId
                        }
                    });
                    return res.status(400).json({ message: `Reference ID ${copy.copyId} already exists for this book` });
                }
                existingCopyIds.add(copy.copyId);
            }

            const updatedCopies = [...(existingBook.copies || []), ...copiesToAdd];
            const updatePayload = {
                copies: updatedCopies,
                totalCopies: updatedCopies.length,
                availableCopies: availableCopiesCount(updatedCopies),
                updatedAt: new Date(),
                updatedBy: req.user.id
            };

            const updatableFields = {
                title,
                publisher,
                category,
                description,
                coverImage,
                status,
                language,
                deweyDecimal,
                publicationDate
            };

            if (sanitizedPages !== null) {
                updatableFields.pages = sanitizedPages;
            }

            if (publishedYearMeta.shouldUpdate) {
                updatePayload.publishedYear = publishedYearMeta.value;
            }

            Object.entries(updatableFields).forEach(([key, value]) => {
                if (value !== undefined && value !== null && String(value).trim() !== '') {
                    updatePayload[key] = value;
                }
            });

            if (authorMeta.hasAuthors) {
                updatePayload.author = authorMeta.authorDisplay;
                updatePayload.authors = authorMeta.authors;
            }

            await req.dbAdapter.updateInCollection('books', { id: existingBook.id }, updatePayload);
            await notifyInventoryState(req, { ...existingBook, ...updatePayload }, 'book-create-append');

            setAuditContext(req, {
                entityId: existingBook.id,
                description: `Updated existing book ${existingBook.title || existingBook.id}`,
                details: {
                    addedCopies: copiesToAdd.length,
                    isbn: existingBook.isbn,
                },
                metadata: {
                    actorId: req.user.id,
                    addedCopyIds: copiesToAdd.map(copy => copy.copyId)
                },
                success: true,
                status: 'Updated'
            });

            return res.status(200).json({
                message: `Existing book updated with ${copiesToAdd.length} new ${copiesToAdd.length === 1 ? 'copy' : 'copies'}`,
                bookId: existingBook.id,
                addedCopyIds: copiesToAdd.map(copy => copy.copyId),
                copyIds: copiesToAdd.map(copy => copy.copyId),
                duplicate: true
            });
        }

        if (!title || !authorMeta.hasAuthors) {
            setAuditContext(req, {
                success: false,
                status: 'ValidationError',
                description: 'Create book failed: title and author are required',
            });
            return res.status(400).json({ message: 'Title and author are required for new books' });
        }

        const bookId = `book_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        const newBook = {
            id: bookId,
            title,
            author: authorMeta.authorDisplay,
            authors: authorMeta.authors,
            isbn,
            publisher: publisher || '',
            publishedYear: publishedYearMeta.shouldUpdate ? publishedYearMeta.value : null,
            category: category || 'General',
            description: description || '',
            coverImage: coverImage || '',
            status: status || 'active',
            language: language || 'English',
            pages: sanitizedPages,
            deweyDecimal: deweyDecimal || '',
            publicationDate: publicationDate || null,
            totalCopies: copiesToAdd.length,
            availableCopies: availableCopiesCount(copiesToAdd),
            copies: copiesToAdd,
            createdAt: new Date(),
            updatedAt: new Date(),
            createdBy: req.user.id
        };

        await req.dbAdapter.insertIntoCollection('books', newBook);
        await notifyInventoryState(req, newBook, 'book-create');

        setAuditContext(req, {
            entityId: bookId,
            resourceId: bookId,
            description: `Created book ${title}`,
            details: {
                isbn,
                author: authorMeta.authorDisplay,
                totalCopies: newBook.totalCopies,
            },
            metadata: {
                actorId: req.user.id,
                location,
                copyIds: copiesToAdd.map(copy => copy.copyId)
            },
            success: true,
            status: 'Created'
        });

        res.status(201).json({
            message: 'Book created successfully',
            bookId,
            copyIds: copiesToAdd.map(copy => copy.copyId),
            duplicate: false
        });
    } catch (error) {
        console.error('Create book error:', error);
        setAuditContext(req, {
            success: false,
            status: 'Error',
            description: 'Failed to create book',
            details: { error: error.message },
        });
        res.status(500).json({ message: 'Failed to create book' });
    }
});

router.put('/:id', verifyToken, requireStaff, logAction('UPDATE', 'book'), async(req, res) => {
    try {
        const payload = req.body || {};
        setAuditContext(req, {
            entityId: req.params.id,
            metadata: {
                updateRequest: {
                    bookId: req.params.id,
                    fields: Object.keys(payload)
                }
            }
        });

        const book = await findBookByIdentifier(req, req.params.id);
        if (!book) {
            setAuditContext(req, {
                success: false,
                status: 'BookNotFound',
                description: `Update book failed: book ${req.params.id} not found`,
            });
            return res.status(404).json({ message: 'Book not found' });
        }

        const persistenceFilter = resolveBookPersistenceFilter(req, book);
        if (!persistenceFilter) {
            console.error('Unable to resolve persistence filter for book update', req.params.id);
            return res.status(500).json({ message: 'Failed to update book' });
        }

        if (Object.prototype.hasOwnProperty.call(payload, 'isbn') && payload.isbn !== book.isbn) {
            return res.status(400).json({ message: 'ISBN cannot be changed for existing books' });
        }

        const hasField = (field) => Object.prototype.hasOwnProperty.call(payload, field);
        const updateData = { updatedAt: new Date(), updatedBy: req.user.id };
        const stringFields = ['title', 'publisher', 'category', 'description', 'coverImage', 'status', 'language', 'deweyDecimal'];
        stringFields.forEach((field) => {
            if (hasField(field)) {
                updateData[field] = payload[field];
            }
        });

        if (hasField('authors') || hasField('author')) {
            const authorMeta = deriveAuthorsFromPayload({
                authors: hasField('authors') ? payload.authors : book.authors,
                author: hasField('author') ? payload.author : book.author,
            });
            updateData.authors = authorMeta.authors;
            updateData.author = authorMeta.authorDisplay;
        }

        if (hasField('publicationDate')) {
            updateData.publicationDate = payload.publicationDate || null;
        }

        if (hasField('pages')) {
            const pagesValue = payload.pages;
            if (pagesValue === null || pagesValue === '' || typeof pagesValue === 'undefined') {
                updateData.pages = null;
            } else {
                const parsedPages = parseInt(pagesValue, 10);
                if (Number.isNaN(parsedPages) || parsedPages <= 0) {
                    return res.status(400).json({ message: 'Invalid number of pages' });
                }
                updateData.pages = parsedPages;
            }
        }

        if (hasField('publishedYear') || hasField('publicationDate')) {
            try {
                const publishedYearMeta = computePublishedYear(
                    payload.publishedYear,
                    hasField('publicationDate') ? payload.publicationDate : book.publicationDate
                );
                if (publishedYearMeta.shouldUpdate) {
                    updateData.publishedYear = publishedYearMeta.value;
                } else if (payload.publishedYear === '' || payload.publishedYear === null) {
                    updateData.publishedYear = null;
                }
            } catch (err) {
                return res.status(400).json({ message: err.message });
            }
        }

        let copySummary = null;
        if (hasField('copies')) {
            const sanitizeCopiesPayload = () => {
                if (!Array.isArray(payload.copies) || payload.copies.length === 0) {
                    throw new Error('At least one copy is required');
                }

                const seenIds = new Set();
                const normalizedCopies = [];
                const existingCopies = Array.isArray(book.copies) ? book.copies : [];
                const existingCopyMap = new Map(
                    existingCopies
                        .filter((copy) => copy.copyId)
                        .map((copy) => [String(copy.copyId).toUpperCase(), copy])
                );

                const addedCopyIds = [];
                const updatedCopyIds = [];

                payload.copies.forEach((raw) => {
                    const normalizedId = String(raw?.copyId || '').trim().toUpperCase();
                    if (!normalizedId) {
                        throw new Error('Reference ID is required for each copy');
                    }
                    if (seenIds.has(normalizedId)) {
                        throw new Error(`Duplicate reference ID ${normalizedId}`);
                    }
                    seenIds.add(normalizedId);

                    const existing = existingCopyMap.get(normalizedId);
                    const statusValue = normalizeString(raw.status) || 'available';
                    const normalizedStatus = allowedCopyStatuses.has(statusValue) ? statusValue : 'available';

                    const baseCopy = existing ? { ...existing } : {
                        copyId: normalizedId,
                        createdAt: new Date(),
                        createdBy: req.user.id,
                    };

                    baseCopy.status = normalizedStatus;
                    baseCopy.condition = raw.condition || existing?.condition || 'good';
                    baseCopy.location = raw.location || existing?.location || 'main-library';
                    baseCopy.updatedAt = new Date();
                    baseCopy.updatedBy = req.user.id;

                    normalizedCopies.push(baseCopy);
                    if (existing) {
                        updatedCopyIds.push(normalizedId);
                    } else {
                        addedCopyIds.push(normalizedId);
                    }
                });

                const incomingIdSet = new Set(seenIds);
                const removedCopyIds = [];
                const blockedRemovals = [];

                (book.copies || []).forEach((copy) => {
                    const normalizedExistingId = String(copy.copyId || '').toUpperCase();
                    if (!incomingIdSet.has(normalizedExistingId)) {
                        if (normalizeString(copy.status) === 'borrowed') {
                            blockedRemovals.push(copy.copyId);
                        } else {
                            removedCopyIds.push(copy.copyId);
                        }
                    }
                });

                if (blockedRemovals.length > 0) {
                    const error = new Error('Cannot remove copies that are currently borrowed');
                    error.details = { copyIds: blockedRemovals };
                    throw error;
                }

                return {
                    copies: normalizedCopies,
                    summary: {
                        added: addedCopyIds,
                        removed: removedCopyIds,
                        updated: updatedCopyIds,
                    }
                };
            };

            try {
                const { copies, summary } = sanitizeCopiesPayload();
                updateData.copies = copies;
                updateData.totalCopies = copies.length;
                updateData.availableCopies = availableCopiesCount(copies);
                copySummary = summary;
            } catch (error) {
                const response = { message: error.message };
                if (error.details) {
                    response.details = error.details;
                }
                return res.status(400).json(response);
            }
        }

        const updatedFields = Object.keys(updateData).filter((key) => key !== 'updatedAt' && key !== 'updatedBy');
        if (updatedFields.length === 0) {
            return res.status(400).json({ message: 'No valid fields provided for update' });
        }

        await req.dbAdapter.updateInCollection('books', persistenceFilter, updateData);

        const touchesInventory = Object.prototype.hasOwnProperty.call(updateData, 'copies') ||
            Object.prototype.hasOwnProperty.call(updateData, 'availableCopies');
        if (touchesInventory) {
            await notifyInventoryState(req, { ...book, ...updateData }, 'book-update');
        }

        const auditDetails = {
            updatedFields: updatedFields.filter((field) => field !== 'copies'),
        };
        if (copySummary) {
            auditDetails.copies = copySummary;
        }

        setAuditContext(req, {
            entityId: book.id || book._id || req.params.id,
            description: `Updated book ${book.title || req.params.id}`,
            details: auditDetails,
            metadata: {
                actorId: req.user.id
            },
            success: true,
            status: 'Updated'
        });

        res.json({ message: 'Book updated successfully', updatedFields });
    } catch (error) {
        console.error('Update book error:', error);
        setAuditContext(req, {
            success: false,
            status: 'Error',
            description: 'Failed to update book',
            details: { error: error.message },
        });
        res.status(500).json({ message: 'Failed to update book' });
    }
});

router.delete('/:id', verifyToken, requireLibrarian, logAction('DELETE', 'book'), async(req, res) => {
    try {
        setAuditContext(req, {
            entityId: req.params.id
        });
        const book = await findBookByIdentifier(req, req.params.id);
        if (!book) {
            setAuditContext(req, {
                success: false,
                status: 'BookNotFound',
                description: `Delete book failed: book ${req.params.id} not found`,
            });
            return res.status(404).json({ message: 'Book not found' });
        }
    const borrowedCopies = book.copies?.filter(c => c.status === 'borrowed') || [];
        if (borrowedCopies.length > 0) {
            setAuditContext(req, {
                success: false,
                status: 'Conflict',
                description: `Delete book failed: ${borrowedCopies.length} copies currently borrowed`,
                details: {
                    borrowedCount: borrowedCopies.length,
                },
            });
            return res.status(400).json({ message: 'Cannot delete book with borrowed copies' });
        }
        const persistenceFilter = resolveBookPersistenceFilter(req, book);
        if (!persistenceFilter) {
            console.error('Unable to resolve persistence filter for book delete', req.params.id);
            return res.status(500).json({ message: 'Failed to delete book' });
        }

        await req.dbAdapter.deleteFromCollection('books', persistenceFilter);

        setAuditContext(req, {
            entityId: book.id || book._id || req.params.id,
            description: `Deleted book ${book.title || req.params.id}`,
            details: {
                isbn: book.isbn,
                totalCopies: book.copies?.length || 0,
            },
            metadata: {
                actorId: req.user.id
            },
            success: true,
            status: 'Deleted'
        });

        res.json({ message: 'Book and all copies deleted successfully' });
    } catch (error) {
        console.error('Delete book error:', error);
        setAuditContext(req, {
            success: false,
            status: 'Error',
            description: 'Failed to delete book',
            details: { error: error.message },
        });
        res.status(500).json({ message: 'Failed to delete book' });
    }
});

router.post('/:id/copies', verifyToken, requireStaff, logAction('ADD_COPIES', 'book'), async(req, res) => {
    try {
        const { numberOfCopies = 1, location = 'main-library' } = req.body;
        setAuditContext(req, {
            entityId: req.params.id,
            metadata: {
                addCopiesRequest: {
                    numberOfCopies,
                    location
                }
            }
        });
        const book = await findBookByIdentifier(req, req.params.id);
        if (!book) {
            setAuditContext(req, {
                success: false,
                status: 'BookNotFound',
                description: `Add copies failed: book ${req.params.id} not found`,
            });
            return res.status(404).json({ message: 'Book not found' });
        }
        const newCopies = [];
        const copyIds = [];
        for (let i = 0; i < numberOfCopies; i++) {
            const copyId = generateCopyId(book.isbn);
            newCopies.push({ copyId, status: 'available', condition: 'good', location, createdAt: new Date(), updatedAt: new Date(), createdBy: req.user.id });
            copyIds.push(copyId);
        }
        const updatedCopies = [...(book.copies || []), ...newCopies];
        const persistenceFilter = resolveBookPersistenceFilter(req, book);
        if (!persistenceFilter) {
            console.error('Unable to resolve persistence filter for add copies', req.params.id);
            return res.status(500).json({ message: 'Failed to add book copies' });
        }

        const availableCopies = updatedCopies.filter(c => c.status === 'available').length;
        await req.dbAdapter.updateInCollection('books', persistenceFilter, {
            copies: updatedCopies,
            totalCopies: updatedCopies.length,
            availableCopies,
            updatedAt: new Date()
        });
        await notifyInventoryState(req, { ...book, copies: updatedCopies, availableCopies }, 'book-add-copies');

        setAuditContext(req, {
            entityId: book.id || book._id || req.params.id,
            description: `Added ${numberOfCopies} copies to ${book.title || req.params.id}`,
            details: {
                copyIds,
                location,
            },
            metadata: {
                actorId: req.user.id
            },
            success: true,
            status: 'Updated'
        });

        res.status(201).json({ message: 'Book copies added successfully', copyIds });
    } catch (error) {
        console.error('Add copies error:', error);
        setAuditContext(req, {
            success: false,
            status: 'Error',
            description: 'Failed to add book copies',
            details: { error: error.message },
        });
        res.status(500).json({ message: 'Failed to add book copies' });
    }
});

router.delete('/:id/copies/:copyId', verifyToken, requireStaff, logAction('DELETE_COPY', 'book'), async(req, res) => {
    try {
        const { id, copyId } = req.params;

        setAuditContext(req, {
            entityId: id,
            metadata: {
                deleteCopyRequest: {
                    copyId,
                },
            },
        });

        const book = await findBookByIdentifier(req, id);
        if (!book) {
            setAuditContext(req, {
                success: false,
                status: 'BookNotFound',
                description: `Delete copy failed: book ${id} not found`,
            });
            return res.status(404).json({ message: 'Book not found' });
        }

        const copies = Array.isArray(book.copies) ? [...book.copies] : [];
        const targetIndex = copies.findIndex((copy) => String(copy.copyId).toLowerCase() === String(copyId).toLowerCase());

        if (targetIndex === -1) {
            setAuditContext(req, {
                success: false,
                status: 'CopyNotFound',
                description: `Delete copy failed: copy ${copyId} not found in book ${id}`,
            });
            return res.status(404).json({ message: 'Book copy not found' });
        }

        const targetCopy = copies[targetIndex];
        const copyStatus = normalizeString(targetCopy.status);
        if (copyStatus === 'borrowed' || copyStatus === 'pending') {
            setAuditContext(req, {
                success: false,
                status: 'CopyBorrowed',
                description: `Delete copy blocked: copy ${copyId} is currently ${targetCopy.status}`,
            });
            return res.status(400).json({ message: 'Cannot delete a copy that is currently borrowed or pending' });
        }

        const updatedCopies = copies.filter((_, index) => index !== targetIndex);
        const availableCopies = updatedCopies.filter((copy) => normalizeString(copy.status) === 'available').length;

        const persistenceFilter = resolveBookPersistenceFilter(req, book);
        if (!persistenceFilter) {
            console.error('Unable to resolve persistence filter for delete copy', id);
            return res.status(500).json({ message: 'Failed to delete book copy' });
        }

        await req.dbAdapter.updateInCollection('books', persistenceFilter, {
            copies: updatedCopies,
            totalCopies: updatedCopies.length,
            availableCopies,
            updatedAt: new Date(),
        });
        await notifyInventoryState(req, { ...book, copies: updatedCopies, availableCopies }, 'book-delete-copy');

        setAuditContext(req, {
            entityId: book.id || book._id || id,
            description: `Deleted copy ${copyId} from ${book.title || id}`,
            details: {
                copyId,
                status: targetCopy.status,
            },
            metadata: {
                actorId: req.user.id,
            },
            success: true,
            status: 'Deleted',
        });

        return res.json({ message: 'Book copy deleted successfully' });
    } catch (error) {
        console.error('Delete copy error:', error);
        setAuditContext(req, {
            success: false,
            status: 'Error',
            description: 'Failed to delete book copy',
            details: { error: error.message },
        });
        return res.status(500).json({ message: 'Failed to delete book copy' });
    }
});

router.get('/:id/copies/barcodes', verifyToken, requireStaff, logAction('GENERATE_BARCODES', 'book'), async(req, res) => {
    try {
        const book = await findBookByIdentifier(req, req.params.id);
        if (!book) {
            setAuditContext(req, {
                success: false,
                status: 'BookNotFound',
                description: `Generate barcodes failed: book ${req.params.id} not found`,
            });
            return res.status(404).json({ message: 'Book not found' });
        }

        const copies = Array.isArray(book.copies) ? book.copies : [];
        if (copies.length === 0) {
            setAuditContext(req, {
                success: false,
                status: 'NoCopies',
                description: `Generate barcodes failed: book ${req.params.id} has no copies`,
            });
            return res.status(404).json({ message: 'No copies available for this book' });
        }

        const copyIdsParam = req.query.copyIds;
        let requestedCopyIds = copies.map((copy) => copy.copyId).filter(Boolean);

        if (copyIdsParam) {
            const asArray = Array.isArray(copyIdsParam) ? copyIdsParam : String(copyIdsParam).split(',');
            const requestedSet = new Set(
                asArray
                    .map((value) => String(value).trim())
                    .filter(Boolean)
                    .map((value) => value.toUpperCase())
            );

            requestedCopyIds = copies
                .map((copy) => copy.copyId)
                .filter(Boolean)
                .filter((copyId) => requestedSet.has(String(copyId).toUpperCase()));

            if (requestedCopyIds.length === 0) {
                setAuditContext(req, {
                    success: false,
                    status: 'CopiesNotFound',
                    description: `Generate barcodes failed: requested reference IDs not found for book ${req.params.id}`,
                    details: {
                        requested: Array.from(requestedSet),
                    },
                });
                return res.status(404).json({ message: 'Requested reference IDs not found for this book' });
            }
        }

        const filteredCopies = copies
            .filter((copy) => Boolean(copy.copyId))
            .filter((copy) => requestedCopyIds.includes(copy.copyId));

        if (filteredCopies.length === 0) {
            setAuditContext(req, {
                success: false,
                status: 'CopiesNotFound',
                description: `Generate barcodes failed: no matching copies with IDs for book ${req.params.id}`,
                details: {
                    requested: requestedCopyIds,
                },
            });
            return res.status(404).json({ message: 'No matching copies found for barcode generation' });
        }

        const generatedBy = [req.user?.firstName, req.user?.lastName]
            .filter(Boolean)
            .join(' ') || req.user?.username || req.user?.email || null;

        const pdfPayload = await buildBarcodePdf({
            book,
            copies: filteredCopies,
            requestedCopyIds,
            generatedBy,
        });

        setAuditContext(req, {
            entityId: book.id || book._id || req.params.id,
            description: `Generated ${requestedCopyIds.length} barcode labels for ${book.title || req.params.id}`,
            success: true,
            status: 'Generated',
            details: {
                copyIds: requestedCopyIds,
            },
            metadata: {
                actorId: req.user?.id,
                filename: pdfPayload.filename,
            },
        });

        res.setHeader('Content-Type', 'application/pdf');
        res.setHeader('Content-Disposition', `attachment; filename="${pdfPayload.filename}"`);
        return res.send(pdfPayload.buffer);
    } catch (error) {
        console.error('Generate barcode PDF error:', error);
        setAuditContext(req, {
            success: false,
            status: 'Error',
            description: 'Failed to generate barcodes',
            details: { error: error.message },
        });
        return res.status(500).json({ message: 'Failed to generate barcodes' });
    }
});

router.get('/:id/copies', verifyToken, async(req, res) => {
    try {
        const book = await findBookByIdentifier(req, req.params.id);
        if (!book) return res.status(404).json({ message: 'Book not found' });
        res.json(book.copies || []);
    } catch (error) {
        console.error('Get copies error:', error);
        res.status(500).json({ message: 'Failed to fetch book copies' });
    }
});

router.get('/:id/history', verifyToken, async(req, res) => {
    try {
        const book = await findBookByIdentifier(req, req.params.id);
        if (!book) {
            return res.status(404).json({ message: 'Book not found' });
        }

        const allTransactions = await req.dbAdapter.findInCollection('transactions', {});
        const allUsers = await req.dbAdapter.findInCollection('users', {});

        const userLookup = buildLookupMap(allUsers, user => [user.id, user._id, user.uid, user.userId, user.libraryCardNumber]);
        const copyIds = new Set((book.copies || []).map(copy => String(copy.copyId).toLowerCase()).filter(Boolean));
        const bookIdentifiers = new Set([
            book.id,
            book._id,
            book.bookId,
            book.isbn
        ].filter(Boolean).map(value => String(value).toLowerCase()));

        const history = [];

        allTransactions.forEach(transaction => {
            const borrower = userLookup.get(String(transaction.userId || transaction.borrowerId || '').toLowerCase()) || null;
            const borrowerName = getBorrowerName(borrower);
            const baseBorrowDate = transaction.borrowDate || transaction.createdAt || null;
            const baseDueDate = transaction.dueDate || null;
            const baseReturnDate = transaction.returnDate || null;
            const baseStatus = normalizeStatus(transaction.status);

            const items = Array.isArray(transaction.items) && transaction.items.length > 0
                ? transaction.items
                : [{
                    copyId: transaction.copyId || '',
                    bookId: transaction.bookId || transaction.isbn || '',
                    borrowDate: baseBorrowDate,
                    dueDate: baseDueDate,
                    returnedAt: baseReturnDate,
                    status: transaction.status
                }];

            items.forEach((item, index) => {
                const itemCopyId = item.copyId ? String(item.copyId).toLowerCase() : null;
                const itemBookIds = [item.bookId, item.isbn, item.book?.id, item.book?.isbn]
                    .filter(Boolean)
                    .map(value => String(value).toLowerCase());

                const matchesCopy = itemCopyId ? copyIds.has(itemCopyId) : false;
                const matchesBook = itemBookIds.some(identifier => bookIdentifiers.has(identifier));

                if (!matchesCopy && !matchesBook) {
                    return;
                }

                const borrowDate = item.borrowDate || baseBorrowDate;
                const dueDate = item.dueDate || baseDueDate;
                const returnDate = item.returnedAt || baseReturnDate;
                const status = normalizeStatus(item.status) || baseStatus;

                history.push({
                    _id: `${transaction.id || transaction._id || 'transaction'}_${item.copyId || index}`,
                    transactionId: transaction.id || transaction._id || null,
                    copyId: item.copyId || 'N/A',
                    borrowerId: transaction.userId || transaction.borrowerId || null,
                    borrowerName,
                    borrowDate,
                    dueDate,
                    returnDate,
                    status,
                    fineAmount: transaction.fineAmount || transaction.fine || 0
                });
            });
        });

        history.sort((a, b) => new Date(b.borrowDate || b.createdAt || 0) - new Date(a.borrowDate || a.createdAt || 0));

        res.json(history);
    } catch (error) {
        console.error('Get book history error:', error);
        res.status(500).json({ message: 'Failed to fetch borrowing history' });
    }
});

router.patch('/copies/:copyId', verifyToken, requireStaff, logAction('UPDATE_COPY', 'book'), async(req, res) => {
    try {
        const { status, condition, location } = req.body;
        setAuditContext(req, {
            metadata: {
                updateCopyRequest: {
                    copyId: req.params.copyId,
                    status: status || null,
                    condition: condition || null,
                    location: location || null
                }
            }
        });
        const allBooks = await req.dbAdapter.findInCollection('books', {});
        let targetBook = null;
        let targetCopyIndex = -1;
        for (const book of allBooks) {
            const copyIndex = book.copies?.findIndex(c => c.copyId === req.params.copyId);
            if (copyIndex !== undefined && copyIndex >= 0) {
                targetBook = book;
                targetCopyIndex = copyIndex;
                break;
            }
        }
        if (!targetBook || targetCopyIndex === -1) {
            setAuditContext(req, {
                success: false,
                status: 'CopyNotFound',
                description: `Update copy failed: copy ${req.params.copyId} not found`,
            });
            return res.status(404).json({ message: 'Book copy not found' });
        }
        const updatedCopies = [...targetBook.copies];
        if (status) updatedCopies[targetCopyIndex].status = status;
        if (condition) updatedCopies[targetCopyIndex].condition = condition;
        if (location) updatedCopies[targetCopyIndex].location = location;
        updatedCopies[targetCopyIndex].updatedAt = new Date();
        updatedCopies[targetCopyIndex].updatedBy = req.user.id;
        const availableCopies = updatedCopies.filter(c => c.status === 'available').length;
        const persistenceFilter = resolveBookPersistenceFilter(req, targetBook);
        if (!persistenceFilter) {
            console.error('Unable to resolve persistence filter for copy update', targetBook?.id || targetBook?._id || 'unknown');
            return res.status(500).json({ message: 'Failed to update book copy' });
        }

        await req.dbAdapter.updateInCollection('books', persistenceFilter, { copies: updatedCopies, availableCopies, updatedAt: new Date() });
        setAuditContext(req, {
            entityId: targetBook.id || targetBook._id,
            description: `Updated copy ${req.params.copyId} for ${targetBook.title || targetBook.id}`,
            details: {
                status: status || updatedCopies[targetCopyIndex].status,
                condition: condition || updatedCopies[targetCopyIndex].condition,
                location: location || updatedCopies[targetCopyIndex].location,
            },
            metadata: {
                actorId: req.user.id
            },
            success: true,
            status: 'Updated'
        });
        res.json({ message: 'Book copy updated successfully' });
    } catch (error) {
        console.error('Update copy error:', error);
        setAuditContext(req, {
            success: false,
            status: 'Error',
            description: 'Failed to update book copy',
            details: { error: error.message },
        });
        res.status(500).json({ message: 'Failed to update book copy' });
    }
});

router.get('/search/advanced', verifyToken, async(req, res) => {
    try {
        const { q, type = 'all' } = req.query;
        if (!q) return res.status(400).json({ message: 'Search query required' });
        const searchLower = q.toLowerCase();
        const allBooks = await req.dbAdapter.findInCollection('books', {});
        allBooks.forEach(ensureAuthorMetadata);
        const results = [];
        for (const book of allBooks) {
            let matches = false;
            const authorMatches = () =>
                (Array.isArray(book.authors) && book.authors.some((author) => author?.toLowerCase().includes(searchLower))) ||
                (book.author && book.author.toLowerCase().includes(searchLower));
            switch (type) {
                case 'title':
                    matches = book.title?.toLowerCase().includes(searchLower);
                    break;
                case 'author':
                    matches = authorMatches();
                    break;
                case 'isbn':
                    matches = book.isbn?.toLowerCase().includes(searchLower);
                    break;
                case 'all':
                default:
                    matches = book.title?.toLowerCase().includes(searchLower) || authorMatches() || book.isbn?.toLowerCase().includes(searchLower) || book.publisher?.toLowerCase().includes(searchLower) || book.category?.toLowerCase().includes(searchLower);
                    break;
            }
            if (matches) results.push(book);
        }
        res.json(results);
    } catch (error) {
        console.error('Search error:', error);
        res.status(500).json({ message: 'Search failed' });
    }
});

router.get('/meta/categories', verifyToken, async(req, res) => {
    try {
        const storedCategories = await ensureStoredCategories(req.dbAdapter);
        const response = storedCategories
            .map((category) => normalizeCategoryDisplayName(category?.name || category?.slug))
            .filter(Boolean);
        res.json(response);
    } catch (error) {
        console.error('Get categories error:', error);
        res.status(500).json({ message: 'Failed to fetch categories' });
    }
});

module.exports = router;
```

## curriculum.js

| Field | Details |
| --- | --- |
| Program Name | curriculum.js |
| Description | API route handler for curriculum resources. |
| Called by | app.js, departments.js |
| Table used | None |
|  |  |
| Programmer | Nazel Asca√±o |
| Date created | 12/14/2025 |
| Revision Date | TBD |
| Revision / description of change | None |

```javascript
const express = require('express');
const router = express.Router();
const { verifyToken } = require('../middleware/customAuth');
const {
  DEFAULT_CURRICULA,
  normalizeStringList,
  toSlug
} = require('../utils/userAttributes');

router.get('/', verifyToken, async (req, res) => {
  try {
    const setting = await req.dbAdapter.findOneInCollection('settings', { id: 'USER_CURRICULA' });
    const curriculumOptions = normalizeStringList(setting?.value, DEFAULT_CURRICULA);

    const response = curriculumOptions.map((name, index) => ({
      id: toSlug(name, `curriculum-${index}`),
      name
    }));

    res.json(response);
  } catch (error) {
    console.error('Get curriculum options error:', error);
    res.status(500).json({ message: 'Failed to fetch curriculum options' });
  }
});

module.exports = router;
```

## customAuth.js

| Field | Details |
| --- | --- |
| Program Name | customAuth.js |
| Description | API route handler for customAuth resources. |
| Called by | annualSets.js, app.js, audit.js, books.js, curriculum.js, locations.js, notifications.js, reports.js, search.js, settings.js, students.js, transactions.js, transactions_fixed.js, users.js |
| Table used | None |
|  |  |
| Programmer | Nazel Asca√±o |
| Date created | 12/14/2025 |
| Revision Date | TBD |
| Revision / description of change | None |

```javascript
const express = require('express');
const {
  verifyToken,
  logAction,
  generateToken,
  hashPassword,
  verifyPassword,
  recordAuditEvent,
  setAuditContext,
  resolveSessionExpiration,
  setSessionCookie,
  clearSessionCookie,
  getCookieMaxAgeSeconds,
  normalizeRole,
  AUTH_COOKIE_NAME,
} = require('../middleware/customAuth');
const { getSettingsSnapshot } = require('../utils/settingsCache');
const { notifyRoles, formatUserName } = require('../utils/notificationChannels');
const router = express.Router();

const isPlainObject = (value) =>
  value !== null && typeof value === 'object' && !Array.isArray(value);

const mergePreferences = (base = {}, updates = {}) => {
  if (!isPlainObject(base)) base = {};
  if (!isPlainObject(updates)) return { ...base };

  const result = { ...base };
  for (const [key, value] of Object.entries(updates)) {
    if (isPlainObject(value)) {
      result[key] = mergePreferences(base[key], value);
    } else {
      result[key] = value;
    }
  }
  return result;
};

const loadSystemSettings = async (req) => {
  try {
    const snapshot = await getSettingsSnapshot(req.dbAdapter);
    return snapshot.system || null;
  } catch (error) {
    console.error('Failed to load system settings:', error);
    return null;
  }
};

router.post('/register', logAction('REGISTER', 'user'), async (req, res) => {
  try {
    const systemSettings = await loadSystemSettings(req);
    if (systemSettings?.maintenanceMode) {
      setAuditContext(req, {
        success: false,
        status: 'MaintenanceMode',
        description: 'Registration blocked during maintenance',
      });
      return res.status(503).json({ message: 'Registration is unavailable during maintenance' });
    }

    const {
      username,
      email,
      password,
      firstName,
      lastName,
      role = 'student',
      curriculum,
      gradeLevel
    } = req.body;

    if (!username || !email || !password || !firstName || !lastName) {
      setAuditContext(req, {
        success: false,
        status: 'Failed',
        description: 'Registration failed: missing required fields',
        details: { username, email },
      });
      return res.status(400).json({
        message: 'Username, email, password, firstName, and lastName are required'
      });
    }

    const minLength = systemSettings?.passwordMinLength || 8;
    if (password.length < minLength) {
      setAuditContext(req, {
        success: false,
        status: 'Failed',
        description: `Registration failed: password too short (minimum ${minLength} characters)`,
      });
      return res.status(400).json({ message: `Password must be at least ${minLength} characters long` });
    }

    const existingUsers = await req.dbAdapter.getUsers({ username });
    if (existingUsers.length > 0) {
      setAuditContext(req, {
        success: false,
        status: 'Failed',
        description: `Registration failed: username ${username} already exists`,
        details: { username },
      });
      return res.status(400).json({ message: 'Username already exists' });
    }

    if (gradeLevel) {
      const gradeStructureSetting = await req.dbAdapter.findOneInCollection('settings', { id: 'USER_GRADE_STRUCTURE' });
      if (gradeStructureSetting && gradeStructureSetting.value) {
        const structure = gradeStructureSetting.value;
        if (!Array.isArray(structure) || !structure.some(entry => entry.grade === gradeLevel)) {
          setAuditContext(req, {
            success: false,
            status: 'Failed',
            description: 'Registration failed: invalid grade level',
            details: { gradeLevel },
          });
          return res.status(400).json({ message: 'Invalid grade level' });
        }
      }
    }

    const hashedPassword = await hashPassword(password);

    const userData = {
      username,
      email,
      password: hashedPassword,
      firstName,
      lastName,
        role,
      curriculum: curriculum || null,
      gradeLevel: gradeLevel || null,
      isActive: true,
      createdAt: new Date(),
      updatedAt: new Date(),
      lastLoginAt: null,
      borrowingStats: {
        totalBorrowed: 0,
        currentlyBorrowed: 0,
        totalFines: 0,
        totalReturned: 0
      }
    };

    const newUser = await req.dbAdapter.createUser(userData);

    setAuditContext(req, {
      user: {
        id: newUser._id,
        email: newUser.email,
        role: newUser.role,
        username: newUser.username,
        firstName: newUser.firstName,
        lastName: newUser.lastName,
      },
      entityId: newUser._id,
      resourceId: newUser._id,
      description: `Registered new user ${newUser.username}`,
      details: {
        role: newUser.role,
  curriculum: newUser.curriculum || null,
        gradeLevel: newUser.gradeLevel || null,
      },
    });

    const expiresIn = resolveSessionExpiration(systemSettings);
    const token = generateToken(newUser, expiresIn);
    const cookieMaxAgeSeconds = getCookieMaxAgeSeconds(systemSettings);
    setSessionCookie(res, token, cookieMaxAgeSeconds);

    const { password: _, ...userResponse } = newUser;

    res.status(201).json({
      message: 'User registered successfully',
      token,
      user: userResponse
    });

  } catch (error) {
    console.error('Registration error:', error);
    setAuditContext(req, {
      success: false,
      status: 'Failed',
      description: 'Registration failed due to server error',
      details: { error: error.message },
    });
    res.status(500).json({ message: 'Registration failed', error: error.message });
  }
});

router.post('/login', async (req, res) => {
  try {
    const { usernameOrEmail, password } = req.body;

    if (!usernameOrEmail || !password) {
      await recordAuditEvent(req, {
        action: 'LOGIN',
        entity: 'auth',
        success: false,
        statusCode: 400,
        description: 'Login failed: missing credentials',
        details: { usernameOrEmail: usernameOrEmail || null },
      });
      return res.status(400).json({ message: 'Username/email and password are required' });
    }

    let userData = null;

    try {
      const fs = require('fs');
      const logLine = `${new Date().toISOString()}\tAUTH_DEBUG\tlookup\tusernameOrEmail=${usernameOrEmail}\tfound=${userData?userData.username:'none'}\tid=${userData?userData._id:'none'}\tpwdPrefix=${userData&&userData.password?String(userData.password).slice(0,6):'no-password'}\n`;
      fs.appendFileSync(require('path').join(__dirname, '../tmp_auth_debug.log'), logLine);
    } catch (e) {

    }
    if (!usernameOrEmail.includes('@')) {

      const users = await req.dbAdapter.getUsers({ username: usernameOrEmail });
      if (users.length === 0) {
        await recordAuditEvent(req, {
          action: 'LOGIN',
          entity: 'auth',
          success: false,
          statusCode: 404,
          description: `Login failed: user ${usernameOrEmail} not found`,
          details: { usernameOrEmail },
        });
        return res.status(404).json({ message: 'User not found' });
      }
      userData = users[0];
    } else {

      const users = await req.dbAdapter.getUsers({ email: usernameOrEmail });
      if (users.length === 0) {
        await recordAuditEvent(req, {
          action: 'LOGIN',
          entity: 'auth',
          success: false,
          statusCode: 404,
          description: `Login failed: user ${usernameOrEmail} not found`,
          details: { usernameOrEmail },
        });
        return res.status(404).json({ message: 'User not found' });
      }
      userData = users[0];
    }

    if (!userData.isActive) {
      await recordAuditEvent(req, {
        action: 'LOGIN',
        entity: 'auth',
        success: false,
        statusCode: 403,
        description: `Login failed: account ${userData.username} is deactivated`,
        user: userData,
      });
      return res.status(403).json({ message: 'Account is deactivated' });
    }

    if (userData.lockedUntil && userData.lockedUntil > new Date()) {
      await recordAuditEvent(req, {
        action: 'LOGIN',
        entity: 'auth',
        success: false,
        statusCode: 429,
        description: `Login failed: account ${userData.username} is locked`,
        user: userData,
      });
      return res.status(429).json({ message: 'Account locked due to too many failed attempts' });
    }

    const systemSettings = await loadSystemSettings(req);
    const isAdmin = (userData.role || '').toLowerCase() === 'admin';
    if (systemSettings?.maintenanceMode && !isAdmin) {
      await recordAuditEvent(req, {
        action: 'LOGIN',
        entity: 'auth',
        success: false,
        statusCode: 503,
        description: 'Login blocked: system in maintenance mode',
        user: userData,
      });
      return res.status(503).json({ message: 'System is currently in maintenance mode' });
    }

    const isPasswordValid = await verifyPassword(password, userData.password);
    if (!isPasswordValid) {

      const maxAttempts = systemSettings?.maxLoginAttempts || 5;
      const currentAttempts = (userData.failedLoginAttempts || 0) + 1;
      const lockDurationMinutes = 15; // Lock for 15 minutes after max attempts
      let lockedUntil = null;
      if (currentAttempts >= maxAttempts) {
        lockedUntil = new Date(Date.now() + lockDurationMinutes * 60 * 1000);
      }
      await req.dbAdapter.updateUser(userData._id, {
        failedLoginAttempts: currentAttempts,
        lastFailedLoginAt: new Date(),
        lockedUntil
      });
      await recordAuditEvent(req, {
        action: 'LOGIN',
        entity: 'auth',
        success: false,
        statusCode: 401,
        description: `Login failed: invalid credentials for ${userData.username}`,
        user: userData,
      });
      return res.status(401).json({ message: 'Invalid credentials' });
    }

    try {
      if (isPasswordValid && typeof userData.password === 'string' && !/^\$2[aby]\$/.test(userData.password)) {
        const bcrypt = require('bcrypt');
        const newHashed = await bcrypt.hash(password, 10);

        await req.dbAdapter.updateUser(userData._id, { password: newHashed, updatedAt: new Date() });

        userData.password = newHashed;
      }
    } catch (migrateErr) {
      console.error('Password migration error for user', userData.username, migrateErr);

    }

    await req.dbAdapter.updateUser(userData._id, {
      lastLoginAt: new Date(),
      failedLoginAttempts: 0, // Reset on successful login
      lockedUntil: null
    });

    const expiresIn = resolveSessionExpiration(systemSettings);
    const token = generateToken(userData, expiresIn);
    const cookieMaxAgeSeconds = getCookieMaxAgeSeconds(systemSettings);
    setSessionCookie(res, token, cookieMaxAgeSeconds);

    const { password: _, ...userResponse } = userData;
    const safeUser = {
      ...userResponse,
      preferences: userResponse.preferences && typeof userResponse.preferences === 'object'
        ? userResponse.preferences
        : {},
    };

    const normalizedRole = normalizeRole(userResponse.role);
    safeUser.roleLabel = userResponse.role || normalizedRole || 'student';
    safeUser.role = normalizedRole || userResponse.role || 'student';

    const responsePayload = {
      message: 'Login successful',
      token,
      user: safeUser
    };

    await recordAuditEvent(req, {
      action: 'LOGIN',
      entity: 'auth',
      success: true,
      statusCode: 200,
      description: `Login successful for ${userData.username}`,
      user: userData,
      details: {
        username: userData.username,
        role: userData.role,
        lastLoginAt: userData.lastLoginAt,
      },
    });

  res.json(responsePayload);

  } catch (error) {
    console.error('Login error:', error);
    await recordAuditEvent(req, {
      action: 'LOGIN',
      entity: 'auth',
      success: false,
      statusCode: 500,
      description: 'Login failed due to server error',
      details: { error: error.message },
    });
    res.status(500).json({ message: 'Login failed' });
  }
});

router.get('/verify', verifyToken, async (req, res) => {
  try {

    const { password: _, ...userResponse } = req.user;
    const safeUser = {
      ...userResponse,
      preferences: userResponse.preferences && typeof userResponse.preferences === 'object'
        ? userResponse.preferences
        : {},
    };
    const headerToken = req.headers.authorization?.split(' ')[1] || null;
    const cookieToken = req.cookies?.[AUTH_COOKIE_NAME] || null;
    const responsePayload = {
      message: 'Token is valid',
      user: safeUser,
    };
    if (!headerToken && cookieToken) {
      responsePayload.token = cookieToken;
    }

    res.json(responsePayload);
  } catch (error) {
    console.error('Token verification error:', error);
    res.status(401).json({ message: 'Token verification failed' });
  }
});

router.post('/change-password', verifyToken, logAction('CHANGE_PASSWORD', 'auth'), async (req, res) => {
  try {
    const { currentPassword, newPassword } = req.body;

    if (!currentPassword || !newPassword) {
      setAuditContext(req, {
        success: false,
        status: 'Failed',
        description: 'Change password failed: missing required fields',
      });
      return res.status(400).json({ message: 'Current password and new password are required' });
    }

    const systemSettings = await loadSystemSettings(req);
    const minLength = systemSettings?.passwordMinLength || 8;
    if (newPassword.length < minLength) {
      setAuditContext(req, {
        success: false,
        status: 'Failed',
        description: `Change password failed: new password too short (minimum ${minLength} characters)`,
      });
      return res.status(400).json({ message: `New password must be at least ${minLength} characters long` });
    }

    const userData = await req.dbAdapter.findUserById(req.user.id);
    if (!userData) {
      setAuditContext(req, {
        success: false,
        status: 'Failed',
        description: 'Change password failed: user not found',
      });
      return res.status(404).json({ message: 'User not found' });
    }

    const isCurrentPasswordValid = await verifyPassword(currentPassword, userData.password);
    if (!isCurrentPasswordValid) {
      setAuditContext(req, {
        success: false,
        status: 'Failed',
        description: 'Change password failed: current password incorrect',
      });
      return res.status(401).json({ message: 'Current password is incorrect' });
    }

    const hashedNewPassword = await hashPassword(newPassword);

    await req.dbAdapter.updateUser(req.user.id, {
      password: hashedNewPassword,
      updatedAt: new Date()
    });

    setAuditContext(req, {
      description: 'Password changed successfully',
    });

    const displayName = formatUserName(userData);
    try {
      await notifyRoles(req, ['admin'], {
        title: 'User password changed',
        body: `${displayName} (${userData.username}) updated their password`,
        category: 'security',
        meta: {
          userId: userData._id,
          username: userData.username,
          role: userData.role || 'unknown',
          changedBy: req.user.id,
        },
      });
    } catch (notifyError) {
      console.error('Failed to notify admins about password change:', notifyError);
    }

    res.json({ message: 'Password changed successfully' });

  } catch (error) {
    console.error('Change password error:', error);
    setAuditContext(req, {
      success: false,
      status: 'Failed',
      description: 'Change password failed due to server error',
      details: { error: error.message },
    });
    res.status(500).json({ message: 'Failed to change password' });
  }
});

router.post('/logout', verifyToken, async (req, res) => {
  await recordAuditEvent(req, {
    action: 'LOGOUT',
    entity: 'auth',
    success: true,
    statusCode: 200,
    description: 'User logged out',
    user: req.user,
  });
  clearSessionCookie(res);
  res.json({ message: 'Logged out successfully' });
});

router.get('/preferences', verifyToken, async (req, res) => {
  try {
    const preferences = isPlainObject(req.user.preferences)
      ? req.user.preferences
      : {};
    res.json({ preferences });
  } catch (error) {
    console.error('Get preferences error:', error);
    res.status(500).json({ message: 'Failed to fetch preferences' });
  }
});

router.put(
  '/preferences',
  verifyToken,
  logAction('UPDATE', 'preferences'),
  async (req, res) => {
    try {
      const incoming = req.body?.preferences;
      if (!isPlainObject(incoming)) {
        setAuditContext(req, {
          success: false,
          status: 'ValidationError',
          description: 'Invalid preferences payload',
        });
        return res.status(400).json({ message: 'Preferences object is required' });
      }

      const userId = req.user.id;
      const currentUser = await req.dbAdapter.findUserById(userId);
      if (!currentUser) {
        setAuditContext(req, {
          success: false,
          status: 'UserNotFound',
          description: 'Failed to update preferences: user not found',
        });
        return res.status(404).json({ message: 'User not found' });
      }

      const merged = mergePreferences(currentUser.preferences, incoming);
      const updatedUser = await req.dbAdapter.updateUser(userId, {
        preferences: merged,
        updatedAt: new Date(),
      });

      if (!updatedUser) {
        setAuditContext(req, {
          success: false,
          status: 'UpdateFailed',
          description: 'Failed to persist user preferences',
        });
        return res.status(500).json({ message: 'Failed to update preferences' });
      }

      req.user.preferences = merged;

      setAuditContext(req, {
        success: true,
        status: 'Updated',
        entityId: userId,
        description: 'Updated user preferences',
      });

      res.json({ message: 'Preferences updated', preferences: merged });
    } catch (error) {
      console.error('Update preferences error:', error);
      setAuditContext(req, {
        success: false,
        status: 'Failed',
        description: 'Failed to update preferences',
        details: { error: error.message },
      });
      res.status(500).json({ message: 'Failed to update preferences' });
    }
  },
);

module.exports = router;
```

## departments.js

| Field | Details |
| --- | --- |
| Program Name | departments.js |
| Description | API route handler for departments resources. |
| Called by | None |
| Table used | None |
|  |  |
| Programmer | Nazel Asca√±o |
| Date created | 12/14/2025 |
| Revision Date | TBD |
| Revision / description of change | None |

```javascript
module.exports = require('./curriculum');
```

## locations.js

| Field | Details |
| --- | --- |
| Program Name | locations.js |
| Description | API route handler for locations resources. |
| Called by | app.js |
| Table used | None |
|  |  |
| Programmer | Nazel Asca√±o |
| Date created | 12/14/2025 |
| Revision Date | TBD |
| Revision / description of change | None |

```javascript
const express = require('express');
const {
  verifyToken,
  requireStaff,
} = require('../middleware/customAuth');
const {
  getProvinces,
  getMunicipalitiesByProvince,
  getBarangaysByMunicipality,
} = require('../utils/psgcClient');

const router = express.Router();

const handleError = (res, error, fallbackMessage) => {
  console.error('[Locations API]', error.message);
  res.status(502).json({ message: fallbackMessage });
};

router.get('/provinces', verifyToken, requireStaff, async (req, res) => {
  try {
    const provinces = await getProvinces();
    const query = (req.query.q || '').toLowerCase().trim();
    const filtered = query
      ? provinces.filter((province) =>
          province.name.toLowerCase().includes(query),
        )
      : provinces;

    res.json({ provinces: filtered });
  } catch (error) {
    handleError(res, error, 'Failed to load provinces from PSGC');
  }
});

router.get(
  '/provinces/:provinceCode/municipalities',
  verifyToken,
  requireStaff,
  async (req, res) => {
    try {
      const { provinceCode } = req.params;
      if (!provinceCode) {
        return res.status(400).json({ message: 'provinceCode is required' });
      }

      const municipalities = await getMunicipalitiesByProvince(provinceCode);
      const query = (req.query.q || '').toLowerCase().trim();
      const filtered = query
        ? municipalities.filter((municipality) =>
            municipality.name.toLowerCase().includes(query),
          )
        : municipalities;

      res.json({ municipalities: filtered });
    } catch (error) {
      handleError(
        res,
        error,
        'Failed to load municipalities for the selected province',
      );
    }
  },
);

router.get(
  '/municipalities/:municipalityCode/barangays',
  verifyToken,
  requireStaff,
  async (req, res) => {
    try {
      const { municipalityCode } = req.params;
      if (!municipalityCode) {
        return res.status(400).json({ message: 'municipalityCode is required' });
      }

      const barangays = await getBarangaysByMunicipality(municipalityCode);
      const query = (req.query.q || '').toLowerCase().trim();
      const filtered = query
        ? barangays.filter((barangay) =>
            barangay.name.toLowerCase().includes(query),
          )
        : barangays;

      res.json({ barangays: filtered });
    } catch (error) {
      handleError(res, error, 'Failed to load barangays for the municipality');
    }
  },
);

module.exports = router;
```

## notifications.js

| Field | Details |
| --- | --- |
| Program Name | notifications.js |
| Description | API route handler for notifications resources. |
| Called by | app.js |
| Table used | notifications |
|  |  |
| Programmer | Nazel Asca√±o |
| Date created | 12/14/2025 |
| Revision Date | TBD |
| Revision / description of change | None |

```javascript
const express = require('express');
const { verifyToken } = require('../middleware/customAuth');
const { getSettingsSnapshot, NOTIFICATION_DEFAULTS, getNotificationChannelState } = require('../utils/settingsCache');
const { buildBorrowRequestStaffMessage, buildNotePreview } = require('../utils/notificationCopy');

const router = express.Router();

const MS_IN_DAY = 24 * 60 * 60 * 1000;
const MS_IN_HOUR = 60 * 60 * 1000;
const REQUEST_RECENT_THRESHOLD_HOURS = 12;
const SYNTHETIC_READ_COLLECTION = 'notificationReads';

const ensureSettingsSnapshot = async (req) => {
  if (req.settingsSnapshot) {
    return req.settingsSnapshot;
  }
  const snapshot = await getSettingsSnapshot(req.dbAdapter);
  req.settingsSnapshot = snapshot;
  if (!req.systemSettings) {
    req.systemSettings = snapshot.system;
  }
  return snapshot;
};

const getNotificationSettings = async (req) => {
  try {
    const snapshot = await ensureSettingsSnapshot(req);
    return snapshot?.notifications || NOTIFICATION_DEFAULTS;
  } catch (error) {
    console.error('Notification settings retrieval error:', error);
    return NOTIFICATION_DEFAULTS;
  }
};

const getUserIdString = (user = {}) => {
  const candidates = [user.id, user._id, user.userId];
  for (const candidate of candidates) {
    if (candidate === undefined || candidate === null) {
      continue;
    }
    const normalized = String(candidate).trim();
    if (normalized) {
      return normalized;
    }
  }
  return null;
};

const buildNotificationFingerprint = (item) => {
  if (!item || typeof item !== 'object') {
    return null;
  }

  const candidates = [
    item.fingerprint,
    item.link ? `${item.type || 'notification'}:${item.link}` : null,
  ];

  for (const candidate of candidates) {
    if (candidate === undefined || candidate === null) {
      continue;
    }
    const normalized = String(candidate).trim();
    if (normalized) {
      return normalized;
    }
  }

  if (item.title || item.message) {
    const parts = [item.type || 'notification'];
    if (item.title) {
      parts.push(item.title);
    }
    if (item.message) {
      parts.push(item.message);
    }
    const fingerprint = parts.join(':').trim();
    if (fingerprint) {
      return fingerprint;
    }
  }

  return null;
};

const getNotificationIdentifier = (item) => {
  if (!item || typeof item !== 'object') {
    return null;
  }

  const candidates = [
    item.id,
    item._id,
    item.transactionId,
    item?.meta?.transactionId,
    buildNotificationFingerprint(item),
  ];

  for (const candidate of candidates) {
    if (candidate === undefined || candidate === null) {
      continue;
    }
    const normalized = String(candidate).trim();
    if (normalized) {
      return normalized;
    }
  }

  return null;
};

const ensureNotificationIdentifiers = (notification) => {
  if (!notification || typeof notification !== 'object') {
    return notification;
  }

  const identifier = getNotificationIdentifier(notification);
  if (identifier) {
    if (!notification.id) {
      notification.id = identifier;
    }
    if (!notification._id) {
      notification._id = identifier;
    }
  }

  const fingerprint = buildNotificationFingerprint(notification);
  if (fingerprint) {
    notification.fingerprint = fingerprint;
  }

  return notification;
};

const loadUserReadSet = async (dbAdapter, userId) => {
  if (!userId) {
    return new Set();
  }

  try {
    const entries = await dbAdapter.findInCollection(SYNTHETIC_READ_COLLECTION, {
      userId,
    });

    const identifiers = entries
      .map((entry) => entry.notificationId)
      .filter((value) => typeof value === 'string' && value.trim().length > 0)
      .map((value) => value.trim());

    return new Set(identifiers);
  } catch (error) {
    console.error('Notifications read-state load error:', error);
    return new Set();
  }
};

const persistSyntheticReadState = async (dbAdapter, userId, notificationId, read) => {
  if (!userId || !notificationId) {
    return null;
  }

  const normalizedUserId = String(userId).trim();
  const normalizedNotificationId = String(notificationId).trim();

  if (!normalizedUserId || !normalizedNotificationId) {
    return null;
  }

  const existing = await dbAdapter.findOneInCollection(
    SYNTHETIC_READ_COLLECTION,
    {
      userId: normalizedUserId,
      notificationId: normalizedNotificationId,
    },
  );

  if (read) {
    if (existing) {
      const updated = await dbAdapter.updateInCollection(
        SYNTHETIC_READ_COLLECTION,
        { _id: existing._id },
        { read: true },
      );
      return updated || existing;
    }

    return await dbAdapter.insertIntoCollection(SYNTHETIC_READ_COLLECTION, {
      userId: normalizedUserId,
      notificationId: normalizedNotificationId,
      read: true,
    });
  }

  if (existing) {
    await dbAdapter.deleteFromCollection(SYNTHETIC_READ_COLLECTION, {
      _id: existing._id,
    });
  }

  return null;
};

const toDate = (value) => {
  if (!value) return null;
  const date = new Date(value);
  if (Number.isNaN(date.getTime())) return null;
  return date;
};

const toIsoString = (value) => {
  if (!value) return null;
  const date = value instanceof Date ? value : new Date(value);
  if (Number.isNaN(date.getTime())) return null;
  return date.toISOString();
};

const resolveNotificationTimeMs = (notification) => {
  if (!notification || typeof notification !== 'object') {
    return 0;
  }

  const candidates = [
    notification.timestamp,
    notification?.meta?.requestCreatedAt,
    notification.createdAt,
    notification.updatedAt,
  ];

  for (const candidate of candidates) {
    const date = toDate(candidate);
    if (date) {
      return date.getTime();
    }
  }

  return 0;
};

const registerInMap = (map, candidates, value) => {
  candidates
    .map((candidate) =>
      candidate !== undefined && candidate !== null ? String(candidate) : null,
    )
    .filter(Boolean)
    .forEach((key) => {
      if (!map.has(key)) {
        map.set(key, value);
      }
    });
};

const collectUserIdentifiers = (user) => {
  const identifiers = new Set();
  if (!user) return identifiers;

  [
    user.id,
    user._id,
    user.userId,
    user.libraryCardNumber,
    user?.library?.cardNumber,
    user.username,
    user.email,
  ]
    .filter(Boolean)
    .forEach((value) => identifiers.add(String(value)));

  return identifiers;
};

const normalizeRole = (role) => {
  if (!role && role !== 0) {
    return '';
  }
  const value = String(role).trim().toLowerCase();
  if (!value) {
    return '';
  }
  switch (value) {
    case 'super admin':
    case 'super-admin':
    case 'superadmin':
    case 'administrator':
      return 'admin';
    default:
      return value;
  }
};

const buildRoleTargets = (role) => {
  const normalized = normalizeRole(role);
  if (!normalized) {
    return [];
  }

  const targets = new Set();
  targets.add(normalized);
  if (!normalized.endsWith('s')) {
    targets.add(`${normalized}s`);
  }

  if (normalized === 'admin') {
    targets.add('librarian');
    targets.add('librarians');
    targets.add('staff');
    targets.add('staffs');
  } else if (normalized === 'librarian') {
    targets.add('staff');
    targets.add('staffs');
  }

  return Array.from(targets);
};

const shouldDeliverPersistentNotification = (notification, context = {}) => {
  if (!notification || notification.archived) {
    return false;
  }

  const recipients = Array.isArray(notification.recipients)
    ? notification.recipients
    : [];

  if (recipients.length === 0) {
    return true;
  }

  const identifiers = context.identifiers instanceof Set ? context.identifiers : new Set();
  const roleTargets = Array.isArray(context.roleTargets) ? context.roleTargets : [];
  const normalizedRoleTargets = roleTargets.map((value) => normalizeRole(value)).filter(Boolean);

  const normalizedRecipients = recipients
    .map((value) => (value === undefined || value === null ? '' : String(value).trim()))
    .filter(Boolean);

  const excludedRoleTokens = [
    ...(Array.isArray(notification.excludeRoles) ? notification.excludeRoles : []),
    ...(Array.isArray(notification?.meta?.excludeRoles) ? notification.meta.excludeRoles : []),
  ]
    .map((value) => normalizeRole(value))
    .filter(Boolean);

  if (excludedRoleTokens.length > 0 && normalizedRoleTargets.length > 0) {
    const shouldExclude = normalizedRoleTargets.some((target) => excludedRoleTokens.includes(target));
    if (shouldExclude) {
      return false;
    }
  }

  if (normalizedRecipients.length === 0) {
    return true;
  }

  const broadcast = normalizedRecipients.some((value) => {
    const normalized = value.toLowerCase();
    return normalized === 'all' || normalized === '*' || normalized === 'everyone';
  });
  if (broadcast) {
    return true;
  }

  const userMatch = normalizedRecipients.some((value) => identifiers.has(value));
  if (userMatch) {
    return true;
  }

  if (normalizedRoleTargets.length > 0) {
    const recipientRoleTokens = normalizedRecipients.map((value) => value.toLowerCase());
    const match = normalizedRoleTargets.some((target) => recipientRoleTokens.includes(target));
    if (match) {
      return true;
    }
  }

  return false;
};

const resolveTransactionBook = (transaction, bookMap) => {
  const collections = [];
  if (Array.isArray(transaction.items)) collections.push(transaction.items);
  if (Array.isArray(transaction.books)) collections.push(transaction.books);

  for (const list of collections) {
    for (const item of list) {
      const candidates = [item.bookId, item.id, item._id];
      for (const candidate of candidates) {
        if (!candidate) continue;
        const book = bookMap.get(String(candidate));
        if (book) return book;
      }
      if (item.title) {
        return item;
      }
    }
  }

  const candidates = [
    transaction.bookId,
    transaction?.book?.id,
    transaction?.book?._id,
  ];
  for (const candidate of candidates) {
    if (!candidate) continue;
    const book = bookMap.get(String(candidate));
    if (book) return book;
  }

  if (transaction.bookTitle) {
    return { title: transaction.bookTitle, author: transaction.bookAuthor };
  }

  return null;
};

const resolveTransactionBorrower = (transaction, userMap) => {
  const candidates = [
    transaction.userId,
    transaction?.user?.id,
    transaction?.user?._id,
    transaction.borrowerId,
    transaction.borrowerLibraryCardNumber,
    transaction?.user?.userId,
    transaction?.user?.username,
    transaction?.user?.email,
    transaction.borrowerCardNumber,
  ];

  for (const candidate of candidates) {
    if (!candidate) continue;
    const user = userMap.get(String(candidate));
    if (user) return user;
  }

  return transaction.user || null;
};

const buildTransactionSummary = (transaction, context) => {
  const { bookMap, userMap } = context;
  const book = resolveTransactionBook(transaction, bookMap);
  const borrower = resolveTransactionBorrower(transaction, userMap);

  const title =
    book?.title ||
    book?.name ||
    transaction.bookTitle ||
    transaction.title ||
    '';

  const borrowerName = borrower
    ? [borrower.firstName, borrower.lastName]
        .filter(Boolean)
        .join(' ') ||
      borrower.username ||
      borrower.email ||
      transaction.borrowerName ||
      ''
    : transaction.borrowerName || '';

  return {
    title,
    borrower: borrowerName,
    dueDate: toDate(transaction.dueDate),
    dueIso: toIsoString(transaction.dueDate),
    status: (transaction.status || '').toLowerCase(),
    itemCount: Array.isArray(transaction.items) ? transaction.items.length : 0,
    requestId:
      transaction.id ||
      transaction._id ||
      transaction.transactionCode ||
      transaction.referenceNumber ||
      transaction.recordId ||
      transaction.borrowingId ||
      null,
    requestType: transaction.type || '',
    notes: typeof transaction.notes === 'string' ? transaction.notes : '',
    timestamp:
      toIsoString(transaction.updatedAt) ||
      toIsoString(transaction.dueDate) ||
      toIsoString(transaction.borrowDate) ||
      toIsoString(transaction.createdAt),
  };
};

const transactionBelongsToUser = (transaction, identifiers) => {
  const candidates = [
    transaction.userId,
    transaction?.user?.id,
    transaction?.user?._id,
    transaction.borrowerId,
    transaction.borrowerLibraryCardNumber,
    transaction?.user?.userId,
    transaction?.user?.username,
    transaction?.user?.email,
    transaction.borrowerCardNumber,
  ];

  return candidates
    .filter(Boolean)
    .map((value) => String(value))
    .some((candidate) => identifiers.has(candidate));
};

const daysOverdue = (dueDate, reference) =>
  Math.max(1, Math.floor((reference.getTime() - dueDate.getTime()) / MS_IN_DAY));

const daysUntilDue = (dueDate, reference) =>
  Math.max(0, Math.ceil((dueDate.getTime() - reference.getTime()) / MS_IN_DAY));

const overdueSeverity = (days) => {
  if (days >= 7) return 'high';
  if (days >= 3) return 'medium';
  return 'low';
};

const formatRelativeAge = (date, reference = new Date()) => {
  if (!(date instanceof Date) || Number.isNaN(date.getTime())) {
    return null;
  }
  const referenceDate = reference instanceof Date ? reference : new Date(reference);
  if (Number.isNaN(referenceDate.getTime())) {
    return null;
  }
  const diffMs = referenceDate.getTime() - date.getTime();
  if (!Number.isFinite(diffMs) || diffMs < 0) {
    return null;
  }
  if (diffMs < 60 * 1000) {
    return 'moments';
  }
  if (diffMs < MS_IN_HOUR) {
    const minutes = Math.max(1, Math.round(diffMs / (60 * 1000)));
    return `${minutes} minute${minutes === 1 ? '' : 's'}`;
  }
  if (diffMs < MS_IN_DAY) {
    const hours = Math.max(1, Math.round(diffMs / MS_IN_HOUR));
    return `${hours} hour${hours === 1 ? '' : 's'}`;
  }
  const days = Math.max(1, Math.round(diffMs / MS_IN_DAY));
  return `${days} day${days === 1 ? '' : 's'}`;
};

const formatShortDateLabel = (date) => {
  if (!(date instanceof Date) || Number.isNaN(date.getTime())) {
    return null;
  }
  try {
    return new Intl.DateTimeFormat('en-US', { month: 'short', day: 'numeric' }).format(date);
  } catch (error) {
    return null;
  }
};

const decorateBorrowRequestNotification = (notification, referenceDate = new Date()) => {
  if (!notification || notification.type !== 'request') {
    return notification;
  }

  const createdAt =
    toDate(notification?.meta?.requestCreatedAt) ||
    toDate(notification.createdAt) ||
    toDate(notification.timestamp);

  if (!createdAt) {
    return notification;
  }

  const now = referenceDate instanceof Date ? referenceDate : new Date(referenceDate);
  if (Number.isNaN(now.getTime())) {
    return notification;
  }

  const ageMs = now.getTime() - createdAt.getTime();
  if (!Number.isFinite(ageMs) || ageMs < 0) {
    return notification;
  }

  const isRecent = ageMs <= REQUEST_RECENT_THRESHOLD_HOURS * MS_IN_HOUR;
  if (isRecent) {
    if (!notification.timestamp) {
      notification.timestamp = createdAt.toISOString();
    }
    return notification;
  }

  const hasBorrowRequestTitle = typeof notification.title === 'string' && /borrow request/i.test(notification.title);
  if (hasBorrowRequestTitle) {
    notification.title = 'Pending borrow request';
  }

  const rawMessage = typeof notification.message === 'string' ? notification.message.trim() : '';
  const baseMessage = (() => {
    if (!rawMessage) {
      return 'Borrow request pending review';
    }
    const pendingIndex = rawMessage.toLowerCase().indexOf('pending ');
    if (pendingIndex === -1) {
      return rawMessage.replace(/[.]+$/, '');
    }
    return rawMessage.slice(0, pendingIndex).trim().replace(/[.]+$/, '');
  })();

  const ageLabel = formatRelativeAge(createdAt, now);
  const dateLabel = formatShortDateLabel(createdAt);
  const pendingClause = ageLabel
    ? `Pending for ${ageLabel}${dateLabel ? ` (requested ${dateLabel})` : ''}`
    : dateLabel
      ? `Pending since ${dateLabel}`
      : 'Pending review';

  const lead = baseMessage ? `${baseMessage}${baseMessage.endsWith('.') ? '' : '.'}` : '';
  notification.message = `${lead} ${pendingClause}.`.trim().replace(/\.\./g, '.');
  notification.meta = {
    ...(notification.meta || {}),
    requestCreatedAt: createdAt.toISOString(),
    requestAgeHours: Math.round(ageMs / MS_IN_HOUR),
  };

  if (!notification.timestamp) {
    notification.timestamp = createdAt.toISOString();
  }

  return notification;
};

router.get('/', verifyToken, async (req, res) => {
  try {
    const limit = Math.max(parseInt(req.query.limit, 10) || 10, 1);
    const role = req.user.role || 'student';
    const normalizedRole = normalizeRole(role);
    const userId = getUserIdString(req.user);
    const notificationSettings = await getNotificationSettings(req);
    const channelState = getNotificationChannelState(notificationSettings);
    if (!channelState.hasActiveChannel) {
      return res.json({
        notifications: [],
        total: 0,
        generatedAt: new Date().toISOString(),
      });
    }
    const dueRemindersEnabled = notificationSettings.dueDateReminders !== false;
    const overdueEnabled = notificationSettings.overdueNotifications !== false;
    const reservationEnabled = notificationSettings.reservationNotifications !== false;
    const reminderDaysBefore = Math.max(parseInt(notificationSettings.reminderDaysBefore, 10) || 0, 0);

    const [transactions, books, users, persistentRecords] = await Promise.all([
      req.dbAdapter.findInCollection('transactions', {}),
      req.dbAdapter.findInCollection('books', {}),
      req.dbAdapter.findInCollection('users', {}),
      req.dbAdapter.findInCollection('notifications', {}),
    ]);

    const bookMap = new Map();
    const userMap = new Map();

    books.forEach((book) => {
      registerInMap(bookMap, [book._id, book.id, book.bookId], book);
    });

    users.forEach((user) => {
      registerInMap(
        userMap,
        [
          user._id,
          user.id,
          user.userId,
          user.libraryCardNumber,
          user?.library?.cardNumber,
          user.username,
          user.email,
        ],
        user,
      );
    });

    const identifiers = collectUserIdentifiers(req.user);
    const roleTargets = buildRoleTargets(role);
    const now = new Date();
    const dueSoonThreshold = new Date(now.getTime() + reminderDaysBefore * MS_IN_DAY);

    const notifications = [];
    const registerNotification = (payload) => {
      if (!payload) {
        return;
      }
      const normalized = ensureNotificationIdentifiers({ ...payload, read: false });
      normalized.read = false;
      notifications.push(normalized);
    };

    const transactionSource = normalizedRole === 'admin' ? [] : transactions;

    transactionSource.forEach((transaction) => {
      if (role === 'student' && !transactionBelongsToUser(transaction, identifiers)) {
        return;
      }

      const summary = buildTransactionSummary(transaction, { bookMap, userMap });
      const baseId = String(
        transaction.id ||
          transaction._id ||
          transaction.transactionCode ||
          transaction.referenceNumber ||
          transaction.recordId ||
          transaction.borrowingId ||
          `${Date.now()}-${Math.random()}`,
      );
      const link = `/transactions/${String(transaction.id || transaction._id || '')}`;
      const meta = {
        borrower: summary.borrower || null,
        dueDate: summary.dueIso,
        status: summary.status || null,
      };

      const status = summary.status;
      const dueDate = summary.dueDate;
      const isReturned = status === 'returned' || status === 'completed';
      const isMissing = status === 'missing' || status === 'lost';

      if (isMissing) {
        registerNotification({
          id: `missing-${baseId}`,
          type: 'missing',
          title: summary.title || 'Missing item',
          message:
            role === 'student'
              ? 'Please contact the librarian about this missing item.'
              : `${summary.borrower || 'A borrower'} reported a missing item.`,
          timestamp: summary.timestamp || toIsoString(now),
          severity: 'high',
          link,
          meta,
        });
        return;
      }

      if (!dueDate || isReturned) {
        return;
      }

      if (status === 'requested' && role !== 'student') {
        if (!reservationEnabled) {
          return;
        }
        const staffRequestMessage = buildBorrowRequestStaffMessage({
          borrowerName: summary.borrower || 'A borrower',
          transactionId: summary.requestId || transaction.id || transaction._id,
          transactionType: summary.requestType || transaction.type,
          itemCount: summary.itemCount || (Array.isArray(transaction.items) ? transaction.items.length : 0),
          notes: summary.notes || transaction.notes || ''
        });
        registerNotification({
          id: `request-${baseId}`,
          type: 'request',
          title: summary.title || 'Borrow request',
          message: staffRequestMessage,
          timestamp: summary.timestamp || toIsoString(now),
          severity: 'info',
          link,
          meta: {
            ...meta,
            transactionId: summary.requestId || transaction.id || transaction._id,
            itemCount: summary.itemCount || (Array.isArray(transaction.items) ? transaction.items.length : 0),
            requestType: summary.requestType || transaction.type || 'regular',
            notesPreview: buildNotePreview(summary.notes || transaction.notes || '')
          },
        });
        return;
      }

      if (dueDate < now) {
        if (!overdueEnabled) {
          return;
        }
        const overdueDays = daysOverdue(dueDate, now);
        registerNotification({
          id: `overdue-${baseId}`,
          type: 'overdue',
          title: summary.title || 'Overdue item',
          message:
            role === 'student'
              ? `This item is ${overdueDays} day${overdueDays === 1 ? '' : 's'} overdue.`
              : `${summary.borrower || 'A borrower'} is ${overdueDays} day${
                  overdueDays === 1 ? '' : 's'
                } overdue.`,
          timestamp: summary.timestamp || toIsoString(now),
          severity: overdueSeverity(overdueDays),
          link,
          meta: {
            ...meta,
            daysOverdue: overdueDays,
          },
        });
        return;
      }

      if (dueRemindersEnabled && dueDate <= dueSoonThreshold) {
        const daysRemaining = daysUntilDue(dueDate, now);
        registerNotification({
          id: `due-soon-${baseId}`,
          type: 'due-soon',
          title: summary.title || 'Upcoming due date',
          message:
            role === 'student'
              ? `Due in ${daysRemaining} day${daysRemaining === 1 ? '' : 's'}.`
              : `${summary.borrower || 'A borrower'} is due in ${daysRemaining} day${
                  daysRemaining === 1 ? '' : 's'
                }.`,
          timestamp: summary.timestamp || summary.dueIso || toIsoString(now),
          severity: daysRemaining <= 1 ? 'medium' : 'info',
          link,
          meta: {
            ...meta,
            daysUntilDue: daysRemaining,
          },
        });
      }
    });

    const viewerId = userId;
    const persistentContext = { identifiers, roleTargets };
    (Array.isArray(persistentRecords) ? persistentRecords : [])
      .filter((entry) => shouldDeliverPersistentNotification(entry, persistentContext))
      .forEach((entry) => {
        const normalized = ensureNotificationIdentifiers({ ...entry });
        const readByList = Array.isArray(entry.readBy)
          ? entry.readBy.map((value) => String(value))
          : [];
        normalized.read = viewerId ? readByList.includes(viewerId) : false;
        const timestampCandidate =
          normalized.timestamp ||
          normalized.updatedAt ||
          normalized.createdAt ||
          entry.timestamp;
        normalized.timestamp =
          toIsoString(timestampCandidate) ||
          toIsoString(new Date());
        if (!normalized.link && normalized.transactionId) {
          normalized.link = `/transactions/${String(normalized.transactionId)}`;
        }
        normalized.source = normalized.source || 'persistent';
        decorateBorrowRequestNotification(normalized, now);
        notifications.push(normalized);
      });

    const readIdSet = await loadUserReadSet(req.dbAdapter, userId);
    notifications.forEach((entry) => {
      const identifier = getNotificationIdentifier(entry);
      if (identifier && readIdSet.has(identifier)) {
        entry.read = true;
      }
    });

    notifications.sort((a, b) => resolveNotificationTimeMs(b) - resolveNotificationTimeMs(a));

    res.json({
      notifications: notifications.slice(0, limit),
      total: notifications.length,
      generatedAt: new Date().toISOString(),
    });
  } catch (error) {
    console.error('Notifications fetch error:', error);
    res.status(500).json({ message: 'Failed to fetch notifications' });
  }
});

router.get('/persistent', verifyToken, async (req, res) => {
  try {
    const role = req.user?.role || 'student';
    const identifiers = collectUserIdentifiers(req.user);
    const roleTargets = buildRoleTargets(role);
    let items = await req.dbAdapter.findInCollection('notifications', {});
    items = items.filter((entry) => shouldDeliverPersistentNotification(entry, { identifiers, roleTargets }));
    items.sort((a, b) => resolveNotificationTimeMs(b) - resolveNotificationTimeMs(a));

    const viewerId = getUserIdString(req.user);
    const normalizedItems = items.map((entry) => {
      const readByList = Array.isArray(entry.readBy)
        ? entry.readBy.map((value) => String(value))
        : [];
      const normalized = ensureNotificationIdentifiers({ ...entry });
      normalized.read = viewerId ? readByList.includes(viewerId) : false;
      normalized.source = normalized.source || 'persistent';
      decorateBorrowRequestNotification(normalized);
      return normalized;
    });

    res.json({ notifications: normalizedItems });
  } catch (error) {
    console.error('Get persistent notifications error:', error);
    res.status(500).json({ message: 'Failed to fetch persistent notifications' });
  }
});

router.post('/', verifyToken, async (req, res) => {
  try {
    const { title, message, type, recipients, meta } = req.body || {};
    if (!title || !message) return res.status(400).json({ message: 'Title and message required' });
    const entry = {
      title,
      message,
      type: type || 'info',
      recipients: Array.isArray(recipients) ? recipients : [],
      meta: meta || {},
      createdAt: new Date(),
      updatedAt: new Date(),
      readBy: []
    };
    const created = await req.dbAdapter.insertIntoCollection('notifications', entry);
    res.status(201).json(created);
  } catch (error) {
    console.error('Create notification error:', error);
    res.status(500).json({ message: 'Failed to create notification' });
  }
});

router.put('/:id/read', verifyToken, async (req, res) => {
  try {
    const idParam = typeof req.params.id === 'string' ? req.params.id.trim() : '';
    if (!idParam) {
      return res.status(400).json({ message: 'Notification id is required' });
    }

    const requestBody = req.body || {};
    const shouldMarkRead =
      typeof requestBody.read === 'boolean' ? requestBody.read : true;
    const normalizedUserId = getUserIdString(req.user);

    if (!normalizedUserId) {
      return res.status(400).json({ message: 'User identifier unavailable' });
    }

    const item =
      (await req.dbAdapter.findOneInCollection('notifications', { id: idParam })) ||
      (await req.dbAdapter.findOneInCollection('notifications', { _id: idParam }));

    if (item) {
      const readBy = Array.isArray(item.readBy)
        ? item.readBy.map((value) => String(value))
        : [];
      const existingIndex = readBy.indexOf(normalizedUserId);

      if (shouldMarkRead && existingIndex === -1) {
        readBy.push(normalizedUserId);
      } else if (!shouldMarkRead && existingIndex !== -1) {
        readBy.splice(existingIndex, 1);
      }

      const query = item.id ? { id: item.id } : { _id: item._id };
      const updated = await req.dbAdapter.updateInCollection('notifications', query, {
        readBy,
        updatedAt: new Date(),
      });

      const responsePayload = updated || { ...item, readBy };
      responsePayload.read = readBy.includes(normalizedUserId);

      return res.json(responsePayload);
    }

    await persistSyntheticReadState(
      req.dbAdapter,
      normalizedUserId,
      idParam,
      shouldMarkRead,
    );

    return res.json({
      notificationId: idParam,
      userId: normalizedUserId,
      read: shouldMarkRead,
    });
  } catch (error) {
    console.error('Mark read error:', error);
    res.status(500).json({ message: 'Failed to update notification' });
  }
});

router.delete('/:id', verifyToken, async (req, res) => {
  try {
    const id = req.params.id;
    const deleted = await req.dbAdapter.deleteFromCollection('notifications', { id }) || await req.dbAdapter.deleteFromCollection('notifications', { _id: id });
    if (!deleted) return res.status(404).json({ message: 'Notification not found' });
    res.json({ message: 'Deleted' });
  } catch (error) {
    console.error('Delete notification error:', error);
    res.status(500).json({ message: 'Failed to delete notification' });
  }
});

module.exports = router;
```

## reports.js

| Field | Details |
| --- | --- |
| Program Name | reports.js |
| Description | API route handler for reports resources. |
| Called by | app.js |
| Table used | None |
|  |  |
| Programmer | Nazel Asca√±o |
| Date created | 12/14/2025 |
| Revision Date | TBD |
| Revision / description of change | None |

```javascript
const express = require('express');
const { verifyToken, requireStaff } = require('../middleware/customAuth');
const router = express.Router();

router.use(verifyToken, requireStaff);

const normalizeId = (value) => {
    if (value === undefined || value === null) {
        return '';
    }
    return String(value).trim();
};

const findByEntityId = (collection, identifier) => {
    if (!Array.isArray(collection)) {
        return undefined;
    }
    const target = normalizeId(identifier);
    if (!target) {
        return undefined;
    }
    return collection.find((entity) => {
        const candidate = entity || {};
        return normalizeId(candidate.id) === target || normalizeId(candidate._id) === target;
    });
};

const formatUserName = (user) => {
    if (!user) {
        return 'Unknown';
    }
    const fullName = `${user.firstName || ''} ${user.lastName || ''}`.trim();
    return fullName || user.username || user.email || 'Unknown';
};

const extractBookReferenceId = (reference) => {
    if (!reference) {
        return '';
    }
    return (
        normalizeId(reference.bookId) ||
        normalizeId(reference.book_id) ||
        normalizeId(reference.book) ||
        normalizeId(reference.id) ||
        normalizeId(reference._id)
    );
};

const getTransactionBookReferences = (transaction = {}) => {
    if (Array.isArray(transaction.books) && transaction.books.length) {
        return transaction.books;
    }
    if (Array.isArray(transaction.items) && transaction.items.length) {
        return transaction.items;
    }
    return [];
};

const resolveTransactionBookTitles = (transaction, books) => {
    const references = getTransactionBookReferences(transaction);
    if (!references.length) {
        return 'Unknown';
    }
    const titles = references.map((ref) => {
        const bookId = extractBookReferenceId(ref);
        const book = findByEntityId(books, bookId);
        return book?.title || ref.title || ref.isbn || bookId || 'Unknown';
    }).filter(Boolean);
    return titles.length ? titles.join(', ') : 'Unknown';
};

const resolvePrimaryBookDetails = (transaction, books) => {
    const [firstReference] = getTransactionBookReferences(transaction);
    if (!firstReference) {
        return { title: 'Unknown Book', author: 'Unknown Author', isbn: '' };
    }
    const bookId = extractBookReferenceId(firstReference);
    const book = findByEntityId(books, bookId);
    return {
        title: book?.title || firstReference.title || 'Unknown Book',
        author: book?.author || firstReference.author || 'Unknown Author',
        isbn: book?.isbn || firstReference.isbn || ''
    };
};

const getTransactionFineAmount = (transaction) => {
    if (!transaction) {
        return 0;
    }
    const rawValue = Number(
        transaction.fine ??
        transaction.fineAmount ??
        transaction.fineDue ??
        transaction.fineTotal ??
        0
    );
    return Number.isFinite(rawValue) ? rawValue : 0;
};

const toDateOrNull = (value) => {
    if (!value) {
        return null;
    }
    const date = new Date(value);
    return Number.isNaN(date.getTime()) ? null : date;
};

const getTransactionReportDate = (transaction) => {
    if (!transaction) {
        return null;
    }
    return (
        toDateOrNull(transaction.returnDate) ||
        toDateOrNull(transaction.updatedAt) ||
        toDateOrNull(transaction.dueDate) ||
        toDateOrNull(transaction.borrowDate) ||
        toDateOrNull(transaction.createdAt)
    );
};

router.get('/stats', async(req, res) => {
    try {
        console.log('üìä Stats endpoint called, checking database adapter...');

        if (!req.dbAdapter) {
            console.error('‚ùå Database adapter not found in request');
            return res.status(500).json({ message: 'Database adapter not available' });
        }

        console.log('üìä Fetching data from offline database...');

        const books = await req.dbAdapter.findInCollection('books', {});
        const users = await req.dbAdapter.findInCollection('users', {});
        const transactions = await req.dbAdapter.findInCollection('transactions', {});

        console.log('üìä Data fetched:', { booksCount: books.length, usersCount: users.length, transactionsCount: transactions.length });

        const now = new Date();
        const thirtyMinutesAgo = new Date(now.getTime() - (30 * 60 * 1000)); // 30 minutes ago
        const activeUsers = users.filter(u => u.lastActivityAt && new Date(u.lastActivityAt) > thirtyMinutesAgo);

        console.log(`üìä Activity tracking: ${activeUsers.length} users active in last 30 minutes`);
        activeUsers.forEach(u => console.log(`  - ${u.firstName} ${u.lastName} (${u.role}) - last seen: ${u.lastActivityAt}`));

        const borrowedTransactions = transactions.filter(t =>
            t.status === 'borrowed' && !t.returnDate
        );

        const overdueTransactions = borrowedTransactions.filter(t => {
            if (!t.dueDate) return false;
            const dueDate = new Date(t.dueDate);
            return dueDate < now;
        });

        const returnedTransactions = transactions.filter(t =>
            t.status === 'returned' || t.returnDate
        );

        const missingTransactions = transactions.filter(t =>
            t.status === 'missing'
        );

        const stats = {
            totalBooks: books.length,
            borrowedBooks: borrowedTransactions.length,
            returnedBooks: returnedTransactions.length,
            overdueBooks: overdueTransactions.length,
            missingBooks: missingTransactions.length,
            visitors: activeUsers.length,
            newStudents: users.filter(u => u.role === 'student').length,
            totalUsers: users.length,
            activeUsers: users.filter(u => u.isActive !== false).length,
            totalTransactions: transactions.length,
            totalFinesCollected: transactions.reduce((sum, t) => sum + (t.fineAmount || 0), 0)
        };

        console.log('üìä Calculated stats:', stats);
        res.json(stats);
    } catch (error) {
        console.error('‚ùå Error in stats endpoint:', error);
        res.status(500).json({
            message: 'Failed to fetch statistics',
            error: error.message,
            stack: error.stack
        });
    }
});

router.get('/trends/daily', async(req, res) => {
    try {
        const transactions = await req.dbAdapter.findInCollection('transactions', {});

        const trends = [];
        console.log('Generating trends for last 30 days...');
        for (let i = 0; i < 30; i++) {
            const date = new Date();
            date.setDate(date.getDate() - (29 - i));
            const dateStr = date.toISOString().split('T')[0];

            const dayBorrows = transactions.filter(t => {
                if (!t.borrowDate && !t.createdAt) return false;
                const tDate = new Date(t.borrowDate || t.createdAt);
                return tDate.toISOString().split('T')[0] === dateStr && t.status === 'borrowed';
            });

            const dayReturns = transactions.filter(t => {
                if (!t.returnDate && !t.returnedDate) return false;
                const tDate = new Date(t.returnDate || t.returnedDate);
                return tDate.toISOString().split('T')[0] === dateStr && t.status === 'returned';
            });

            trends.push({
                date: dateStr,
                borrows: dayBorrows.length,
                returns: dayReturns.length
            });
        }
        console.log('Generated trends:', trends.length, 'items');

        res.json(trends);
    } catch (error) {
        console.error('Trends error:', error);
        res.json([]);
    }
});

router.get('/overdue/recent', async(req, res) => {
    try {
        const transactions = await req.dbAdapter.findInCollection('transactions', {});
        const users = await req.dbAdapter.findInCollection('users', {});
        const books = await req.dbAdapter.findInCollection('books', {});

        const now = new Date();

        const overdueTransactions = transactions.filter(t => {
            if (t.status !== 'borrowed' || t.returnDate) return false;
            if (!t.dueDate) return false;
            const dueDate = new Date(t.dueDate);
            return dueDate < now;
        });

        const overdueBooks = overdueTransactions.map(trans => {
            const user = findByEntityId(users, trans.userId);
            const { title } = resolvePrimaryBookDetails(trans, books);

            return {
                transactionId: trans.id || trans._id,
                libraryCardNumber: user?.libraryCardNumber || user?.library?.cardNumber || '',
                student: formatUserName(user),
                title,
                dueDate: trans.dueDate,
                borrowDate: trans.borrowDate,
                daysOverdue: Math.floor((now - new Date(trans.dueDate)) / (1000 * 60 * 60 * 24))
            };
        });

        res.json(overdueBooks);
    } catch (error) {
        console.error('Overdue error:', error);
        res.status(500).json({ message: 'Failed to fetch overdue books' });
    }
});

router.get('/transactions/recent', async(req, res) => {
    try {
        if (req.dbAdapter) {
            const transactions = await req.dbAdapter.findInCollection('transactions', {});
            const users = await req.dbAdapter.findInCollection('users', {});
            const books = await req.dbAdapter.findInCollection('books', {});

            const recent = transactions.slice(-10).reverse();

            const enrichedTransactions = recent.map(trans => {
                const user = findByEntityId(users, trans.userId);
                const bookDetails = resolvePrimaryBookDetails(trans, books);

                return {
                    ...trans,
                    libraryCardNumber: user?.libraryCardNumber || user?.library?.cardNumber || '',
                    student: formatUserName(user),
                    title: bookDetails.title,
                    author: bookDetails.author,
                    isbn: bookDetails.isbn,
                    recordDate: trans.borrowDate,
                    returnedDate: trans.returnDate
                };
            });

            res.json(enrichedTransactions);
        } else {
            res.json([]);
        }
    } catch (error) {
        console.error('Recent transactions error:', error);
        res.json([]);
    }
});

router.get('/dashboard', async(req, res) => {
    try {
        const { startDate, endDate } = req.query;
        const transactions = await req.dbAdapter.findInCollection('transactions', {});
        const books = await req.dbAdapter.findInCollection('books', {});
        const users = await req.dbAdapter.findInCollection('users', {});

        let filteredTransactions = transactions;
        if (startDate && endDate) {
            filteredTransactions = transactions.filter(t => {
                const tDate = new Date(t.borrowDate || t.createdAt);
                return tDate >= new Date(startDate) && tDate <= new Date(endDate);
            });
        }

        const bookBorrowCounts = {};
        filteredTransactions.forEach(t => {
            if (t.books && Array.isArray(t.books)) {
                t.books.forEach(book => {
                    const bid = book.id || book._id || book.bookId;
                    if (bid) bookBorrowCounts[bid] = (bookBorrowCounts[bid] || 0) + 1;
                });
            } else if (t.items && Array.isArray(t.items)) {
                t.items.forEach(item => {
                    const bid = item.bookId || item.book_id || item.book;
                    if (bid) bookBorrowCounts[bid] = (bookBorrowCounts[bid] || 0) + 1;
                });
            }
        });

        const popularBooks = Object.entries(bookBorrowCounts)
            .map(([bookId, count]) => {
                const book = findByEntityId(books, bookId) || {};
                return {
                    id: bookId,
                    title: book.title || 'Unknown',
                    author: book.author || 'Unknown',
                    borrowCount: count
                };
            })
            .sort((a, b) => b.borrowCount - a.borrowCount)
            .slice(0, 10);

        const recentActivity = filteredTransactions
            .sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt))
            .slice(0, 10)
            .map(t => ({
                id: t.id,
                type: t.status,
                date: t.borrowDate || t.createdAt,
                userId: t.userId,
                bookCount: t.books ? t.books.length : (t.items ? t.items.length : 0)
            }));

        res.json({
            totalTransactions: filteredTransactions.length,
            totalBooks: books.length,
            totalUsers: users.length,
            activeTransactions: filteredTransactions.filter(t => t.status === 'borrowed').length,
            popularBooks: popularBooks,
            recentActivity: recentActivity
        });
    } catch (error) {
        console.error('Dashboard report error:', error);
        res.status(500).json({ message: 'Failed to fetch dashboard report' });
    }
});

router.get('/circulation', async(req, res) => {
    try {
        const { startDate, endDate } = req.query;
        const transactions = await req.dbAdapter.findInCollection('transactions', {});
        const users = await req.dbAdapter.findInCollection('users', {});

        let filtered = transactions;
        if (startDate && endDate) {
            filtered = transactions.filter(t => {
                const tDate = new Date(t.borrowDate || t.createdAt);
                return tDate >= new Date(startDate) && tDate <= new Date(endDate);
            });
        }

        const dailyData = {};
        filtered.forEach(t => {
            const date = new Date(t.borrowDate || t.createdAt).toDateString();
            if (!dailyData[date]) {
                dailyData[date] = { date, borrowed: 0, returned: 0, newUsers: 0, finesCollected: 0 };
            }
            if (t.status === 'borrowed') dailyData[date].borrowed++;
            if (t.status === 'returned') dailyData[date].returned++;
            const fineValue = getTransactionFineAmount(t);
            if (fineValue > 0 && (t.finePaid || typeof t.finePaid === 'undefined')) {
                dailyData[date].finesCollected += fineValue;
            }
        });

        if (startDate && endDate) {
            users.forEach(u => {
                const userDate = new Date(u.createdAt).toDateString();
                if (dailyData[userDate]) {
                    dailyData[userDate].newUsers++;
                }
            });
        }

        const result = Object.values(dailyData).sort((a, b) => new Date(a.date) - new Date(b.date));
        res.json(result);
    } catch (error) {
        console.error('Circulation report error:', error);
        res.status(500).json({ message: 'Failed to fetch circulation report' });
    }
});

router.get('/popular-books', async(req, res) => {
    try {
        const { startDate, endDate } = req.query;
        const transactions = await req.dbAdapter.findInCollection('transactions', {});
        const books = await req.dbAdapter.findInCollection('books', {});

        let filtered = transactions;
        if (startDate && endDate) {
            filtered = transactions.filter(t => {
                const tDate = new Date(t.borrowDate || t.createdAt);
                return tDate >= new Date(startDate) && tDate <= new Date(endDate);
            });
        }

        const bookCounts = {};
        filtered.forEach(t => {
            if (t.books && Array.isArray(t.books)) {
                t.books.forEach(book => {
                    const bid = extractBookReferenceId(book);
                    if (bid) bookCounts[bid] = (bookCounts[bid] || 0) + 1;
                });
            } else if (t.items && Array.isArray(t.items)) {
                t.items.forEach(item => {
                    const bid = extractBookReferenceId(item);
                    if (bid) bookCounts[bid] = (bookCounts[bid] || 0) + 1;
                });
            }
        });

        const popularBooks = Object.entries(bookCounts)
            .map(([bookId, count]) => {
                const book = findByEntityId(books, bookId);
                return {
                    id: bookId,
                    title: book?.title || 'Unknown',
                    author: book?.author || 'Unknown',
                    category: book?.category || 'Uncategorized',
                    borrowCount: count,
                    averageRating: book?.rating ?? null
                };
            })
            .sort((a, b) => b.borrowCount - a.borrowCount)
            .slice(0, 20);

        res.json(popularBooks);
    } catch (error) {
        console.error('Popular books error:', error);
        res.status(500).json({ message: 'Failed to fetch popular books' });
    }
});

router.get('/user-activity', async(req, res) => {
    try {
        const { startDate, endDate } = req.query;
        const transactions = await req.dbAdapter.findInCollection('transactions', {});
        const users = await req.dbAdapter.findInCollection('users', {});

        let filtered = transactions;
        if (startDate && endDate) {
            filtered = transactions.filter(t => {
                const tDate = new Date(t.borrowDate || t.createdAt);
                return tDate >= new Date(startDate) && tDate <= new Date(endDate);
            });
        }

        const userActivity = {};
        filtered.forEach(t => {
            const userKey = normalizeId(t.userId);
            if (!userKey) {
                return;
            }
            if (!userActivity[userKey]) {
                userActivity[userKey] = { borrowed: 0, returned: 0, totalFines: 0, lastActivity: t.createdAt };
            }
            if (t.status === 'borrowed') userActivity[userKey].borrowed++;
            if (t.status === 'returned') userActivity[userKey].returned++;
            const fineValue = getTransactionFineAmount(t);
            if (fineValue > 0) {
                userActivity[userKey].totalFines += fineValue;
            }
            if (new Date(t.createdAt) > new Date(userActivity[userKey].lastActivity)) {
                userActivity[userKey].lastActivity = t.createdAt;
            }
        });

        const result = Object.entries(userActivity).map(([userId, activity]) => {
            const user = findByEntityId(users, userId);
            return {
                id: userId,
                name: formatUserName(user),
                role: user?.role || 'Unknown',
                borrowed: activity.borrowed,
                returned: activity.returned,
                totalFines: activity.totalFines,
                lastActivity: activity.lastActivity
            };
        }).sort((a, b) => b.borrowed - a.borrowed);

        res.json(result);
    } catch (error) {
        console.error('User activity error:', error);
        res.status(500).json({ message: 'Failed to fetch user activity' });
    }
});

router.get('/fines', async(req, res) => {
    try {
        const { startDate, endDate } = req.query;
        const transactions = await req.dbAdapter.findInCollection('transactions', {});
        const users = await req.dbAdapter.findInCollection('users', {});
        const books = await req.dbAdapter.findInCollection('books', {});

        let filtered = transactions;
        const start = toDateOrNull(startDate);
        const end = toDateOrNull(endDate);

        if (start || end) {
            filtered = transactions.filter(t => {
                const referenceDate = getTransactionReportDate(t);
                const withinRange = (() => {
                    if (!referenceDate) {
                        return false;
                    }
                    if (start && end) {
                        return referenceDate >= start && referenceDate <= end;
                    }
                    if (start) {
                        return referenceDate >= start;
                    }
                    if (end) {
                        return referenceDate <= end;
                    }
                    return true;
                })();
                const outstandingFine = !t.returnDate && getTransactionFineAmount(t) > 0;
                return withinRange || outstandingFine;
            });
        }

        const fineTransactions = filtered
            .filter(t => getTransactionFineAmount(t) > 0)
            .map(t => {
                const user = findByEntityId(users, t.userId);
                const bookTitles = resolveTransactionBookTitles(t, books);
                const amount = getTransactionFineAmount(t);

                return {
                    id: t.id,
                    date: t.returnDate || t.createdAt,
                    userName: formatUserName(user),
                    bookTitle: bookTitles,
                    amount,
                    reason: 'Late Return',
                    status: t.finePaid ? 'paid' : 'unpaid'
                };
            });

        res.json(fineTransactions);
    } catch (error) {
        console.error('Fines report error:', error);
        res.status(500).json({ message: 'Failed to fetch fines report' });
    }
});

router.get('/inventory', async(req, res) => {
    try {
        const books = await req.dbAdapter.findInCollection('books', {});

        const result = books.map(book => {
            let totalCopies = 0;
            let available = 0;
            let borrowed = 0;
            let lostDamaged = 0;

            if (book.copies && Array.isArray(book.copies)) {
                totalCopies = book.copies.length;
                available = book.copies.filter(c => c.status === 'available').length;
                borrowed = book.copies.filter(c => c.status === 'borrowed').length;
                lostDamaged = book.copies.filter(c => c.status === 'lost' || c.status === 'damaged').length;
            }

            return {
                id: book.id,
                title: book.title || 'Unknown',
                author: book.author || 'Unknown',
                category: book.category || 'Uncategorized',
                totalCopies,
                available,
                borrowed,
                lostDamaged
            };
        });

        res.json(result);
    } catch (error) {
        console.error('Inventory report error:', error);
        res.status(500).json({ message: 'Failed to fetch inventory report' });
    }
});

router.get('/overdue', async(req, res) => {
    try {
        const transactions = await req.dbAdapter.findInCollection('transactions', {});
        const users = await req.dbAdapter.findInCollection('users', {});
        const books = await req.dbAdapter.findInCollection('books', {});
        const now = new Date();

        const overdueTransactions = transactions.filter(t => {
            if (t.status !== 'borrowed') return false;
            const dueDate = new Date(t.dueDate);
            return dueDate < now;
        });

        const result = overdueTransactions.map(t => {
            const user = findByEntityId(users, t.userId);
            const dueDate = new Date(t.dueDate);
            const daysOverdue = Math.floor((now - dueDate) / (1000 * 60 * 60 * 24));
            const fine = daysOverdue * 5; // $5 per day fine

            const bookTitles = resolveTransactionBookTitles(t, books);

            return {
                id: t.id,
                bookTitle: bookTitles,
                borrowerName: formatUserName(user),
                dueDate: t.dueDate,
                daysOverdue,
                fine,
                status: daysOverdue > 30 ? 'Critical' : 'Overdue'
            };
        });

        res.json(result);
    } catch (error) {
        console.error('Overdue report error:', error);
        res.status(500).json({ message: 'Failed to fetch overdue report' });
    }
});

module.exports = router;

router.get('/export/:type', async (req, res) => {
    try {
        const { type } = req.params;
        const { startDate, endDate } = req.query;

        if (!req.dbAdapter) {
            return res.status(500).json({ message: 'Database adapter not available' });
        }

        const transactions = await req.dbAdapter.findInCollection('transactions', {});
        const users = await req.dbAdapter.findInCollection('users', {});
        const books = await req.dbAdapter.findInCollection('books', {});

        const toCSV = (arr) => {
            if (!Array.isArray(arr) || arr.length === 0) return '';
            const headers = Object.keys(arr[0]);
            const escape = (v) => {
                if (v === null || v === undefined) return '';
                const s = String(v);
                if (s.includes(',') || s.includes('"') || s.includes('\n')) {
                    return '"' + s.replace(/"/g, '""') + '"';
                }
                return s;
            };
            const rows = [headers.join(',')];
            arr.forEach(r => {
                const row = headers.map(h => escape(r[h]));
                rows.push(row.join(','));
            });
            return rows.join('\n');
        };

        let data = [];

        switch ((type || '').toLowerCase()) {
            case 'circulation': {

                let filtered = transactions;
                if (startDate && endDate) {
                    filtered = transactions.filter(t => {
                        const tDate = new Date(t.borrowDate || t.createdAt);
                        return tDate >= new Date(startDate) && tDate <= new Date(endDate);
                    });
                }
                const dailyData = {};
                filtered.forEach(t => {
                    const date = new Date(t.borrowDate || t.createdAt).toDateString();
                    if (!dailyData[date]) dailyData[date] = { date, borrowed: 0, returned: 0, newUsers: 0, finesCollected: 0 };
                    if (t.status === 'borrowed') dailyData[date].borrowed++;
                    if (t.status === 'returned') dailyData[date].returned++;
                    const fineValue = getTransactionFineAmount(t);
                    if (fineValue > 0 && (t.finePaid || typeof t.finePaid === 'undefined')) {
                        dailyData[date].finesCollected += fineValue;
                    }
                });
                if (startDate && endDate) {

                    users.forEach(u => {
                        const userDate = new Date(u.createdAt).toDateString();
                        if (dailyData[userDate]) dailyData[userDate].newUsers++;
                    });
                }
                data = Object.values(dailyData).sort((a, b) => new Date(a.date) - new Date(b.date));
                break;
            }
            case 'popular-books': {
                let filtered = transactions;
                if (startDate && endDate) {
                    filtered = transactions.filter(t => {
                        const tDate = new Date(t.borrowDate || t.createdAt);
                        return tDate >= new Date(startDate) && tDate <= new Date(endDate);
                    });
                }
                const bookCounts = {};
                filtered.forEach(t => {
                    if (t.books && Array.isArray(t.books)) {
                        t.books.forEach(b => {
                            const bookKey = extractBookReferenceId(b);
                            if (bookKey) {
                                bookCounts[bookKey] = (bookCounts[bookKey] || 0) + 1;
                            }
                        });
                    } else if (t.items && Array.isArray(t.items)) {
                        t.items.forEach(it => {
                            const bookId = extractBookReferenceId(it);
                            if (bookId) bookCounts[bookId] = (bookCounts[bookId] || 0) + 1;
                        });
                    }
                });
                data = Object.entries(bookCounts).map(([bookId, count]) => {
                    const book = findByEntityId(books, bookId) || {};
                    return {
                        id: bookId,
                        title: book.title || 'Unknown',
                        author: book.author || 'Unknown',
                        category: book.category || 'Uncategorized',
                        borrowCount: count,
                        averageRating: book.rating || ''
                    };
                }).sort((a, b) => b.borrowCount - a.borrowCount).slice(0, 1000);
                break;
            }
            case 'user-activity': {
                let filtered = transactions;
                if (startDate && endDate) {
                    filtered = transactions.filter(t => {
                        const tDate = new Date(t.borrowDate || t.createdAt);
                        return tDate >= new Date(startDate) && tDate <= new Date(endDate);
                    });
                }
                const userActivity = {};
                filtered.forEach(t => {
                    const userKey = normalizeId(t.userId);
                    if (!userKey) {
                        return;
                    }
                    if (!userActivity[userKey]) userActivity[userKey] = { borrowed: 0, returned: 0, totalFines: 0, lastActivity: t.createdAt };
                    if (t.status === 'borrowed') userActivity[userKey].borrowed++;
                    if (t.status === 'returned') userActivity[userKey].returned++;
                    const fineValue = getTransactionFineAmount(t);
                    if (fineValue > 0) {
                        userActivity[userKey].totalFines += fineValue;
                    }
                    if (new Date(t.createdAt) > new Date(userActivity[userKey].lastActivity)) userActivity[userKey].lastActivity = t.createdAt;
                });
                data = Object.entries(userActivity).map(([userId, activity]) => {
                    const user = findByEntityId(users, userId) || {};
                    return {
                        id: userId,
                        name: formatUserName(user),
                        role: user.role || '',
                        borrowed: activity.borrowed,
                        returned: activity.returned,
                        totalFines: activity.totalFines,
                        lastActivity: activity.lastActivity
                    };
                }).sort((a, b) => b.borrowed - a.borrowed);
                break;
            }
            case 'overdue': {
                const now = new Date();
                const overdueTransactions = transactions.filter(t => {
                    if (t.status !== 'borrowed') return false;
                    if (!t.dueDate) return false;
                    const dueDate = new Date(t.dueDate);
                    return dueDate < now;
                });
                data = overdueTransactions.map(t => {
                    const user = findByEntityId(users, t.userId) || {};
                    const bookTitles = resolveTransactionBookTitles(t, books);
                    const dueDate = t.dueDate;
                    const daysOverdue = Math.floor((new Date() - new Date(dueDate)) / (1000 * 60 * 60 * 24));
                    const fine = daysOverdue * 5;
                    return {
                        id: t.id || t._id,
                        bookTitle: bookTitles,
                        borrowerName: formatUserName(user),
                        dueDate: dueDate,
                        daysOverdue,
                        fine,
                        status: daysOverdue > 30 ? 'Critical' : 'Overdue'
                    };
                });
                break;
            }
            case 'fines': {
                let filtered = transactions;
                const start = toDateOrNull(startDate);
                const end = toDateOrNull(endDate);
                if (start || end) {
                    filtered = transactions.filter(t => {
                        const referenceDate = getTransactionReportDate(t);
                        const withinRange = (() => {
                            if (!referenceDate) {
                                return false;
                            }
                            if (start && end) {
                                return referenceDate >= start && referenceDate <= end;
                            }
                            if (start) {
                                return referenceDate >= start;
                            }
                            if (end) {
                                return referenceDate <= end;
                            }
                            return true;
                        })();
                        const outstandingFine = !t.returnDate && getTransactionFineAmount(t) > 0;
                        return withinRange || outstandingFine;
                    });
                }
                const fineTransactions = filtered.filter(t => getTransactionFineAmount(t) > 0).map(t => {
                    const user = findByEntityId(users, t.userId) || {};
                    const bookTitles = resolveTransactionBookTitles(t, books);
                    const amount = getTransactionFineAmount(t);
                    return {
                        id: t.id || t._id,
                        date: t.returnDate || t.createdAt,
                        userName: formatUserName(user),
                        bookTitle: bookTitles,
                        amount,
                        reason: 'Late Return',
                        status: t.finePaid ? 'paid' : 'unpaid'
                    };
                });
                data = fineTransactions;
                break;
            }
            case 'inventory': {
                data = books.map(book => {
                    let totalCopies = 0;
                    let available = 0;
                    let borrowed = 0;
                    let lostDamaged = 0;
                    if (book.copies && Array.isArray(book.copies)) {
                        totalCopies = book.copies.length;
                        available = book.copies.filter(c => c.status === 'available').length;
                        borrowed = book.copies.filter(c => c.status === 'borrowed').length;
                        lostDamaged = book.copies.filter(c => c.status === 'lost' || c.status === 'damaged').length;
                    }
                    return {
                        id: book.id,
                        title: book.title || 'Unknown',
                        author: book.author || 'Unknown',
                        category: book.category || 'Uncategorized',
                        totalCopies,
                        available,
                        borrowed,
                        lostDamaged
                    };
                });
                break;
            }
            case 'transactions_recent':
            case 'transactions-recent':
            case 'recent-transactions': {
                const recent = transactions.slice(-100).reverse();
                data = recent.map(t => {
                    const user = findByEntityId(users, t.userId) || {};
                    const bookDetails = resolvePrimaryBookDetails(t, books);
                    return {
                        id: t.id || t._id,
                        libraryCardNumber: user ? (user.libraryCardNumber || user.library?.cardNumber || '') : '',
                        student: formatUserName(user),
                        title: bookDetails.title,
                        author: bookDetails.author,
                        isbn: bookDetails.isbn,
                        recordDate: t.borrowDate,
                        returnedDate: t.returnDate
                    };
                });
                break;
            }
            default:
                return res.status(400).json({ message: 'Unknown export type' });
        }

        const csv = toCSV(data);
        res.setHeader('Content-Type', 'text/csv');
        res.setHeader('Content-Disposition', `attachment; filename="${type}_report.csv"`);
        res.send(csv);
    } catch (error) {
        console.error('Export report error:', error);
        res.status(500).json({ message: 'Failed to export report' });
    }
});
```

## search.js

| Field | Details |
| --- | --- |
| Program Name | search.js |
| Description | API route handler for search resources. |
| Called by | app.js |
| Table used | None |
|  |  |
| Programmer | Nazel Asca√±o |
| Date created | 12/14/2025 |
| Revision Date | TBD |
| Revision / description of change | None |

```javascript
const express = require('express');
const { verifyToken } = require('../middleware/customAuth');

const router = express.Router();

const toLower = (value) => (value ? String(value).toLowerCase() : '');
const includesTerm = (value, term) => toLower(value).includes(term);
const toIsoString = (value) => {
  if (!value) return null;
  const date = new Date(value);
  if (Number.isNaN(date.getTime())) return null;
  return date.toISOString();
};
const formatDueLabel = (value) => {
  const iso = toIsoString(value);
  if (!iso) return '';
  return `Due ${iso.slice(0, 10)}`;
};
const limitItems = (items, limit) => items.slice(0, limit);

const matchesTerm = (value, term) => {
  if (value === null || value === undefined) {
    return false;
  }

  if (Array.isArray(value)) {
    return value.some((entry) => matchesTerm(entry, term));
  }

  if (typeof value === 'object') {
    return Object.values(value).some((entry) => matchesTerm(entry, term));
  }

  return includesTerm(value, term);
};

const registerInMap = (map, candidates, value) => {
  candidates
    .map((candidate) =>
      candidate !== undefined && candidate !== null ? String(candidate) : null,
    )
    .filter(Boolean)
    .forEach((key) => {
      if (!map.has(key)) {
        map.set(key, value);
      }
    });
};

const collectUserIdentifiers = (user) => {
  const identifiers = new Set();
  if (!user) return identifiers;

  [
    user.id,
    user._id,
    user.userId,
    user.libraryCardNumber,
    user?.library?.cardNumber,
    user.username,
    user.email,
  ]
    .filter(Boolean)
    .forEach((value) => identifiers.add(String(value)));

  return identifiers;
};

const findUserByIdentifier = (userMap, term) => {
  if (!term) return null;
  const normalizedTerm = term.toLowerCase();

  for (const [key, user] of userMap.entries()) {
    if (typeof key !== 'string') {
      continue;
    }
    if (key.toLowerCase() === normalizedTerm) {
      return user;
    }
  }

  return null;
};

const resolveTransactionBook = (transaction, bookMap) => {
  const collections = [];
  if (Array.isArray(transaction.items)) collections.push(transaction.items);
  if (Array.isArray(transaction.books)) collections.push(transaction.books);

  for (const list of collections) {
    for (const item of list) {
      const candidates = [item.bookId, item.id, item._id];
      for (const candidate of candidates) {
        if (!candidate) continue;
        const book = bookMap.get(String(candidate));
        if (book) return book;
      }
      if (item.title) {
        return item;
      }
    }
  }

  const candidates = [
    transaction.bookId,
    transaction?.book?.id,
    transaction?.book?._id,
  ];
  for (const candidate of candidates) {
    if (!candidate) continue;
    const book = bookMap.get(String(candidate));
    if (book) return book;
  }

  if (transaction.bookTitle) {
    return { title: transaction.bookTitle, author: transaction.bookAuthor };
  }

  return null;
};

const resolveTransactionBorrower = (transaction, userMap) => {
  const candidates = [
    transaction.userId,
    transaction?.user?.id,
    transaction?.user?._id,
    transaction.borrowerId,
    transaction.borrowerLibraryCardNumber,
    transaction?.user?.userId,
    transaction?.user?.username,
    transaction?.user?.email,
    transaction.borrowerCardNumber,
  ];

  for (const candidate of candidates) {
    if (!candidate) continue;
    const user = userMap.get(String(candidate));
    if (user) return user;
  }

  return transaction.user || null;
};

const buildTransactionSummary = (transaction, context) => {
  const { bookMap, userMap } = context;
  const book = resolveTransactionBook(transaction, bookMap);
  const borrower = resolveTransactionBorrower(transaction, userMap);

  const title =
    book?.title ||
    book?.name ||
    transaction.bookTitle ||
    transaction.title ||
    '';

  const borrowerName = borrower
    ? [borrower.firstName, borrower.lastName]
        .filter(Boolean)
        .join(' ') ||
      borrower.username ||
      borrower.email ||
      transaction.borrowerName ||
      ''
    : transaction.borrowerName || '';

  return {
    title,
    borrower: borrowerName,
    dueLabel: formatDueLabel(transaction.dueDate),
    timestamp:
      toIsoString(transaction.dueDate) ||
      toIsoString(transaction.borrowDate) ||
      toIsoString(transaction.createdAt),
    status: (transaction.status || '').toLowerCase(),
  };
};

const transactionBelongsToUser = (transaction, identifiers) => {
  const candidates = [
    transaction.userId,
    transaction?.user?.id,
    transaction?.user?._id,
    transaction.borrowerId,
    transaction.borrowerLibraryCardNumber,
    transaction?.user?.userId,
    transaction?.user?.username,
    transaction?.user?.email,
    transaction.borrowerCardNumber,
  ];

  return candidates
    .filter(Boolean)
    .map((value) => String(value))
    .some((candidate) => identifiers.has(candidate));
};

const collectTransactionIdentifiers = (transaction) => {
  const identifiers = new Set();
  const register = (value) => {
    if (value !== undefined && value !== null) {
      const normalized = String(value).trim();
      if (normalized) {
        identifiers.add(normalized);
      }
    }
  };

  [
    transaction.id,
    transaction._id,
    transaction.transactionId,
    transaction.transactionCode,
    transaction.referenceNumber,
    transaction.documentId,
    transaction.copyId,
    transaction.barcode,
  ].forEach(register);

  const collections = [];
  if (Array.isArray(transaction.items)) collections.push(transaction.items);
  if (Array.isArray(transaction.books)) collections.push(transaction.books);

  collections.forEach((list) => {
    list.forEach((item) => {
      register(item?.copyId);
      register(item?.barcode);
      register(item?.isbn);
    });
  });

  return identifiers;
};

router.get('/', verifyToken, async (req, res) => {
  try {
    const query = String(req.query.q || '').trim();
    if (!query) {
      return res.json({ query, results: {}, total: 0 });
    }

    const role = req.user.role || 'student';
    const limit = Math.max(parseInt(req.query.limit, 10) || 5, 1);
    const term = query.toLowerCase();

    const [books, users, transactions] = await Promise.all([
      req.dbAdapter.findInCollection('books', {}),
      req.dbAdapter.findInCollection('users', {}),
      req.dbAdapter.findInCollection('transactions', {}),
    ]);

    const bookMap = new Map();
    const userMap = new Map();

    books.forEach((book) => {
      registerInMap(bookMap, [book._id, book.id, book.bookId], book);
    });

    users.forEach((user) => {
      registerInMap(
        userMap,
        [
          user._id,
          user.id,
          user.userId,
          user.libraryCardNumber,
          user?.library?.cardNumber,
          user.username,
          user.email,
        ],
        user,
      );
    });

    const results = {};

    const bookMatches = books.filter((book) =>
      matchesTerm(
        [
          book.title,
          book.author,
          book.subtitle,
          book.description,
          book.summary,
          book.isbn,
          book.category,
          book.publisher,
          book.language,
          book.tags,
          book.subjects,
          book.location,
          book.copies,
        ],
        term,
      ),
    );

    if (bookMatches.length) {
      results.books = limitItems(bookMatches, limit).map((book) => {
        const id = String(book.id || book._id);
        return {
          id,
          primary: book.title || 'Untitled book',
          secondary: [book.author, book.isbn].filter(Boolean).join(' ‚Ä¢ '),
          chip: book.category || '',
          link: `/books/${id}`,
          category: 'books',
          status: book.status || '',
        };
      });
    }

    const canViewStaffData = role !== 'student';

    if (canViewStaffData) {
      const userMatches = users.filter((user) =>
        matchesTerm(
          [
            user.firstName,
            user.lastName,
            user.middleName,
            user.username,
            user.email,
            user.curriculum,
            user.gradeLevel,
            user.phoneNumber,
            user.profile?.phone,
            user.profile?.address,
            user.library?.cardNumber,
          ],
          term,
        ),
      );

      const staff = userMatches.filter((user) => user.role && user.role !== 'student');
      const students = userMatches.filter((user) => user.role === 'student');

      if (staff.length) {
        results.users = limitItems(staff, limit).map((user) => {
          const id = String(user._id || user.id);
          const fullName = [user.firstName, user.lastName].filter(Boolean).join(' ');
          const secondary = [user.role, user.email || user.username]
            .filter(Boolean)
            .join(' ‚Ä¢ ');

          return {
            id,
            primary: fullName || user.username || 'User',
            secondary,
            chip: (user.role || '').toUpperCase(),
            link: `/users/${id}`,
            category: 'users',
          };
        });
      }

      if (students.length) {
        results.students = limitItems(students, limit).map((student) => {
          const id = String(student._id || student.id);
          const fullName = [student.firstName, student.lastName]
            .filter(Boolean)
            .join(' ');
          const secondary = [
            student.library?.cardNumber || student.libraryCardNumber,
            student.gradeLevel || student.grade,
            student.section,
          ]
            .filter(Boolean)
            .join(' ‚Ä¢ ');

          return {
            id,
            primary: fullName || student.username || 'Student',
            secondary,
            chip: 'STUDENT',
            link: `/students/${id}`,
            category: 'students',
          };
        });
      }
    }

    const identifiers = collectUserIdentifiers(req.user);
    const relevantTransactions = transactions.filter((transaction) =>
      canViewStaffData ? true : transactionBelongsToUser(transaction, identifiers),
    );

    if (canViewStaffData) {
      const directUser = findUserByIdentifier(userMap, term);
      if (directUser) {
        const targetKey = directUser.role === 'student' ? 'students' : 'users';
        const container = results[targetKey] || [];

        const exists = container.some((item) => item.id === String(directUser._id || directUser.id));
        if (!exists) {
          const id = String(directUser._id || directUser.id);
          const fullName = [directUser.firstName, directUser.lastName].filter(Boolean).join(' ');
          const secondary = [
            directUser.library?.cardNumber || directUser.libraryCardNumber,
            directUser.gradeLevel || directUser.grade,
            directUser.section,
            directUser.email || directUser.username,
          ]
            .filter(Boolean)
            .join(' ‚Ä¢ ');

          const entry = {
            id,
            primary: fullName || directUser.username || directUser.email || 'User',
            secondary,
            chip: directUser.role ? directUser.role.toUpperCase() : '',
            link:
              directUser.role === 'student'
                ? `/students/${id}`
                : `/users/${id}`,
            category: targetKey,
          };

          results[targetKey] = container.length
            ? [entry, ...container.slice(0, limit - 1)]
            : [entry];
        }
      }
    }

    const transactionMatches = relevantTransactions.filter((transaction) => {
      const summary = buildTransactionSummary(transaction, { bookMap, userMap });
      const identifiers = collectTransactionIdentifiers(transaction);
      const identifierHit = Array.from(identifiers).some((identifier) =>
        includesTerm(identifier, term),
      );

      if (identifierHit) {
        return true;
      }

      return (
        includesTerm(summary.title, term) ||
        includesTerm(summary.borrower, term) ||
        includesTerm(transaction.referenceNumber, term) ||
        includesTerm(transaction.transactionCode, term)
      );
    });

    if (transactionMatches.length) {
      results.transactions = limitItems(transactionMatches, limit).map((transaction) => {
        const summary = buildTransactionSummary(transaction, { bookMap, userMap });
        const id = String(transaction.id || transaction._id);
        const chip = summary.status ? summary.status.toUpperCase() : '';
        const identifiers = Array.from(collectTransactionIdentifiers(transaction));
        const matchedIdentifier = identifiers.find((identifier) =>
          includesTerm(identifier, term),
        );

        return {
          id,
          primary: summary.title || `Transaction ${id}`,
          secondary: [
            summary.borrower,
            summary.dueLabel,
            matchedIdentifier || transaction.referenceNumber,
          ]
            .filter(Boolean)
            .join(' ‚Ä¢ '),
          chip,
          link: canViewStaffData ? `/transactions/${id}` : '/student/dashboard',
          category: 'transactions',
          timestamp: summary.timestamp,
        };
      });
    }

    const total = Object.values(results).reduce(
      (acc, section) => acc + (Array.isArray(section) ? section.length : 0),
      0,
    );

    res.json({ query, results, total });
  } catch (error) {
    console.error('Global search error:', error);
    res.status(500).json({ message: 'Failed to run search' });
  }
});

module.exports = router;
```

## settings.js

| Field | Details |
| --- | --- |
| Program Name | settings.js |
| Description | API route handler for settings resources. |
| Called by | app.js |
| Table used | settings |
|  |  |
| Programmer | Nazel Asca√±o |
| Date created | 12/14/2025 |
| Revision Date | TBD |
| Revision / description of change | None |

```javascript
const express = require('express');
const multer = require('multer');
const path = require('path');
const fs = require('fs');
const { verifyToken, requireLibrarian, logAction, setAuditContext } = require('../middleware/customAuth');
const { invalidateSettingsCache } = require('../utils/settingsCache');
const {
    DEFAULT_CURRICULA,
    DEFAULT_GRADE_LEVELS,
    DEFAULT_GRADE_STRUCTURE,
    normalizeStringList,
    normalizeGradeStructure
} = require('../utils/userAttributes');
const router = express.Router();

const LIBRARY_CATEGORY = 'library';
const LEGACY_LIBRARY_CATEGORIES = [LIBRARY_CATEGORY, 'receipt'];
const SYSTEM_CATEGORY = 'system';
const NOTIFICATION_CATEGORY = 'notifications';
const USER_CATEGORY = 'user';
const DEFAULT_LIBRARY_TIMEZONE = process.env.LIBRARY_TIMEZONE || 'Asia/Manila';
const BRANDING_STORAGE_DIR = path.join(__dirname, '..', 'uploads', 'branding');
const ALLOWED_BRANDING_MIME_TYPES = {
    'image/jpeg': '.jpg',
    'image/png': '.png',
    'image/webp': '.webp',
    'image/gif': '.gif',
    'image/svg+xml': '.svg'
};
const BRANDING_FILE_FIELD = 'brandingAsset';
const MAX_BRANDING_SIZE_BYTES = 5 * 1024 * 1024; // 5 MB

const ensureDirectory = async(dirPath) => {
    try {
        await fs.promises.mkdir(dirPath, { recursive: true });
    } catch (error) {
        if (error.code !== 'EEXIST') {
            throw error;
        }
    }
};

const sanitizeBrandingSlot = (value) => {
    const normalized = String(value || '').trim().toLowerCase();
    if (normalized === 'background') {
        return 'background';
    }
    return 'logo';
};

const brandingStorage = multer.diskStorage({
    destination: (req, file, cb) => {
        ensureDirectory(BRANDING_STORAGE_DIR)
            .then(() => cb(null, BRANDING_STORAGE_DIR))
            .catch((error) => cb(error));
    },
    filename: (req, file, cb) => {
        const timestamp = Date.now();
        const randomSuffix = Math.round(Math.random() * 1e9);
        const extensionFromMime = ALLOWED_BRANDING_MIME_TYPES[file.mimetype];
        const extensionFromName = path.extname(file.originalname || '').toLowerCase();
        const allowedExtensions = new Set(Object.values(ALLOWED_BRANDING_MIME_TYPES));
        const resolvedExtension = extensionFromMime || (allowedExtensions.has(extensionFromName) ? extensionFromName : '.png');
        cb(null, `branding-${timestamp}-${randomSuffix}${resolvedExtension}`);
    }
});

const brandingFileFilter = (req, file, cb) => {
    if (ALLOWED_BRANDING_MIME_TYPES[file.mimetype]) {
        return cb(null, true);
    }
    return cb(new Error('Unsupported file type. Please upload a JPG, PNG, GIF, WEBP, or SVG image.'));
};

const brandingUpload = multer({
    storage: brandingStorage,
    fileFilter: brandingFileFilter,
    limits: {
        fileSize: MAX_BRANDING_SIZE_BYTES
    }
});

const BRANDING_UPLOAD_ERROR_LIMIT_MESSAGE = 'Image is too large. Maximum allowed size is 5 MB.';

const buildBrandingUrl = (filename = '') => {
    const safeName = path.basename(filename);
    return path.posix.join('/uploads/branding', safeName);
};

const toBoolean = (value, fallback = false) => {
    if (typeof value === 'boolean') {
        return value;
    }
    if (typeof value === 'string') {
        const normalized = value.trim().toLowerCase();
        if (['true', '1', 'yes'].includes(normalized)) {
            return true;
        }
        if (['false', '0', 'no'].includes(normalized)) {
            return false;
        }
    }
    if (typeof value === 'number') {
        return value !== 0;
    }
    return fallback;
};

const toNumber = (value, fallback = 0) => {
    const parsed = Number(value);
    return Number.isFinite(parsed) ? parsed : fallback;
};

const updateOrCreateSetting = async (dbAdapter, userId, {
    id,
    value,
    type,
    category = LIBRARY_CATEGORY,
    description
}) => {
    const existing = await dbAdapter.findOneInCollection('settings', { id });
    const timestamp = new Date();

    if (existing) {
        const updateData = {
            value,
            type: type || existing.type,
            category: category || existing.category || LIBRARY_CATEGORY,
            updatedAt: timestamp,
            updatedBy: userId
        };

        if (description !== undefined) {
            updateData.description = description;
        }

        await dbAdapter.updateInCollection('settings', { id }, updateData);
        return;
    }

    await dbAdapter.insertIntoCollection('settings', {
        id,
        value,
        type: type || typeof value,
        category,
        description: description || '',
        createdAt: timestamp,
        updatedAt: timestamp,
        createdBy: userId,
        updatedBy: userId
    });
};

const applySettingsUpdates = async (dbAdapter, userId, updates = []) => {
    for (const item of updates) {
        await updateOrCreateSetting(dbAdapter, userId, item);
    }
};

router.get('/', verifyToken, requireLibrarian, async(req, res) => {
    try {
        let settings = await req.dbAdapter.findInCollection('settings', {});

        settings.sort((a, b) => (a.category || '').localeCompare(b.category || ''));

        res.json(settings);
    } catch (error) {
        console.error('Get settings error:', error);
        res.status(500).json({ message: 'Failed to fetch settings' });
    }
});

router.get('/library', async(req, res) => {
    try {
        const [librarySettings, legacyReceiptSettings] = await Promise.all(
            LEGACY_LIBRARY_CATEGORIES.map((category) =>
                req.dbAdapter.findInCollection('settings', { category })
            )
        );

        const combinedSettings = [...legacyReceiptSettings, ...librarySettings];
        const index = combinedSettings.reduce((acc, setting) => {
            acc[setting.id] = setting.value;
            return acc;
        }, {});

        const response = {
            libraryName: index.LIBRARY_NAME || '',
            libraryAddress: index.LIBRARY_ADDRESS || '',
            libraryPhone: index.LIBRARY_PHONE || '',
            libraryEmail: index.LIBRARY_EMAIL || '',
            website: index.LIBRARY_WEBSITE || '',
            description: index.LIBRARY_DESCRIPTION || '',
            openingTime: index.LIBRARY_OPENING_TIME || '08:00',
            closingTime: index.LIBRARY_CLOSING_TIME || '17:00',
            operatingDays: Array.isArray(index.LIBRARY_OPERATING_DAYS) ? index.LIBRARY_OPERATING_DAYS : ['monday', 'tuesday', 'wednesday', 'thursday', 'friday'],
            timezone: index.LIBRARY_TIMEZONE || DEFAULT_LIBRARY_TIMEZONE,
            loginLogoUrl: index.LIBRARY_LOGIN_LOGO || '',
            loginMotto: index.LIBRARY_LOGIN_MOTTO || '',
            loginBackgroundUrl: index.LIBRARY_LOGIN_BACKGROUND || '',
        };

        res.json(response);
    } catch (error) {
        console.error('Get library settings error:', error);
        res.status(500).json({ message: 'Failed to fetch library settings' });
    }
});

router.get('/borrowing-rules', verifyToken, async(req, res) => {
    try {
        const settings = await req.dbAdapter.findInCollection('settings', { category: LIBRARY_CATEGORY });
        const index = settings.reduce((acc, setting) => {
            acc[setting.id] = setting.value;
            return acc;
        }, {});

        const response = {
            maxBooksPerTransaction: toNumber(index.MAX_BOOKS_PER_TRANSACTION, 10),
            maxBorrowDays: toNumber(index.MAX_BORROW_DAYS, 14),
            finePerDay: toNumber(index.FINE_PER_DAY, 5),
            gracePeriodDays: toNumber(index.GRACE_PERIOD_DAYS, 0),
            maxFineAmount: toNumber(index.MAX_FINE_AMOUNT, 0),
            reservationPeriodDays: toNumber(index.RESERVATION_PERIOD_DAYS, 3),
            enableFines: toBoolean(index.ENABLE_FINES, true),
            annualBorrowingEnabled: toBoolean(index.ANNUAL_BORROWING_ENABLED, true),
            overnightBorrowingEnabled: toBoolean(index.OVERNIGHT_BORROWING_ENABLED, false)
        };

        res.json(response);
    } catch (error) {
        console.error('Get borrowing-rules settings error:', error);
        res.status(500).json({ message: 'Failed to fetch borrowing-rules settings' });
    }
});

router.get('/notifications', verifyToken, requireLibrarian, async(req, res) => {
    try {
        const setting = await req.dbAdapter.findOneInCollection('settings', { id: 'NOTIFICATION_SETTINGS' });
        const defaults = {
            dueDateReminders: true,
            overdueNotifications: true,
            reservationNotifications: true,
            returnNotifications: true,
            reminderDaysBefore: 3,
            maxReminders: 3
        };

        const value = setting?.value || {};
        const response = {
            ...defaults,
            ...value
        };

        res.json(response);
    } catch (error) {
        console.error('Get notifications settings error:', error);
        res.status(500).json({ message: 'Failed to fetch notifications settings' });
    }
});

router.get('/user-attributes', verifyToken, async(req, res) => {
    try {
        const [curriculaSetting, gradeLevelsSetting, gradeStructureSetting] = await Promise.all([
            req.dbAdapter.findOneInCollection('settings', { id: 'USER_CURRICULA' }),
            req.dbAdapter.findOneInCollection('settings', { id: 'USER_GRADE_LEVELS' }),
            req.dbAdapter.findOneInCollection('settings', { id: 'USER_GRADE_STRUCTURE' })
        ]);

        const curriculumOptions = normalizeStringList(curriculaSetting?.value, DEFAULT_CURRICULA);
        const rawStructureSource = Array.isArray(gradeStructureSetting?.value)
            ? gradeStructureSetting.value
            : Array.isArray(gradeLevelsSetting?.value)
                ? gradeLevelsSetting.value
                : DEFAULT_GRADE_STRUCTURE;

        const gradeStructure = normalizeGradeStructure(rawStructureSource, DEFAULT_GRADE_STRUCTURE);
        const gradeLevelFallback = gradeStructure.map((entry) => entry.grade);
        const gradeLevels = normalizeStringList(
            Array.isArray(gradeLevelsSetting?.value) ? gradeLevelsSetting.value : gradeLevelFallback,
            gradeLevelFallback.length > 0 ? gradeLevelFallback : DEFAULT_GRADE_LEVELS
        );

        res.json({
            curriculum: curriculumOptions,
            gradeLevels,
            gradeStructure
        });
    } catch (error) {
        console.error('Get user attributes settings error:', error);
        res.status(500).json({ message: 'Failed to fetch user attributes' });
    }
});

router.get('/system', verifyToken, requireLibrarian, async(req, res) => {
    try {
        const settings = await req.dbAdapter.findInCollection('settings', {});
        const index = settings.reduce((acc, setting) => {
            acc[setting.id] = setting.value;
            return acc;
        }, {});

        const response = {
            maintenanceMode: toBoolean(index.MAINTENANCE_MODE, false),
            sessionTimeoutMinutes: toNumber(index.SESSION_TIMEOUT_MINUTES, 60),
            maxLoginAttempts: toNumber(index.MAX_LOGIN_ATTEMPTS, 5),
            passwordPolicy: {
                minLength: toNumber(index.PASSWORD_MIN_LENGTH, 8),
            },
            backupFrequency: index.BACKUP_FREQUENCY || 'daily',
            logRetentionDays: toNumber(index.LOG_RETENTION_DAYS, 90),
            auditLogging: toBoolean(index.AUDIT_LOGGING_ENABLED, true),
            schoolYearStart: index.SCHOOL_YEAR_START || '2024-08-01',
            schoolYearEnd: index.SCHOOL_YEAR_END || '2025-05-31'
        };

        res.json(response);
    } catch (error) {
        console.error('Get system settings error:', error);
        res.status(500).json({ message: 'Failed to fetch system settings' });
    }
});

router.put('/library', verifyToken, requireLibrarian, logAction('UPDATE', 'settings-library'), async(req, res) => {
    try {
        const {
            libraryName = '',
            libraryAddress = '',
            libraryPhone = '',
            libraryEmail = '',
            website = '',
            description = '',
            openingTime = '08:00',
            closingTime = '17:00',
            operatingDays = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday'],
            timezone = DEFAULT_LIBRARY_TIMEZONE,
            loginLogoUrl = '',
            loginMotto = '',
            loginBackgroundUrl = '',
        } = req.body || {};

        const updates = [
            { id: 'LIBRARY_NAME', value: libraryName, type: 'string', category: LIBRARY_CATEGORY },
            { id: 'LIBRARY_ADDRESS', value: libraryAddress, type: 'string', category: LIBRARY_CATEGORY },
            { id: 'LIBRARY_PHONE', value: libraryPhone, type: 'string', category: LIBRARY_CATEGORY },
            { id: 'LIBRARY_EMAIL', value: libraryEmail, type: 'string', category: LIBRARY_CATEGORY },
            { id: 'LIBRARY_WEBSITE', value: website, type: 'string', category: LIBRARY_CATEGORY },
            { id: 'LIBRARY_DESCRIPTION', value: description, type: 'string', category: LIBRARY_CATEGORY },
            { id: 'LIBRARY_OPENING_TIME', value: openingTime, type: 'string', category: LIBRARY_CATEGORY },
            { id: 'LIBRARY_CLOSING_TIME', value: closingTime, type: 'string', category: LIBRARY_CATEGORY },
            { id: 'LIBRARY_OPERATING_DAYS', value: Array.isArray(operatingDays) ? operatingDays : ['monday', 'tuesday', 'wednesday', 'thursday', 'friday'], type: 'array', category: LIBRARY_CATEGORY },
            { id: 'LIBRARY_TIMEZONE', value: timezone, type: 'string', category: LIBRARY_CATEGORY },
            { id: 'LIBRARY_LOGIN_LOGO', value: loginLogoUrl, type: 'string', category: LIBRARY_CATEGORY },
            { id: 'LIBRARY_LOGIN_MOTTO', value: loginMotto, type: 'string', category: LIBRARY_CATEGORY },
            { id: 'LIBRARY_LOGIN_BACKGROUND', value: loginBackgroundUrl, type: 'string', category: LIBRARY_CATEGORY },
        ];

        await applySettingsUpdates(req.dbAdapter, req.user.id, updates);
        invalidateSettingsCache();
        invalidateSettingsCache();

        setAuditContext(req, {
            success: true,
            status: 'Updated',
            description: 'Updated library settings'
        });

        res.json({ message: 'Library settings saved successfully' });
    } catch (error) {
        console.error('Update library settings error:', error);
        setAuditContext(req, {
            success: false,
            status: 'Error',
            description: `Library settings update failed: ${error.message}`
        });
        res.status(500).json({ message: 'Failed to save library settings' });
    }
});

const resolveBrandingUploadErrorMessage = (error) => {
    if (!error) {
        return 'Failed to upload branding image.';
    }
    if (error instanceof multer.MulterError) {
        if (error.code === 'LIMIT_FILE_SIZE') {
            return BRANDING_UPLOAD_ERROR_LIMIT_MESSAGE;
        }
        return error.message || 'Upload failed due to an unexpected upload error.';
    }
    return error.message || 'Failed to upload branding image.';
};

router.post('/library/branding/upload', verifyToken, requireLibrarian, logAction('UPLOAD', 'settings-library-branding'), (req, res) => {
    brandingUpload.single(BRANDING_FILE_FIELD)(req, res, (uploadError) => {
        if (uploadError) {
            const message = resolveBrandingUploadErrorMessage(uploadError);
            setAuditContext(req, {
                success: false,
                status: 'Error',
                description: `Branding upload failed: ${message}`
            });
            return res.status(400).json({ message });
        }

        const uploadedFile = req.file;

        if (!uploadedFile) {
            setAuditContext(req, {
                success: false,
                status: 'Error',
                description: 'Branding upload failed: no file provided'
            });
            return res.status(400).json({ message: `Please provide an image file using the "${BRANDING_FILE_FIELD}" field.` });
        }

        const resolvedSlot = sanitizeBrandingSlot(req.body?.slot);
        const relativeUrl = buildBrandingUrl(uploadedFile.filename);

        setAuditContext(req, {
            success: true,
            status: 'Uploaded',
            description: `Uploaded login branding asset for ${resolvedSlot}`
        });

        return res.json({
            message: 'Branding image uploaded successfully',
            url: relativeUrl,
            filename: uploadedFile.filename,
            slot: resolvedSlot
        });
    });
});

router.put('/borrowing-rules', verifyToken, requireLibrarian, logAction('UPDATE', 'settings-borrowing'), async(req, res) => {
    try {
        const {
            maxBooksPerTransaction,
            maxBorrowDays,
            finePerDay,
            gracePeriodDays,
            maxFineAmount,
            reservationPeriodDays,
            enableFines,
            annualBorrowingEnabled,
            overnightBorrowingEnabled
        } = req.body || {};

        const updates = [
            { id: 'MAX_BOOKS_PER_TRANSACTION', value: toNumber(maxBooksPerTransaction, 0), type: 'number' },
            { id: 'MAX_BORROW_DAYS', value: toNumber(maxBorrowDays, 0), type: 'number' },
            { id: 'FINE_PER_DAY', value: toNumber(finePerDay, 0), type: 'number' },
            { id: 'GRACE_PERIOD_DAYS', value: toNumber(gracePeriodDays, 0), type: 'number' },
            { id: 'MAX_FINE_AMOUNT', value: toNumber(maxFineAmount, 0), type: 'number' },
            { id: 'RESERVATION_PERIOD_DAYS', value: toNumber(reservationPeriodDays, 0), type: 'number' },
            { id: 'ENABLE_FINES', value: toBoolean(enableFines, true), type: 'boolean' },
            { id: 'ANNUAL_BORROWING_ENABLED', value: toBoolean(annualBorrowingEnabled, true), type: 'boolean' },
            { id: 'OVERNIGHT_BORROWING_ENABLED', value: toBoolean(overnightBorrowingEnabled, false), type: 'boolean' }
        ];

        await applySettingsUpdates(req.dbAdapter, req.user.id, updates);

        setAuditContext(req, {
            success: true,
            status: 'Updated',
            description: 'Updated borrowing rules settings'
        });

        res.json({ message: 'Borrowing rules saved successfully' });
    } catch (error) {
        console.error('Update borrowing rules error:', error);
        setAuditContext(req, {
            success: false,
            status: 'Error',
            description: `Borrowing rules update failed: ${error.message}`
        });
        res.status(500).json({ message: 'Failed to save borrowing rules' });
    }
});

router.put('/notifications', verifyToken, requireLibrarian, logAction('UPDATE', 'settings-notifications'), async(req, res) => {
    try {
        const {
            dueDateReminders = true,
            overdueNotifications = true,
            reservationNotifications = true,
            returnNotifications = true,
            reminderDaysBefore = 3,
            maxReminders = 3
        } = req.body || {};

        const normalized = {
            dueDateReminders: toBoolean(dueDateReminders, true),
            overdueNotifications: toBoolean(overdueNotifications, true),
            reservationNotifications: toBoolean(reservationNotifications, true),
            returnNotifications: toBoolean(returnNotifications, true),
            reminderDaysBefore: toNumber(reminderDaysBefore, 0),
            maxReminders: toNumber(maxReminders, 0)
        };

        await updateOrCreateSetting(req.dbAdapter, req.user.id, {
            id: 'NOTIFICATION_SETTINGS',
            value: normalized,
            type: 'object',
            category: NOTIFICATION_CATEGORY
        });
        invalidateSettingsCache();

        setAuditContext(req, {
            success: true,
            status: 'Updated',
            description: 'Updated notification settings'
        });

        res.json({ message: 'Notification settings saved successfully' });
    } catch (error) {
        console.error('Update notification settings error:', error);
        setAuditContext(req, {
            success: false,
            status: 'Error',
            description: `Notification settings update failed: ${error.message}`
        });
        res.status(500).json({ message: 'Failed to save notification settings' });
    }
});

router.put('/user-attributes', verifyToken, requireLibrarian, logAction('UPDATE', 'settings-user-attributes'), async(req, res) => {
    try {
        const {
            curriculum = [],
            gradeLevels = [],
            gradeStructure = []
        } = req.body || {};

        const normalizedCurriculum = normalizeStringList(curriculum, DEFAULT_CURRICULA);
        const normalizedGradeStructure = normalizeGradeStructure(
            Array.isArray(gradeStructure) && gradeStructure.length > 0 ? gradeStructure : gradeLevels,
            DEFAULT_GRADE_STRUCTURE,
            { useFallbackWhenEmpty: false }
        );
        const structureGradeNames = normalizedGradeStructure.map((entry) => entry.grade);
        const normalizedGradeLevels = normalizeStringList(
            gradeLevels && gradeLevels.length > 0 ? gradeLevels : structureGradeNames,
            structureGradeNames.length > 0 ? structureGradeNames : DEFAULT_GRADE_LEVELS
        );

        await applySettingsUpdates(req.dbAdapter, req.user.id, [
            {
                id: 'USER_CURRICULA',
                value: normalizedCurriculum,
                type: 'array',
                category: USER_CATEGORY,
                description: 'Configured curriculum options for users and students'
            },
            {
                id: 'USER_GRADE_LEVELS',
                value: normalizedGradeLevels,
                type: 'array',
                category: USER_CATEGORY,
                description: 'Configured grade level options for users and students'
            },
            {
                id: 'USER_GRADE_STRUCTURE',
                value: normalizedGradeStructure,
                type: 'array',
                category: USER_CATEGORY,
                description: 'Configured grade levels with section options'
            }
        ]);
        invalidateSettingsCache();

        setAuditContext(req, {
            success: true,
            status: 'Updated',
            description: 'Updated user attribute settings'
        });

        res.json({ message: 'User attributes saved successfully' });
    } catch (error) {
        console.error('Update user attributes settings error:', error);
        setAuditContext(req, {
            success: false,
            status: 'Error',
            description: `User attributes update failed: ${error.message}`
        });
        res.status(500).json({ message: 'Failed to save user attributes' });
    }
});

router.put('/system', verifyToken, requireLibrarian, logAction('UPDATE', 'settings-system'), async(req, res) => {
    try {
        const {
            maintenanceMode,
            sessionTimeoutMinutes,
            maxLoginAttempts,
            passwordPolicy = {},
            backupFrequency,
            logRetentionDays,
            auditLogging
        } = req.body || {};

        const updates = [
            { id: 'MAINTENANCE_MODE', value: toBoolean(maintenanceMode, false), type: 'boolean', category: SYSTEM_CATEGORY },
            { id: 'SESSION_TIMEOUT_MINUTES', value: toNumber(sessionTimeoutMinutes, 60), type: 'number', category: SYSTEM_CATEGORY },
            { id: 'MAX_LOGIN_ATTEMPTS', value: toNumber(maxLoginAttempts, 5), type: 'number', category: SYSTEM_CATEGORY },
            { id: 'BACKUP_FREQUENCY', value: backupFrequency || 'daily', type: 'string', category: SYSTEM_CATEGORY },
            { id: 'LOG_RETENTION_DAYS', value: toNumber(logRetentionDays, 90), type: 'number', category: SYSTEM_CATEGORY },
            { id: 'AUDIT_LOGGING_ENABLED', value: toBoolean(auditLogging, true), type: 'boolean', category: SYSTEM_CATEGORY }
        ];

        const normalizedPolicy = {
            minLength: toNumber(passwordPolicy.minLength, 8),
        };

        const policyUpdates = [
            { id: 'PASSWORD_MIN_LENGTH', value: normalizedPolicy.minLength, type: 'number', category: SYSTEM_CATEGORY }
        ];

        await applySettingsUpdates(req.dbAdapter, req.user.id, [...updates, ...policyUpdates]);
        invalidateSettingsCache();

        setAuditContext(req, {
            success: true,
            status: 'Updated',
            description: 'Updated system settings'
        });

        res.json({ message: 'System settings saved successfully' });
    } catch (error) {
        console.error('Update system settings error:', error);
        setAuditContext(req, {
            success: false,
            status: 'Error',
            description: `System settings update failed: ${error.message}`
        });
        res.status(500).json({ message: 'Failed to save system settings' });
    }
});

router.get('/category/:category', verifyToken, requireLibrarian, async(req, res) => {
    try {
        const category = req.params.category;

        const settings = await req.dbAdapter.findInCollection('settings', { category });

        res.json(settings);
    } catch (error) {
        console.error('Get settings by category error:', error);
        res.status(500).json({ message: 'Failed to fetch settings' });
    }
});

router.get('/:key', verifyToken, requireLibrarian, async(req, res) => {
    try {
        const setting = await req.dbAdapter.findOneInCollection('settings', { id: req.params.key });

        if (!setting) {
            return res.status(404).json({ message: 'Setting not found' });
        }

        res.json(setting);
    } catch (error) {
        console.error('Get setting error:', error);
        res.status(500).json({ message: 'Failed to fetch setting' });
    }
});

router.put('/:key', verifyToken, requireLibrarian, logAction('UPDATE', 'setting'), async(req, res) => {
    try {
        const { value, description } = req.body;
        const settingKey = req.params.key;

        setAuditContext(req, {
            entityId: settingKey,
            metadata: {
                updateRequest: {
                    key: settingKey,
                    hasValue: value !== undefined,
                    hasDescription: description !== undefined
                }
            }
        });

        const setting = await req.dbAdapter.findOneInCollection('settings', { id: settingKey });
        if (!setting) {
            setAuditContext(req, {
                success: false,
                status: 'SettingNotFound',
                description: `Setting update failed: ${settingKey} not found`
            });
            return res.status(404).json({ message: 'Setting not found' });
        }

        const updateData = {
            updatedAt: new Date(),
            updatedBy: req.user.id
        };

        if (value !== undefined) updateData.value = value;
        if (description !== undefined) updateData.description = description;

        await req.dbAdapter.updateInCollection('settings', { id: settingKey }, updateData);
        invalidateSettingsCache();

        setAuditContext(req, {
            success: true,
            status: 'Updated',
            entityId: settingKey,
            resourceId: settingKey,
            description: `Updated setting ${settingKey}`,
            metadata: {
                actorId: req.user.id
            },
            details: {
                updatedFields: Object.keys(updateData).filter(key => key !== 'updatedAt' && key !== 'updatedBy')
            }
        });

        res.json({ message: 'Setting updated successfully' });
    } catch (error) {
        console.error('Update setting error:', error);
        setAuditContext(req, {
            success: false,
            status: 'Error',
            description: `Setting update failed: ${error.message}`,
            details: {
                error: error.message
            }
        });
        res.status(500).json({ message: 'Failed to update setting' });
    }
});

router.post('/', verifyToken, requireLibrarian, logAction('CREATE', 'setting'), async(req, res) => {
    try {
        const { key, value, type, category, description } = req.body;

        setAuditContext(req, {
            entityId: key || null,
            metadata: {
                createRequest: {
                    key: key || null,
                    hasValue: value !== undefined,
                    type: type || null,
                    category: category || null
                }
            }
        });

        if (!key || value === undefined || !type || !category) {
            setAuditContext(req, {
                success: false,
                status: 'ValidationError',
                description: 'Setting creation failed: missing required fields'
            });
            return res.status(400).json({ message: 'Key, value, type, and category are required' });
        }

        const existingSetting = await req.dbAdapter.findOneInCollection('settings', { id: key });
        if (existingSetting) {
            setAuditContext(req, {
                success: false,
                status: 'Conflict',
                description: `Setting creation failed: ${key} already exists`
            });
            return res.status(400).json({ message: 'Setting already exists' });
        }

        const settingData = {
            id: key,
            value,
            type,
            category,
            description: description || '',
            createdAt: new Date(),
            updatedAt: new Date(),
            createdBy: req.user.id
        };

        await req.dbAdapter.insertIntoCollection('settings', settingData);
        invalidateSettingsCache();

        setAuditContext(req, {
            success: true,
            status: 'Created',
            entityId: key,
            resourceId: key,
            description: `Created setting ${key}`,
            metadata: {
                actorId: req.user.id
            }
        });

        res.status(201).json({ message: 'Setting created successfully' });
    } catch (error) {
        console.error('Create setting error:', error);
        setAuditContext(req, {
            success: false,
            status: 'Error',
            description: `Setting creation failed: ${error.message}`,
            details: {
                error: error.message
            }
        });
        res.status(500).json({ message: 'Failed to create setting' });
    }
});

router.delete('/:key', verifyToken, requireLibrarian, logAction('DELETE', 'setting'), async(req, res) => {
    try {
        const settingKey = req.params.key;

        setAuditContext(req, {
            entityId: settingKey
        });

        const setting = await req.dbAdapter.findOneInCollection('settings', { id: settingKey });
        if (!setting) {
            setAuditContext(req, {
                success: false,
                status: 'SettingNotFound',
                description: `Setting deletion failed: ${settingKey} not found`
            });
            return res.status(404).json({ message: 'Setting not found' });
        }

        await req.dbAdapter.deleteFromCollection('settings', { id: settingKey });
        invalidateSettingsCache();

        setAuditContext(req, {
            success: true,
            status: 'Deleted',
            entityId: settingKey,
            resourceId: settingKey,
            description: `Deleted setting ${settingKey}`,
            metadata: {
                actorId: req.user.id
            }
        });

        res.json({ message: 'Setting deleted successfully' });
    } catch (error) {
        console.error('Delete setting error:', error);
        setAuditContext(req, {
            success: false,
            status: 'Error',
            description: `Setting deletion failed: ${error.message}`,
            details: {
                error: error.message
            }
        });
        res.status(500).json({ message: 'Failed to delete setting' });
    }
});

router.post('/reset/defaults', verifyToken, requireLibrarian, logAction('RESET_DEFAULTS', 'setting'), async(req, res) => {
    try {
        setAuditContext(req, {
            metadata: {
                resetDefaultsRequest: {
                    count: 8
                }
            }
        });
        const defaultSettings = [
            { id: 'MAX_BORROW_DAYS', value: 14, type: 'number', category: 'library', description: 'Maximum number of days for regular book borrowing' },
            { id: 'FINE_PER_DAY', value: 5, type: 'number', category: 'library', description: 'Fine amount per day for overdue books' },
            { id: 'SCHOOL_YEAR_START', value: '2024-08-01', type: 'string', category: 'library', description: 'School year start date' },
            { id: 'SCHOOL_YEAR_END', value: '2025-05-31', type: 'string', category: 'library', description: 'School year end date' },
            { id: 'LIBRARY_NAME', value: 'ONHS Library', type: 'string', category: LIBRARY_CATEGORY, description: 'Library name for receipts' },
            { id: 'LIBRARY_ADDRESS', value: 'School Address', type: 'string', category: LIBRARY_CATEGORY, description: 'Library address for receipts' },
            { id: 'ENABLE_FINES', value: true, type: 'boolean', category: 'library', description: 'Enable or disable fine system' },
            { id: 'MAX_BOOKS_PER_TRANSACTION', value: 10, type: 'number', category: 'library', description: 'Maximum number of books per transaction' }
        ];

        for (const setting of defaultSettings) {
            const existing = await req.dbAdapter.findOneInCollection('settings', { id: setting.id });

            const settingData = {
                ...setting,
                createdAt: existing ? existing.createdAt : new Date(),
                updatedAt: new Date(),
                createdBy: existing ? existing.createdBy : req.user.id
            };

            if (existing) {
                await req.dbAdapter.updateInCollection('settings', { id: setting.id }, settingData);
            } else {
                await req.dbAdapter.insertIntoCollection('settings', settingData);
            }
        }

        invalidateSettingsCache();

        setAuditContext(req, {
            success: true,
            status: 'Completed',
            description: 'Reset settings to default values',
            metadata: {
                actorId: req.user.id,
                totalApplied: defaultSettings.length
            }
        });

        res.json({ message: 'Settings reset to defaults successfully' });
    } catch (error) {
        console.error('Reset defaults error:', error);
        setAuditContext(req, {
            success: false,
            status: 'Error',
            description: `Reset settings failed: ${error.message}`,
            details: {
                error: error.message
            }
        });
        res.status(500).json({ message: 'Failed to reset settings' });
    }
});

router.post('/backup', verifyToken, requireLibrarian, logAction('BACKUP', 'system'), async (req, res) => {
  try {
    const fs = require('fs').promises;
    const path = require('path');

    const backupDir = path.join(__dirname, '../backups');
    await fs.mkdir(backupDir, { recursive: true });

    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const backupPath = path.join(backupDir, `backup-${timestamp}`);
    await fs.mkdir(backupPath, { recursive: true });

    const collections = ['users', 'books', 'transactions', 'settings', 'audit', 'notifications'];

    for (const collection of collections) {
      const data = await req.dbAdapter.findInCollection(collection, {});
      const filePath = path.join(backupPath, `${collection}.json`);
      await fs.writeFile(filePath, JSON.stringify(data, null, 2));
    }

    setAuditContext(req, {
      success: true,
      description: `Backup created at ${backupPath}`,
      metadata: { backupPath, collections }
    });

    res.json({ message: 'Backup created successfully', path: backupPath });
  } catch (error) {
    console.error('Backup error:', error);
    setAuditContext(req, {
      success: false,
      description: `Backup failed: ${error.message}`,
      details: { error: error.message }
    });
    res.status(500).json({ message: 'Backup failed' });
  }
});

router.post('/cleanup-logs', verifyToken, requireLibrarian, logAction('CLEANUP_LOGS', 'system'), async (req, res) => {
  try {
    const systemSettings = req.systemSettings;
    const retentionDays = systemSettings?.logRetentionDays || 90;
    const cutoff = new Date(Date.now() - retentionDays * 24 * 60 * 60 * 1000);

    const deletedCount = await req.dbAdapter.deleteFromCollection('audit', { timestamp: { $lt: cutoff } });

    setAuditContext(req, {
      success: true,
      description: `Cleaned up audit logs older than ${retentionDays} days`,
      metadata: { retentionDays, deletedCount, cutoff }
    });

    res.json({ message: `Cleaned up ${deletedCount || 'some'} old audit logs` });
  } catch (error) {
    console.error('Cleanup logs error:', error);
    setAuditContext(req, {
      success: false,
      description: `Log cleanup failed: ${error.message}`,
      details: { error: error.message }
    });
    res.status(500).json({ message: 'Log cleanup failed' });
  }
});

module.exports = router;
```

## students.js

| Field | Details |
| --- | --- |
| Program Name | students.js |
| Description | API route handler for students resources. |
| Called by | app.js |
| Table used | None |
|  |  |
| Programmer | Nazel Asca√±o |
| Date created | 12/14/2025 |
| Revision Date | TBD |
| Revision / description of change | None |

```javascript
const express = require('express');
const bcrypt = require('bcrypt');
const { verifyToken, requireRole, requireAdmin, requireLibrarian, requireStaff, logAction, setAuditContext } = require('../middleware/customAuth');
const { notifyRoles, formatUserName } = require('../utils/notificationChannels');
const router = express.Router();

const computeSchoolYearFromDate = (dateInput) => {
    const source = dateInput ? new Date(dateInput) : new Date();
    const baseYear = Number.isFinite(source.getFullYear()) ? source.getFullYear() : new Date().getFullYear();
    return `${baseYear}-${baseYear + 1}`;
};

const resolveSchoolYear = (payload = {}) => {
    const provided = (payload.schoolYear || payload.academicYear || '').toString().trim();
    if (provided) return provided;

    const timestamp = payload.createdAt || payload.updatedAt;
    return computeSchoolYearFromDate(timestamp);
};

const resolveLibraryCardNumber = (student = {}) => {
    return student.libraryCardNumber || student.library?.cardNumber || '';
};

const determineCrossRoleRecipients = (role = '') => {
    const normalized = String(role || '').toLowerCase();
    if (normalized === 'admin') {
        return ['librarian'];
    }
    if (normalized === 'librarian') {
        return ['admin'];
    }
    return ['admin', 'librarian'];
};

const formatStudentName = (student = {}) => {
    const parts = [student.firstName, student.middleName, student.lastName]
        .filter(Boolean)
        .join(' ')
        .trim();
    if (parts) {
        return parts;
    }
    return student.username || student.lrn || student.libraryCardNumber || 'Student';
};

const buildGradeSectionLabel = (student = {}) => {
    const grade = student.grade || student.gradeLevel || '';
    const section = student.section || '';
    const segments = [grade, section].filter(Boolean);
    return segments.length ? segments.join(' - ') : null;
};

const buildStudentMeta = (student = {}) => ({
    studentId: student._id || student.id || student.userId || null,
    grade: student.grade || student.gradeLevel || null,
    section: student.section || null
});

const generateLibraryCardNumber = async(dbAdapter) => {
    const currentYear = new Date().getFullYear();
    const allUsers = await dbAdapter.findInCollection('users', { role: 'student' });

    const yearPrefix = currentYear.toString().slice(-2); // Last 2 digits of year (e.g., "25" for 2025)
    const existingCards = allUsers
        .filter(u => u.libraryCardNumber && u.libraryCardNumber.startsWith(`LIB-${yearPrefix}`))
        .map(u => {
            const match = u.libraryCardNumber.match(/LIB-\d{2}-(\d{4})/);
            return match ? parseInt(match[1]) : 0;
        });

    const nextNumber = existingCards.length > 0 ? Math.max(...existingCards) + 1 : 1;
    return `LIB-${yearPrefix}-${String(nextNumber).padStart(4, '0')}`;
};

router.get('/next-library-card', verifyToken, requireStaff, async(req, res) => {
    try {
        const nextCardNumber = await generateLibraryCardNumber(req.dbAdapter);
        res.json({ nextCardNumber });
    } catch (error) {
        console.error('Error generating next library card number:', error);
        res.status(500).json({ message: 'Failed to generate next library card number', error: error.message });
    }
});

router.get('/', verifyToken, requireStaff, async(req, res) => {
    try {
        const {
            page = 1,
            limit = 20,
            grade,
            section,
            curriculum,
            search,
            isActive,
            schoolYear
        } = req.query;

        const baseFilters = { role: 'student' };
        if (curriculum) baseFilters.curriculum = curriculum;
        if (isActive !== undefined) baseFilters.isActive = isActive === 'true';

        const students = await req.dbAdapter.getUsers(baseFilters);

        const hydratedStudents = await Promise.all(students.map(async(student) => {
            if (!student || student.schoolYear || student.academicYear) {
                return student;
            }

            const computedYear = resolveSchoolYear(student);
            try {
                await req.dbAdapter.updateUser(student._id, {
                    schoolYear: computedYear,
                    academicYear: computedYear
                });
                return {
                    ...student,
                    schoolYear: computedYear,
                    academicYear: computedYear
                };
            } catch (error) {
                console.warn(`Failed to backfill school year for student ${student._id}:`, error.message);
                return student;
            }
        }));

        const enhancedStudents = hydratedStudents.map(student => ({
            ...student,
            grade: student.grade || student.gradeLevel || 'N/A',
            section: student.section || 'N/A',
            dues: student.borrowingStats?.totalFines || 0,
                libraryCardNumber: resolveLibraryCardNumber(student) || 'N/A'
        }));

        const searchTerm = typeof search === 'string' ? search.toLowerCase() : '';
        let filteredStudents = enhancedStudents;

        if (grade) {
            const gradeLower = grade.toString().toLowerCase();
            filteredStudents = filteredStudents.filter(student =>
                (student.grade || '').toString().toLowerCase() === gradeLower ||
                (student.gradeLevel || '').toString().toLowerCase() === gradeLower
            );
        }

        if (section) {
            const sectionLower = section.toString().toLowerCase();
            filteredStudents = filteredStudents.filter(student =>
                (student.section || '').toString().toLowerCase() === sectionLower
            );
        }

        if (schoolYear) {
            const yearLower = schoolYear.toString().toLowerCase();
            filteredStudents = filteredStudents.filter(student =>
                (student.schoolYear || student.academicYear || '')
                    .toString()
                    .toLowerCase() === yearLower
            );
        }

        if (searchTerm) {
            filteredStudents = filteredStudents.filter(student => {
                const valuesToMatch = [
                    student.firstName,
                    student.lastName,
                    student.middleName,
                    student.email,
                    student.username,
                    student.libraryCardNumber,
                    student.lrn,
                    student.library?.cardNumber
                ];
                return valuesToMatch.some(value =>
                    value && value.toString().toLowerCase().includes(searchTerm)
                );
            });
        }

        const total = filteredStudents.length;
        const normalizedPage = Math.max(parseInt(page, 10) || 1, 1);
        const limitString = typeof limit === 'string' ? limit.toLowerCase() : limit;
        const wantsAll = limitString === 'all' || parseInt(limit, 10) === -1;
        const resolvedLimit = wantsAll ? total : Math.max(parseInt(limit, 10) || 20, 1);
        const offset = wantsAll ? 0 : (normalizedPage - 1) * resolvedLimit;
        const paginatedStudents = wantsAll ? filteredStudents : filteredStudents.slice(offset, offset + resolvedLimit);
        const totalPages = wantsAll ? (total > 0 ? 1 : 0) : Math.ceil(total / resolvedLimit);

        res.json({
            students: paginatedStudents,
            total,
            page: normalizedPage,
            totalPages,
            pagination: {
                page: normalizedPage,
                limit: resolvedLimit,
                total,
                pages: totalPages,
                mode: wantsAll ? 'all' : 'paged'
            }
        });
    } catch (error) {
        console.error('Failed to fetch students:', error);
        res.status(500).json({ message: 'Failed to fetch students', error: error.message });
    }
});

router.get('/school-years', verifyToken, requireStaff, async(req, res) => {
    try {
        const students = await req.dbAdapter.getUsers({ role: 'student' });
        const uniqueYears = Array.from(new Set(
            (students || []).map((student) => {
                const resolvedYear = student?.schoolYear || student?.academicYear || resolveSchoolYear(student);
                return (resolvedYear || '').toString().trim();
            }).filter(Boolean)
        )).sort((a, b) => a.localeCompare(b));

        res.json({ schoolYears: uniqueYears });
    } catch (error) {
        console.error('Failed to fetch school years:', error);
        res.status(500).json({ message: 'Failed to fetch school years', error: error.message });
    }
});

router.get('/:id', verifyToken, requireStaff, async(req, res) => {
    try {
        const student = await req.dbAdapter.findUserById(req.params.id);

        if (!student) {
            return res.status(404).json({ message: 'Student not found' });
        }

        if (student.role !== 'student') {
            return res.status(400).json({ message: 'User is not a student' });
        }

        res.json({ student });
    } catch (error) {
        console.error('Get student error:', error);
        res.status(500).json({ message: 'Failed to fetch student' });
    }
});

router.post('/', verifyToken, requireLibrarian, logAction('CREATE', 'student'), async(req, res) => {
    try {

        const libraryCardNumber = await generateLibraryCardNumber(req.dbAdapter);
        const schoolYear = resolveSchoolYear(req.body);

        const studentData = {

            libraryCardNumber: libraryCardNumber,

                username: req.body.lrn || req.body.username,

            firstName: req.body.firstName,
            lastName: req.body.lastName,
            middleName: req.body.middleName,
            email: req.body.email,
            phoneNumber: req.body.phoneNumber,

            lrn: req.body.lrn, // Learner Reference Number
            grade: req.body.grade,
            section: req.body.section,
            curriculum: req.body.curriculum,
            schoolYear: schoolYear,
            academicYear: schoolYear,

            barangay: req.body.barangay,
            municipality: req.body.municipality,
            province: req.body.province,
            fullAddress: req.body.fullAddress,

            parentGuardianName: req.body.parentGuardianName,
            parentOccupation: req.body.parentOccupation,
            parentAddress: req.body.parentAddress,
            parentPhone: req.body.parentPhone,
            parentEmail: req.body.parentEmail,

            role: 'student',
            isActive: true,
            borrowingStats: {
                totalBorrowed: 0,
                currentlyBorrowed: 0,
                totalFines: 0,
                totalReturned: 0
            },
            createdBy: req.user.uid
        };

        setAuditContext(req, {
            metadata: {
                createRequest: {
                    libraryCardNumber: studentData.libraryCardNumber || null,
                    lrn: studentData.lrn || null,
                    grade: studentData.grade || null,
                    section: studentData.section || null,
                    schoolYear: studentData.schoolYear || null
                }
            },
            details: {
                profile: {
                    firstName: studentData.firstName,
                    lastName: studentData.lastName,
                    email: studentData.email,
                    curriculum: studentData.curriculum
                }
            }
        });

        if (!studentData.firstName || !studentData.lastName || !studentData.lrn) {
            setAuditContext(req, {
                success: false,
                status: 'ValidationError',
                description: 'Create student failed: missing required fields',
            });
            return res.status(400).json({
                message: 'Missing required fields: firstName, lastName, lrn'
            });
        }

        const usernameToUse = studentData.lrn || studentData.username;
        if (!usernameToUse) {
            setAuditContext(req, {
                success: false,
                status: 'ValidationError',
                description: 'Create student failed: username (lrn) is required'
            });
            return res.status(400).json({ message: 'LRN (used as username) is required' });
        }

        const existingUsers = await req.dbAdapter.getUsers({ username: usernameToUse });
        if (existingUsers.length > 0) {
            setAuditContext(req, {
                success: false,
                status: 'Conflict',
                description: `Create student failed: username ${usernameToUse} already exists`,
                details: { username: usernameToUse },
            });
            return res.status(400).json({ message: 'Username already exists' });
        }

    const firstInitial = (studentData.firstName || '').charAt(0) || '';
    const surname = (studentData.lastName || '').toString().replace(/\s+/g, '');
    const rawPassword = surname ? `${firstInitial}${surname}` : `${firstInitial}${usernameToUse}`;
        const hashedPassword = await bcrypt.hash(rawPassword.toLowerCase(), 10);
        studentData.password = hashedPassword;

        studentData.username = usernameToUse;

        const student = await req.dbAdapter.createUser(studentData);

        const crossRoleRecipients = determineCrossRoleRecipients(req.user.role);
        const gradeSectionLabel = buildGradeSectionLabel(student);
        const studentDescriptor = gradeSectionLabel
            ? `${formatStudentName(student)} (${gradeSectionLabel})`
            : formatStudentName(student);
        if (crossRoleRecipients.length > 0) {
            await notifyRoles(req, crossRoleRecipients, {
                title: 'Student profile created',
                message: `${formatUserName(req.user)} added ${studentDescriptor}.`,
                type: 'student-created',
                meta: {
                    ...buildStudentMeta(student),
                    createdBy: req.user.id
                }
            });
        }

        setAuditContext(req, {
            entityId: student._id,
            resourceId: student._id,
            description: `Created student ${student.firstName} ${student.lastName}`,
            details: {
                libraryCardNumber: resolveLibraryCardNumber(student),
                grade: student.grade,
                section: student.section,
            },
            metadata: {
                actorId: req.user.id,
                libraryCardNumber: resolveLibraryCardNumber(student)
            },
            success: true,
            status: 'Created'
        });

        res.status(201).json({
            message: 'Student created successfully',
            student
        });
    } catch (error) {
        console.error('Create student error:', error);
        setAuditContext(req, {
            success: false,
            status: 'Failed',
            description: 'Failed to create student',
            details: { error: error.message },
        });
        res.status(500).json({
            message: 'Failed to create student',
            error: error.message
        });
    }
});

router.put('/:id', verifyToken, requireLibrarian, logAction('UPDATE', 'student'), async(req, res) => {
    try {
        const updates = {
            ...req.body,
            updatedAt: new Date(),
            updatedBy: req.user.uid
        };

        setAuditContext(req, {
            entityId: req.params.id,
            metadata: {
                updateRequest: {
                    studentRecordId: req.params.id,
                    fields: Object.keys(req.body || {})
                }
            }
        });

        const student = await req.dbAdapter.updateUser(req.params.id, updates);

        if (!student) {
            setAuditContext(req, {
                success: false,
                status: 'StudentNotFound',
                description: `Update student failed: ${req.params.id} not found`
            });
            return res.status(404).json({ message: 'Student not found' });
        }

        setAuditContext(req, {
            entityId: req.params.id,
            description: `Updated student ${student.firstName} ${student.lastName}`,
            details: {
                updatedFields: Object.keys(req.body || {}),
            },
            metadata: {
                actorId: req.user.id
            },
            success: true,
            status: 'Updated'
        });

        const updatedFields = Object.keys(req.body || {});
        await notifyRoles(req, ['admin', 'librarian'], {
            title: 'Student profile updated',
            message: `${formatUserName(req.user)} updated ${formatStudentName(student)}'s profile.`,
            type: 'student-updated',
            meta: {
                ...buildStudentMeta(student),
                updatedFields,
                actorId: req.user.id
            }
        });

        res.json({
            message: 'Student updated successfully',
            student
        });
    } catch (error) {
        console.error('Update student error:', error);
        setAuditContext(req, {
            success: false,
            status: 'Failed',
            description: 'Failed to update student',
            details: { error: error.message },
        });
        res.status(500).json({
            message: 'Failed to update student',
            error: error.message
        });
    }
});

router.delete('/:id', verifyToken, requireLibrarian, logAction('DELETE', 'student'), async(req, res) => {
    try {
        setAuditContext(req, {
            entityId: req.params.id
        });

        const student = await req.dbAdapter.findUserById(req.params.id);

        if (!student) {
            setAuditContext(req, {
                success: false,
                status: 'StudentNotFound',
                description: `Delete student failed: ${req.params.id} not found`
            });
            return res.status(404).json({ message: 'Student not found' });
        }

        if (student.role !== 'student') {
            setAuditContext(req, {
                success: false,
                status: 'ValidationError',
                description: 'Delete student failed: user is not a student'
            });
            return res.status(400).json({ message: 'User is not a student' });
        }

        await req.dbAdapter.deleteUser(req.params.id);

        setAuditContext(req, {
            entityId: req.params.id,
            description: `Deleted student ${student.firstName} ${student.lastName}`,
            details: {
                libraryCardNumber: resolveLibraryCardNumber(student),
            },
            metadata: {
                actorId: req.user.id
            },
            success: true,
            status: 'Deleted'
        });

        res.json({ message: 'Student deleted successfully' });
    } catch (error) {
        console.error('Delete student error:', error);
        setAuditContext(req, {
            success: false,
            status: 'Failed',
            description: 'Failed to delete student',
            details: { error: error.message },
        });
        res.status(500).json({
            message: 'Failed to delete student',
            error: error.message
        });
    }
});

router.post('/bulk-import', verifyToken, requireLibrarian, logAction('BULK_IMPORT', 'students'), async(req, res) => {
    try {
        const { students } = req.body;

        if (!Array.isArray(students) || students.length === 0) {
            setAuditContext(req, {
                success: false,
                status: 'ValidationError',
                description: 'Student bulk import failed: students array is required'
            });
            return res.status(400).json({ message: 'Students array is required' });
        }

        const resolveRowIndex = (value, idx) => {
            if (typeof value === 'number' && Number.isFinite(value)) {
                return value;
            }
            if (typeof value === 'string' && value.trim() !== '') {
                const parsed = Number(value);
                if (Number.isFinite(parsed)) {
                    return parsed;
                }
            }
            return idx + 1;
        };

        const missingLrnRows = students
            .map((s, idx) => ({
                idx,
                libraryCardNumber: s?.libraryCardNumber || null,
                lrn: s?.lrn,
                rowIndex: resolveRowIndex(s?.rowIndex, idx)
            }))
            .filter(r => !r.lrn || String(r.lrn).trim() === '');

        if (missingLrnRows.length > 0) {
            setAuditContext(req, {
                success: false,
                status: 'ValidationError',
                description: 'Student bulk import failed: one or more rows missing LRN',
                details: { missingRows: missingLrnRows }
            });
            return res.status(400).json({
                message: 'Bulk import requires LRN for every student. One or more rows are missing LRN.',
                missing: missingLrnRows
            });
        }

        const errors = [];

        const findDuplicates = (arr) => arr.reduce((acc, val, idx, a) => {
            if (a.indexOf(val) !== idx && !acc.includes(val)) acc.push(val);
            return acc;
        }, []);

        const normalized = students.map((s, idx) => ({
            idx,
            rowIndex: resolveRowIndex(s?.rowIndex, idx),
            firstName: (s.firstName || '').toString().trim(),
            lastName: (s.lastName || '').toString().trim(),
            libraryCardNumber: (s.libraryCardNumber || '').toString().trim(),
            lrn: (s.lrn || '').toString().trim(),
            email: (s.email || '').toString().trim().toLowerCase()
        }));

        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        normalized.forEach((row) => {
            const rowErrors = [];
            if (!row.firstName) rowErrors.push('Missing firstName');
            if (!row.lastName) rowErrors.push('Missing lastName');
            if (!row.lrn) rowErrors.push('Missing lrn'); // redundant if earlier, but keep for specificity
            if (row.email && !emailRegex.test(row.email)) rowErrors.push('Invalid email');
            if (rowErrors.length > 0) {
                errors.push({ idx: row.idx, rowIndex: row.rowIndex, libraryCardNumber: row.libraryCardNumber || null, issues: rowErrors });
            }
        });

        const lrns = normalized.map(r => r.lrn).filter(Boolean);
        const duplicateLrns = findDuplicates(lrns);
        duplicateLrns.forEach((dup) => {

            normalized.forEach(r => {
                if (r.lrn === dup) {
                    errors.push({ idx: r.idx, rowIndex: r.rowIndex, libraryCardNumber: r.libraryCardNumber || null, issues: ['Duplicate lrn in payload'] });
                }
            });
        });

        const libraryCardNumbers = normalized.map(r => r.libraryCardNumber).filter(Boolean);
        const duplicateLibraryCards = findDuplicates(libraryCardNumbers);
        duplicateLibraryCards.forEach((dup) => {
            normalized.forEach(r => {
                if (r.libraryCardNumber === dup) {
                    errors.push({ idx: r.idx, rowIndex: r.rowIndex, libraryCardNumber: r.libraryCardNumber || null, issues: ['Duplicate libraryCardNumber in payload'] });
                }
            });
        });

        const uniqueLrns = Array.from(new Set(lrns));
        if (uniqueLrns.length > 0) {
            try {
                const existingUsersByLrn = await req.dbAdapter.getUsers({ username: { $in: uniqueLrns } });
                if (existingUsersByLrn && existingUsersByLrn.length > 0) {
                    const existingLrnSet = new Set(existingUsersByLrn.map(u => String(u.username)));
                    normalized.forEach(r => {
                        if (existingLrnSet.has(r.lrn)) {
                            errors.push({ idx: r.idx, rowIndex: r.rowIndex, libraryCardNumber: r.libraryCardNumber || null, issues: ['Username (LRN) already exists in system'] });
                        }
                    });
                }
            } catch (dbErr) {
                console.error('Error checking existing usernames during bulk import validation:', dbErr);
                errors.push({ idx: null, rowIndex: null, libraryCardNumber: null, issues: ['Failed to validate existing usernames'] });
            }
        }

        const uniqueLibraryCards = Array.from(new Set(libraryCardNumbers));
        if (uniqueLibraryCards.length > 0) {
            try {
                const existingUsersByLibraryCard = await req.dbAdapter.getUsers({ libraryCardNumber: { $in: uniqueLibraryCards } });
                if (existingUsersByLibraryCard && existingUsersByLibraryCard.length > 0) {
                    const existingCardSet = new Set(existingUsersByLibraryCard.map(u => String(resolveLibraryCardNumber(u))));
                    normalized.forEach(r => {
                        if (existingCardSet.has(r.libraryCardNumber)) {
                            errors.push({ idx: r.idx, rowIndex: r.rowIndex, libraryCardNumber: r.libraryCardNumber || null, issues: ['libraryCardNumber already exists in system'] });
                        }
                    });
                }
            } catch (dbErr) {
                console.error('Error checking existing libraryCardNumbers during bulk import validation:', dbErr);
                errors.push({ idx: null, rowIndex: null, libraryCardNumber: null, issues: ['Failed to validate existing libraryCardNumbers'] });
            }
        }

        const validationErrorsByIndex = new Map();
        errors.forEach((entry) => {
            const idx = entry.idx;
            if (idx === undefined || idx === null) {
                return;
            }
            const issues = Array.isArray(entry.issues)
                ? entry.issues
                : Array.isArray(entry.errors)
                    ? entry.errors
                    : [entry.error || 'Validation failed'];
            const current = validationErrorsByIndex.get(idx) || { issues: [], rowIndex: entry.rowIndex };
            if (entry.rowIndex && !current.rowIndex) {
                current.rowIndex = entry.rowIndex;
            }
            current.issues.push(...issues);
            validationErrorsByIndex.set(idx, current);
        });

        setAuditContext(req, {
            metadata: {
                bulkImportRequest: {
                    count: students.length
                }
            }
        });

        const results = {
            successful: [],
            failed: []
        };

        for (const [idx, studentData] of students.entries()) {
            try {
                const resolvedRowIndex = resolveRowIndex(studentData?.rowIndex, idx);
                if (validationErrorsByIndex.has(idx)) {
                    const validationEntry = validationErrorsByIndex.get(idx);
                    const issues = validationEntry?.issues && validationEntry.issues.length > 0
                        ? validationEntry.issues
                        : ['Validation failed'];
                    results.failed.push({
                        studentData,
                        error: issues.join('; '),
                        issues,
                        rowIndex: validationEntry?.rowIndex ?? resolvedRowIndex
                    });
                    continue;
                }

                const providedLibraryCard = (studentData.libraryCardNumber || '').toString().trim();
                const libraryCardNumber = providedLibraryCard || await generateLibraryCardNumber(req.dbAdapter);
                const schoolYear = resolveSchoolYear(studentData);

                const username = studentData.lrn || studentData.username || null;
                let hashedPassword = null;
                if (username) {
                    const firstInitial = (studentData.firstName || '').charAt(0) || '';
                    const surname = (studentData.lastName || '').toString().replace(/\s+/g, '');
                    const rawPassword = surname ? `${firstInitial}${surname}` : `${firstInitial}${username}`;
                    hashedPassword = await bcrypt.hash(rawPassword.toLowerCase(), 10);
                } else if (studentData.password) {

                    const isBcrypt = (p) => typeof p === 'string' && /^\$2[aby]\$/.test(p);
                    if (isBcrypt(studentData.password)) {
                        hashedPassword = studentData.password;
                    } else {
                        hashedPassword = await bcrypt.hash(studentData.password, 10);
                    }
                }

                const newStudent = {
                    ...studentData,
                    username: username,
                    libraryCardNumber: libraryCardNumber, // Auto-generated
                    schoolYear: schoolYear,
                    academicYear: schoolYear,
                    password: hashedPassword,
                    role: 'student',
                    isActive: true,
                    borrowingStats: {
                        totalBorrowed: 0,
                        currentlyBorrowed: 0,
                        totalFines: 0,
                        totalReturned: 0
                    },
                    createdBy: req.user.uid
                };

                const student = await req.dbAdapter.createUser(newStudent);
                results.successful.push({
                    libraryCardNumber: resolveLibraryCardNumber(student),
                    rowIndex: resolvedRowIndex
                });
            } catch (error) {
                results.failed.push({
                    studentData,
                    error: error.message,
                    issues: error.message ? [error.message] : [],
                    rowIndex: resolveRowIndex(studentData?.rowIndex, idx)
                });
            }
        }

        const successCount = results.successful.length;
        const failureCount = results.failed.length;
        const statusCode = successCount > 0 ? 200 : 400;

        setAuditContext(req, {
            success: successCount > 0,
            status: successCount > 0 ? 'CompletedWithWarnings' : 'ValidationError',
            description: `Imported ${successCount} students (${failureCount} failed)`,
            details: {
                success: successCount,
                errors: failureCount,
            },
            metadata: {
                actorId: req.user.id
            }
        });

        if (successCount > 0) {
            const crossRoleRecipients = determineCrossRoleRecipients(req.user.role);
            if (crossRoleRecipients.length > 0) {
                const sampleCards = results.successful
                    .map(entry => entry.libraryCardNumber)
                    .filter(Boolean)
                    .slice(0, 3);
                await notifyRoles(req, crossRoleRecipients, {
                    title: 'Students imported',
                    message: `${formatUserName(req.user)} imported ${successCount} student${successCount === 1 ? '' : 's'}${failureCount ? ` (${failureCount} failed)` : ''}.`,
                    type: 'student-import',
                    severity: failureCount > 0 ? 'medium' : 'info',
                    meta: {
                        successCount,
                        failureCount,
                        sampleLibraryCardNumbers: sampleCards,
                        actorId: req.user.id
                    }
                });
            }
        }

        res.status(statusCode).json({
            message: `Bulk import completed. ${successCount} successful, ${failureCount} failed.`,
            results: {
                success: successCount,
                errors: failureCount,
                details: [
                    ...results.successful.map(s => ({
                        libraryCardNumber: s.libraryCardNumber,
                        status: 'success',
                        message: 'Imported successfully',
                        rowIndex: s.rowIndex ?? null
                    })),
                    ...results.failed.map(f => ({
                        libraryCardNumber: f.studentData?.libraryCardNumber || null,
                        status: 'error',
                        message: f.error,
                        issues: Array.isArray(f.issues) && f.issues.length > 0 ? f.issues : undefined,
                        rowIndex: f.rowIndex ?? (Number.isFinite(f.studentData?.rowIndex) ? f.studentData.rowIndex : null)
                    }))
                ]
            }
        });
    } catch (error) {
        console.error('Bulk import error:', error);
        res.status(500).json({
            message: 'Failed to import students',
            error: error.message
        });
    }
});

module.exports = router;
```

## transactions.js

| Field | Details |
| --- | --- |
| Program Name | transactions.js |
| Description | API route handler for transactions resources. |
| Called by | app.js, users.js |
| Table used | transactions |
|  |  |
| Programmer | Nazel Asca√±o |
| Date created | 12/14/2025 |
| Revision Date | TBD |
| Revision / description of change | None |

```javascript
Ôªøconst express = require('express');
const { verifyToken, requireCirculation, logAction, setAuditContext } = require('../middleware/customAuth');
const { generateTransactionId, ensureTransactionId } = require('../utils/transactionIds');
const {
    getSettingsSnapshot,
    BORROWING_DEFAULTS,
    NOTIFICATION_DEFAULTS,
    getNotificationChannelState
} = require('../utils/settingsCache');
const { maybeNotifyLowInventory } = require('../utils/inventoryNotifications');
const { notifyRoles, notifyRecipients } = require('../utils/notificationChannels');
const { buildBorrowRequestStaffMessage, buildNotePreview, formatCountLabel } = require('../utils/notificationCopy');
const router = express.Router();
const DEFAULT_LIBRARY_TIMEZONE = process.env.LIBRARY_TIMEZONE || 'Asia/Manila';

const ensureSettingsSnapshot = async (req) => {
    if (req.settingsSnapshot) {
        return req.settingsSnapshot;
    }
    const snapshot = await getSettingsSnapshot(req.dbAdapter);
    req.settingsSnapshot = snapshot;
    if (!req.systemSettings) {
        req.systemSettings = snapshot.system;
    }
    return snapshot;
};

const getBorrowingSettings = async (req) => {
    try {
        const snapshot = await ensureSettingsSnapshot(req);
        return snapshot?.borrowing || BORROWING_DEFAULTS;
    } catch (error) {
        console.error('Borrowing settings load error:', error);
        return BORROWING_DEFAULTS;
    }
};

const getLibrarySettings = async (req) => {
    try {
        const snapshot = await ensureSettingsSnapshot(req);
        return snapshot?.library || {
            openingTime: "08:00",
            closingTime: "17:00",
            operatingDays: ["monday", "tuesday", "wednesday", "thursday", "friday"],
            timezone: DEFAULT_LIBRARY_TIMEZONE,
        };
    } catch (error) {
        console.error('Library settings load error:', error);
        return {
            openingTime: "08:00",
            closingTime: "17:00",
            operatingDays: ["monday", "tuesday", "wednesday", "thursday", "friday"],
            timezone: DEFAULT_LIBRARY_TIMEZONE,
        };
    }
};

const parseTimeStringToMinutes = (value) => {
    if (value === undefined || value === null) {
        return null;
    }
    const normalized = String(value).trim().toLowerCase();
    if (!normalized) {
        return null;
    }

    const ampmMatch = normalized.match(/^([0-9]{1,2})(?::([0-9]{1,2}))?\s*(am|pm)$/);
    if (ampmMatch) {
        let hours = parseInt(ampmMatch[1], 10);
        const minutes = parseInt(ampmMatch[2] || '0', 10);
        if (Number.isNaN(hours) || Number.isNaN(minutes)) {
            return null;
        }
        const suffix = ampmMatch[3];
        if (suffix === 'pm' && hours < 12) {
            hours += 12;
        }
        if (suffix === 'am' && hours === 12) {
            hours = 0;
        }
        return hours * 60 + minutes;
    }

    const segments = normalized.split(':');
    if (segments.length < 2) {
        return null;
    }
    const hours = parseInt(segments[0], 10);
    const minutes = parseInt(segments[1], 10);
    if (Number.isNaN(hours) || Number.isNaN(minutes)) {
        return null;
    }
    if (hours < 0 || hours > 23 || minutes < 0 || minutes > 59) {
        return null;
    }
    return hours * 60 + minutes;
};

const getLibraryTimezone = (librarySettings = {}) => {
    const configured = librarySettings.timezone;
    if (configured && typeof configured === 'string' && configured.trim().length > 0) {
        return configured.trim();
    }
    return DEFAULT_LIBRARY_TIMEZONE;
};

const getZonedDayAndMinutes = (timeZone = DEFAULT_LIBRARY_TIMEZONE) => {
    try {
        const formatter = new Intl.DateTimeFormat('en-US', {
            timeZone,
            hour: '2-digit',
            minute: '2-digit',
            hour12: false,
            weekday: 'long'
        });
        const parts = formatter.formatToParts(new Date());
        const weekday = parts.find((part) => part.type === 'weekday')?.value?.toLowerCase();
        const hourPart = parts.find((part) => part.type === 'hour')?.value;
        const minutePart = parts.find((part) => part.type === 'minute')?.value;
        const hour = hourPart !== undefined ? parseInt(hourPart, 10) : NaN;
        const minute = minutePart !== undefined ? parseInt(minutePart, 10) : NaN;
        if (weekday && !Number.isNaN(hour) && !Number.isNaN(minute)) {
            return { weekday, minutes: hour * 60 + minute };
        }
    } catch (error) {
        console.error('Zoned time calculation error:', error);
    }

    const fallback = new Date();
    return {
        weekday: fallback.toLocaleString('en-US', { weekday: 'long' }).toLowerCase(),
        minutes: fallback.getHours() * 60 + fallback.getMinutes()
    };
};

const isWithinOperatingHours = (librarySettings = {}) => {
    const timeZone = getLibraryTimezone(librarySettings);
    const { weekday: currentDay, minutes: currentMinutes } = getZonedDayAndMinutes(timeZone);

    const operatingDays = Array.isArray(librarySettings.operatingDays)
        ? librarySettings.operatingDays.map(day => String(day).toLowerCase())
        : [];

    if (operatingDays.length > 0 && !operatingDays.includes(currentDay)) {
        return false;
    }

    const openingMinutes = parseTimeStringToMinutes(librarySettings.openingTime) ?? 0;
    const closingMinutes = parseTimeStringToMinutes(librarySettings.closingTime) ?? (23 * 60 + 59);

    if (openingMinutes === closingMinutes) {
        return true;
    }

    if (closingMinutes > openingMinutes) {
        return currentMinutes >= openingMinutes && currentMinutes <= closingMinutes;
    }

    return currentMinutes >= openingMinutes || currentMinutes <= closingMinutes;
};

const getNotificationSettings = async (req) => {
    try {
        const snapshot = await ensureSettingsSnapshot(req);
        return snapshot?.notifications || NOTIFICATION_DEFAULTS;
    } catch (error) {
        console.error('Notification settings load error:', error);
        return NOTIFICATION_DEFAULTS;
    }
};

const normalizeTransactionType = (value) => {
    if (!value) return 'regular';
    return String(value).trim().toLowerCase();
};

const isOvernightType = (type) => normalizeTransactionType(type) === 'overnight';
const isAnnualType = (type) => {
    const normalized = normalizeTransactionType(type);
    return normalized === 'annual' || normalized === 'annual-set';
};

const resolveBorrowWindowDays = (type, borrowingSettings) => {
    if (isOvernightType(type)) {
        return 1;
    }
    const fallback = BORROWING_DEFAULTS.maxBorrowDays || 14;
    const configured = Number(borrowingSettings?.maxBorrowDays) || fallback;
    return configured > 0 ? configured : fallback;
};

const calculateDueDate = (borrowDate, maxBorrowDays = 14) => {
    const dueDate = new Date(borrowDate);
    dueDate.setDate(dueDate.getDate() + maxBorrowDays);
    return dueDate;
};

const MS_IN_DAY = 24 * 60 * 60 * 1000;
const MAX_TRANSACTION_NOTE_LENGTH = 5000;

const calculateFine = (dueDate, returnDate, options = {}) => {
    const finePerDay = Number(options.finePerDay) || 5;
    const gracePeriodDays = Number(options.gracePeriodDays) || 0;
    if (!dueDate || !returnDate || returnDate <= dueDate) return 0;
    const diffTime = returnDate - dueDate;
    const diffDays = Math.ceil(diffTime / MS_IN_DAY);
    const chargeableDays = Math.max(0, diffDays - gracePeriodDays);
    if (chargeableDays === 0) {
        return 0;
    }
    return chargeableDays * finePerDay;
};

const normalizeStatus = (status) => {
    if (!status) return 'pending';
    return status === 'borrowed' ? 'active' : status;
};

const resolveTransactionDueDate = (transaction = {}) => {
    if (!transaction || typeof transaction !== 'object') {
        return null;
    }

    const directSources = [
        transaction.dueDate,
        transaction.metadata?.providedDueDate,
        transaction.expectedReturnDate,
        transaction.returnBy
    ];

    let source = directSources.find(value => Boolean(value)) || null;

    if (!source && Array.isArray(transaction.items)) {
        for (const item of transaction.items) {
            if (!item) continue;
            const itemSource = item.dueDate || item.expectedReturnDate || item.returnBy;
            if (itemSource) {
                source = itemSource;
                break;
            }
        }
    }

    if (!source) {
        return null;
    }

    const parsed = new Date(source);
    if (Number.isNaN(parsed.getTime())) {
        return null;
    }
    return parsed;
};

const matchesStatusFilter = (transaction = {}, filterValue = '', nowMs = Date.now()) => {
    const normalizedFilter = String(filterValue || '').trim().toLowerCase();
    if (!normalizedFilter || normalizedFilter === 'all') {
        return true;
    }

    const normalizedStatus = normalizeStatus(transaction.status);

    switch (normalizedFilter) {
        case 'active':
        case 'borrowed':
            return normalizedStatus === 'active';
        case 'requested':
        case 'pending':
            return normalizedStatus === 'requested' || normalizedStatus === 'pending';
        case 'overdue': {
            if (normalizedStatus !== 'active') {
                return false;
            }
            const dueDate = resolveTransactionDueDate(transaction);
            return Boolean(dueDate) && dueDate.getTime() < nowMs;
        }
        default:
            return normalizedStatus === normalizedFilter;
    }
};

const matchesTypeFilter = (transaction = {}, filterValue = '') => {
    const normalizedFilter = String(filterValue || '').trim().toLowerCase();
    if (!normalizedFilter || normalizedFilter === 'all') {
        return true;
    }

    const transactionType = normalizeTransactionType(transaction.type);
    if (normalizedFilter === 'annual') {
        return isAnnualType(transactionType);
    }
    return transactionType === normalizedFilter;
};

const buildLookupMap = (records, keysResolver) => {
    const map = new Map();
    records.forEach(record => {
        const keys = keysResolver(record);
        keys.filter(Boolean).forEach(key => {
            map.set(String(key), record);
        });
    });
    return map;
};

const getBorrowerName = (user) => {
    if (!user) return 'Unknown Borrower';
    if (user.fullName) return user.fullName;
    const nameParts = [user.firstName, user.middleName, user.lastName]
        .filter(Boolean)
        .join(' ')
        .trim();
    if (nameParts) return nameParts;
    return user.username || user.email || 'Unknown Borrower';
};

const buildRecipientList = (...values) => {
    return Array.from(
        new Set(
            values
                .flat()
                .filter(value => value !== undefined && value !== null && String(value).trim() !== '')
                .map(value => String(value))
        )
    );
};

const findUserByAnyIdentifier = async (dbAdapter, identifier) => {
    if (!identifier || !dbAdapter) {
        return null;
    }

    const probes = [
        { id: identifier },
        { _id: identifier },
        { userId: identifier },
        { libraryCardNumber: identifier },
        { username: identifier },
        { email: identifier }
    ];

    for (const query of probes) {
        try {
            const user = await dbAdapter.findOneInCollection('users', query);
            if (user) {
                return user;
            }
        } catch (error) {
            console.warn('User lookup failed for query', query, error.message || error);
        }
    }

    return null;
};

const findTransactionByIdentifier = async(dbAdapter, identifier) => {
    if (!identifier) return null;
    const idValue = String(identifier);
    let transaction = await dbAdapter.findOneInCollection('transactions', { id: idValue });
    if (!transaction) {
        transaction = await dbAdapter.findOneInCollection('transactions', { _id: idValue });
    }

    if (transaction && !transaction.id) {
        const generatedId = ensureTransactionId(transaction);
        if (generatedId) {
            const query = transaction._id ? { _id: transaction._id } : transaction.id ? { id: transaction.id } : null;
            if (query) {
                await dbAdapter.updateInCollection('transactions', query, { id: generatedId });
            }
            transaction.id = generatedId;
        }
    }

    return transaction;
};

const ACTIVE_TRANSACTION_STATUSES = new Set(['borrowed', 'active', 'pending']);

const loadBorrowingLookups = async(dbAdapter) => {
    const [users, books] = await Promise.all([
        dbAdapter.findInCollection('users', {}),
        dbAdapter.findInCollection('books', {})
    ]);

    const usersLookup = buildLookupMap(users, user => [user.id, user._id, user.uid, user.userId, user.libraryCardNumber, user.email]);
    const booksLookup = buildLookupMap(books, book => [book.id, book._id, book.bookId, book.isbn]);
    const copiesLookup = new Map();

    books.forEach(book => {
        (book.copies || []).forEach(copy => {
            if (copy.copyId) {
                copiesLookup.set(String(copy.copyId), { book, copy });
            }
        });
    });

    return { usersLookup, booksLookup, copiesLookup };
};

const resolveItemBookMetadata = (item = {}, lookups = {}) => {
    const copyMatch = lookups.copiesLookup?.get(String(item.copyId || ''));
    const matchingBook = copyMatch?.book || lookups.booksLookup?.get(String(item.bookId)) || null;

    const bookTitle = matchingBook?.title || item.title || item.isbn || 'Unknown Book';
    const author = matchingBook?.author || matchingBook?.publisher || item.author || '';

    return {
        ...item,
        bookTitle,
        author
    };
};

const enrichTransactionsWithBookMetadata = async(transactions, dbAdapter) => {
    if (!Array.isArray(transactions) || transactions.length === 0) {
        return Array.isArray(transactions) ? transactions : [];
    }

    const lookups = await loadBorrowingLookups(dbAdapter);

    return transactions.map(transaction => {
        const items = (transaction.items || []).map(item => resolveItemBookMetadata(item, lookups));
        const titleList = items.map(item => item.bookTitle).filter(Boolean);
        const authorList = items.map(item => item.author).filter(Boolean);

        return {
            ...transaction,
            items,
            bookTitle: titleList.length > 0 ? titleList.join(', ') : (transaction.bookTitle || 'Unknown Book'),
            bookAuthor: authorList.length > 0 ? authorList.join(', ') : (transaction.bookAuthor || '')
        };
    });
};

const buildBorrowedRecord = ({ transaction, item, lookups }) => {
    const documentId = transaction.id || transaction._id || `txn_${transaction.userId || 'unknown'}`;
    const borrower = lookups.usersLookup.get(String(transaction.userId)) || null;
    const borrowerName = getBorrowerName(borrower);
    const borrowerEmail = borrower?.email || borrower?.username || '';

    const copyMatch = lookups.copiesLookup.get(String(item.copyId || ''));
    const matchingBook = copyMatch?.book || lookups.booksLookup.get(String(item.bookId)) || null;

    const bookTitle = matchingBook?.title || item.title || item.isbn || 'Unknown Book';
    const author = matchingBook?.author || matchingBook?.publisher || item.author || '';

    const baseRowId = `${documentId}_${item.copyId || item.bookId || item.isbn || 'item'}`;

    return {
        transactionId: documentId,
        rowId: baseRowId,
        _id: baseRowId,
        borrowerId: transaction.userId,
        borrowerName,
        borrowerEmail,
        copyId: item.copyId || '',
        bookTitle,
        author,
        borrowDate: transaction.borrowDate || transaction.createdAt || null,
        dueDate: transaction.dueDate || null,
        status: normalizeStatus(transaction.status),
        fine: transaction.fineAmount || transaction.fine || 0
    };
};

const normalizeIdValue = (value) => {
    if (value === undefined || value === null) return '';
    return String(value).trim();
};

const mergeRequestAssignments = (items = [], assignments = []) => {
    const consumedIndices = new Set();

    const findMatchIndex = (matcher) => {
        for (let idx = 0; idx < assignments.length; idx += 1) {
            if (consumedIndices.has(idx)) continue;
            const assignment = assignments[idx];
            if (matcher(assignment, idx)) {
                return idx;
            }
        }
        return -1;
    };

    const mergedItems = [];
    const missingAssignments = [];

    items.forEach((item, index) => {
        const merged = { ...item };
        if (merged.copyId) {
            mergedItems.push(merged);
            return;
        }

        const requestItemId = normalizeIdValue(merged.requestItemId);
        const bookId = normalizeIdValue(merged.bookId);

        let matchIndex = -1;
        if (requestItemId) {
            matchIndex = findMatchIndex((assignment) => normalizeIdValue(assignment.requestItemId) === requestItemId);
        }
        if (matchIndex === -1 && bookId) {
            matchIndex = findMatchIndex((assignment) => normalizeIdValue(assignment.bookId) === bookId);
        }
        if (matchIndex === -1) {
            matchIndex = findMatchIndex((assignment) => Boolean(normalizeIdValue(assignment.copyId)));
        }

        if (matchIndex === -1) {
            missingAssignments.push({
                index,
                requestItemId: requestItemId || null,
                bookId: bookId || null
            });
            mergedItems.push(merged);
            return;
        }

        const assignment = assignments[matchIndex];
        consumedIndices.add(matchIndex);

        mergedItems.push({
            ...merged,
            copyId: normalizeIdValue(assignment.copyId),
            bookId: normalizeIdValue(assignment.bookId) || bookId
        });
    });

    const unusedAssignments = assignments
        .map((assignment, index) => ({ ...assignment, index }))
        .filter(entry => !consumedIndices.has(entry.index));

    return { mergedItems, missingAssignments, unusedAssignments };
};

const processReturnTransaction = async({
    dbAdapter,
    transaction,
    items,
    actorId,
    notes = '',
    returnDateOverride = null,
    borrowingSettings = BORROWING_DEFAULTS,
    notificationOptions = {}
}) => {
    if (!transaction) {
        throw new Error('Transaction not found');
    }
    if (!Array.isArray(items) || items.length === 0) {
        throw new Error('No items provided for return');
    }
    if (transaction.status === 'returned') {
        throw new Error('Transaction already returned');
    }

    const {
        notificationSettings = NOTIFICATION_DEFAULTS,
        channelState: providedChannelState,
        actorName = '',
        enabled = true
    } = notificationOptions || {};
    const channelState = providedChannelState || getNotificationChannelState(notificationSettings);
    const allowReturnNotifications = enabled !== false && notificationSettings?.returnNotifications !== false;

    const finePerDay = Number(borrowingSettings?.finePerDay) || BORROWING_DEFAULTS.finePerDay;
    const enableFines = borrowingSettings?.enableFines !== false;
    const gracePeriodDays = Number(borrowingSettings?.gracePeriodDays) || BORROWING_DEFAULTS.gracePeriodDays;
    const maxFineAmount = Number(borrowingSettings?.maxFineAmount) || 0;

    const allBooks = await dbAdapter.findInCollection('books', {});
    let returnDate = returnDateOverride ? new Date(returnDateOverride) : new Date();
    if (Number.isNaN(returnDate.getTime())) {
        returnDate = new Date();
    }
    const dueDateSource = transaction.dueDate || transaction.metadata?.providedDueDate || null;
    const dueDate = dueDateSource ? new Date(dueDateSource) : null;
    let totalFine = 0;
    let returnedItems = 0;

    for (const returnItem of items) {
        const { copyId, condition = 'good' } = returnItem;
        if (!copyId) continue;

        let targetBook = null;
        for (const book of allBooks) {
            const copy = book.copies?.find(c => c.copyId === copyId);
            if (copy) {
                targetBook = book;
                break;
            }
        }

        if (!targetBook) continue;

        const updatedCopies = (targetBook.copies || []).map(c =>
            c.copyId === copyId
                ? {
                    ...c,
                    status: 'available',
                    condition,
                    updatedAt: new Date(),
                    updatedBy: actorId
                }
                : c
        );

        const availableCopies = updatedCopies.filter(c => c.status === 'available').length;
        const bookQuery = targetBook.id ? { id: targetBook.id } : { _id: targetBook._id };
        await dbAdapter.updateInCollection('books', bookQuery, {
            copies: updatedCopies,
            availableCopies,
            updatedAt: new Date()
        });
        await maybeNotifyLowInventory(dbAdapter, {
            ...targetBook,
            copies: updatedCopies,
            availableCopies
        }, { source: 'transaction-return' });

        returnedItems++;
    }

    if (enableFines && dueDate && !Number.isNaN(dueDate.getTime()) && returnDate > dueDate && returnedItems > 0) {
        const perItemFine = calculateFine(dueDate, returnDate, {
            finePerDay,
            gracePeriodDays
        });
        totalFine = perItemFine * returnedItems;
        if (maxFineAmount > 0) {
            totalFine = Math.min(totalFine, maxFineAmount);
        }
    }

    const updatedItems = (transaction.items || []).map(item => {
        const wasReturned = items.some(returnItem => returnItem.copyId === item.copyId);
        if (!wasReturned) return item;
        return { ...item, status: 'returned', returnedAt: returnDate };
    });

    const hasOutstandingItems = updatedItems.some(item => item.status !== 'returned');
    const updatedStatus = hasOutstandingItems ? 'borrowed' : 'returned';

    const transactionQuery = transaction.id ? { id: transaction.id } : { _id: transaction._id };
    await dbAdapter.updateInCollection('transactions', transactionQuery, {
        status: updatedStatus,
        items: updatedItems,
        returnDate,
        fineAmount: totalFine,
        returnNotes: notes || '',
        updatedAt: new Date(),
        returnedBy: actorId
    });

    let user = await dbAdapter.findOneInCollection('users', { id: transaction.userId });
    if (!user) {
        user = await dbAdapter.findOneInCollection('users', { _id: transaction.userId });
    }
    if (user) {
        const stats = user.borrowingStats || { totalBorrowed: 0, currentlyBorrowed: 0, totalFines: 0, totalReturned: 0 };
        const updatedStats = {
            totalBorrowed: stats.totalBorrowed || 0,
            currentlyBorrowed: Math.max(0, (stats.currentlyBorrowed || 0) - returnedItems),
            totalFines: (stats.totalFines || 0) + totalFine,
            totalReturned: (stats.totalReturned || 0) + returnedItems
        };
        const userQuery = user.id ? { id: user.id } : { _id: user._id };
        await dbAdapter.updateInCollection('users', userQuery, {
            borrowingStats: updatedStats,
            updatedAt: new Date()
        });
    }

    const daysOverdue = totalFine > 0 && dueDate ? Math.ceil((returnDate - dueDate) / (1000 * 60 * 60 * 24)) : 0;
    const borrowerRecipients = user
        ? buildRecipientList(
            user.id,
            user._id,
            user.userId,
            user.libraryCardNumber,
            user.email,
            user.username
        )
        : buildRecipientList(transaction.userId);
    const borrowerName = user ? getBorrowerName(user) : getBorrowerName(transaction.user || {});

    if (
        allowReturnNotifications &&
        channelState?.hasActiveChannel &&
        borrowerRecipients.length > 0 &&
        returnedItems > 0
    ) {
        try {
            const completionClause = hasOutstandingItems
                ? 'Some items are still checked out.'
                : 'All items on this transaction are now returned.';
            const fineClause = totalFine > 0
                ? `Return fine: PHP ${totalFine.toFixed(2)}.`
                : 'No fines were added.';
            const processedByClause = actorName ? `Processed by ${actorName}.` : '';
            const messageParts = [
                `We recorded the return of ${formatCountLabel(returnedItems, 'item')} for transaction ${transaction.id || transaction._id}.`,
                completionClause,
                processedByClause,
                fineClause
            ].filter(Boolean);

            await dbAdapter.insertIntoCollection('notifications', {
                title: 'Items returned',
                message: messageParts.join(' ').replace(/\s+/g, ' ').trim(),
                type: 'return-processed',
                transactionId: transaction.id || transaction._id,
                recipients: borrowerRecipients,
                meta: {
                    transactionId: transaction.id || transaction._id,
                    borrowerName,
                    returnedItems,
                    fineAmount: totalFine,
                    hasOutstandingItems,
                    returnDate: returnDate.toISOString(),
                    daysOverdue,
                    processedBy: actorId,
                    processedByName: actorName || undefined
                },
                createdAt: new Date(),
                updatedAt: new Date(),
                readBy: []
            });
        } catch (notifyError) {
            console.error('Failed to notify borrower about return processing:', notifyError);
        }
    }

    return {
        returnedItems,
        fineAmount: totalFine,
        daysOverdue
    };
};

router.get('/', verifyToken, requireCirculation, async(req, res) => {
    try {
        const { page = 1, limit = 20, status, userId, type, startDate, endDate, search } = req.query;
        const pageNumber = Math.max(parseInt(page, 10) || 1, 1);
        const limitNumber = Math.max(parseInt(limit, 10) || 20, 1);
        const normalizedStatusFilter = typeof status === 'string' ? status.trim().toLowerCase() : '';
        const normalizedTypeFilter = typeof type === 'string' ? type.trim().toLowerCase() : '';

        const derivedStatusFilters = new Set(['active', 'overdue', 'requested', 'pending']);
        const filters = {};
        if (userId) filters.userId = userId;
        if (normalizedStatusFilter && !derivedStatusFilters.has(normalizedStatusFilter)) {
            filters.status = normalizedStatusFilter;
        }
        if (normalizedTypeFilter && normalizedTypeFilter !== 'annual') {
            filters.type = normalizedTypeFilter;
        }

        let transactions = await req.dbAdapter.findInCollection('transactions', filters);

        if (startDate || endDate) {
            const start = startDate ? new Date(startDate) : null;
            const end = endDate ? new Date(endDate) : null;
            transactions = transactions.filter(transaction => {
                const transactionDate = new Date(transaction.createdAt || transaction.borrowDate || Date.now());
                if (start && transactionDate < start) return false;
                if (end && transactionDate > end) return false;
                return true;
            });
        }

        if (normalizedStatusFilter && normalizedStatusFilter !== 'all') {
            const nowMs = Date.now();
            transactions = transactions.filter(transaction => matchesStatusFilter(transaction, normalizedStatusFilter, nowMs));
        }

        if (normalizedTypeFilter && normalizedTypeFilter !== 'all') {
            transactions = transactions.filter(transaction => matchesTypeFilter(transaction, normalizedTypeFilter));
        }

        transactions.sort((a, b) => new Date(b.createdAt || b.borrowDate) - new Date(a.createdAt || a.borrowDate));

        const allUsers = await req.dbAdapter.findInCollection('users', {});
        const allBooks = await req.dbAdapter.findInCollection('books', {});
        const usersLookup = buildLookupMap(allUsers, user => [user.id, user._id, user.uid, user.userId, user.libraryCardNumber]);
        const booksLookup = buildLookupMap(allBooks, book => [book.id, book._id, book.bookId, book.isbn]);
        const copiesLookup = new Map();
        allBooks.forEach(book => {
            (book.copies || []).forEach(copy => {
                if (copy.copyId) {
                    copiesLookup.set(String(copy.copyId), book);
                }
            });
        });

        let detailedTransactions = [];

        transactions.forEach(transaction => {
            const borrower = usersLookup.get(String(transaction.userId)) || null;
            const borrowerName = getBorrowerName(borrower);
            const borrowerEmail = (borrower?.email) || (borrower?.username) || '';
            const documentId = transaction._id || transaction.id;
            const baseRecord = {
                ...transaction,
                documentId,
                id: transaction.id || transaction._id || documentId,
                status: normalizeStatus(transaction.status),
                borrowerName,
                borrowerEmail,
                borrowerId: transaction.userId,
                fine: transaction.fineAmount || transaction.fine || 0
            };

            if (transaction.items && transaction.items.length > 0) {
                transaction.items.forEach((item, index) => {
                    const book = booksLookup.get(String(item.bookId)) || copiesLookup.get(String(item.copyId)) || null;
                    const bookTitle = (book?.title) || item.title || item.isbn || 'Unknown Book';
                    const author = (book?.author) || (book?.publisher) || '';
                    const rowId = `${documentId || baseRecord.id || 'transaction'}_${item.copyId || index}`;
                    detailedTransactions.push({
                        ...baseRecord,
                        _id: rowId,
                        copyId: item.copyId || '',
                        bookTitle,
                        author
                    });
                });
            } else {
                detailedTransactions.push({
                    ...baseRecord,
                    _id: documentId || baseRecord.id,
                    copyId: '',
                    bookTitle: 'Unknown Book',
                    author: ''
                });
            }
        });

        if (search) {
            const searchValue = String(search).toLowerCase();
            detailedTransactions = detailedTransactions.filter(transaction => {
                const idMatches = [
                    transaction.transactionId,
                    transaction.documentId,
                    transaction.id,
                    transaction._id
                ]
                    .map(value => (value ? String(value).toLowerCase() : ''))
                    .some(value => value.includes(searchValue));
                return (
                    idMatches ||
                    transaction.bookTitle?.toLowerCase().includes(searchValue) ||
                    transaction.author?.toLowerCase().includes(searchValue) ||
                    transaction.borrowerName?.toLowerCase().includes(searchValue) ||
                    transaction.borrowerEmail?.toLowerCase().includes(searchValue) ||
                    transaction.copyId?.toLowerCase().includes(searchValue)
                );
            });
        }

        const total = detailedTransactions.length;
        const startIndex = (pageNumber - 1) * limitNumber;
        const paginatedTransactions = detailedTransactions.slice(startIndex, startIndex + limitNumber);

        res.json({
            transactions: paginatedTransactions,
            pagination: {
                page: pageNumber,
                limit: limitNumber,
                total,
                pages: Math.ceil(total / limitNumber)
            }
        });
    } catch (error) {
        console.error('Get transactions error:', error);
        res.status(500).json({ message: 'Failed to fetch transactions' });
    }
});

router.get('/stats', verifyToken, requireCirculation, async(req, res) => {
    try {
        const transactions = await req.dbAdapter.findInCollection('transactions', {});
        const borrowedCount = transactions.filter(t => (t.status === 'borrowed' || t.status === 'active')).length;
        const stats = {
            total: transactions.length,
            borrowed: borrowedCount,
            returned: transactions.filter(t => t.status === 'returned').length,
            overdue: transactions.filter(t => (t.status === 'borrowed' || t.status === 'active') && new Date(t.dueDate) < new Date()).length
        };
        res.json(stats);
    } catch (error) {
        console.error('Get transaction stats error:', error);
        res.status(500).json({ message: 'Failed to fetch transaction stats' });
    }
});

router.get('/annual/stats', verifyToken, requireCirculation, async(req, res) => {
    try {
        const { year } = req.query;
        const targetYear = year || new Date().getFullYear();
        const transactions = await req.dbAdapter.findInCollection('transactions', {});

        const annualTransactions = transactions.filter(t => {
            const tDate = new Date(t.borrowDate || t.createdAt);
            return tDate.getFullYear() === parseInt(targetYear);
        });

        res.json({
            year: targetYear,
            total: annualTransactions.length,
            byMonth: Array.from({ length: 12 }, (_, i) => {
                const month = i + 1;
                return {
                    month,
                    count: annualTransactions.filter(t => new Date(t.borrowDate || t.createdAt).getMonth() + 1 === month).length
                };
            })
        });
    } catch (error) {
        console.error('Get annual stats error:', error);
        res.status(500).json({ message: 'Failed to fetch annual stats' });
    }
});

router.get('/annual', verifyToken, requireCirculation, async(req, res) => {
    try {
    const { year, curriculum } = req.query;
        const targetYear = year || new Date().getFullYear();
        const transactions = await req.dbAdapter.findInCollection('transactions', {});

        let annualTransactions = transactions.filter(t => {
            const tDate = new Date(t.borrowDate || t.createdAt);
            return tDate.getFullYear() === parseInt(targetYear);
        });

        if (curriculum) {

            const users = await req.dbAdapter.findInCollection('users', { curriculum });
            const userIds = users.map(u => u.id);
            annualTransactions = annualTransactions.filter(t => userIds.includes(t.userId));
        }

        res.json(annualTransactions);
    } catch (error) {
        console.error('Get annual transactions error:', error);
        res.status(500).json({ message: 'Failed to fetch annual transactions' });
    }
});

router.get('/overdue/list', verifyToken, requireCirculation, async(req, res) => {
    try {
        const currentDate = new Date();
        const transactions = await req.dbAdapter.findInCollection('transactions', { status: 'borrowed' });
        const overdueTransactions = transactions
            .filter(transaction => transaction.dueDate)
            .filter(transaction => new Date(transaction.dueDate) < currentDate)
            .map(transaction => {
                const due = new Date(transaction.dueDate);
                const daysOverdue = Math.ceil((currentDate - due) / (1000 * 60 * 60 * 24));
                return { ...transaction, daysOverdue };
            });
        res.json(overdueTransactions);
    } catch (error) {
        console.error('Get overdue transactions error:', error);
        res.status(500).json({ message: 'Failed to fetch overdue transactions' });
    }
});

router.get('/user/:userId', verifyToken, async(req, res) => {
    try {
        let transactions = await req.dbAdapter.findInCollection('transactions', { userId: req.params.userId });
        transactions.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));
        const enriched = await enrichTransactionsWithBookMetadata(transactions, req.dbAdapter);
        res.json(enriched);
    } catch (error) {
        console.error('Get user transactions error:', error);
        res.status(500).json({ message: 'Failed to fetch user transactions' });
    }
});

router.get('/borrowed', verifyToken, requireCirculation, async(req, res) => {
    try {
        const searchTerm = (req.query.search || '').trim().toLowerCase();
        const transactions = await req.dbAdapter.findInCollection('transactions', {});

        const activeTransactions = transactions.filter(transaction => {
            const status = normalizeStatus(transaction.status);
            if (!ACTIVE_TRANSACTION_STATUSES.has(status)) return false;
            return (transaction.items || []).some(item => item && item.copyId && item.status !== 'returned');
        });

        if (activeTransactions.length === 0) {
            return res.json([]);
        }

        const { usersLookup, booksLookup, copiesLookup } = await loadBorrowingLookups(req.dbAdapter);

        const records = [];

        activeTransactions.forEach(transaction => {
            (transaction.items || []).forEach(item => {
                if (!item || !item.copyId || item.status === 'returned') {
                    return;
                }
                const record = buildBorrowedRecord({
                    transaction,
                    item,
                    lookups: { usersLookup, booksLookup, copiesLookup }
                });

                if (!searchTerm) {
                    records.push(record);
                    return;
                }

                const haystacks = [
                    record.bookTitle,
                    record.author,
                    record.borrowerName,
                    record.borrowerEmail,
                    record.copyId,
                    record.transactionId
                ].filter(Boolean).map(value => String(value).toLowerCase());

                if (haystacks.some(value => value.includes(searchTerm))) {
                    records.push(record);
                }
            });
        });

        res.json(records);
    } catch (error) {
        console.error('Borrowed lookup error:', error);
        res.status(500).json({ message: 'Failed to search borrowed transactions' });
    }
});

router.get('/by-copy', verifyToken, requireCirculation, async(req, res) => {
    try {
        const copyId = (req.query.copyId || '').trim();
        if (!copyId) {
            return res.status(400).json({ message: 'copyId query parameter is required' });
        }

        const transactions = await req.dbAdapter.findInCollection('transactions', {});

        for (const transaction of transactions) {
            const status = normalizeStatus(transaction.status);
            if (!ACTIVE_TRANSACTION_STATUSES.has(status)) {
                continue;
            }

            for (const item of transaction.items || []) {
                if (!item || item.status === 'returned') {
                    continue;
                }
                if (String(item.copyId) === copyId) {
                    const { usersLookup, booksLookup, copiesLookup } = await loadBorrowingLookups(req.dbAdapter);
                    const record = buildBorrowedRecord({
                        transaction,
                        item,
                        lookups: { usersLookup, booksLookup, copiesLookup }
                    });
                    return res.json(record);
                }
            }
        }

        res.status(404).json({ message: 'No borrowed record found for this copy' });
    } catch (error) {
        console.error('Borrowed lookup by copy error:', error);
        res.status(500).json({ message: 'Failed to search copy borrowing record' });
    }
});

router.get('/:id/history', verifyToken, async(req, res) => {
    try {
        const transactionId = req.params.id;

        let logs = await req.dbAdapter.findInCollection('audit', {});

        const matches = logs.filter(log => {
            try {
                const entityMatch = log.entityId && String(log.entityId) === String(transactionId);
                const resourceMatch = log.resourceId && String(log.resourceId) === String(transactionId);
                const detailsString = JSON.stringify(log.details || {});
                const metadataString = JSON.stringify(log.metadata || {});
                const inDetails = detailsString.includes(transactionId);
                const inMetadata = metadataString.includes(transactionId);
                const actionEntityMatch = log.entity && String(log.entity).toLowerCase() === 'transaction' && (entityMatch || resourceMatch);

                return entityMatch || resourceMatch || inDetails || inMetadata || actionEntityMatch;
            } catch (e) {
                return false;
            }
        });

        matches.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));

        res.json(matches);
    } catch (error) {
        console.error('Get transaction history error:', error);
        res.status(500).json({ message: 'Failed to fetch transaction history' });
    }
});

router.get('/:id', verifyToken, async(req, res) => {
    try {
        const transaction = await findTransactionByIdentifier(req.dbAdapter, req.params.id);
        if (!transaction) return res.status(404).json({ message: 'Transaction not found' });
        const user = await req.dbAdapter.findOneInCollection('users', { id: transaction.userId });
        if (user) transaction.user = user;
        for (let item of transaction.items) {
            const book = await req.dbAdapter.findOneInCollection('books', { id: item.bookId });
            if (book) item.book = book;
        }
        res.json(transaction);
    } catch (error) {
        console.error('Get transaction error:', error);
        res.status(500).json({ message: 'Failed to fetch transaction' });
    }
});

router.get('/:id/history', verifyToken, async(req, res) => {
    try {
        const transactionId = req.params.id;

        let logs = await req.dbAdapter.findInCollection('audit', {});

        const matches = logs.filter(log => {
            try {
                const entityMatch = log.entityId && String(log.entityId) === String(transactionId);
                const resourceMatch = log.resourceId && String(log.resourceId) === String(transactionId);
                const detailsString = JSON.stringify(log.details || {});
                const metadataString = JSON.stringify(log.metadata || {});
                const inDetails = detailsString.includes(transactionId);
                const inMetadata = metadataString.includes(transactionId);
                const actionEntityMatch = log.entity && String(log.entity).toLowerCase() === 'transaction' && (entityMatch || resourceMatch);

                return entityMatch || resourceMatch || inDetails || inMetadata || actionEntityMatch;
            } catch (e) {
                return false;
            }
        });

        matches.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));

        res.json(matches);
    } catch (error) {
        console.error('Get transaction history error:', error);
        res.status(500).json({ message: 'Failed to fetch transaction history' });
    }
});

router.put('/:id/notes', verifyToken, requireCirculation, logAction('UPDATE_NOTES', 'transaction'), async(req, res) => {
    try {
        const transactionIdentifier = req.params.id;
        const rawNotes = req.body?.notes;
        const normalizedNotes = rawNotes === undefined || rawNotes === null ? '' : String(rawNotes);
        const trimmedNotes = normalizedNotes.length > MAX_TRANSACTION_NOTE_LENGTH
            ? normalizedNotes.slice(0, MAX_TRANSACTION_NOTE_LENGTH)
            : normalizedNotes;

        setAuditContext(req, {
            metadata: {
                notesUpdate: {
                    transactionId: transactionIdentifier,
                    requestedLength: normalizedNotes.length,
                },
            },
        });

        const transaction = await findTransactionByIdentifier(req.dbAdapter, transactionIdentifier);
        if (!transaction) {
            setAuditContext(req, {
                success: false,
                status: 'TransactionNotFound',
                description: `Notes update failed: transaction ${transactionIdentifier} not found`,
            });
            return res.status(404).json({ message: 'Transaction not found' });
        }

        const transactionQuery = transaction.id ? { id: transaction.id } : { _id: transaction._id };
        const updatedTransaction = await req.dbAdapter.updateInCollection('transactions', transactionQuery, {
            notes: trimmedNotes,
        });

        if (!updatedTransaction) {
            throw new Error('Transaction update failed');
        }

        setAuditContext(req, {
            success: true,
            status: 'NotesUpdated',
            description: `Updated notes for transaction ${transaction.id || transaction._id}`,
            entityId: transaction.id || transaction._id,
            resourceId: transaction.id || transaction._id,
            metadata: {
                notesUpdate: {
                    previousLength: String(transaction.notes || '').length,
                    newLength: trimmedNotes.length,
                },
            },
        });

        return res.json({
            message: 'Notes updated successfully',
            transaction: updatedTransaction,
        });
    } catch (error) {
        console.error('Update transaction notes error:', error);
        setAuditContext(req, {
            success: false,
            status: 'NotesUpdateFailed',
            description: `Failed to update notes for transaction ${req.params.id}`,
            metadata: { error: error.message },
        });
        return res.status(500).json({ message: 'Failed to update transaction notes' });
    }
});

router.post('/borrow', verifyToken, requireCirculation, logAction('BORROW', 'transaction'), async(req, res) => {
    try {
        const { userId, items, type = 'regular', notes } = req.body;
        const transactionType = normalizeTransactionType(type);
        const requestedItems = Array.isArray(items) ? items : [];

        setAuditContext(req, {
            details: {
                borrowerId: userId || null
            },
            metadata: {
                borrowRequest: {
                    type: transactionType,
                    itemCount: requestedItems.length,
                    copyIds: requestedItems
                        .map(item => item && item.copyId)
                        .filter(Boolean)
                }
            }
        });

        if (!userId || !Array.isArray(items) || items.length === 0) {
            setAuditContext(req, {
                success: false,
                status: 'ValidationError',
                description: 'Borrow request missing userId or items'
            });
            return res.status(400).json({ message: 'User ID and items are required' });
        }
        const borrowingSettings = await getBorrowingSettings(req);
        const notificationSettings = await getNotificationSettings(req);
        const channelState = getNotificationChannelState(notificationSettings);
        if (isOvernightType(transactionType) && borrowingSettings.overnightBorrowingEnabled === false) {
            setAuditContext(req, {
                success: false,
                status: 'OvernightDisabled',
                description: 'Borrow request blocked: overnight borrowing disabled'
            });
            return res.status(403).json({ message: 'Overnight borrowing is currently disabled' });
        }
        if (isAnnualType(transactionType) && borrowingSettings.annualBorrowingEnabled === false) {
            setAuditContext(req, {
                success: false,
                status: 'AnnualDisabled',
                description: 'Borrow request blocked: annual borrowing disabled'
            });
            return res.status(403).json({ message: 'Annual borrowing is currently disabled' });
        }

        if (isAnnualType(transactionType)) {
            const systemSettings = req.systemSettings;
            const schoolYearStart = new Date(systemSettings.schoolYearStart);
            const schoolYearEnd = new Date(systemSettings.schoolYearEnd);
            const now = new Date();
            if (now < schoolYearStart || now > schoolYearEnd) {
                setAuditContext(req, {
                    success: false,
                    status: 'OutsideSchoolYear',
                    description: 'Borrow request blocked: outside school year for annual borrowing'
                });
                return res.status(403).json({ message: 'Annual borrowing is only allowed during the school year' });
            }
        }

        const maxBooksPerTransaction = Number(borrowingSettings.maxBooksPerTransaction) || 0;
        if (maxBooksPerTransaction > 0 && items.length > maxBooksPerTransaction) {
            setAuditContext(req, {
                success: false,
                status: 'LimitExceeded',
                description: `Borrow request exceeds maximum ${maxBooksPerTransaction} books per transaction`,
                metadata: {
                    attemptedCount: items.length,
                    maxBooksPerTransaction
                }
            });
            return res.status(400).json({ message: `Maximum ${maxBooksPerTransaction} books per transaction` });
        }
        const user = await req.dbAdapter.findUserById(userId);
        if (!user) {
            setAuditContext(req, {
                success: false,
                status: 'UserNotFound',
                description: `Borrow request failed: user ${userId} not found`,
                entityId: userId,
                metadata: {
                    userId
                }
            });
            return res.status(404).json({ message: 'User not found' });
        }
        if (!user.isActive) {
            setAuditContext(req, {
                success: false,
                status: 'UserInactive',
                description: `Borrow request failed: user ${userId} is not active`,
                entityId: userId
            });
            return res.status(400).json({ message: 'User account is not active' });
        }
        const transactionItems = [];
        const borrowDate = new Date();
        const borrowWindowDays = resolveBorrowWindowDays(transactionType, borrowingSettings);
        const dueDate = calculateDueDate(borrowDate, borrowWindowDays);
        for (const item of items) {
            const { copyId } = item;
            const allBooks = await req.dbAdapter.findInCollection('books', {});
            let targetBook = null;
            let targetCopy = null;
            for (const book of allBooks) {
                const copy = book.copies?.find(c => c.copyId === copyId);
                if (copy) {
                    targetBook = book;
                    targetCopy = copy;
                    break;
                }
            }
            if (!targetBook || !targetCopy) {
                setAuditContext(req, {
                    success: false,
                    status: 'CopyNotFound',
                    description: `Borrow request failed: book copy ${copyId} not found`,
                    metadata: {
                        copyId
                    }
                });
                return res.status(404).json({ message: `Book copy ${copyId} not found` });
            }
            if (targetCopy.status !== 'available') {
                setAuditContext(req, {
                    success: false,
                    status: 'CopyUnavailable',
                    description: `Borrow request failed: book copy ${copyId} is not available`,
                    metadata: {
                        copyId,
                        copyStatus: targetCopy.status
                    }
                });
                return res.status(400).json({ message: `Book copy ${copyId} is not available` });
            }
            const updatedCopies = targetBook.copies.map(c => c.copyId === copyId ? {...c, status: 'borrowed', updatedAt: new Date() } : c);
            const availableCopies = updatedCopies.filter(c => c.status === 'available').length;
            await req.dbAdapter.updateInCollection('books', { id: targetBook.id }, { copies: updatedCopies, availableCopies, updatedAt: new Date() });
            await maybeNotifyLowInventory(req.dbAdapter, {
                ...targetBook,
                copies: updatedCopies,
                availableCopies
            }, { source: 'transaction-borrow' });
            transactionItems.push({ copyId, bookId: targetBook.id, isbn: targetBook.isbn, status: 'borrowed' });
        }
    const transactionId = generateTransactionId('borrow');
        const transactionData = { id: transactionId, userId, items: transactionItems, type: transactionType, status: 'borrowed', borrowDate, dueDate, returnDate: null, fineAmount: 0, notes: notes || '', renewalCount: 0, createdAt: new Date(), updatedAt: new Date(), createdBy: req.user.id, metadata: { borrowWindowDays } };
        await req.dbAdapter.insertIntoCollection('transactions', transactionData);
        const userBorrowingStats = user.borrowingStats || { totalBorrowed: 0, currentlyBorrowed: 0, totalFines: 0 };
        await req.dbAdapter.updateInCollection('users', { id: userId }, { borrowingStats: { totalBorrowed: (userBorrowingStats.totalBorrowed || 0) + items.length, currentlyBorrowed: (userBorrowingStats.currentlyBorrowed || 0) + items.length, totalFines: userBorrowingStats.totalFines || 0 }, updatedAt: new Date() });

        const borrowerRecipients = buildRecipientList(user.id, user._id, user.userId, user.libraryCardNumber, user.email, user.username);
        if (channelState.hasActiveChannel && borrowerRecipients.length > 0) {
            try {
                await req.dbAdapter.insertIntoCollection('notifications', {
                    title: 'Borrow transaction created',
                    message: `Your borrow transaction ${transactionId} has been recorded. Please return items on time.`,
                    type: 'borrow-created',
                    transactionId,
                    recipients: borrowerRecipients,
                    meta: {
                        transactionId,
                        itemCount: transactionItems.length,
                        status: 'borrowed'
                    },
                    createdAt: new Date(),
                    updatedAt: new Date(),
                    readBy: []
                });
            } catch (notifyError) {
                console.error('Failed to notify borrower about request submission:', notifyError);
            }
        }

        setAuditContext(req, {
            success: true,
            status: 'Completed',
            entityId: transactionId,
            resourceId: transactionId,
            description: `Borrowed ${transactionItems.length} item(s) for ${getBorrowerName(user)}`,
            details: {
                borrower: {
                    id: userId,
                    name: getBorrowerName(user),
                    email: user.email || ''
                },
                transaction: {
                    id: transactionId,
                    type: transactionType,
                    notes: notes || '',
                    dueDate: dueDate.toISOString(),
                    items: transactionItems.map(entry => ({
                        copyId: entry.copyId,
                        bookId: entry.bookId,
                        isbn: entry.isbn
                    }))
                }
            },
            metadata: {
                borrowDate: borrowDate.toISOString(),
                dueDate: dueDate.toISOString(),
                itemCount: transactionItems.length,
                actorId: req.user.id
            }
        });
        res.status(201).json({ message: 'Books borrowed successfully', transactionId, dueDate: dueDate.toISOString() });
    } catch (error) {
        console.error('Borrow books error:', error);
        setAuditContext(req, {
            success: false,
            status: 'Error',
            description: `Borrow request failed: ${error.message}`,
            metadata: {
                errorName: error.name
            },
            details: {
                error: error.message
            }
        });
        res.status(500).json({ message: 'Failed to borrow books' });
    }
});

router.post('/request', verifyToken, logAction('REQUEST', 'transaction'), async (req, res) => {
    try {
        const { userId: providedUserId, items, type = 'regular', notes } = req.body || {};

        const userId = providedUserId || req.user && req.user.id;
        const borrowingSettings = await getBorrowingSettings(req);
        const notificationSettings = await getNotificationSettings(req);
        const channelState = getNotificationChannelState(notificationSettings);
        const transactionType = normalizeTransactionType(type);
        const requestItems = Array.isArray(items) ? items : [];

        setAuditContext(req, {
            metadata: {
                borrowRequest: {
                    type: transactionType,
                    itemCount: requestItems.length
                }
            },
            details: {
                requestedBy: req.user && req.user.id
            }
        });

        if (!userId || requestItems.length === 0) {
            setAuditContext(req, { success: false, status: 'ValidationError', description: 'Request missing userId or items' });
            return res.status(400).json({ message: 'User ID and items are required' });
        }

        const user = await req.dbAdapter.findUserById(userId);
        if (!user) {
            setAuditContext(req, { success: false, status: 'UserNotFound', description: `Request failed: user ${userId} not found`, entityId: userId });
            return res.status(404).json({ message: 'User not found' });
        }

        if (!user.isActive) {
            setAuditContext(req, { success: false, status: 'UserInactive', description: `Request failed: user ${userId} not active`, entityId: userId });
            return res.status(400).json({ message: 'User account is not active' });
        }

        const userRole = (user.role || '').toLowerCase();
        const isStudent = !['admin', 'librarian', 'staff'].includes(userRole);
        if (isStudent) {
            const librarySettings = await getLibrarySettings(req);
            if (!isWithinOperatingHours(librarySettings)) {
                setAuditContext(req, { success: false, status: 'OutsideOperatingHours', description: 'Request blocked: outside library operating hours' });
                return res.status(403).json({ message: 'Borrow requests are only allowed during library operating hours' });
            }
        }

        if (isOvernightType(transactionType) && borrowingSettings.overnightBorrowingEnabled === false) {
            setAuditContext(req, { success: false, status: 'OvernightDisabled', description: 'Request blocked: overnight borrowing disabled' });
            return res.status(403).json({ message: 'Overnight borrowing is currently disabled' });
        }
        if (isAnnualType(transactionType) && borrowingSettings.annualBorrowingEnabled === false) {
            setAuditContext(req, { success: false, status: 'AnnualDisabled', description: 'Request blocked: annual borrowing disabled' });
            return res.status(403).json({ message: 'Annual borrowing is currently disabled' });
        }

        if (isAnnualType(transactionType)) {
            const systemSettings = req.systemSettings;
            const schoolYearStart = new Date(systemSettings.schoolYearStart);
            const schoolYearEnd = new Date(systemSettings.schoolYearEnd);
            const now = new Date();
            if (now < schoolYearStart || now > schoolYearEnd) {
                setAuditContext(req, {
                    success: false,
                    status: 'OutsideSchoolYear',
                    description: 'Request blocked: outside school year for annual borrowing'
                });
                return res.status(403).json({ message: 'Annual borrowing is only allowed during the school year' });
            }
        }

        const parsedMaxBooks = parseInt(borrowingSettings.maxBooksPerTransaction, 10);
        const maxBooksPerTransaction = Number.isFinite(parsedMaxBooks) && parsedMaxBooks > 0 ? parsedMaxBooks : 0;
        if (maxBooksPerTransaction > 0 && requestItems.length > maxBooksPerTransaction) {
            setAuditContext(req, { success: false, status: 'LimitExceeded', description: `Request exceeds maximum ${maxBooksPerTransaction} books per transaction` });
            return res.status(400).json({ message: `Maximum ${maxBooksPerTransaction} books per transaction` });
        }

        const transactionId = generateTransactionId('request');
        const transactionItems = requestItems.map((item, index) => {
            if (typeof item === 'string') {
                return {
                    requestItemId: `${transactionId}_item_${index + 1}`,
                    copyId: item,
                    bookId: '',
                    status: 'requested'
                };
            }

            const copyId = item && item.copyId ? normalizeIdValue(item.copyId) : '';
            const bookId = item && item.bookId ? normalizeIdValue(item.bookId) : '';

            return {
                requestItemId: `${transactionId}_item_${index + 1}`,
                copyId,
                bookId,
                status: 'requested'
            };
        });

        const invalidItems = transactionItems.filter(entry => !entry.copyId && !entry.bookId);
        if (invalidItems.length > 0) {
            setAuditContext(req, { success: false, status: 'ValidationError', description: 'Each requested item must reference a book copy or book ID' });
            return res.status(400).json({ message: 'Each requested item must reference a book copy or book ID' });
        }
        const now = new Date();
        const transactionData = {
            id: transactionId,
            userId,
            items: transactionItems,
            type: transactionType,
            status: 'requested',
            createdAt: now,
            updatedAt: now,
            createdBy: req.user && req.user.id,
            notes: notes || ''
        };

        await req.dbAdapter.insertIntoCollection('transactions', transactionData);

        const borrowerRecipients = buildRecipientList(
            user.id,
            user._id,
            user.userId,
            user.libraryCardNumber,
            user.email,
            user.username
        );

        if (
            notificationSettings.reservationNotifications !== false &&
            channelState.hasActiveChannel &&
            borrowerRecipients.length > 0
        ) {
            try {
                await req.dbAdapter.insertIntoCollection('notifications', {
                    title: 'Borrow request submitted',
                    message: `We received your borrow request ${transactionId}. A librarian will review it shortly.`,
                    type: 'request-submitted',
                    transactionId,
                    recipients: borrowerRecipients,
                    meta: {
                        transactionId,
                        itemCount: transactionItems.length,
                        status: 'requested'
                    },
                    createdAt: new Date(),
                    updatedAt: new Date(),
                    readBy: []
                });
            } catch (notifyError) {
                console.error('Failed to notify borrower about request submission:', notifyError);
            }
        }

        if (notificationSettings.reservationNotifications !== false && channelState.hasActiveChannel) {
            const staffRequestMessage = buildBorrowRequestStaffMessage({
                borrowerName: getBorrowerName(user),
                transactionId,
                transactionType,
                itemCount: transactionItems.length,
                notes: notes || ''
            });
            const requestNotePreview = buildNotePreview(notes);
            try {
                await req.dbAdapter.insertIntoCollection('notifications', {
                    title: 'New borrow request',
                    message: staffRequestMessage,
                    type: 'request',
                    transactionId,
                    recipients: ['staff','librarian','admin'],
                    meta: {
                        transactionId,
                        itemCount: transactionItems.length,
                        borrowerName: getBorrowerName(user),
                        requestType: transactionType,
                        notesPreview: requestNotePreview
                    },
                    createdAt: new Date(),
                    updatedAt: new Date(),
                    readBy: []
                });
            } catch (nerr) {
                console.error('Failed to create persistent notification for request:', nerr);
            }
        }

        setAuditContext(req, {
            success: true,
            status: 'Created',
            entityId: transactionId,
            resourceId: transactionId,
            description: `Created borrow request (${transactionId}) for user ${userId}`,
            metadata: {
                requestId: transactionId,
                itemCount: transactionItems.length,
                actorId: req.user && req.user.id
            }
        });

        res.status(201).json({ message: 'Borrow request created', transactionId, transaction: transactionData });
    } catch (error) {
        console.error('Create request error:', error);
        setAuditContext(req, { success: false, status: 'Error', description: `Request creation failed: ${error.message}`, details: { error: error.message } });
        res.status(500).json({ message: 'Failed to create borrow request' });
    }
});

router.post('/cancel/:id', verifyToken, logAction('CANCEL', 'transaction'), async (req, res) => {
    try {
        const txnIdentifier = req.params.id;
        const reason = req.body && typeof req.body === 'object' ? req.body.reason : '';

        setAuditContext(req, {
            details: {
                transactionId: txnIdentifier,
                reason: reason || undefined
            },
            metadata: {
                cancelRequest: {
                    transactionId: txnIdentifier,
                    actorId: req.user && req.user.id || null
                }
            }
        });

        const transaction = await findTransactionByIdentifier(req.dbAdapter, txnIdentifier);
        if (!transaction) {
            setAuditContext(req, {
                success: false,
                status: 'TransactionNotFound',
                description: `Cancel request failed: transaction ${txnIdentifier} not found`,
                entityId: txnIdentifier
            });
            return res.status(404).json({ message: 'Transaction not found' });
        }

        const transactionOwnerId = normalizeIdValue(transaction.userId || transaction.user?._id || transaction.user?.id);
        const requesterIds = [
            normalizeIdValue(req.user && req.user.id),
            normalizeIdValue(req.user && req.user._id),
            normalizeIdValue(req.user && req.user.userId)
        ].filter(Boolean);

        const privilegedRoles = new Set(['admin', 'librarian', 'staff']);
        const actorRole = (req.user && req.user.role) ? String(req.user.role).toLowerCase() : '';
        const hasOwnership = transactionOwnerId && requesterIds.some(id => id === transactionOwnerId);
        const isPrivileged = privilegedRoles.has(actorRole);

        if (!hasOwnership && !isPrivileged) {
            setAuditContext(req, {
                success: false,
                status: 'Forbidden',
                description: `Cancel request failed: user ${req.user && req.user.id} is not authorized`,
                entityId: transaction.id || transaction._id
            });
            return res.status(403).json({ message: 'You are not allowed to cancel this request' });
        }

        const cancellableStatuses = new Set(['requested', 'pending']);
        if (!cancellableStatuses.has(String(transaction.status || '').toLowerCase())) {
            setAuditContext(req, {
                success: false,
                status: 'InvalidStatus',
                description: `Cancel request failed: transaction ${transaction.id || transaction._id} is not pending`,
                entityId: transaction.id || transaction._id,
                metadata: {
                    currentStatus: transaction.status || null
                }
            });
            return res.status(400).json({ message: 'Only pending requests can be cancelled' });
        }

        const notificationSettings = await getNotificationSettings(req);
        const sendCancellationAlerts = notificationSettings.reservationNotifications !== false;
        let borrowerUser = null;
        let borrowerRecipients = [];
        let borrowerName = 'Borrower';
        const actorName = getBorrowerName(req.user);

        if (sendCancellationAlerts) {
            borrowerUser = await findUserByAnyIdentifier(req.dbAdapter, transaction.userId) || transaction.user || null;
            borrowerRecipients = borrowerUser
                ? buildRecipientList(
                    borrowerUser.id,
                    borrowerUser._id,
                    borrowerUser.userId,
                    borrowerUser.libraryCardNumber,
                    borrowerUser.email,
                    borrowerUser.username
                )
                : buildRecipientList(transaction.userId);
            borrowerName = borrowerUser ? getBorrowerName(borrowerUser) : borrowerName;
        }

        const updatePayload = {
            status: 'cancelled',
            cancelledAt: new Date(),
            cancelledBy: req.user && req.user.id,
            cancelReason: reason || '',
            updatedAt: new Date()
        };

        const txQuery = transaction.id ? { id: transaction.id } : { _id: transaction._id };
        const updatedTransaction = await req.dbAdapter.updateInCollection('transactions', txQuery, updatePayload);
        const responseTransaction = (updatedTransaction && typeof updatedTransaction === 'object')
            ? updatedTransaction
            : { ...transaction, ...updatePayload };

        try {
            const notifications = await req.dbAdapter.findInCollection('notifications', { transactionId: transaction.id || transaction._id });
            for (const notification of notifications) {
                const notificationQuery = notification.id ? { id: notification.id } : { _id: notification._id };
                await req.dbAdapter.updateInCollection('notifications', notificationQuery, {
                    archived: true,
                    updatedAt: new Date(),
                    readBy: Array.from(new Set([...(notification.readBy || []), req.user && req.user.id].filter(Boolean)))
                });
            }
        } catch (notifyError) {
            console.error('Failed to mark notifications after cancel:', notifyError);
        }

        if (sendCancellationAlerts) {
            try {
                const reasonSuffix = reason ? ` Reason: ${reason}` : '';
                if (borrowerRecipients.length > 0) {
                    await notifyRecipients(req, borrowerRecipients, {
                        title: 'Borrow request cancelled',
                        message: `Your borrow request ${transaction.id || transaction._id} was cancelled.${reasonSuffix}`,
                        type: 'request-cancelled',
                        severity: 'info',
                        transactionId: transaction.id || transaction._id,
                        meta: {
                            transactionId: transaction.id || transaction._id,
                            cancelledBy: req.user && req.user.id,
                            reason: reason || ''
                        }
                    });
                }

                await notifyRoles(req, ['staff', 'librarian', 'admin'], {
                    title: 'Borrow request cancelled',
                    message: `${borrowerName} cancelled request ${transaction.id || transaction._id}. ${actorName ? `Handled by ${actorName}.` : ''}${reason ? ` Reason: ${reason}.` : ''}`.trim(),
                    type: 'request-cancelled-alert',
                    severity: 'low',
                    transactionId: transaction.id || transaction._id,
                    meta: {
                        transactionId: transaction.id || transaction._id,
                        actorId: req.user && req.user.id,
                        borrowerId: transaction.userId,
                        reason: reason || '',
                        excludeRoles: ['admin']
                    }
                });
            } catch (notificationError) {
                console.error('Failed to send cancellation notifications:', notificationError);
            }
        }

        setAuditContext(req, {
            success: true,
            status: 'Cancelled',
            description: `Cancelled borrow request ${transaction.id || transaction._id}`,
            entityId: transaction.id || transaction._id,
            resourceId: transaction.id || transaction._id,
            metadata: {
                actorId: req.user && req.user.id,
                reason: reason || '',
                previousStatus: transaction.status || null
            }
        });

        res.json({
            message: 'Borrow request cancelled',
            transactionId: transaction.id || transaction._id,
            transaction: responseTransaction
        });
    } catch (error) {
        console.error('Cancel request error:', error);
        setAuditContext(req, {
            success: false,
            status: 'Error',
            description: `Cancel failed: ${error.message}`,
            details: { error: error.message }
        });
        res.status(500).json({ message: 'Failed to cancel borrow request' });
    }
});

router.post('/approve/:id', verifyToken, requireCirculation, logAction('APPROVE', 'transaction'), async (req, res) => {
    try {
        const txnIdentifier = req.params.id;
        const transaction = await findTransactionByIdentifier(req.dbAdapter, txnIdentifier);
        if (!transaction) return res.status(404).json({ message: 'Transaction not found' });

        if (transaction.status !== 'requested') {
            return res.status(400).json({ message: 'Only requested transactions can be approved' });
        }

        const approverName = getBorrowerName(req.user);

        const items = Array.isArray(transaction.items)
            ? transaction.items.map(item => ({
                ...item,
                copyId: normalizeIdValue(item.copyId),
                bookId: normalizeIdValue(item.bookId),
                requestItemId: normalizeIdValue(item.requestItemId)
            }))
            : [];
        if (items.length === 0) {
            return res.status(400).json({ message: 'Requested transaction has no items' });
        }

        const bodyPayload = req.body && typeof req.body === 'object' ? req.body : {};
        const assignmentPayload = Array.isArray(bodyPayload.items)
            ? bodyPayload.items
            : Array.isArray(bodyPayload.assignments)
                ? bodyPayload.assignments
                : [];

        const normalizedAssignments = assignmentPayload
            .map(entry => ({
                copyId: normalizeIdValue(entry && entry.copyId),
                bookId: normalizeIdValue(entry && entry.bookId),
                requestItemId: normalizeIdValue(entry && entry.requestItemId)
            }))
            .filter(entry => Boolean(entry.copyId));

        if (normalizedAssignments.length > 0) {
            const { mergedItems, missingAssignments } = mergeRequestAssignments(items, normalizedAssignments);
            if (missingAssignments.length > 0) {
                setAuditContext(req, {
                    success: false,
                    status: 'ValidationFailed',
                    description: 'Missing copy assignments for one or more request items',
                    details: { missingAssignments }
                });
                return res.status(400).json({ message: 'Missing copy assignments for requested items', details: missingAssignments });
            }
            items.length = 0;
            mergedItems.forEach(entry => items.push({
                ...entry,
                copyId: normalizeIdValue(entry.copyId),
                bookId: normalizeIdValue(entry.bookId),
                requestItemId: normalizeIdValue(entry.requestItemId)
            }));
        }

        const allBooks = await req.dbAdapter.findInCollection('books', {});

        const copyLookup = new Map();
        allBooks.forEach(book => {
            (book.copies || []).forEach(copy => {
                const trackedCopyId = normalizeIdValue(copy.copyId);
                if (trackedCopyId) {
                    copyLookup.set(trackedCopyId, { book, copy });
                }
            });
        });

        const normalizeLower = (value) => {
            const normalized = normalizeIdValue(value);
            return normalized ? normalized.toLowerCase() : '';
        };

        const duplicateCopyAssignments = [];
        const missingCopyAssignments = [];
        const copyTracker = new Set();

        items.forEach((item, idx) => {
            const normalizedCopyId = normalizeIdValue(item.copyId);
            if (!normalizedCopyId) {
                missingCopyAssignments.push({
                    index: idx,
                    reason: 'missing-copyId',
                    requestItemId: item.requestItemId || null,
                    bookId: normalizeIdValue(item.bookId) || null
                });
                return;
            }

            const copyKey = normalizedCopyId.toLowerCase();
            if (copyTracker.has(copyKey)) {
                duplicateCopyAssignments.push({
                    index: idx,
                    copyId: normalizedCopyId,
                    requestItemId: item.requestItemId || null
                });
                return;
            }

            copyTracker.add(copyKey);
            item.copyId = normalizedCopyId;
            item.bookId = normalizeIdValue(item.bookId);
        });

        if (missingCopyAssignments.length > 0) {
            setAuditContext(req, {
                success: false,
                status: 'ValidationFailed',
                description: 'Copy assignments are required for each requested item',
                details: { missingCopyAssignments }
            });
            return res.status(400).json({ message: 'Copy assignments are required for each requested item', details: missingCopyAssignments });
        }

        if (duplicateCopyAssignments.length > 0) {
            setAuditContext(req, {
                success: false,
                status: 'ValidationFailed',
                description: 'Invalid or duplicate copy assignments provided',
                details: { duplicateCopyAssignments }
            });
            return res.status(400).json({ message: 'Invalid or duplicate copy assignments provided', details: duplicateCopyAssignments });
        }

        const validationFailures = [];
        const readyToUpdate = []; // { targetBook, targetCopy, copyId }

        for (const item of items) {
            const copyId = item.copyId;
            if (!copyId) {
                validationFailures.push({ item, reason: 'missing-copyId' });
                continue;
            }

            let targetBook = null;
            let targetCopy = null;

            const lookupEntry = copyLookup.get(normalizeIdValue(copyId));
            if (lookupEntry) {
                targetBook = lookupEntry.book;
                targetCopy = lookupEntry.copy;
            } else {
                for (const book of allBooks) {
                    const copy = (book.copies || []).find(c => String(c.copyId) === String(copyId));
                    if (copy) {
                        targetBook = book;
                        targetCopy = copy;
                        break;
                    }
                }
            }

            if (!targetBook || !targetCopy) {
                validationFailures.push({ item, reason: 'copy-not-found' });
                continue;
            }

            const canonicalBookId = normalizeIdValue(targetBook.id || targetBook._id || targetBook.bookId || targetBook.isbn);
            if (!item.bookId) {
                item.bookId = canonicalBookId;
            } else if (canonicalBookId && canonicalBookId !== normalizeIdValue(item.bookId)) {
                validationFailures.push({ item, reason: 'book-mismatch', expectedBookId: canonicalBookId });
                continue;
            }

            if (String(targetCopy.status).toLowerCase() !== 'available') {
                validationFailures.push({ item, reason: 'copy-unavailable', copyStatus: targetCopy.status });
                continue;
            }

            readyToUpdate.push({ targetBook, targetCopy, copyId });
        }

        if (validationFailures.length > 0) {
            setAuditContext(req, {
                success: false,
                status: 'ValidationFailed',
                description: 'Cannot approve request: one or more copies missing or unavailable',
                details: { validationFailures }
            });
            return res.status(400).json({ message: 'One or more requested copies are missing or unavailable', details: validationFailures });
        }

        const updatedBooks = [];
        for (const ready of readyToUpdate) {
            const { targetBook, copyId } = ready;
            const updatedCopies = (targetBook.copies || []).map(c => c.copyId === copyId ? { ...c, status: 'borrowed', updatedAt: new Date(), updatedBy: req.user.id } : c);
            const bookQuery = targetBook.id ? { id: targetBook.id } : { _id: targetBook._id };
            const availableCopies = updatedCopies.filter(c => c.status === 'available').length;
            await req.dbAdapter.updateInCollection('books', bookQuery, { copies: updatedCopies, availableCopies, updatedAt: new Date() });
            await maybeNotifyLowInventory(req.dbAdapter, {
                ...targetBook,
                copies: updatedCopies,
                availableCopies
            }, { source: 'transaction-approve' });
            updatedBooks.push({ bookId: targetBook.id || targetBook._id, copyId });
        }

        const borrowingSettings = await getBorrowingSettings(req);
        const notificationSettings = await getNotificationSettings(req);
        const channelState = getNotificationChannelState(notificationSettings);
        const transactionType = normalizeTransactionType(transaction.type);
        if (isOvernightType(transactionType) && borrowingSettings.overnightBorrowingEnabled === false) {
            setAuditContext(req, {
                success: false,
                status: 'OvernightDisabled',
                description: 'Approve request blocked: overnight borrowing disabled'
            });
            return res.status(403).json({ message: 'Overnight borrowing is currently disabled' });
        }
        if (isAnnualType(transactionType) && borrowingSettings.annualBorrowingEnabled === false) {
            setAuditContext(req, {
                success: false,
                status: 'AnnualDisabled',
                description: 'Approve request blocked: annual borrowing disabled'
            });
            return res.status(403).json({ message: 'Annual borrowing is currently disabled' });
        }

        if (isAnnualType(transactionType)) {
            const systemSettings = req.systemSettings;
            const schoolYearStart = new Date(systemSettings.schoolYearStart);
            const schoolYearEnd = new Date(systemSettings.schoolYearEnd);
            const now = new Date();
            if (now < schoolYearStart || now > schoolYearEnd) {
                setAuditContext(req, {
                    success: false,
                    status: 'OutsideSchoolYear',
                    description: 'Approve request blocked: outside school year for annual borrowing'
                });
                return res.status(403).json({ message: 'Annual borrowing is only allowed during the school year' });
            }
        }

        const borrowWindowDays = resolveBorrowWindowDays(transactionType, borrowingSettings);
        const borrowDate = new Date();
        const dueDate = calculateDueDate(borrowDate, borrowWindowDays);

        const reservationPeriodDays = Number(borrowingSettings.reservationPeriodDays) || 3;
        const reservationExpiresAt = new Date(borrowDate);
        reservationExpiresAt.setDate(reservationExpiresAt.getDate() + reservationPeriodDays);

        const txQuery = transaction.id ? { id: transaction.id } : { _id: transaction._id };
        const updatedTransaction = await req.dbAdapter.updateInCollection('transactions', txQuery, {
            status: 'borrowed',
            borrowDate,
            dueDate,
            reservationExpiresAt,
            updatedAt: new Date(),
            updatedBy: req.user.id,
            items: items.map(it => ({ ...it, status: 'borrowed' }))
        });

        const borrowerLookupVariants = [
            { id: transaction.userId },
            { _id: transaction.userId },
            { userId: transaction.userId },
            { libraryCardNumber: transaction.userId }
        ];

        let user = null;
        for (const variant of borrowerLookupVariants) {
            user = await req.dbAdapter.findOneInCollection('users', variant);
            if (user) {
                break;
            }
        }
        if (user) {
            try {
                const stats = user.borrowingStats || { totalBorrowed: 0, currentlyBorrowed: 0, totalFines: 0, totalReturned: 0 };
                const updatedStats = {
                    totalBorrowed: (stats.totalBorrowed || 0) + items.length,
                    currentlyBorrowed: (stats.currentlyBorrowed || 0) + items.length,
                    totalFines: stats.totalFines || 0,
                    totalReturned: stats.totalReturned || 0
                };
                const userQuery = user.id ? { id: user.id } : { _id: user._id };
                await req.dbAdapter.updateInCollection('users', userQuery, { borrowingStats: updatedStats, updatedAt: new Date() });
            } catch (statsErr) {
                console.error('Failed to update borrower stats after approval:', statsErr);
            }

            const borrowerRecipients = buildRecipientList(user.id, user._id, user.userId, user.libraryCardNumber, user.email, user.username);
            if (
                notificationSettings.reservationNotifications !== false &&
                channelState.hasActiveChannel &&
                borrowerRecipients.length > 0
            ) {
                try {
                    const dueDateValue = dueDate instanceof Date ? dueDate : new Date(dueDate);
                    const dueDateIso = Number.isNaN(dueDateValue.getTime()) ? null : dueDateValue.toISOString();
                    const friendlyDueDate = dueDateIso ? dueDateIso.split('T')[0] : 'the scheduled due date';

                    const reservationExpiresValue = reservationExpiresAt instanceof Date ? reservationExpiresAt : new Date(reservationExpiresAt);
                    const reservationExpiresIso = Number.isNaN(reservationExpiresValue.getTime()) ? null : reservationExpiresValue.toISOString();
                    const friendlyPickupDate = reservationExpiresIso ? reservationExpiresIso.split('T')[0] : 'the pickup deadline';

                    await req.dbAdapter.insertIntoCollection('notifications', {
                        title: 'Borrow request approved',
                        message: `Your borrow request ${transaction.id || transaction._id} has been approved${approverName ? ` by ${approverName}` : ''}. Please pick up your items by ${friendlyPickupDate}. Items are due on ${friendlyDueDate}.`,
                        type: 'request-approved',
                        transactionId: transaction.id || transaction._id,
                        recipients: borrowerRecipients,
                        meta: {
                            transactionId: transaction.id || transaction._id,
                            dueDate: dueDateIso,
                            reservationExpiresAt: reservationExpiresIso,
                            itemCount: items.length,
                            status: 'borrowed',
                            approvedBy: req.user.id,
                            approvedByName: approverName
                        },
                        createdAt: new Date(),
                        updatedAt: new Date(),
                        readBy: []
                    });
                } catch (notifyError) {
                    console.error('Failed to notify borrower about request approval:', notifyError);
                }
            }
        }
        else {
            console.warn('Approve request warning: borrower not found for transaction', transaction.id || transaction._id);
        }

        setAuditContext(req, {
            success: true,
            status: 'Approved',
            entityId: updatedTransaction.id || updatedTransaction._id,
            resourceId: updatedTransaction.id || updatedTransaction._id,
            description: `Approved borrow request ${transaction.id || transaction._id}`,
            metadata: { approvedBy: req.user.id }
        });

        try {
            const notifications = await req.dbAdapter.findInCollection('notifications', { transactionId: transaction.id || transaction._id });
            for (const n of notifications) {
                const q = n.id ? { id: n.id } : { _id: n._id };
                await req.dbAdapter.updateInCollection('notifications', q, { readBy: Array.from(new Set([...(n.readBy || []), req.user.id])), updatedAt: new Date(), archived: true });
            }
        } catch (nerr) {
            console.error('Failed to mark notifications after approve:', nerr);
        }

        res.json({ message: 'Borrow request approved', transactionId: updatedTransaction.id || updatedTransaction._id });
    } catch (error) {
        console.error('Approve request error:', error);
        setAuditContext(req, { success: false, status: 'Error', description: `Approve failed: ${error.message}`, details: { error: error.message } });
        res.status(500).json({ message: 'Failed to approve request' });
    }
});

router.post('/reject/:id', verifyToken, requireCirculation, logAction('REJECT', 'transaction'), async (req, res) => {
    try {
        const txnIdentifier = req.params.id;
        const { reason } = req.body || {};
        const transaction = await findTransactionByIdentifier(req.dbAdapter, txnIdentifier);
        if (!transaction) return res.status(404).json({ message: 'Transaction not found' });

        if (transaction.status !== 'requested') {
            return res.status(400).json({ message: 'Only requested transactions can be rejected' });
        }

        const notificationSettings = await getNotificationSettings(req);
        const channelState = getNotificationChannelState(notificationSettings);

        const txQuery = transaction.id ? { id: transaction.id } : { _id: transaction._id };
        const updatedTransaction = await req.dbAdapter.updateInCollection('transactions', txQuery, {
            status: 'rejected',
            rejectedAt: new Date(),
            rejectedBy: req.user.id,
            rejectReason: reason || ''
        });

        if (notificationSettings.reservationNotifications !== false && channelState.hasActiveChannel) {
            try {
                await req.dbAdapter.insertIntoCollection('notifications', {
                    title: 'Borrow request rejected',
                    message: `Your borrow request ${transaction.id || transaction._id} was rejected${reason ? `: ${reason}` : ''}`,
                    type: 'request-rejected',
                    transactionId: transaction.id || transaction._id,
                    recipients: [transaction.userId],
                    meta: { transactionId: transaction.id || transaction._id },
                    createdAt: new Date(),
                    readBy: []
                });
            } catch (nerr) {
                console.error('Failed to create notification for rejection:', nerr);
            }
        }

        setAuditContext(req, {
            success: true,
            status: 'Rejected',
            entityId: updatedTransaction.id || updatedTransaction._id,
            resourceId: updatedTransaction.id || updatedTransaction._id,
            description: `Rejected borrow request ${transaction.id || transaction._id}`,
            metadata: { rejectedBy: req.user.id, reason: reason || '' }
        });

        res.json({ message: 'Borrow request rejected', transactionId: updatedTransaction.id || updatedTransaction._id });
    } catch (error) {
        console.error('Reject request error:', error);
        setAuditContext(req, { success: false, status: 'Error', description: `Reject failed: ${error.message}`, details: { error: error.message } });
        res.status(500).json({ message: 'Failed to reject request' });
    }
});

router.post('/:id/missing', verifyToken, requireCirculation, logAction('MARK_MISSING', 'transaction'), async (req, res) => {
    try {
        const txnIdentifier = req.params.id;
        const { reason } = req.body || {};

        setAuditContext(req, {
            metadata: {
                missingRequest: {
                    transactionId: txnIdentifier,
                    providedReason: reason || ''
                }
            }
        });

        const transaction = await findTransactionByIdentifier(req.dbAdapter, txnIdentifier);
        if (!transaction) {
            setAuditContext(req, {
                success: false,
                status: 'TransactionNotFound',
                description: `Missing mark failed: transaction ${txnIdentifier} not found`,
                entityId: txnIdentifier
            });
            return res.status(404).json({ message: 'Transaction not found' });
        }

        const normalizedStatus = normalizeStatus(transaction.status);
        const allowedStatuses = new Set(['active', 'overdue', 'renewed']);
        if (!allowedStatuses.has(normalizedStatus)) {
            setAuditContext(req, {
                success: false,
                status: 'InvalidStatus',
                description: `Missing mark failed: transaction ${transaction.id || transaction._id} is not active`,
                entityId: transaction.id || transaction._id,
                metadata: { currentStatus: transaction.status || null }
            });
            return res.status(400).json({ message: 'Only active or overdue transactions can be marked as missing' });
        }

        const outstandingItems = (transaction.items || []).filter(item => item && item.status !== 'returned');
        if (outstandingItems.length === 0) {
            setAuditContext(req, {
                success: false,
                status: 'NoOutstandingItems',
                description: `Missing mark failed: no outstanding items for ${transaction.id || transaction._id}`,
                entityId: transaction.id || transaction._id
            });
            return res.status(400).json({ message: 'All items on this transaction are already returned' });
        }

        const missingCopyIds = Array.from(new Set(
            outstandingItems
                .map(item => normalizeIdValue(item.copyId))
                .filter(Boolean)
        ));

        if (missingCopyIds.length === 0) {
            setAuditContext(req, {
                success: false,
                status: 'MissingCopyIds',
                description: `Missing mark failed: no reference IDs for outstanding items (${transaction.id || transaction._id})`
            });
            return res.status(400).json({ message: 'Outstanding items do not have reference IDs to flag as missing' });
        }

        const { copiesLookup } = await loadBorrowingLookups(req.dbAdapter);
        const pendingBookUpdates = new Map();
        const unresolvedCopies = [];
        const now = new Date();

        missingCopyIds.forEach(copyId => {
            const lookup = copiesLookup.get(String(copyId));
            if (!lookup) {
                unresolvedCopies.push(copyId);
                return;
            }

            const book = lookup.book;
            const bookKey = book.id || book._id;
            if (!pendingBookUpdates.has(bookKey)) {
                pendingBookUpdates.set(bookKey, {
                    book,
                    copies: Array.isArray(book.copies) ? [...book.copies] : []
                });
            }

            const entry = pendingBookUpdates.get(bookKey);
            entry.copies = entry.copies.map(copy =>
                copy.copyId === lookup.copy.copyId
                    ? { ...copy, status: 'lost', updatedAt: now, updatedBy: req.user.id }
                    : copy
            );
        });

        for (const { book, copies } of pendingBookUpdates.values()) {
            const bookQuery = book.id ? { id: book.id } : { _id: book._id };
            const availableCopies = copies.filter(c => c.status === 'available').length;
            await req.dbAdapter.updateInCollection('books', bookQuery, {
                copies,
                availableCopies,
                updatedAt: now
            });
        }

        const missingCopySet = new Set(missingCopyIds);
        const updatedItems = (transaction.items || []).map(item => {
            if (!item) return item;
            const copyKey = normalizeIdValue(item.copyId);
            if (!copyKey || !missingCopySet.has(copyKey)) {
                return item;
            }
            return {
                ...item,
                status: 'missing',
                missingReportedAt: now,
                missingReason: reason || ''
            };
        });

        const txQuery = transaction.id ? { id: transaction.id } : { _id: transaction._id };
        await req.dbAdapter.updateInCollection('transactions', txQuery, {
            status: 'missing',
            items: updatedItems,
            missingReportedAt: now,
            missingReportedBy: req.user.id,
            missingReason: reason || '',
            updatedAt: now
        });

        let borrower = await findUserByAnyIdentifier(req.dbAdapter, transaction.userId);
        if (!borrower && transaction.user) {
            borrower = transaction.user;
        }

        if (borrower) {
            const stats = borrower.borrowingStats || { totalBorrowed: 0, currentlyBorrowed: 0, totalFines: 0, totalReturned: 0 };
            const missingCount = missingCopyIds.length;
            const borrowerQuery = borrower.id ? { id: borrower.id } : { _id: borrower._id };
            await req.dbAdapter.updateInCollection('users', borrowerQuery, {
                borrowingStats: {
                    ...stats,
                    currentlyBorrowed: Math.max(0, (stats.currentlyBorrowed || 0) - missingCount)
                },
                updatedAt: now
            });
        }

        const notificationSettings = await getNotificationSettings(req);
        const channelState = getNotificationChannelState(notificationSettings);
        const borrowerRecipients = borrower
            ? buildRecipientList(
                borrower.id,
                borrower._id,
                borrower.userId,
                borrower.libraryCardNumber,
                borrower.email,
                borrower.username
            )
            : buildRecipientList(transaction.userId);

        if (channelState?.hasActiveChannel && borrowerRecipients.length > 0) {
            try {
                await notifyRecipients(req, borrowerRecipients, {
                    title: 'Transaction flagged as missing',
                    message: `Transaction ${transaction.id || transaction._id} has been marked as missing. Please coordinate with the library to settle this record.${reason ? ` Reason: ${reason}.` : ''}`,
                    type: 'missing',
                    severity: 'high',
                    transactionId: transaction.id || transaction._id,
                    meta: {
                        transactionId: transaction.id || transaction._id,
                        missingCopies: missingCopyIds,
                        reason: reason || ''
                    }
                });
            } catch (notifyError) {
                console.error('Failed to notify borrower about missing transaction:', notifyError);
            }
        }

        try {
            await notifyRoles(req, ['staff', 'librarian', 'admin'], {
                title: 'Missing transaction recorded',
                message: `${getBorrowerName(borrower || transaction.user || {})} has a transaction flagged as missing (${transaction.id || transaction._id}).`,
                type: 'missing-alert',
                severity: 'high',
                transactionId: transaction.id || transaction._id,
                meta: {
                    transactionId: transaction.id || transaction._id,
                    actorId: req.user.id,
                    missingCopies: missingCopyIds,
                    reason: reason || ''
                }
            });
        } catch (staffNotifyError) {
            console.error('Failed to notify staff about missing transaction:', staffNotifyError);
        }

        setAuditContext(req, {
            success: true,
            status: 'MarkedMissing',
            entityId: transaction.id || transaction._id,
            resourceId: transaction.id || transaction._id,
            description: `Marked transaction ${transaction.id || transaction._id} as missing`,
            metadata: {
                actorId: req.user.id,
                reason: reason || '',
                missingCopies: missingCopyIds,
                unresolvedCopies
            }
        });

        res.json({
            message: 'Transaction marked as missing',
            transactionId: transaction.id || transaction._id,
            missingCopies: missingCopyIds,
            unresolvedCopies
        });
    } catch (error) {
        console.error('Mark missing error:', error);
        setAuditContext(req, {
            success: false,
            status: 'Error',
            description: `Missing mark failed: ${error.message}`,
            details: { error: error.message }
        });
        res.status(500).json({ message: 'Failed to mark transaction as missing' });
    }
});

router.post('/return', verifyToken, requireCirculation, logAction('RETURN', 'transaction'), async(req, res) => {
    try {
        const { transactions, returnDate, notes } = req.body || {};

        const transactionsPayload = Array.isArray(transactions) ? transactions : [];
        setAuditContext(req, {
            metadata: {
                returnRequest: {
                    transactionCount: transactionsPayload.length,
                    transactionIds: transactionsPayload
                        .map(entry => entry && entry.transactionId)
                        .filter(Boolean),
                    providedReturnDate: returnDate || null
                }
            },
            details: {
                notes: notes || ''
            }
        });

        if (!Array.isArray(transactions) || transactions.length === 0) {
            setAuditContext(req, {
                success: false,
                status: 'ValidationError',
                description: 'Return request missing transactions payload'
            });
            return res.status(400).json({ message: 'Transactions payload is required' });
        }

        const borrowingSettings = await getBorrowingSettings(req);
        const notificationSettings = await getNotificationSettings(req);
        const channelState = getNotificationChannelState(notificationSettings);
        const returnNotificationContext = {
            notificationSettings,
            channelState,
            actorName: getBorrowerName(req.user || {})
        };
        const results = [];
        let totalReturnedItems = 0;

        for (const entry of transactions) {
            if (!entry || !entry.transactionId) {
                setAuditContext(req, {
                    success: false,
                    status: 'ValidationError',
                    description: 'Return request is missing transactionId for one or more entries'
                });
                return res.status(400).json({ message: 'Each transaction entry must include a transactionId' });
            }

            const transaction = await findTransactionByIdentifier(req.dbAdapter, entry.transactionId);
            if (!transaction) {
                setAuditContext(req, {
                    success: false,
                    status: 'TransactionNotFound',
                    description: `Return request failed: transaction not found (${entry.transactionId})`,
                    entityId: entry.transactionId,
                    metadata: {
                        transactionId: entry.transactionId
                    }
                });
                return res.status(404).json({ message: `Transaction not found: ${entry.transactionId}` });
            }

            const itemsToProcess = Array.isArray(entry.items) && entry.items.length > 0
                ? entry.items.filter(item => item && item.copyId)
                : (transaction.items || []).filter(item => item.status !== 'returned').map(item => ({ copyId: item.copyId }));

            if (itemsToProcess.length === 0) {
                setAuditContext(req, {
                    success: false,
                    status: 'NoItemsToReturn',
                    description: `Return request failed: no returnable items for transaction ${entry.transactionId}`,
                    metadata: {
                        transactionId: entry.transactionId
                    }
                });
                return res.status(400).json({ message: `No returnable items found for transaction ${entry.transactionId}` });
            }

            const result = await processReturnTransaction({
                dbAdapter: req.dbAdapter,
                transaction,
                items: itemsToProcess,
                actorId: req.user.id,
                notes: notes || '',
                returnDateOverride: returnDate || null,
                borrowingSettings,
                notificationOptions: returnNotificationContext
            });

            totalReturnedItems += result.returnedItems;
            results.push({
                transactionId: transaction.id || transaction._id,
                ...result
            });
        }

        const singleTransactionId = results.length === 1 ? results[0].transactionId : null;

        setAuditContext(req, {
            success: true,
            status: 'Completed',
            description: `Returned ${totalReturnedItems} item(s) across ${results.length} transaction(s)`,
            entityId: singleTransactionId || undefined,
            resourceId: singleTransactionId || undefined,
            metadata: {
                totalReturnedItems,
                processedTransactions: results.map(entry => entry.transactionId),
                actorId: req.user.id,
                providedReturnDate: returnDate || null
            },
            details: {
                results
            }
        });

        res.json({
            message: `Processed ${formatCountLabel(totalReturnedItems, 'item')} across ${formatCountLabel(results.length, 'transaction')}`,
            results
        });
    } catch (error) {
        console.error('Return books error:', error);
        setAuditContext(req, {
            success: false,
            status: error.message === 'Transaction not found' ? 'TransactionNotFound' : 'Error',
            description: `Return request failed: ${error.message}`,
            metadata: {
                errorName: error.name
            },
            details: {
                error: error.message
            }
        });
        if (error.message === 'Transaction not found') {
            return res.status(404).json({ message: error.message });
        }
        if (error.message === 'Transaction already returned' || error.message === 'No items provided for return') {
            return res.status(400).json({ message: error.message });
        }
        res.status(500).json({ message: 'Failed to return books' });
    }
});

router.post('/:id/return', verifyToken, requireCirculation, logAction('RETURN', 'transaction'), async(req, res) => {
    try {
        setAuditContext(req, {
            details: {
                transactionId: req.params.id
            },
            metadata: {
                returnRequest: {
                    transactionId: req.params.id,
                    providedReturnDate: (req.body && req.body.returnDate) || null,
                    hasNotes: Boolean(req.body && req.body.notes)
                }
            }
        });
        const borrowingSettings = await getBorrowingSettings(req);
        const notificationSettings = await getNotificationSettings(req);
        const channelState = getNotificationChannelState(notificationSettings);
        const returnNotificationContext = {
            notificationSettings,
            channelState,
            actorName: getBorrowerName(req.user || {})
        };
        const transaction = await findTransactionByIdentifier(req.dbAdapter, req.params.id);
        if (!transaction) {
            setAuditContext(req, {
                success: false,
                status: 'TransactionNotFound',
                description: `Return request failed: transaction ${req.params.id} not found`,
                entityId: req.params.id
            });
            return res.status(404).json({ message: 'Transaction not found' });
        }

        const itemsToProcess = (transaction.items || [])
            .filter(item => item && item.copyId && item.status !== 'returned')
            .map(item => ({ copyId: item.copyId }));
        if (itemsToProcess.length === 0) {
            setAuditContext(req, {
                success: false,
                status: 'NoItemsToReturn',
                description: `Return request failed: no items to return for transaction ${req.params.id}`,
                entityId: transaction.id || transaction._id || req.params.id
            });
            return res.status(400).json({ message: 'No items to return for this transaction' });
        }

        const result = await processReturnTransaction({
            dbAdapter: req.dbAdapter,
            transaction,
            items: itemsToProcess,
            actorId: req.user.id,
            notes: (req.body && req.body.notes) || '',
            returnDateOverride: (req.body && req.body.returnDate) || null,
            borrowingSettings,
            notificationOptions: returnNotificationContext
        });

        setAuditContext(req, {
            success: true,
            status: 'Completed',
            entityId: transaction.id || transaction._id,
            resourceId: transaction.id || transaction._id,
            description: `Returned ${result.returnedItems} item(s) for transaction ${transaction.id || transaction._id}`,
            metadata: {
                actorId: req.user.id,
                returnedItems: result.returnedItems,
                providedReturnDate: (req.body && req.body.returnDate) || null,
                notes: (req.body && req.body.notes) || ''
            },
            details: {
                result
            }
        });

        res.json({
            message: 'Transaction returned successfully',
            ...result
        });
    } catch (error) {
        console.error('Return transaction error:', error);
        setAuditContext(req, {
            success: false,
            status: error.message === 'Transaction not found' ? 'TransactionNotFound' : error.message === 'Transaction already returned' ? 'AlreadyReturned' : 'Error',
            description: `Return request failed: ${error.message}`,
            metadata: {
                errorName: error.name
            },
            details: {
                error: error.message
            }
        });
        if (error.message === 'Transaction already returned') {
            return res.status(400).json({ message: error.message });
        }
        if (error.message === 'Transaction not found') {
            return res.status(404).json({ message: error.message });
        }
        res.status(500).json({ message: 'Failed to return transaction' });
    }
});

router.post('/expire-reservations', verifyToken, requireCirculation, logAction('EXPIRE_RESERVATIONS', 'transaction'), async (req, res) => {
    try {
        const now = new Date();

        const expiredReservations = await req.dbAdapter.findInCollection('transactions', {
            status: 'borrowed',
            reservationExpiresAt: { $lt: now }
        });

        if (expiredReservations.length === 0) {
            return res.json({ message: 'No expired reservations found', expiredCount: 0 });
        }

        let expiredCount = 0;
        const results = [];

        for (const transaction of expiredReservations) {
            try {

                const hasActiveItems = (transaction.items || []).some(item => item.status !== 'returned');
                if (!hasActiveItems) {
                    continue; // Skip already returned transactions
                }

                const txQuery = transaction.id ? { id: transaction.id } : { _id: transaction._id };
                await req.dbAdapter.updateInCollection('transactions', txQuery, {
                    status: 'reservation-expired',
                    reservationExpiredAt: now,
                    updatedAt: now,
                    notes: (transaction.notes || '') + ' [Reservation expired]'
                });

                const allBooks = await req.dbAdapter.findInCollection('books', {});
                for (const item of transaction.items || []) {
                    if (item.status !== 'returned') {

                        for (const book of allBooks) {
                            const copy = book.copies?.find(c => c.copyId === item.copyId);
                            if (copy && copy.status === 'borrowed') {
                                const updatedCopies = book.copies.map(c =>
                                    c.copyId === item.copyId ? { ...c, status: 'available', updatedAt: now } : c
                                );
                                const bookQuery = book.id ? { id: book.id } : { _id: book._id };
                                await req.dbAdapter.updateInCollection('books', bookQuery, {
                                    copies: updatedCopies,
                                    availableCopies: updatedCopies.filter(c => c.status === 'available').length,
                                    updatedAt: now
                                });
                                break;
                            }
                        }
                    }
                }

                let user = await req.dbAdapter.findOneInCollection('users', { id: transaction.userId });
                if (!user) user = await req.dbAdapter.findOneInCollection('users', { _id: transaction.userId });
                if (user) {
                    const stats = user.borrowingStats || { totalBorrowed: 0, currentlyBorrowed: 0, totalFines: 0, totalReturned: 0 };
                    const activeItems = (transaction.items || []).filter(item => item.status !== 'returned').length;
                    const updatedStats = {
                        ...stats,
                        currentlyBorrowed: Math.max(0, (stats.currentlyBorrowed || 0) - activeItems)
                    };
                    const userQuery = user.id ? { id: user.id } : { _id: user._id };
                    await req.dbAdapter.updateInCollection('users', userQuery, { borrowingStats: updatedStats, updatedAt: now });
                }

                expiredCount++;
                results.push({
                    transactionId: transaction.id || transaction._id,
                    userId: transaction.userId,
                    itemCount: (transaction.items || []).filter(item => item.status !== 'returned').length
                });

            } catch (error) {
                console.error(`Failed to expire reservation for transaction ${transaction.id || transaction._id}:`, error);
            }
        }

        setAuditContext(req, {
            success: true,
            status: 'Completed',
            description: `Expired ${expiredCount} reservations`,
            metadata: {
                expiredCount,
                actorId: req.user.id
            },
            details: {
                results
            }
        });

        res.json({
            message: `Expired ${expiredCount} reservations`,
            expiredCount,
            results
        });
    } catch (error) {
        console.error('Expire reservations error:', error);
        setAuditContext(req, {
            success: false,
            status: 'Error',
            description: `Expire reservations failed: ${error.message}`,
            details: { error: error.message }
        });
        res.status(500).json({ message: 'Failed to expire reservations' });
    }
});

module.exports = router;
module.exports.enrichTransactionsWithBookMetadata = enrichTransactionsWithBookMetadata;
```

## transactions_fixed.js

| Field | Details |
| --- | --- |
| Program Name | transactions_fixed.js |
| Description | API route handler for transactions fixed resources. |
| Called by | None |
| Table used | transactions |
|  |  |
| Programmer | Nazel Asca√±o |
| Date created | 12/14/2025 |
| Revision Date | TBD |
| Revision / description of change | None |

```javascript
Ôªøconst express = require('express');
const { verifyToken, requireCirculation, logAction, setAuditContext } = require('../middleware/customAuth');
const { generateTransactionId, ensureTransactionId } = require('../utils/transactionIds');
const {
    getSettingsSnapshot,
    BORROWING_DEFAULTS,
    NOTIFICATION_DEFAULTS,
    getNotificationChannelState
} = require('../utils/settingsCache');
const router = express.Router();

const ensureSettingsSnapshot = async (req) => {
    if (req.settingsSnapshot) {
        return req.settingsSnapshot;
    }
    const snapshot = await getSettingsSnapshot(req.dbAdapter);
    req.settingsSnapshot = snapshot;
    if (!req.systemSettings) {
        req.systemSettings = snapshot.system;
    }
    return snapshot;
};

const getBorrowingSettings = async (req) => {
    try {
        const snapshot = await ensureSettingsSnapshot(req);
        return snapshot?.borrowing || BORROWING_DEFAULTS;
    } catch (error) {
        console.error('Borrowing settings load error:', error);
        return BORROWING_DEFAULTS;
    }
};

const getNotificationSettings = async (req) => {
    try {
        const snapshot = await ensureSettingsSnapshot(req);
        return snapshot?.notifications || NOTIFICATION_DEFAULTS;
    } catch (error) {
        console.error('Notification settings load error:', error);
        return NOTIFICATION_DEFAULTS;
    }
};

const normalizeTransactionType = (value) => {
    if (!value) return 'regular';
    return String(value).trim().toLowerCase();
};

const isOvernightType = (type) => normalizeTransactionType(type) === 'overnight';
const isAnnualType = (type) => {
    const normalized = normalizeTransactionType(type);
    return normalized === 'annual' || normalized === 'annual-set';
};

const resolveBorrowWindowDays = (type, borrowingSettings) => {
    if (isOvernightType(type)) {
        return 1;
    }
    const fallback = BORROWING_DEFAULTS.maxBorrowDays || 14;
    const configured = Number(borrowingSettings?.maxBorrowDays) || fallback;
    return configured > 0 ? configured : fallback;
};

const calculateDueDate = (borrowDate, maxBorrowDays = 14) => {
    const dueDate = new Date(borrowDate);
    dueDate.setDate(dueDate.getDate() + maxBorrowDays);
    return dueDate;
};

const MS_IN_DAY = 24 * 60 * 60 * 1000;

const calculateFine = (dueDate, returnDate, options = {}) => {
    const finePerDay = Number(options.finePerDay) || 5;
    const gracePeriodDays = Number(options.gracePeriodDays) || 0;
    if (!dueDate || !returnDate || returnDate <= dueDate) return 0;
    const diffTime = returnDate - dueDate;
    const diffDays = Math.ceil(diffTime / MS_IN_DAY);
    const chargeableDays = Math.max(0, diffDays - gracePeriodDays);
    if (chargeableDays === 0) {
        return 0;
    }
    return chargeableDays * finePerDay;
};

const normalizeStatus = (status) => {
    if (!status) return 'pending';
    return status === 'borrowed' ? 'active' : status;
};

const buildLookupMap = (records, keysResolver) => {
    const map = new Map();
    records.forEach(record => {
        const keys = keysResolver(record);
        keys.filter(Boolean).forEach(key => {
            map.set(String(key), record);
        });
    });
    return map;
};

const getBorrowerName = (user) => {
    if (!user) return 'Unknown Borrower';
    if (user.fullName) return user.fullName;
    const nameParts = [user.firstName, user.middleName, user.lastName]
        .filter(Boolean)
        .join(' ')
        .trim();
    if (nameParts) return nameParts;
    return user.username || user.email || 'Unknown Borrower';
};

const buildRecipientList = (...values) => {
    return Array.from(
        new Set(
            values
                .flat()
                .filter(value => value !== undefined && value !== null && String(value).trim() !== '')
                .map(value => String(value))
        )
    );
};

const formatCountLabel = (count, singular, plural) => {
    const numericValue = Number(count);
    const resolvedCount = Number.isFinite(numericValue) ? numericValue : 0;
    const resolvedPlural = plural || `${singular}s`;
    const label = resolvedCount === 1 ? singular : resolvedPlural;
    return `${resolvedCount} ${label}`;
};

const findTransactionByIdentifier = async(dbAdapter, identifier) => {
    if (!identifier) return null;
    const idValue = String(identifier);
    let transaction = await dbAdapter.findOneInCollection('transactions', { id: idValue });
    if (!transaction) {
        transaction = await dbAdapter.findOneInCollection('transactions', { _id: idValue });
    }

    if (transaction && !transaction.id) {
        const generatedId = ensureTransactionId(transaction);
        if (generatedId) {
            const query = transaction._id ? { _id: transaction._id } : transaction.id ? { id: transaction.id } : null;
            if (query) {
                await dbAdapter.updateInCollection('transactions', query, { id: generatedId });
            }
            transaction.id = generatedId;
        }
    }

    return transaction;
};

const ACTIVE_TRANSACTION_STATUSES = new Set(['borrowed', 'active', 'pending']);

const loadBorrowingLookups = async(dbAdapter) => {
    const [users, books] = await Promise.all([
        dbAdapter.findInCollection('users', {}),
        dbAdapter.findInCollection('books', {})
    ]);

    const usersLookup = buildLookupMap(users, user => [user.id, user._id, user.uid, user.userId, user.libraryCardNumber, user.email]);
    const booksLookup = buildLookupMap(books, book => [book.id, book._id, book.bookId, book.isbn]);
    const copiesLookup = new Map();

    books.forEach(book => {
        (book.copies || []).forEach(copy => {
            if (copy.copyId) {
                copiesLookup.set(String(copy.copyId), { book, copy });
            }
        });
    });

    return { usersLookup, booksLookup, copiesLookup };
};

const resolveItemBookMetadata = (item = {}, lookups = {}) => {
    const copyMatch = lookups.copiesLookup?.get(String(item.copyId || ''));
    const matchingBook = copyMatch?.book || lookups.booksLookup?.get(String(item.bookId)) || null;

    const bookTitle = matchingBook?.title || item.title || item.isbn || 'Unknown Book';
    const author = matchingBook?.author || matchingBook?.publisher || item.author || '';

    return {
        ...item,
        bookTitle,
        author
    };
};

const enrichTransactionsWithBookMetadata = async(transactions, dbAdapter) => {
    if (!Array.isArray(transactions) || transactions.length === 0) {
        return Array.isArray(transactions) ? transactions : [];
    }

    const lookups = await loadBorrowingLookups(dbAdapter);

    return transactions.map(transaction => {
        const items = (transaction.items || []).map(item => resolveItemBookMetadata(item, lookups));
        const titleList = items.map(item => item.bookTitle).filter(Boolean);
        const authorList = items.map(item => item.author).filter(Boolean);

        return {
            ...transaction,
            items,
            bookTitle: titleList.length > 0 ? titleList.join(', ') : (transaction.bookTitle || 'Unknown Book'),
            bookAuthor: authorList.length > 0 ? authorList.join(', ') : (transaction.bookAuthor || '')
        };
    });
};

const buildBorrowedRecord = ({ transaction, item, lookups }) => {
    const documentId = transaction.id || transaction._id || `txn_${transaction.userId || 'unknown'}`;
    const borrower = lookups.usersLookup.get(String(transaction.userId)) || null;
    const borrowerName = getBorrowerName(borrower);
    const borrowerEmail = borrower?.email || borrower?.username || '';

    const copyMatch = lookups.copiesLookup.get(String(item.copyId || ''));
    const matchingBook = copyMatch?.book || lookups.booksLookup.get(String(item.bookId)) || null;

    const bookTitle = matchingBook?.title || item.title || item.isbn || 'Unknown Book';
    const author = matchingBook?.author || matchingBook?.publisher || item.author || '';

    const baseRowId = `${documentId}_${item.copyId || item.bookId || item.isbn || 'item'}`;

    return {
        transactionId: documentId,
        rowId: baseRowId,
        _id: baseRowId,
        borrowerId: transaction.userId,
        borrowerName,
        borrowerEmail,
        copyId: item.copyId || '',
        bookTitle,
        author,
        borrowDate: transaction.borrowDate || transaction.createdAt || null,
        dueDate: transaction.dueDate || null,
        status: normalizeStatus(transaction.status),
        fine: transaction.fineAmount || transaction.fine || 0
    };
};

const normalizeIdValue = (value) => {
    if (value === undefined || value === null) return '';
    return String(value).trim();
};

const mergeRequestAssignments = (items = [], assignments = []) => {
    const consumedIndices = new Set();

    const findMatchIndex = (matcher) => {
        for (let idx = 0; idx < assignments.length; idx += 1) {
            if (consumedIndices.has(idx)) continue;
            const assignment = assignments[idx];
            if (matcher(assignment, idx)) {
                return idx;
            }
        }
        return -1;
    };

    const mergedItems = [];
    const missingAssignments = [];

    items.forEach((item, index) => {
        const merged = { ...item };
        if (merged.copyId) {
            mergedItems.push(merged);
            return;
        }

        const requestItemId = normalizeIdValue(merged.requestItemId);
        const bookId = normalizeIdValue(merged.bookId);

        let matchIndex = -1;
        if (requestItemId) {
            matchIndex = findMatchIndex((assignment) => normalizeIdValue(assignment.requestItemId) === requestItemId);
        }
        if (matchIndex === -1 && bookId) {
            matchIndex = findMatchIndex((assignment) => normalizeIdValue(assignment.bookId) === bookId);
        }
        if (matchIndex === -1) {
            matchIndex = findMatchIndex((assignment) => Boolean(normalizeIdValue(assignment.copyId)));
        }

        if (matchIndex === -1) {
            missingAssignments.push({
                index,
                requestItemId: requestItemId || null,
                bookId: bookId || null
            });
            mergedItems.push(merged);
            return;
        }

        const assignment = assignments[matchIndex];
        consumedIndices.add(matchIndex);

        mergedItems.push({
            ...merged,
            copyId: normalizeIdValue(assignment.copyId),
            bookId: normalizeIdValue(assignment.bookId) || bookId
        });
    });

    const unusedAssignments = assignments
        .map((assignment, index) => ({ ...assignment, index }))
        .filter(entry => !consumedIndices.has(entry.index));

    return { mergedItems, missingAssignments, unusedAssignments };
};

const processReturnTransaction = async({
    dbAdapter,
    transaction,
    items,
    actorId,
    notes = '',
    returnDateOverride = null,
    borrowingSettings = BORROWING_DEFAULTS
}) => {
    if (!transaction) {
        throw new Error('Transaction not found');
    }
    if (!Array.isArray(items) || items.length === 0) {
        throw new Error('No items provided for return');
    }
    if (transaction.status === 'returned') {
        throw new Error('Transaction already returned');
    }

    const finePerDay = Number(borrowingSettings?.finePerDay) || BORROWING_DEFAULTS.finePerDay;
    const enableFines = borrowingSettings?.enableFines !== false;
    const gracePeriodDays = Number(borrowingSettings?.gracePeriodDays) || BORROWING_DEFAULTS.gracePeriodDays;
    const maxFineAmount = Number(borrowingSettings?.maxFineAmount) || 0;

    const allBooks = await dbAdapter.findInCollection('books', {});
    let returnDate = returnDateOverride ? new Date(returnDateOverride) : new Date();
    if (Number.isNaN(returnDate.getTime())) {
        returnDate = new Date();
    }
    const dueDateSource = transaction.dueDate || transaction.metadata?.providedDueDate || null;
    const dueDate = dueDateSource ? new Date(dueDateSource) : null;
    let totalFine = 0;
    let returnedItems = 0;

    for (const returnItem of items) {
        const { copyId, condition = 'good' } = returnItem;
        if (!copyId) continue;

        let targetBook = null;
        for (const book of allBooks) {
            const copy = book.copies?.find(c => c.copyId === copyId);
            if (copy) {
                targetBook = book;
                break;
            }
        }

        if (!targetBook) continue;

        const updatedCopies = (targetBook.copies || []).map(c =>
            c.copyId === copyId
                ? {
                    ...c,
                    status: 'available',
                    condition,
                    updatedAt: new Date(),
                    updatedBy: actorId
                }
                : c
        );

        const bookQuery = targetBook.id ? { id: targetBook.id } : { _id: targetBook._id };
        await dbAdapter.updateInCollection('books', bookQuery, {
            copies: updatedCopies,
            availableCopies: updatedCopies.filter(c => c.status === 'available').length,
            updatedAt: new Date()
        });

        returnedItems++;
    }

    if (enableFines && dueDate && !Number.isNaN(dueDate.getTime()) && returnDate > dueDate && returnedItems > 0) {
        const perItemFine = calculateFine(dueDate, returnDate, {
            finePerDay,
            gracePeriodDays
        });
        totalFine = perItemFine * returnedItems;
        if (maxFineAmount > 0) {
            totalFine = Math.min(totalFine, maxFineAmount);
        }
    }

    const updatedItems = (transaction.items || []).map(item => {
        const wasReturned = items.some(returnItem => returnItem.copyId === item.copyId);
        if (!wasReturned) return item;
        return { ...item, status: 'returned', returnedAt: returnDate };
    });

    const hasOutstandingItems = updatedItems.some(item => item.status !== 'returned');
    const updatedStatus = hasOutstandingItems ? 'borrowed' : 'returned';

    const transactionQuery = transaction.id ? { id: transaction.id } : { _id: transaction._id };
    await dbAdapter.updateInCollection('transactions', transactionQuery, {
        status: updatedStatus,
        items: updatedItems,
        returnDate,
        fineAmount: totalFine,
        returnNotes: notes || '',
        updatedAt: new Date(),
        returnedBy: actorId
    });

    let user = await dbAdapter.findOneInCollection('users', { id: transaction.userId });
    if (!user) {
        user = await dbAdapter.findOneInCollection('users', { _id: transaction.userId });
    }
    if (user) {
        const stats = user.borrowingStats || { totalBorrowed: 0, currentlyBorrowed: 0, totalFines: 0, totalReturned: 0 };
        const updatedStats = {
            totalBorrowed: stats.totalBorrowed || 0,
            currentlyBorrowed: Math.max(0, (stats.currentlyBorrowed || 0) - returnedItems),
            totalFines: (stats.totalFines || 0) + totalFine,
            totalReturned: (stats.totalReturned || 0) + returnedItems
        };
        const userQuery = user.id ? { id: user.id } : { _id: user._id };
        await dbAdapter.updateInCollection('users', userQuery, {
            borrowingStats: updatedStats,
            updatedAt: new Date()
        });
    }

    const daysOverdue = totalFine > 0 && dueDate ? Math.ceil((returnDate - dueDate) / (1000 * 60 * 60 * 24)) : 0;

    return {
        returnedItems,
        fineAmount: totalFine,
        daysOverdue
    };
};

router.get('/', verifyToken, requireCirculation, async(req, res) => {
    try {
        const { page = 1, limit = 20, status, userId, type, startDate, endDate, search } = req.query;
        const pageNumber = Math.max(parseInt(page, 10) || 1, 1);
        const limitNumber = Math.max(parseInt(limit, 10) || 20, 1);

        const filters = {};
        if (status) filters.status = status === 'active' ? 'borrowed' : status;
        if (userId) filters.userId = userId;
        if (type) filters.type = type;

        let transactions = await req.dbAdapter.findInCollection('transactions', filters);

        if (startDate || endDate) {
            const start = startDate ? new Date(startDate) : null;
            const end = endDate ? new Date(endDate) : null;
            transactions = transactions.filter(transaction => {
                const transactionDate = new Date(transaction.createdAt || transaction.borrowDate || Date.now());
                if (start && transactionDate < start) return false;
                if (end && transactionDate > end) return false;
                return true;
            });
        }

        transactions.sort((a, b) => new Date(b.createdAt || b.borrowDate) - new Date(a.createdAt || a.borrowDate));

        const allUsers = await req.dbAdapter.findInCollection('users', {});
        const allBooks = await req.dbAdapter.findInCollection('books', {});
        const usersLookup = buildLookupMap(allUsers, user => [user.id, user._id, user.uid, user.userId, user.libraryCardNumber]);
        const booksLookup = buildLookupMap(allBooks, book => [book.id, book._id, book.bookId, book.isbn]);
        const copiesLookup = new Map();
        allBooks.forEach(book => {
            (book.copies || []).forEach(copy => {
                if (copy.copyId) {
                    copiesLookup.set(String(copy.copyId), book);
                }
            });
        });

        let detailedTransactions = [];

        transactions.forEach(transaction => {
            const borrower = usersLookup.get(String(transaction.userId)) || null;
            const borrowerName = getBorrowerName(borrower);
            const borrowerEmail = (borrower?.email) || (borrower?.username) || '';
            const documentId = transaction._id || transaction.id;
            const baseRecord = {
                ...transaction,
                documentId,
                id: transaction.id || transaction._id || documentId,
                status: normalizeStatus(transaction.status),
                borrowerName,
                borrowerEmail,
                borrowerId: transaction.userId,
                fine: transaction.fineAmount || transaction.fine || 0
            };

            if (transaction.items && transaction.items.length > 0) {
                transaction.items.forEach((item, index) => {
                    const book = booksLookup.get(String(item.bookId)) || copiesLookup.get(String(item.copyId)) || null;
                    const bookTitle = (book?.title) || item.title || item.isbn || 'Unknown Book';
                    const author = (book?.author) || (book?.publisher) || '';
                    const rowId = `${documentId || baseRecord.id || 'transaction'}_${item.copyId || index}`;
                    detailedTransactions.push({
                        ...baseRecord,
                        _id: rowId,
                        copyId: item.copyId || '',
                        bookTitle,
                        author
                    });
                });
            } else {
                detailedTransactions.push({
                    ...baseRecord,
                    _id: documentId || baseRecord.id,
                    copyId: '',
                    bookTitle: 'Unknown Book',
                    author: ''
                });
            }
        });

        if (search) {
            const searchValue = String(search).toLowerCase();
            detailedTransactions = detailedTransactions.filter(transaction => {
                const idMatches = [
                    transaction.transactionId,
                    transaction.documentId,
                    transaction.id,
                    transaction._id
                ]
                    .map(value => (value ? String(value).toLowerCase() : ''))
                    .some(value => value.includes(searchValue));
                return (
                    idMatches ||
                    transaction.bookTitle?.toLowerCase().includes(searchValue) ||
                    transaction.author?.toLowerCase().includes(searchValue) ||
                    transaction.borrowerName?.toLowerCase().includes(searchValue) ||
                    transaction.borrowerEmail?.toLowerCase().includes(searchValue) ||
                    transaction.copyId?.toLowerCase().includes(searchValue)
                );
            });
        }

        const total = detailedTransactions.length;
        const startIndex = (pageNumber - 1) * limitNumber;
        const paginatedTransactions = detailedTransactions.slice(startIndex, startIndex + limitNumber);

        res.json({
            transactions: paginatedTransactions,
            pagination: {
                page: pageNumber,
                limit: limitNumber,
                total,
                pages: Math.ceil(total / limitNumber)
            }
        });
    } catch (error) {
        console.error('Get transactions error:', error);
        res.status(500).json({ message: 'Failed to fetch transactions' });
    }
});

router.get('/stats', verifyToken, requireCirculation, async(req, res) => {
    try {
        const transactions = await req.dbAdapter.findInCollection('transactions', {});
        const borrowedCount = transactions.filter(t => (t.status === 'borrowed' || t.status === 'active')).length;
        const stats = {
            total: transactions.length,
            borrowed: borrowedCount,
            returned: transactions.filter(t => t.status === 'returned').length,
            overdue: transactions.filter(t => (t.status === 'borrowed' || t.status === 'active') && new Date(t.dueDate) < new Date()).length
        };
        res.json(stats);
    } catch (error) {
        console.error('Get transaction stats error:', error);
        res.status(500).json({ message: 'Failed to fetch transaction stats' });
    }
});

router.get('/annual/stats', verifyToken, requireCirculation, async(req, res) => {
    try {
        const { year } = req.query;
        const targetYear = year || new Date().getFullYear();
        const transactions = await req.dbAdapter.findInCollection('transactions', {});

        const annualTransactions = transactions.filter(t => {
            const tDate = new Date(t.borrowDate || t.createdAt);
            return tDate.getFullYear() === parseInt(targetYear);
        });

        res.json({
            year: targetYear,
            total: annualTransactions.length,
            byMonth: Array.from({ length: 12 }, (_, i) => {
                const month = i + 1;
                return {
                    month,
                    count: annualTransactions.filter(t => new Date(t.borrowDate || t.createdAt).getMonth() + 1 === month).length
                };
            })
        });
    } catch (error) {
        console.error('Get annual stats error:', error);
        res.status(500).json({ message: 'Failed to fetch annual stats' });
    }
});

router.get('/annual', verifyToken, requireCirculation, async(req, res) => {
    try {
    const { year, curriculum } = req.query;
        const targetYear = year || new Date().getFullYear();
        const transactions = await req.dbAdapter.findInCollection('transactions', {});

        let annualTransactions = transactions.filter(t => {
            const tDate = new Date(t.borrowDate || t.createdAt);
            return tDate.getFullYear() === parseInt(targetYear);
        });

        if (curriculum) {

            const users = await req.dbAdapter.findInCollection('users', { curriculum });
            const userIds = users.map(u => u.id);
            annualTransactions = annualTransactions.filter(t => userIds.includes(t.userId));
        }

        res.json(annualTransactions);
    } catch (error) {
        console.error('Get annual transactions error:', error);
        res.status(500).json({ message: 'Failed to fetch annual transactions' });
    }
});

router.get('/overdue/list', verifyToken, requireCirculation, async(req, res) => {
    try {
        const currentDate = new Date();
        const transactions = await req.dbAdapter.findInCollection('transactions', { status: 'borrowed' });
        const overdueTransactions = transactions
            .filter(transaction => transaction.dueDate)
            .filter(transaction => new Date(transaction.dueDate) < currentDate)
            .map(transaction => {
                const due = new Date(transaction.dueDate);
                const daysOverdue = Math.ceil((currentDate - due) / (1000 * 60 * 60 * 24));
                return { ...transaction, daysOverdue };
            });
        res.json(overdueTransactions);
    } catch (error) {
        console.error('Get overdue transactions error:', error);
        res.status(500).json({ message: 'Failed to fetch overdue transactions' });
    }
});

router.get('/user/:userId', verifyToken, async(req, res) => {
    try {
        let transactions = await req.dbAdapter.findInCollection('transactions', { userId: req.params.userId });
        transactions.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));
        const enriched = await enrichTransactionsWithBookMetadata(transactions, req.dbAdapter);
        res.json(enriched);
    } catch (error) {
        console.error('Get user transactions error:', error);
        res.status(500).json({ message: 'Failed to fetch user transactions' });
    }
});

router.get('/borrowed', verifyToken, requireCirculation, async(req, res) => {
    try {
        const searchTerm = (req.query.search || '').trim().toLowerCase();
        const transactions = await req.dbAdapter.findInCollection('transactions', {});

        const activeTransactions = transactions.filter(transaction => {
            const status = normalizeStatus(transaction.status);
            if (!ACTIVE_TRANSACTION_STATUSES.has(status)) return false;
            return (transaction.items || []).some(item => item && item.copyId && item.status !== 'returned');
        });

        if (activeTransactions.length === 0) {
            return res.json([]);
        }

        const { usersLookup, booksLookup, copiesLookup } = await loadBorrowingLookups(req.dbAdapter);

        const records = [];

        activeTransactions.forEach(transaction => {
            (transaction.items || []).forEach(item => {
                if (!item || !item.copyId || item.status === 'returned') {
                    return;
                }
                const record = buildBorrowedRecord({
                    transaction,
                    item,
                    lookups: { usersLookup, booksLookup, copiesLookup }
                });

                if (!searchTerm) {
                    records.push(record);
                    return;
                }

                const haystacks = [
                    record.bookTitle,
                    record.author,
                    record.borrowerName,
                    record.borrowerEmail,
                    record.copyId,
                    record.transactionId
                ].filter(Boolean).map(value => String(value).toLowerCase());

                if (haystacks.some(value => value.includes(searchTerm))) {
                    records.push(record);
                }
            });
        });

        res.json(records);
    } catch (error) {
        console.error('Borrowed lookup error:', error);
        res.status(500).json({ message: 'Failed to search borrowed transactions' });
    }
});

router.get('/by-copy', verifyToken, requireCirculation, async(req, res) => {
    try {
        const copyId = (req.query.copyId || '').trim();
        if (!copyId) {
            return res.status(400).json({ message: 'copyId query parameter is required' });
        }

        const transactions = await req.dbAdapter.findInCollection('transactions', {});

        for (const transaction of transactions) {
            const status = normalizeStatus(transaction.status);
            if (!ACTIVE_TRANSACTION_STATUSES.has(status)) {
                continue;
            }

            for (const item of transaction.items || []) {
                if (!item || item.status === 'returned') {
                    continue;
                }
                if (String(item.copyId) === copyId) {
                    const { usersLookup, booksLookup, copiesLookup } = await loadBorrowingLookups(req.dbAdapter);
                    const record = buildBorrowedRecord({
                        transaction,
                        item,
                        lookups: { usersLookup, booksLookup, copiesLookup }
                    });
                    return res.json(record);
                }
            }
        }

        res.status(404).json({ message: 'No borrowed record found for this copy' });
    } catch (error) {
        console.error('Borrowed lookup by copy error:', error);
        res.status(500).json({ message: 'Failed to search copy borrowing record' });
    }
});

router.get('/:id/history', verifyToken, async(req, res) => {
    try {
        const transactionId = req.params.id;

        let logs = await req.dbAdapter.findInCollection('audit', {});

        const matches = logs.filter(log => {
            try {
                const entityMatch = log.entityId && String(log.entityId) === String(transactionId);
                const resourceMatch = log.resourceId && String(log.resourceId) === String(transactionId);
                const detailsString = JSON.stringify(log.details || {});
                const metadataString = JSON.stringify(log.metadata || {});
                const inDetails = detailsString.includes(transactionId);
                const inMetadata = metadataString.includes(transactionId);
                const actionEntityMatch = log.entity && String(log.entity).toLowerCase() === 'transaction' && (entityMatch || resourceMatch);

                return entityMatch || resourceMatch || inDetails || inMetadata || actionEntityMatch;
            } catch (e) {
                return false;
            }
        });

        matches.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));

        res.json(matches);
    } catch (error) {
        console.error('Get transaction history error:', error);
        res.status(500).json({ message: 'Failed to fetch transaction history' });
    }
});

router.get('/:id', verifyToken, async(req, res) => {
    try {
        const transaction = await findTransactionByIdentifier(req.dbAdapter, req.params.id);
        if (!transaction) return res.status(404).json({ message: 'Transaction not found' });
        const user = await req.dbAdapter.findOneInCollection('users', { id: transaction.userId });
        if (user) transaction.user = user;
        for (let item of transaction.items) {
            const book = await req.dbAdapter.findOneInCollection('books', { id: item.bookId });
            if (book) item.book = book;
        }
        res.json(transaction);
    } catch (error) {
        console.error('Get transaction error:', error);
        res.status(500).json({ message: 'Failed to fetch transaction' });
    }
});

router.get('/:id/history', verifyToken, async(req, res) => {
    try {
        const transactionId = req.params.id;

        let logs = await req.dbAdapter.findInCollection('audit', {});

        const matches = logs.filter(log => {
            try {
                const entityMatch = log.entityId && String(log.entityId) === String(transactionId);
                const resourceMatch = log.resourceId && String(log.resourceId) === String(transactionId);
                const detailsString = JSON.stringify(log.details || {});
                const metadataString = JSON.stringify(log.metadata || {});
                const inDetails = detailsString.includes(transactionId);
                const inMetadata = metadataString.includes(transactionId);
                const actionEntityMatch = log.entity && String(log.entity).toLowerCase() === 'transaction' && (entityMatch || resourceMatch);

                return entityMatch || resourceMatch || inDetails || inMetadata || actionEntityMatch;
            } catch (e) {
                return false;
            }
        });

        matches.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));

        res.json(matches);
    } catch (error) {
        console.error('Get transaction history error:', error);
        res.status(500).json({ message: 'Failed to fetch transaction history' });
    }
});

router.post('/borrow', verifyToken, requireCirculation, logAction('BORROW', 'transaction'), async(req, res) => {
    try {
        const { userId, items, type = 'regular', notes } = req.body;
        const transactionType = normalizeTransactionType(type);
        const requestedItems = Array.isArray(items) ? items : [];

        setAuditContext(req, {
            details: {
                borrowerId: userId || null
            },
            metadata: {
                borrowRequest: {
                    type: transactionType,
                    itemCount: requestedItems.length,
                    copyIds: requestedItems
                        .map(item => item && item.copyId)
                        .filter(Boolean)
                }
            }
        });

        if (!userId || !Array.isArray(items) || items.length === 0) {
            setAuditContext(req, {
                success: false,
                status: 'ValidationError',
                description: 'Borrow request missing userId or items'
            });
            return res.status(400).json({ message: 'User ID and items are required' });
        }
        const borrowingSettings = await getBorrowingSettings(req);
        const notificationSettings = await getNotificationSettings(req);
        const channelState = getNotificationChannelState(notificationSettings);
        if (isOvernightType(transactionType) && borrowingSettings.overnightBorrowingEnabled === false) {
            setAuditContext(req, {
                success: false,
                status: 'OvernightDisabled',
                description: 'Borrow request blocked: overnight borrowing disabled'
            });
            return res.status(403).json({ message: 'Overnight borrowing is currently disabled' });
        }
        if (isAnnualType(transactionType) && borrowingSettings.annualBorrowingEnabled === false) {
            setAuditContext(req, {
                success: false,
                status: 'AnnualDisabled',
                description: 'Borrow request blocked: annual borrowing disabled'
            });
            return res.status(403).json({ message: 'Annual borrowing is currently disabled' });
        }

        const maxBooksPerTransaction = Number(borrowingSettings.maxBooksPerTransaction) || 0;
        if (maxBooksPerTransaction > 0 && items.length > maxBooksPerTransaction) {
            setAuditContext(req, {
                success: false,
                status: 'LimitExceeded',
                description: `Borrow request exceeds maximum ${maxBooksPerTransaction} books per transaction`,
                metadata: {
                    attemptedCount: items.length,
                    maxBooksPerTransaction
                }
            });
            return res.status(400).json({ message: `Maximum ${maxBooksPerTransaction} books per transaction` });
        }
        const user = await req.dbAdapter.findUserById(userId);
        if (!user) {
            setAuditContext(req, {
                success: false,
                status: 'UserNotFound',
                description: `Borrow request failed: user ${userId} not found`,
                entityId: userId,
                metadata: {
                    userId
                }
            });
            return res.status(404).json({ message: 'User not found' });
        }
        if (!user.isActive) {
            setAuditContext(req, {
                success: false,
                status: 'UserInactive',
                description: `Borrow request failed: user ${userId} is not active`,
                entityId: userId
            });
            return res.status(400).json({ message: 'User account is not active' });
        }
        const transactionItems = [];
        const borrowDate = new Date();
        const borrowWindowDays = resolveBorrowWindowDays(transactionType, borrowingSettings);
        const dueDate = calculateDueDate(borrowDate, borrowWindowDays);
        for (const item of items) {
            const { copyId } = item;
            const allBooks = await req.dbAdapter.findInCollection('books', {});
            let targetBook = null;
            let targetCopy = null;
            for (const book of allBooks) {
                const copy = book.copies?.find(c => c.copyId === copyId);
                if (copy) {
                    targetBook = book;
                    targetCopy = copy;
                    break;
                }
            }
            if (!targetBook || !targetCopy) {
                setAuditContext(req, {
                    success: false,
                    status: 'CopyNotFound',
                    description: `Borrow request failed: book copy ${copyId} not found`,
                    metadata: {
                        copyId
                    }
                });
                return res.status(404).json({ message: `Book copy ${copyId} not found` });
            }
            if (targetCopy.status !== 'available') {
                setAuditContext(req, {
                    success: false,
                    status: 'CopyUnavailable',
                    description: `Borrow request failed: book copy ${copyId} is not available`,
                    metadata: {
                        copyId,
                        copyStatus: targetCopy.status
                    }
                });
                return res.status(400).json({ message: `Book copy ${copyId} is not available` });
            }
            const updatedCopies = targetBook.copies.map(c => c.copyId === copyId ? {...c, status: 'borrowed', updatedAt: new Date() } : c);
            await req.dbAdapter.updateInCollection('books', { id: targetBook.id }, { copies: updatedCopies, availableCopies: updatedCopies.filter(c => c.status === 'available').length, updatedAt: new Date() });
            transactionItems.push({ copyId, bookId: targetBook.id, isbn: targetBook.isbn, status: 'borrowed' });
        }
    const transactionId = generateTransactionId('borrow');
        const transactionData = { id: transactionId, userId, items: transactionItems, type: transactionType, status: 'borrowed', borrowDate, dueDate, returnDate: null, fineAmount: 0, notes: notes || '', renewalCount: 0, createdAt: new Date(), updatedAt: new Date(), createdBy: req.user.id, metadata: { borrowWindowDays } };
        await req.dbAdapter.insertIntoCollection('transactions', transactionData);
        const userBorrowingStats = user.borrowingStats || { totalBorrowed: 0, currentlyBorrowed: 0, totalFines: 0 };
        await req.dbAdapter.updateInCollection('users', { id: userId }, { borrowingStats: { totalBorrowed: (userBorrowingStats.totalBorrowed || 0) + items.length, currentlyBorrowed: (userBorrowingStats.currentlyBorrowed || 0) + items.length, totalFines: userBorrowingStats.totalFines || 0 }, updatedAt: new Date() });

        const borrowerRecipients = buildRecipientList(user.id, user._id, user.userId, user.libraryCardNumber, user.email, user.username);
        if (channelState.hasActiveChannel && borrowerRecipients.length > 0) {
            try {
                await req.dbAdapter.insertIntoCollection('notifications', {
                    title: 'Borrow transaction created',
                    message: `Your borrow transaction ${transactionId} has been recorded. Please return items on time.`,
                    type: 'borrow-created',
                    transactionId,
                    recipients: borrowerRecipients,
                    meta: {
                        transactionId,
                        itemCount: transactionItems.length,
                        status: 'borrowed'
                    },
                    createdAt: new Date(),
                    updatedAt: new Date(),
                    readBy: []
                });
            } catch (notifyError) {
                console.error('Failed to notify borrower about request submission:', notifyError);
            }
        }

        setAuditContext(req, {
            success: true,
            status: 'Completed',
            entityId: transactionId,
            resourceId: transactionId,
            description: `Borrowed ${transactionItems.length} item(s) for ${getBorrowerName(user)}`,
            details: {
                borrower: {
                    id: userId,
                    name: getBorrowerName(user),
                    email: user.email || ''
                },
                transaction: {
                    id: transactionId,
                    type: transactionType,
                    notes: notes || '',
                    dueDate: dueDate.toISOString(),
                    items: transactionItems.map(entry => ({
                        copyId: entry.copyId,
                        bookId: entry.bookId,
                        isbn: entry.isbn
                    }))
                }
            },
            metadata: {
                borrowDate: borrowDate.toISOString(),
                dueDate: dueDate.toISOString(),
                itemCount: transactionItems.length,
                actorId: req.user.id
            }
        });
        res.status(201).json({ message: 'Books borrowed successfully', transactionId, dueDate: dueDate.toISOString() });
    } catch (error) {
        console.error('Borrow books error:', error);
        setAuditContext(req, {
            success: false,
            status: 'Error',
            description: `Borrow request failed: ${error.message}`,
            metadata: {
                errorName: error.name
            },
            details: {
                error: error.message
            }
        });
        res.status(500).json({ message: 'Failed to borrow books' });
    }
});

router.post('/request', verifyToken, logAction('REQUEST', 'transaction'), async (req, res) => {
    try {
        const { userId: providedUserId, items, type = 'regular', notes } = req.body || {};

        const userId = providedUserId || req.user && req.user.id;
        const borrowingSettings = await getBorrowingSettings(req);
        const notificationSettings = await getNotificationSettings(req);
        const channelState = getNotificationChannelState(notificationSettings);
        const transactionType = normalizeTransactionType(type);
        const requestItems = Array.isArray(items) ? items : [];

        setAuditContext(req, {
            metadata: {
                borrowRequest: {
                    type: transactionType,
                    itemCount: requestItems.length
                }
            },
            details: {
                requestedBy: req.user && req.user.id
            }
        });

        if (!userId || requestItems.length === 0) {
            setAuditContext(req, { success: false, status: 'ValidationError', description: 'Request missing userId or items' });
            return res.status(400).json({ message: 'User ID and items are required' });
        }

        const user = await req.dbAdapter.findUserById(userId);
        if (!user) {
            setAuditContext(req, { success: false, status: 'UserNotFound', description: `Request failed: user ${userId} not found`, entityId: userId });
            return res.status(404).json({ message: 'User not found' });
        }

        if (!user.isActive) {
            setAuditContext(req, { success: false, status: 'UserInactive', description: `Request failed: user ${userId} not active`, entityId: userId });
            return res.status(400).json({ message: 'User account is not active' });
        }

        if (isOvernightType(transactionType) && borrowingSettings.overnightBorrowingEnabled === false) {
            setAuditContext(req, { success: false, status: 'OvernightDisabled', description: 'Request blocked: overnight borrowing disabled' });
            return res.status(403).json({ message: 'Overnight borrowing is currently disabled' });
        }
        if (isAnnualType(transactionType) && borrowingSettings.annualBorrowingEnabled === false) {
            setAuditContext(req, { success: false, status: 'AnnualDisabled', description: 'Request blocked: annual borrowing disabled' });
            return res.status(403).json({ message: 'Annual borrowing is currently disabled' });
        }

        const parsedMaxBooks = parseInt(borrowingSettings.maxBooksPerTransaction, 10);
        const maxBooksPerTransaction = Number.isFinite(parsedMaxBooks) && parsedMaxBooks > 0 ? parsedMaxBooks : 0;
        if (maxBooksPerTransaction > 0 && requestItems.length > maxBooksPerTransaction) {
            setAuditContext(req, { success: false, status: 'LimitExceeded', description: `Request exceeds maximum ${maxBooksPerTransaction} books per transaction` });
            return res.status(400).json({ message: `Maximum ${maxBooksPerTransaction} books per transaction` });
        }

        const transactionId = generateTransactionId('request');
        const transactionItems = requestItems.map((item, index) => {
            if (typeof item === 'string') {
                return {
                    requestItemId: `${transactionId}_item_${index + 1}`,
                    copyId: item,
                    bookId: '',
                    status: 'requested'
                };
            }

            const copyId = item && item.copyId ? normalizeIdValue(item.copyId) : '';
            const bookId = item && item.bookId ? normalizeIdValue(item.bookId) : '';

            return {
                requestItemId: `${transactionId}_item_${index + 1}`,
                copyId,
                bookId,
                status: 'requested'
            };
        });

        const invalidItems = transactionItems.filter(entry => !entry.copyId && !entry.bookId);
        if (invalidItems.length > 0) {
            setAuditContext(req, { success: false, status: 'ValidationError', description: 'Each requested item must reference a book copy or book ID' });
            return res.status(400).json({ message: 'Each requested item must reference a book copy or book ID' });
        }
        const now = new Date();
        const transactionData = {
            id: transactionId,
            userId,
            items: transactionItems,
            type: transactionType,
            status: 'requested',
            createdAt: now,
            updatedAt: now,
            createdBy: req.user && req.user.id,
            notes: notes || ''
        };

        await req.dbAdapter.insertIntoCollection('transactions', transactionData);

        const borrowerRecipients = buildRecipientList(
            user.id,
            user._id,
            user.userId,
            user.libraryCardNumber,
            user.email,
            user.username
        );

        if (
            notificationSettings.reservationNotifications !== false &&
            channelState.hasActiveChannel &&
            borrowerRecipients.length > 0
        ) {
            try {
                await req.dbAdapter.insertIntoCollection('notifications', {
                    title: 'Borrow request submitted',
                    message: `We received your borrow request ${transactionId}. A librarian will review it shortly.`,
                    type: 'request-submitted',
                    transactionId,
                    recipients: borrowerRecipients,
                    meta: {
                        transactionId,
                        itemCount: transactionItems.length,
                        status: 'requested'
                    },
                    createdAt: new Date(),
                    updatedAt: new Date(),
                    readBy: []
                });
            } catch (notifyError) {
                console.error('Failed to notify borrower about request submission:', notifyError);
            }
        }

        if (notificationSettings.reservationNotifications !== false && channelState.hasActiveChannel) {
            try {
                await req.dbAdapter.insertIntoCollection('notifications', {
                    title: 'New borrow request',
                    message: `${getBorrowerName(user)} requested ${transactionItems.length} item(s).`,
                    type: 'request',
                    transactionId,
                    recipients: ['staff','librarian','admin'],
                    meta: { transactionId },
                    createdAt: new Date(),
                    readBy: []
                });
            } catch (nerr) {
                console.error('Failed to create persistent notification for request:', nerr);
            }
        }

        setAuditContext(req, {
            success: true,
            status: 'Created',
            entityId: transactionId,
            resourceId: transactionId,
            description: `Created borrow request (${transactionId}) for user ${userId}`,
            metadata: {
                requestId: transactionId,
                itemCount: transactionItems.length,
                actorId: req.user && req.user.id
            }
        });

        res.status(201).json({ message: 'Borrow request created', transactionId, transaction: transactionData });
    } catch (error) {
        console.error('Create request error:', error);
        setAuditContext(req, { success: false, status: 'Error', description: `Request creation failed: ${error.message}`, details: { error: error.message } });
        res.status(500).json({ message: 'Failed to create borrow request' });
    }
});

router.post('/cancel/:id', verifyToken, logAction('CANCEL', 'transaction'), async (req, res) => {
    try {
        const txnIdentifier = req.params.id;
        const reason = req.body && typeof req.body === 'object' ? req.body.reason : '';

        setAuditContext(req, {
            details: {
                transactionId: txnIdentifier,
                reason: reason || undefined
            },
            metadata: {
                cancelRequest: {
                    transactionId: txnIdentifier,
                    actorId: req.user && req.user.id || null
                }
            }
        });

        const transaction = await findTransactionByIdentifier(req.dbAdapter, txnIdentifier);
        if (!transaction) {
            setAuditContext(req, {
                success: false,
                status: 'TransactionNotFound',
                description: `Cancel request failed: transaction ${txnIdentifier} not found`,
                entityId: txnIdentifier
            });
            return res.status(404).json({ message: 'Transaction not found' });
        }

        const transactionOwnerId = normalizeIdValue(transaction.userId || transaction.user?._id || transaction.user?.id);
        const requesterIds = [
            normalizeIdValue(req.user && req.user.id),
            normalizeIdValue(req.user && req.user._id),
            normalizeIdValue(req.user && req.user.userId)
        ].filter(Boolean);

        const privilegedRoles = new Set(['admin', 'librarian', 'staff']);
        const actorRole = (req.user && req.user.role) ? String(req.user.role).toLowerCase() : '';
        const hasOwnership = transactionOwnerId && requesterIds.some(id => id === transactionOwnerId);
        const isPrivileged = privilegedRoles.has(actorRole);

        if (!hasOwnership && !isPrivileged) {
            setAuditContext(req, {
                success: false,
                status: 'Forbidden',
                description: `Cancel request failed: user ${req.user && req.user.id} is not authorized`,
                entityId: transaction.id || transaction._id
            });
            return res.status(403).json({ message: 'You are not allowed to cancel this request' });
        }

        const cancellableStatuses = new Set(['requested', 'pending']);
        if (!cancellableStatuses.has(String(transaction.status || '').toLowerCase())) {
            setAuditContext(req, {
                success: false,
                status: 'InvalidStatus',
                description: `Cancel request failed: transaction ${transaction.id || transaction._id} is not pending`,
                entityId: transaction.id || transaction._id,
                metadata: {
                    currentStatus: transaction.status || null
                }
            });
            return res.status(400).json({ message: 'Only pending requests can be cancelled' });
        }

        const updatePayload = {
            status: 'cancelled',
            cancelledAt: new Date(),
            cancelledBy: req.user && req.user.id,
            cancelReason: reason || '',
            updatedAt: new Date()
        };

        const txQuery = transaction.id ? { id: transaction.id } : { _id: transaction._id };
        const updatedTransaction = await req.dbAdapter.updateInCollection('transactions', txQuery, updatePayload);
        const responseTransaction = (updatedTransaction && typeof updatedTransaction === 'object')
            ? updatedTransaction
            : { ...transaction, ...updatePayload };

        try {
            const notifications = await req.dbAdapter.findInCollection('notifications', { transactionId: transaction.id || transaction._id });
            for (const notification of notifications) {
                const notificationQuery = notification.id ? { id: notification.id } : { _id: notification._id };
                await req.dbAdapter.updateInCollection('notifications', notificationQuery, {
                    archived: true,
                    updatedAt: new Date(),
                    readBy: Array.from(new Set([...(notification.readBy || []), req.user && req.user.id].filter(Boolean)))
                });
            }
        } catch (notifyError) {
            console.error('Failed to mark notifications after cancel:', notifyError);
        }

        setAuditContext(req, {
            success: true,
            status: 'Cancelled',
            description: `Cancelled borrow request ${transaction.id || transaction._id}`,
            entityId: transaction.id || transaction._id,
            resourceId: transaction.id || transaction._id,
            metadata: {
                actorId: req.user && req.user.id,
                reason: reason || '',
                previousStatus: transaction.status || null
            }
        });

        res.json({
            message: 'Borrow request cancelled',
            transactionId: transaction.id || transaction._id,
            transaction: responseTransaction
        });
    } catch (error) {
        console.error('Cancel request error:', error);
        setAuditContext(req, {
            success: false,
            status: 'Error',
            description: `Cancel failed: ${error.message}`,
            details: { error: error.message }
        });
        res.status(500).json({ message: 'Failed to cancel borrow request' });
    }
});

router.post('/approve/:id', verifyToken, requireCirculation, logAction('APPROVE', 'transaction'), async (req, res) => {
    try {
        const txnIdentifier = req.params.id;
        const transaction = await findTransactionByIdentifier(req.dbAdapter, txnIdentifier);
        if (!transaction) return res.status(404).json({ message: 'Transaction not found' });

        if (transaction.status !== 'requested') {
            return res.status(400).json({ message: 'Only requested transactions can be approved' });
        }

        const items = Array.isArray(transaction.items)
            ? transaction.items.map(item => ({
                ...item,
                copyId: normalizeIdValue(item.copyId),
                bookId: normalizeIdValue(item.bookId),
                requestItemId: normalizeIdValue(item.requestItemId)
            }))
            : [];
        if (items.length === 0) {
            return res.status(400).json({ message: 'Requested transaction has no items' });
        }

        const bodyPayload = req.body && typeof req.body === 'object' ? req.body : {};
        const assignmentPayload = Array.isArray(bodyPayload.items)
            ? bodyPayload.items
            : Array.isArray(bodyPayload.assignments)
                ? bodyPayload.assignments
                : [];

        const normalizedAssignments = assignmentPayload
            .map(entry => ({
                copyId: normalizeIdValue(entry && entry.copyId),
                bookId: normalizeIdValue(entry && entry.bookId),
                requestItemId: normalizeIdValue(entry && entry.requestItemId)
            }))
            .filter(entry => Boolean(entry.copyId));

        if (normalizedAssignments.length > 0) {
            const { mergedItems, missingAssignments } = mergeRequestAssignments(items, normalizedAssignments);
            if (missingAssignments.length > 0) {
                setAuditContext(req, {
                    success: false,
                    status: 'ValidationFailed',
                    description: 'Missing copy assignments for one or more request items',
                    details: { missingAssignments }
                });
                return res.status(400).json({ message: 'Missing copy assignments for requested items', details: missingAssignments });
            }
            items.length = 0;
            mergedItems.forEach(entry => items.push({
                ...entry,
                copyId: normalizeIdValue(entry.copyId),
                bookId: normalizeIdValue(entry.bookId),
                requestItemId: normalizeIdValue(entry.requestItemId)
            }));
        }

        const allBooks = await req.dbAdapter.findInCollection('books', {});

        const copyLookup = new Map();
        allBooks.forEach(book => {
            (book.copies || []).forEach(copy => {
                const trackedCopyId = normalizeIdValue(copy.copyId);
                if (trackedCopyId) {
                    copyLookup.set(trackedCopyId, { book, copy });
                }
            });
        });

        const normalizeLower = (value) => {
            const normalized = normalizeIdValue(value);
            return normalized ? normalized.toLowerCase() : '';
        };

        const duplicateCopyAssignments = [];
        const missingCopyAssignments = [];
        const copyTracker = new Set();

        items.forEach((item, idx) => {
            const normalizedCopyId = normalizeIdValue(item.copyId);
            if (!normalizedCopyId) {
                missingCopyAssignments.push({
                    index: idx,
                    reason: 'missing-copyId',
                    requestItemId: item.requestItemId || null,
                    bookId: normalizeIdValue(item.bookId) || null
                });
                return;
            }

            const copyKey = normalizedCopyId.toLowerCase();
            if (copyTracker.has(copyKey)) {
                duplicateCopyAssignments.push({
                    index: idx,
                    copyId: normalizedCopyId,
                    requestItemId: item.requestItemId || null
                });
                return;
            }

            copyTracker.add(copyKey);
            item.copyId = normalizedCopyId;
            item.bookId = normalizeIdValue(item.bookId);
        });

        if (missingCopyAssignments.length > 0) {
            setAuditContext(req, {
                success: false,
                status: 'ValidationFailed',
                description: 'Copy assignments are required for each requested item',
                details: { missingCopyAssignments }
            });
            return res.status(400).json({ message: 'Copy assignments are required for each requested item', details: missingCopyAssignments });
        }

        if (duplicateCopyAssignments.length > 0) {
            setAuditContext(req, {
                success: false,
                status: 'ValidationFailed',
                description: 'Invalid or duplicate copy assignments provided',
                details: { duplicateCopyAssignments }
            });
            return res.status(400).json({ message: 'Invalid or duplicate copy assignments provided', details: duplicateCopyAssignments });
        }

        const validationFailures = [];
        const readyToUpdate = []; // { targetBook, targetCopy, copyId }

        for (const item of items) {
            const copyId = item.copyId;
            if (!copyId) {
                validationFailures.push({ item, reason: 'missing-copyId' });
                continue;
            }

            let targetBook = null;
            let targetCopy = null;

            const lookupEntry = copyLookup.get(normalizeIdValue(copyId));
            if (lookupEntry) {
                targetBook = lookupEntry.book;
                targetCopy = lookupEntry.copy;
            } else {
                for (const book of allBooks) {
                    const copy = (book.copies || []).find(c => String(c.copyId) === String(copyId));
                    if (copy) {
                        targetBook = book;
                        targetCopy = copy;
                        break;
                    }
                }
            }

            if (!targetBook || !targetCopy) {
                validationFailures.push({ item, reason: 'copy-not-found' });
                continue;
            }

            const canonicalBookId = normalizeIdValue(targetBook.id || targetBook._id || targetBook.bookId || targetBook.isbn);
            if (!item.bookId) {
                item.bookId = canonicalBookId;
            } else if (canonicalBookId && canonicalBookId !== normalizeIdValue(item.bookId)) {
                validationFailures.push({ item, reason: 'book-mismatch', expectedBookId: canonicalBookId });
                continue;
            }

            if (String(targetCopy.status).toLowerCase() !== 'available') {
                validationFailures.push({ item, reason: 'copy-unavailable', copyStatus: targetCopy.status });
                continue;
            }

            readyToUpdate.push({ targetBook, targetCopy, copyId });
        }

        if (validationFailures.length > 0) {
            setAuditContext(req, {
                success: false,
                status: 'ValidationFailed',
                description: 'Cannot approve request: one or more copies missing or unavailable',
                details: { validationFailures }
            });
            return res.status(400).json({ message: 'One or more requested copies are missing or unavailable', details: validationFailures });
        }

        const updatedBooks = [];
        for (const ready of readyToUpdate) {
            const { targetBook, copyId } = ready;
            const updatedCopies = (targetBook.copies || []).map(c => c.copyId === copyId ? { ...c, status: 'borrowed', updatedAt: new Date(), updatedBy: req.user.id } : c);
            const bookQuery = targetBook.id ? { id: targetBook.id } : { _id: targetBook._id };
            const availableCopies = updatedCopies.filter(c => c.status === 'available').length;
            await req.dbAdapter.updateInCollection('books', bookQuery, { copies: updatedCopies, availableCopies, updatedAt: new Date() });
            updatedBooks.push({ bookId: targetBook.id || targetBook._id, copyId });
        }

        const borrowingSettings = await getBorrowingSettings(req);
        const notificationSettings = await getNotificationSettings(req);
        const channelState = getNotificationChannelState(notificationSettings);
        const transactionType = normalizeTransactionType(transaction.type);
        if (isOvernightType(transactionType) && borrowingSettings.overnightBorrowingEnabled === false) {
            setAuditContext(req, {
                success: false,
                status: 'OvernightDisabled',
                description: 'Approve request blocked: overnight borrowing disabled'
            });
            return res.status(403).json({ message: 'Overnight borrowing is currently disabled' });
        }
        if (isAnnualType(transactionType) && borrowingSettings.annualBorrowingEnabled === false) {
            setAuditContext(req, {
                success: false,
                status: 'AnnualDisabled',
                description: 'Approve request blocked: annual borrowing disabled'
            });
            return res.status(403).json({ message: 'Annual borrowing is currently disabled' });
        }

        const borrowWindowDays = resolveBorrowWindowDays(transactionType, borrowingSettings);
        const borrowDate = new Date();
        const dueDate = calculateDueDate(borrowDate, borrowWindowDays);

        const txQuery = transaction.id ? { id: transaction.id } : { _id: transaction._id };
        const updatedTransaction = await req.dbAdapter.updateInCollection('transactions', txQuery, {
            status: 'borrowed',
            borrowDate,
            dueDate,
            updatedAt: new Date(),
            updatedBy: req.user.id,
            items: items.map(it => ({ ...it, status: 'borrowed' }))
        });

        let user = await req.dbAdapter.findOneInCollection('users', { id: transaction.userId });
        if (!user) user = await req.dbAdapter.findOneInCollection('users', { _id: transaction.userId });
        if (user) {
            const stats = user.borrowingStats || { totalBorrowed: 0, currentlyBorrowed: 0, totalFines: 0, totalReturned: 0 };
            const updatedStats = {
                totalBorrowed: (stats.totalBorrowed || 0) + items.length,
                currentlyBorrowed: (stats.currentlyBorrowed || 0) + items.length,
                totalFines: stats.totalFines || 0,
                totalReturned: stats.totalReturned || 0
            };
            const userQuery = user.id ? { id: user.id } : { _id: user._id };
            await req.dbAdapter.updateInCollection('users', userQuery, { borrowingStats: updatedStats, updatedAt: new Date() });

            const borrowerRecipients = buildRecipientList(user.id, user._id, user.userId, user.libraryCardNumber, user.email, user.username);
            if (
                notificationSettings.reservationNotifications !== false &&
                channelState.hasActiveChannel &&
                borrowerRecipients.length > 0
            ) {
                try {
                    const dueDateValue = dueDate instanceof Date ? dueDate : new Date(dueDate);
                    const dueDateIso = Number.isNaN(dueDateValue.getTime()) ? null : dueDateValue.toISOString();
                    const friendlyDueDate = dueDateIso ? dueDateIso.split('T')[0] : 'the scheduled due date';
                    await req.dbAdapter.insertIntoCollection('notifications', {
                        title: 'Borrow request approved',
                        message: `Your borrow request ${transaction.id || transaction._id} has been approved. Items are due on ${friendlyDueDate}.`,
                        type: 'request-approved',
                        transactionId: transaction.id || transaction._id,
                        recipients: borrowerRecipients,
                        meta: {
                            transactionId: transaction.id || transaction._id,
                            dueDate: dueDateIso,
                            itemCount: items.length,
                            status: 'borrowed'
                        },
                        createdAt: new Date(),
                        updatedAt: new Date(),
                        readBy: []
                    });
                } catch (notifyError) {
                    console.error('Failed to notify borrower about request approval:', notifyError);
                }
            }
        }

        setAuditContext(req, {
            success: true,
            status: 'Approved',
            entityId: updatedTransaction.id || updatedTransaction._id,
            resourceId: updatedTransaction.id || updatedTransaction._id,
            description: `Approved borrow request ${transaction.id || transaction._id}`,
            metadata: { approvedBy: req.user.id }
        });

        try {
            const notifications = await req.dbAdapter.findInCollection('notifications', { transactionId: transaction.id || transaction._id });
            for (const n of notifications) {
                const q = n.id ? { id: n.id } : { _id: n._id };
                await req.dbAdapter.updateInCollection('notifications', q, { readBy: Array.from(new Set([...(n.readBy || []), req.user.id])), updatedAt: new Date(), archived: true });
            }
        } catch (nerr) {
            console.error('Failed to mark notifications after approve:', nerr);
        }

        res.json({ message: 'Borrow request approved', transactionId: updatedTransaction.id || updatedTransaction._id });
    } catch (error) {
        console.error('Approve request error:', error);
        setAuditContext(req, { success: false, status: 'Error', description: `Approve failed: ${error.message}`, details: { error: error.message } });
        res.status(500).json({ message: 'Failed to approve request' });
    }
});

router.post('/reject/:id', verifyToken, requireCirculation, logAction('REJECT', 'transaction'), async (req, res) => {
    try {
        const txnIdentifier = req.params.id;
        const { reason } = req.body || {};
        const transaction = await findTransactionByIdentifier(req.dbAdapter, txnIdentifier);
        if (!transaction) return res.status(404).json({ message: 'Transaction not found' });

        if (transaction.status !== 'requested') {
            return res.status(400).json({ message: 'Only requested transactions can be rejected' });
        }

        const notificationSettings = await getNotificationSettings(req);
        const channelState = getNotificationChannelState(notificationSettings);

        const txQuery = transaction.id ? { id: transaction.id } : { _id: transaction._id };
        const updatedTransaction = await req.dbAdapter.updateInCollection('transactions', txQuery, {
            status: 'rejected',
            rejectedAt: new Date(),
            rejectedBy: req.user.id,
            rejectReason: reason || ''
        });

        if (notificationSettings.reservationNotifications !== false && channelState.hasActiveChannel) {
            try {
                await req.dbAdapter.insertIntoCollection('notifications', {
                    title: 'Borrow request rejected',
                    message: `Your borrow request ${transaction.id || transaction._id} was rejected${reason ? `: ${reason}` : ''}`,
                    type: 'request-rejected',
                    transactionId: transaction.id || transaction._id,
                    recipients: [transaction.userId],
                    meta: { transactionId: transaction.id || transaction._id },
                    createdAt: new Date(),
                    readBy: []
                });
            } catch (nerr) {
                console.error('Failed to create notification for rejection:', nerr);
            }
        }

        setAuditContext(req, {
            success: true,
            status: 'Rejected',
            entityId: updatedTransaction.id || updatedTransaction._id,
            resourceId: updatedTransaction.id || updatedTransaction._id,
            description: `Rejected borrow request ${transaction.id || transaction._id}`,
            metadata: { rejectedBy: req.user.id, reason: reason || '' }
        });

        res.json({ message: 'Borrow request rejected', transactionId: updatedTransaction.id || updatedTransaction._id });
    } catch (error) {
        console.error('Reject request error:', error);
        setAuditContext(req, { success: false, status: 'Error', description: `Reject failed: ${error.message}`, details: { error: error.message } });
        res.status(500).json({ message: 'Failed to reject request' });
    }
});

router.post('/return', verifyToken, requireCirculation, logAction('RETURN', 'transaction'), async(req, res) => {
    try {
        const { transactions, returnDate, notes } = req.body || {};

        const transactionsPayload = Array.isArray(transactions) ? transactions : [];
        setAuditContext(req, {
            metadata: {
                returnRequest: {
                    transactionCount: transactionsPayload.length,
                    transactionIds: transactionsPayload
                        .map(entry => entry && entry.transactionId)
                        .filter(Boolean),
                    providedReturnDate: returnDate || null
                }
            },
            details: {
                notes: notes || ''
            }
        });

        if (!Array.isArray(transactions) || transactions.length === 0) {
            setAuditContext(req, {
                success: false,
                status: 'ValidationError',
                description: 'Return request missing transactions payload'
            });
            return res.status(400).json({ message: 'Transactions payload is required' });
        }

        const borrowingSettings = await getBorrowingSettings(req);
        const results = [];
        let totalReturnedItems = 0;

        for (const entry of transactions) {
            if (!entry || !entry.transactionId) {
                setAuditContext(req, {
                    success: false,
                    status: 'ValidationError',
                    description: 'Return request is missing transactionId for one or more entries'
                });
                return res.status(400).json({ message: 'Each transaction entry must include a transactionId' });
            }

            const transaction = await findTransactionByIdentifier(req.dbAdapter, entry.transactionId);
            if (!transaction) {
                setAuditContext(req, {
                    success: false,
                    status: 'TransactionNotFound',
                    description: `Return request failed: transaction not found (${entry.transactionId})`,
                    entityId: entry.transactionId,
                    metadata: {
                        transactionId: entry.transactionId
                    }
                });
                return res.status(404).json({ message: `Transaction not found: ${entry.transactionId}` });
            }

            const itemsToProcess = Array.isArray(entry.items) && entry.items.length > 0
                ? entry.items.filter(item => item && item.copyId)
                : (transaction.items || []).filter(item => item.status !== 'returned').map(item => ({ copyId: item.copyId }));

            if (itemsToProcess.length === 0) {
                setAuditContext(req, {
                    success: false,
                    status: 'NoItemsToReturn',
                    description: `Return request failed: no returnable items for transaction ${entry.transactionId}`,
                    metadata: {
                        transactionId: entry.transactionId
                    }
                });
                return res.status(400).json({ message: `No returnable items found for transaction ${entry.transactionId}` });
            }

            const result = await processReturnTransaction({
                dbAdapter: req.dbAdapter,
                transaction,
                items: itemsToProcess,
                actorId: req.user.id,
                notes: notes || '',
                returnDateOverride: returnDate || null,
                borrowingSettings
            });

            totalReturnedItems += result.returnedItems;
            results.push({
                transactionId: transaction.id || transaction._id,
                ...result
            });
        }

        const singleTransactionId = results.length === 1 ? results[0].transactionId : null;

        setAuditContext(req, {
            success: true,
            status: 'Completed',
            description: `Returned ${totalReturnedItems} item(s) across ${results.length} transaction(s)`,
            entityId: singleTransactionId || undefined,
            resourceId: singleTransactionId || undefined,
            metadata: {
                totalReturnedItems,
                processedTransactions: results.map(entry => entry.transactionId),
                actorId: req.user.id,
                providedReturnDate: returnDate || null
            },
            details: {
                results
            }
        });

        res.json({
            message: `Processed ${formatCountLabel(totalReturnedItems, 'item')} across ${formatCountLabel(results.length, 'transaction')}`,
            results
        });
    } catch (error) {
        console.error('Return books error:', error);
        setAuditContext(req, {
            success: false,
            status: error.message === 'Transaction not found' ? 'TransactionNotFound' : 'Error',
            description: `Return request failed: ${error.message}`,
            metadata: {
                errorName: error.name
            },
            details: {
                error: error.message
            }
        });
        if (error.message === 'Transaction not found') {
            return res.status(404).json({ message: error.message });
        }
        if (error.message === 'Transaction already returned' || error.message === 'No items provided for return') {
            return res.status(400).json({ message: error.message });
        }
        res.status(500).json({ message: 'Failed to return books' });
    }
});

router.post('/:id/return', verifyToken, requireCirculation, logAction('RETURN', 'transaction'), async(req, res) => {
    try {
        setAuditContext(req, {
            details: {
                transactionId: req.params.id
            },
            metadata: {
                returnRequest: {
                    transactionId: req.params.id,
                    providedReturnDate: (req.body && req.body.returnDate) || null,
                    hasNotes: Boolean(req.body && req.body.notes)
                }
            }
        });
        const borrowingSettings = await getBorrowingSettings(req);
        const transaction = await findTransactionByIdentifier(req.dbAdapter, req.params.id);
        if (!transaction) {
            setAuditContext(req, {
                success: false,
                status: 'TransactionNotFound',
                description: `Return request failed: transaction ${req.params.id} not found`,
                entityId: req.params.id
            });
            return res.status(404).json({ message: 'Transaction not found' });
        }

        const itemsToProcess = (transaction.items || [])
            .filter(item => item && item.copyId && item.status !== 'returned')
            .map(item => ({ copyId: item.copyId }));
        if (itemsToProcess.length === 0) {
            setAuditContext(req, {
                success: false,
                status: 'NoItemsToReturn',
                description: `Return request failed: no items to return for transaction ${req.params.id}`,
                entityId: transaction.id || transaction._id || req.params.id
            });
            return res.status(400).json({ message: 'No items to return for this transaction' });
        }

        const result = await processReturnTransaction({
            dbAdapter: req.dbAdapter,
            transaction,
            items: itemsToProcess,
            actorId: req.user.id,
            notes: (req.body && req.body.notes) || '',
            returnDateOverride: (req.body && req.body.returnDate) || null,
            borrowingSettings
        });

        setAuditContext(req, {
            success: true,
            status: 'Completed',
            entityId: transaction.id || transaction._id,
            resourceId: transaction.id || transaction._id,
            description: `Returned ${result.returnedItems} item(s) for transaction ${transaction.id || transaction._id}`,
            metadata: {
                actorId: req.user.id,
                returnedItems: result.returnedItems,
                providedReturnDate: (req.body && req.body.returnDate) || null,
                notes: (req.body && req.body.notes) || ''
            },
            details: {
                result
            }
        });

        res.json({
            message: 'Transaction returned successfully',
            ...result
        });
    } catch (error) {
        console.error('Return transaction error:', error);
        setAuditContext(req, {
            success: false,
            status: error.message === 'Transaction not found' ? 'TransactionNotFound' : error.message === 'Transaction already returned' ? 'AlreadyReturned' : 'Error',
            description: `Return request failed: ${error.message}`,
            metadata: {
                errorName: error.name
            },
            details: {
                error: error.message
            }
        });
        if (error.message === 'Transaction already returned') {
            return res.status(400).json({ message: error.message });
        }
        if (error.message === 'Transaction not found') {
            return res.status(404).json({ message: error.message });
        }
        res.status(500).json({ message: 'Failed to return transaction' });
    }
});

module.exports = router;
module.exports.enrichTransactionsWithBookMetadata = enrichTransactionsWithBookMetadata;
```

## users.js

| Field | Details |
| --- | --- |
| Program Name | users.js |
| Description | API route handler for users resources. |
| Called by | app.js |
| Table used | users |
|  |  |
| Programmer | Nazel Asca√±o |
| Date created | 12/14/2025 |
| Revision Date | TBD |
| Revision / description of change | None |

```javascript
const express = require('express');
const bcrypt = require('bcrypt');
const transactionsRouter = require('./transactions');
const enrichTransactionsWithBookMetadata = transactionsRouter.enrichTransactionsWithBookMetadata;
const multer = require('multer');
const path = require('path');
const fs = require('fs');
const { verifyToken, requireRole, requireAdmin, requireLibrarian, requireStaff, logAction, setAuditContext } = require('../middleware/customAuth');
const { notifyRoles, formatUserName } = require('../utils/notificationChannels');
const {
    DEFAULT_CURRICULA,
    DEFAULT_GRADE_LEVELS,
    DEFAULT_GRADE_STRUCTURE,
    normalizeGradeStructure,
    normalizeStringList
} = require('../utils/userAttributes');
const router = express.Router();

const DEFAULT_SYSTEM_ROLES = ['admin', 'librarian', 'staff', 'student'];

const AVATAR_STORAGE_DIR = path.join(__dirname, '..', 'uploads', 'avatars');
const ALLOWED_AVATAR_MIME_TYPES = {
    'image/jpeg': '.jpg',
    'image/png': '.png',
    'image/gif': '.gif',
    'image/webp': '.webp'
};
const MAX_AVATAR_SIZE_BYTES = 5 * 1024 * 1024; // 5 MB

const ensureDirectory = async(dirPath) => {
    try {
        await fs.promises.mkdir(dirPath, { recursive: true });
    } catch (error) {
        if (error.code !== 'EEXIST') {
            throw error;
        }
    }
};

const avatarStorage = multer.diskStorage({
    destination: (req, file, cb) => {
        ensureDirectory(AVATAR_STORAGE_DIR)
            .then(() => cb(null, AVATAR_STORAGE_DIR))
            .catch((error) => cb(error));
    },
    filename: (req, file, cb) => {
        const timestamp = Date.now();
        const randomSuffix = Math.round(Math.random() * 1e9);
        const extensionFromMime = ALLOWED_AVATAR_MIME_TYPES[file.mimetype];
        const extensionFromName = path.extname(file.originalname || '').toLowerCase();
        const allowedExtensions = new Set(Object.values(ALLOWED_AVATAR_MIME_TYPES));
        const resolvedExtension = extensionFromMime || (allowedExtensions.has(extensionFromName) ? extensionFromName : '.jpg');
        cb(null, `avatar-${timestamp}-${randomSuffix}${resolvedExtension}`);
    }
});

const avatarFileFilter = (req, file, cb) => {
    if (ALLOWED_AVATAR_MIME_TYPES[file.mimetype]) {
        return cb(null, true);
    }
    return cb(new Error('Unsupported file type. Please upload a JPG, PNG, GIF, or WEBP image.'));
};

const avatarUpload = multer({
    storage: avatarStorage,
    fileFilter: avatarFileFilter,
    limits: {
        fileSize: MAX_AVATAR_SIZE_BYTES
    }
});

const removeFileQuietly = async(filePath) => {
    if (!filePath) {
        return;
    }

    try {
        await fs.promises.unlink(filePath);
    } catch (error) {
        if (error.code !== 'ENOENT') {
            console.warn(`Failed to remove file ${filePath}:`, error.message);
        }
    }
};

const resolveAvatarFields = (user) => {
    if (!user || typeof user !== 'object') {
        return { avatar: null, avatarUrl: '' };
    }

    const avatarObject = user.avatar && typeof user.avatar === 'object' ? user.avatar : null;
    const url = user.avatarUrl || (avatarObject && avatarObject.url) || '';

    return {
        avatar: avatarObject || (url ? { url } : null),
        avatarUrl: url
    };
};

const loadUserAttributeOptions = async(dbAdapter) => {
    const [curriculaSetting, gradeLevelsSetting, gradeStructureSetting] = await Promise.all([
        dbAdapter.findOneInCollection('settings', { id: 'USER_CURRICULA' }),
        dbAdapter.findOneInCollection('settings', { id: 'USER_GRADE_LEVELS' }),
        dbAdapter.findOneInCollection('settings', { id: 'USER_GRADE_STRUCTURE' })
    ]);

    const curriculum = normalizeStringList(curriculaSetting?.value, DEFAULT_CURRICULA);
    const rawStructureSource = Array.isArray(gradeStructureSetting?.value)
        ? gradeStructureSetting.value
        : Array.isArray(gradeLevelsSetting?.value)
            ? gradeLevelsSetting.value
            : DEFAULT_GRADE_STRUCTURE;

    const gradeStructure = normalizeGradeStructure(rawStructureSource, DEFAULT_GRADE_STRUCTURE);
    const gradeLevelFallback = gradeStructure.map((entry) => entry.grade);
    const gradeLevels = normalizeStringList(
        Array.isArray(gradeLevelsSetting?.value) ? gradeLevelsSetting.value : gradeLevelFallback,
        gradeLevelFallback.length > 0 ? gradeLevelFallback : DEFAULT_GRADE_LEVELS
    );

    return {
        curriculum,
        gradeLevels,
        gradeStructure
    };
};

const normalizeString = (value) => {
    if (!value) return '';
    return String(value).toLowerCase();
};

const matchesSearchTerm = (user, term) => {
    if (!term) return true;
    const searchTerm = normalizeString(term);
    const fieldsToSearch = [
        user.firstName,
        user.lastName,
        user.middleName,
        user.username,
        user.email,
        user.libraryCardNumber,
    user?.library?.cardNumber,
    user.curriculum,
        user.gradeLevel,
    ];

    return fieldsToSearch.some((field) => normalizeString(field).includes(searchTerm));
};

const getUserIdentifiers = (user) => {
    const identifiers = new Set();
    [
        user?._id,
        user?.id,
        user?.userId,
        user?.libraryCardNumber,
        user?.library?.cardNumber,
        user?.username,
        user?.email,
    ]
        .filter(Boolean)
        .forEach((value) => identifiers.add(String(value)));
    return identifiers;
};

const sanitizeUserSummary = (user) => {
    const primaryId = user.id || user._id;
    if (!primaryId) {
        return null;
    }

    const { avatar, avatarUrl } = resolveAvatarFields(user);

    return {
        id: String(primaryId),
        _id: user._id,
        firstName: user.firstName || '',
        lastName: user.lastName || '',
        middleName: user.middleName || '',
        username: user.username || '',
        email: user.email || '',
        role: user.role || 'student',
    curriculum: user.curriculum || '',
        gradeLevel: user.gradeLevel || user.grade || '',
        libraryCardNumber: user.library?.cardNumber || user.libraryCardNumber || '',
        avatar,
        avatarUrl,
    };
};

router.get('/roles', verifyToken, requireStaff, async (req, res) => {
    try {
        const users = await req.dbAdapter.findInCollection('users', {});
        const roleSet = new Set();

        users.forEach((user) => {
            const rawRole = user?.role;
            if (!rawRole) {
                return;
            }
            const normalized = String(rawRole).trim().toLowerCase();
            if (normalized) {
                roleSet.add(normalized);
            }
        });

        if (roleSet.size === 0) {
            DEFAULT_SYSTEM_ROLES.forEach((role) => roleSet.add(role));
        }

        const roles = Array.from(roleSet).sort((a, b) => a.localeCompare(b));
        res.json({ roles });
    } catch (error) {
        console.error('Failed to load user roles:', error);
        res.status(500).json({ message: 'Failed to load user roles' });
    }
});

router.get('/search', verifyToken, requireStaff, async(req, res) => {
    try {
        const {
            q = '',
                role,
                limit = 20
        } = req.query;

        const searchTerm = String(q || '').trim();
        if (!searchTerm) {
            return res.json([]);
        }

        const filters = {};
        if (role) {
            filters.role = role;
        }

        const users = await req.dbAdapter.findInCollection('users', filters);
        const results = users
            .filter((user) => matchesSearchTerm(user, searchTerm))
            .sort((a, b) => {
                const dateA = new Date(a.updatedAt || a.createdAt || 0);
                const dateB = new Date(b.updatedAt || b.createdAt || 0);
                return dateB - dateA;
            })
            .slice(0, Math.max(parseInt(limit, 10) || 20, 1))
            .map(sanitizeUserSummary)
            .filter(Boolean);

        res.json(results);
    } catch (error) {
        console.error('Search users error:', error);
        res.status(500).json({ message: 'Failed to search users' });
    }
});

router.get('/:id/borrowing-status', verifyToken, requireStaff, async(req, res) => {
    try {
        const rawId = String(req.params.id);
        let user = await req.dbAdapter.findUserById(rawId);
        if (!user) {
            user = await req.dbAdapter.findOneInCollection('users', { id: rawId });
        }
        if (!user) {
            user = await req.dbAdapter.findOneInCollection('users', { username: rawId });
        }

        if (!user) {
            return res.status(404).json({ message: 'User not found' });
        }

        const identifiers = getUserIdentifiers(user);
        const transactions = await req.dbAdapter.findInCollection('transactions', {});
        const now = new Date();
        let borrowedCount = 0;
        let overdueBooks = 0;

        const relevantTransactions = transactions.filter(transaction => {
            const transactionUserId = String(transaction.userId || '');
            return identifiers.has(transactionUserId);
        });

        relevantTransactions.forEach(transaction => {
            const transactionStatus = transaction.status || 'pending';
            const items = Array.isArray(transaction.items) ? transaction.items : [];
            const dueDate = transaction.dueDate ? new Date(transaction.dueDate) : null;
            const isTransactionActive = ['borrowed', 'active'].includes(transactionStatus);

            if (items.length === 0 && isTransactionActive) {
                borrowedCount += 1;
                if (dueDate && dueDate < now) {
                    overdueBooks += 1;
                }
                return;
            }

            items.forEach(item => {
                const itemStatus = item.status || transactionStatus;
                if (['borrowed', 'active'].includes(itemStatus)) {
                    borrowedCount += 1;
                    if (dueDate && dueDate < now) {
                        overdueBooks += 1;
                    }
                }
            });
        });

        const borrowingStats = user.borrowingStats || {};
        const resolvedBorrowedCount = Math.max(borrowedCount, borrowingStats.currentlyBorrowed || 0);

        res.json({
            userId: String(user._id || user.id),
            overdueBooks,
            totalBorrowed: borrowingStats.totalBorrowed || relevantTransactions.length,
            borrowedCount: resolvedBorrowedCount,
            currentlyBorrowed: resolvedBorrowedCount,
            totalReturned: borrowingStats.totalReturned || 0,
            totalFines: borrowingStats.totalFines || 0,
            borrowingLimit: user.library?.borrowingLimit || 5,
            fineBalance: user.library?.fineBalance || 0,
        });
    } catch (error) {
        console.error('Get borrowing status error:', error);
        res.status(500).json({ message: 'Failed to fetch borrowing status' });
    }
});

router.get('/', verifyToken, requireStaff, async(req, res) => {
    try {
        const {
            page = 1,
            limit = 20,
            role,
            curriculum,
            gradeLevel,
            isActive,
            search
        } = req.query;

        let filters = {};
    if (role) filters.role = role;
    if (curriculum) filters.curriculum = curriculum;
        if (gradeLevel) filters.gradeLevel = gradeLevel;
        if (isActive !== undefined) filters.isActive = isActive === 'true';

        let users = await req.dbAdapter.findInCollection('users', filters);

        if (search) {
            const searchLower = search.toLowerCase();
            users = users.filter(user =>
                user.firstName ?.toLowerCase().includes(searchLower) ||
                user.lastName ?.toLowerCase().includes(searchLower) ||
                user.email ?.toLowerCase().includes(searchLower) ||
                user.username ?.toLowerCase().includes(searchLower)
            );
        }

        users.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));

    const total = users.length;
    const normalizedPage = Math.max(parseInt(page, 10) || 1, 1);
    const limitString = typeof limit === 'string' ? limit.toLowerCase() : limit;
    const wantsAll = limitString === 'all' || parseInt(limit, 10) === -1;
    const resolvedLimit = wantsAll ? total : Math.max(parseInt(limit, 10) || 20, 1);
    const skip = wantsAll ? 0 : (normalizedPage - 1) * resolvedLimit;
    const paginatedUsers = wantsAll ? users : users.slice(skip, skip + resolvedLimit);

        const safeUsers = paginatedUsers.map(user => {
            const { password, ...safeUser } = user;
            const { avatar, avatarUrl } = resolveAvatarFields(safeUser);
            return {
                ...safeUser,
                avatar,
                avatarUrl
            };
        });

        res.json({
            users: safeUsers,
            pagination: {
                page: normalizedPage,
                limit: resolvedLimit,
                total,
                pages: wantsAll ? (total > 0 ? 1 : 0) : Math.ceil(total / resolvedLimit),
                mode: wantsAll ? 'all' : 'paged'
            },
            total
        });

    } catch (error) {
        console.error('Get users error:', error);
        res.status(500).json({ message: 'Failed to fetch users' });
    }
});

router.get('/profile/user-attributes', verifyToken, async(req, res) => {
    try {
        const options = await loadUserAttributeOptions(req.dbAdapter);
        res.json(options);
    } catch (error) {
        console.error('Failed to load profile user attributes:', error);
        res.status(500).json({ message: 'Failed to load user attribute options' });
    }
});

router.get('/profile/stats', verifyToken, async(req, res) => {
    try {
        const userId = req.user.id;
        const transactions = await req.dbAdapter.findInCollection('transactions', { userId });

        const stats = {
            totalBorrowings: transactions.length,
            currentlyBorrowed: transactions.filter(t => t.status === 'borrowed').length,
            overdueBorrowings: transactions.filter(t => t.status === 'borrowed' && new Date(t.dueDate) < new Date()).length,
            totalFines: transactions.reduce((sum, t) => sum + (t.fine || 0), 0)
        };

        res.json(stats);
    } catch (error) {
        console.error('Get profile stats error:', error);
        res.status(500).json({ message: 'Failed to fetch profile stats' });
    }
});

router.get('/profile/borrowing-history', verifyToken, async(req, res) => {
    try {
        const userId = req.user.id;
        const { page = 1, limit = 10 } = req.query;

        let transactions = await req.dbAdapter.findInCollection('transactions', { userId });
        transactions.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));

        if (typeof enrichTransactionsWithBookMetadata === 'function') {
            transactions = await enrichTransactionsWithBookMetadata(transactions, req.dbAdapter);
        }

        res.json(transactions);
    } catch (error) {
        console.error('Get borrowing history error:', error);
        res.status(500).json({ message: 'Failed to fetch borrowing history' });
    }
});

router.get('/:id', verifyToken, requireStaff, async(req, res) => {
    try {
        const user = await req.dbAdapter.findUserById(req.params.id);

        if (!user) {
            return res.status(404).json({ message: 'User not found' });
        }

        const { password, ...safeUser } = user;

        const { avatar, avatarUrl } = resolveAvatarFields(safeUser);

        const normalized = {
            ...safeUser,
            avatar,
            avatarUrl
        };

        res.json(normalized);
    } catch (error) {
        console.error('Get user error:', error);
        res.status(500).json({ message: 'Failed to fetch user' });
    }
});

router.post('/', verifyToken, requireLibrarian, logAction('CREATE', 'user'), async(req, res) => {
    try {
        const {
            username,
            email: rawEmail,
            password,
            firstName,
            lastName,
            role,
            curriculum,
            gradeLevel
        } = req.body;

        const trimmedEmail = typeof rawEmail === 'string' ? rawEmail.trim() : '';
        const normalizedRoleInput = typeof role === 'string' ? role.trim() : role;
        const resolvedRole = normalizedRoleInput || 'student';

        setAuditContext(req, {
            metadata: {
                createRequest: {
                    username: username || null,
                    email: trimmedEmail || null,
                    role: resolvedRole || null
                }
            },
            details: {
                userDraft: {
                    username: username || null,
                    email: trimmedEmail || null,
                    firstName: firstName || null,
                    lastName: lastName || null,
                    role: resolvedRole || null,
                    curriculum: curriculum || null,
                    gradeLevel: gradeLevel || null
                }
            }
        });

        const missingFields = [];
        if (!username || !String(username).trim()) missingFields.push('username');
        if (!password) missingFields.push('password');
        if (!firstName || !String(firstName).trim()) missingFields.push('firstName');
        if (!lastName || !String(lastName).trim()) missingFields.push('lastName');

        if (missingFields.length > 0) {
            setAuditContext(req, {
                success: false,
                status: 'ValidationError',
                description: 'User creation missing required fields',
                metadata: { missingFields }
            });
            return res.status(400).json({ message: `Missing required fields: ${missingFields.join(', ')}` });
        }

        if (password.length < 6) {
            setAuditContext(req, {
                success: false,
                status: 'ValidationError',
                description: 'User creation failed due to short password',
                metadata: {
                    passwordLength: password.length
                }
            });
            return res.status(400).json({ message: 'Password must be at least 6 characters' });
        }

        const existingUsers = await req.dbAdapter.findInCollection('users', { username });
        if (existingUsers.length > 0) {
            setAuditContext(req, {
                success: false,
                status: 'Conflict',
                description: `User creation failed: username ${username} already exists`,
                metadata: {
                    username
                }
            });
            return res.status(400).json({ message: 'Username already exists' });
        }

        if (trimmedEmail) {
            const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
            if (!emailRegex.test(trimmedEmail)) {
                setAuditContext(req, {
                    success: false,
                    status: 'ValidationError',
                    description: 'User creation failed due to invalid email format',
                    metadata: { email: trimmedEmail }
                });
                return res.status(400).json({ message: 'Invalid email address' });
            }

            const existingEmails = await req.dbAdapter.findInCollection('users', { email: trimmedEmail });
            if (existingEmails.length > 0) {
                setAuditContext(req, {
                    success: false,
                    status: 'Conflict',
                    description: `User creation failed: email ${trimmedEmail} already exists`,
                    metadata: {
                        email: trimmedEmail
                    }
                });
                return res.status(400).json({ message: 'Email already exists' });
            }
        }

        if (req.user.role === 'librarian' && resolvedRole === 'admin') {
            setAuditContext(req, {
                success: false,
                status: 'PermissionDenied',
                description: 'User creation failed: librarians cannot create admin users'
            });
            return res.status(403).json({ message: 'Cannot create admin users' });
        }

        const hashedPassword = await bcrypt.hash(password, 10);

        const generatedLibraryCardNumber = username || `USER-${Date.now()}`;

        const userData = {
            username,
            email: trimmedEmail || null,
            password: hashedPassword,
            firstName,
            lastName,
            role: resolvedRole,
            curriculum: curriculum || null,
            gradeLevel: gradeLevel || null,
            isActive: true,
            createdAt: new Date(),
            updatedAt: new Date(),
            createdBy: req.user.id,
            lastLoginAt: null,
            profile: {
                phone: '',
                address: '',
                dateOfBirth: null
            },
            library: {
                cardNumber: generatedLibraryCardNumber,
                membershipDate: new Date(),
                borrowingLimit: resolvedRole === 'student' ? 5 : 10,
                fineBalance: 0
            },
            borrowingStats: {
                totalBorrowed: 0,
                currentlyBorrowed: 0,
                totalReturned: 0,
                totalFines: 0
            }
        };

        const newUser = await req.dbAdapter.createUser(userData);

        setAuditContext(req, {
            entityId: newUser._id,
            resourceId: newUser._id,
            description: `Created user ${newUser.username}`,
            details: {
                username: newUser.username,
                email: newUser.email,
                role: newUser.role,
            },
            metadata: {
                actorId: req.user.id,
                createdAt: newUser.createdAt,
                role: newUser.role
            },
            success: true,
            status: 'Created'
        });

        res.status(201).json({
            message: 'User created successfully',
            userId: newUser._id,
            username: newUser.username,
            email: newUser.email
        });

    } catch (error) {
        console.error('Create user error:', error);
        setAuditContext(req, {
            success: false,
            status: 'Error',
            description: `User creation failed: ${error.message}`,
            details: {
                error: error.message
            }
        });
        res.status(500).json({ message: 'Failed to create user', error: error.message });
    }
});

router.put('/:id/status', verifyToken, requireStaff, logAction('UPDATE_STATUS', 'user'), async(req, res) => {
    try {
        const userId = req.params.id;
        const { isActive } = req.body;

        setAuditContext(req, {
            entityId: userId,
            metadata: {
                updateStatusRequest: {
                    userId,
                    isActive
                }
            }
        });

        if (typeof isActive !== 'boolean') {
            setAuditContext(req, {
                success: false,
                status: 'ValidationError',
                description: 'User status update failed: isActive must be boolean'
            });
            return res.status(400).json({ message: 'isActive must be a boolean' });
        }

        const user = await req.dbAdapter.findUserById(userId);
        if (!user) {
            setAuditContext(req, {
                success: false,
                status: 'UserNotFound',
                description: `User status update failed: user ${userId} not found`
            });
            return res.status(404).json({ message: 'User not found' });
        }

        if (userId === req.user.id && isActive === false) {
            setAuditContext(req, {
                success: false,
                status: 'ValidationError',
                description: 'User status update failed: cannot deactivate own account'
            });
            return res.status(400).json({ message: 'Cannot deactivate your own account' });
        }

        if (req.user.role === 'staff' && user.role === 'admin') {
            setAuditContext(req, {
                success: false,
                status: 'PermissionDenied',
                description: 'User status update failed: staff cannot modify admin accounts'
            });
            return res.status(403).json({ message: 'Cannot change status of admin users' });
        }

        if (req.user.role === 'librarian' && user.role === 'admin' && isActive === false) {
            setAuditContext(req, {
                success: false,
                status: 'PermissionDenied',
                description: 'User status update failed: librarians cannot deactivate admins'
            });
            return res.status(403).json({ message: 'Cannot deactivate admin users' });
        }

        await req.dbAdapter.updateUser(userId, {
            isActive,
            updatedAt: new Date(),
            updatedBy: req.user.id
        });

        setAuditContext(req, {
            entityId: userId,
            description: `Updated user status for ${user.username}`,
            details: {
                username: user.username,
                previousStatus: Boolean(user.isActive),
                newStatus: Boolean(isActive),
            },
            metadata: {
                actorId: req.user.id,
                newStatus: Boolean(isActive)
            },
            success: true,
            status: 'Updated'
        });

        res.json({ message: 'User status updated successfully', isActive });
    } catch (error) {
        console.error('Update user status error:', error);
        setAuditContext(req, {
            success: false,
            status: 'Failed',
            description: 'Failed to update user status',
            details: { error: error.message },
        });
        res.status(500).json({ message: 'Failed to update user status' });
    }
});

router.post('/:id/avatar', verifyToken, logAction('UPLOAD_AVATAR', 'user'), async(req, res) => {
    avatarUpload.single('avatar')(req, res, async(uploadError) => {
        if (uploadError) {
            const message = uploadError instanceof multer.MulterError
                ? uploadError.code === 'LIMIT_FILE_SIZE'
                    ? 'File too large. Maximum size is 5 MB.'
                    : uploadError.message
                : uploadError.message;

            setAuditContext(req, {
                success: false,
                status: 'ValidationError',
                description: 'Avatar upload failed',
                metadata: {
                    error: message
                }
            });
            return res.status(400).json({ message: message || 'Failed to upload avatar' });
        }

        try {
            if (!req.file) {
                setAuditContext(req, {
                    success: false,
                    status: 'ValidationError',
                    description: 'Avatar upload failed: no file provided'
                });
                return res.status(400).json({ message: 'Please provide an image file to upload.' });
            }

            const resolvedId = req.params.id === 'me' ? req.user.id : req.params.id;
            if (!resolvedId) {
                setAuditContext(req, {
                    success: false,
                    status: 'ValidationError',
                    description: 'Avatar upload failed: missing user identifier'
                });
                return res.status(400).json({ message: 'Unable to resolve user identifier.' });
            }

            const canModify = resolvedId === req.user.id || ['admin', 'librarian', 'staff'].includes(req.user.role);
            if (!canModify) {
                setAuditContext(req, {
                    success: false,
                    status: 'PermissionDenied',
                    description: 'Avatar upload failed: insufficient permissions'
                });
                return res.status(403).json({ message: 'You do not have permission to update this avatar.' });
            }

            const targetUser = await req.dbAdapter.findUserById(resolvedId);
            if (!targetUser) {
                setAuditContext(req, {
                    success: false,
                    status: 'UserNotFound',
                    description: 'Avatar upload failed: user not found'
                });
                return res.status(404).json({ message: 'User not found.' });
            }

            const relativeUrl = path.posix.join('/uploads/avatars', req.file.filename);
            const avatarPayload = {
                url: relativeUrl,
                filename: req.file.filename,
                mimeType: req.file.mimetype,
                size: req.file.size,
                uploadedAt: new Date()
            };

            await req.dbAdapter.updateUser(resolvedId, {
                avatar: avatarPayload,
                avatarUrl: relativeUrl,
                updatedAt: new Date()
            });

            if (targetUser?.avatar?.filename && targetUser.avatar.filename !== req.file.filename) {
                const previousPath = path.join(AVATAR_STORAGE_DIR, targetUser.avatar.filename);
                await removeFileQuietly(previousPath);
            }

            setAuditContext(req, {
                success: true,
                status: 'Updated',
                entityId: resolvedId,
                description: `Updated avatar for user ${targetUser.username || resolvedId}`,
                metadata: {
                    filename: req.file.filename,
                    size: req.file.size,
                    mimeType: req.file.mimetype
                }
            });

            res.json({
                message: 'Profile photo updated successfully.',
                avatar: avatarPayload,
                avatarUrl: relativeUrl
            });
        } catch (error) {
            console.error('Avatar upload error:', error);
            setAuditContext(req, {
                success: false,
                status: 'Failed',
                description: 'Avatar upload failed due to server error',
                details: { error: error.message }
            });
            res.status(500).json({ message: 'Failed to update avatar.' });
        }
    });
});

router.put('/:id', verifyToken, logAction('UPDATE', 'user'), async(req, res) => {
    try {
        const userId = req.params.id;
        const {
            firstName,
            lastName,
            role,
            curriculum,
            gradeLevel,
            grade,
            section,
            isActive,
            email
        } = req.body;

        const roleProvided = Object.prototype.hasOwnProperty.call(req.body || {}, 'role');
        const gradeLevelProvided = Object.prototype.hasOwnProperty.call(req.body || {}, 'gradeLevel');
        const gradeProvided = Object.prototype.hasOwnProperty.call(req.body || {}, 'grade');
        const sectionProvided = Object.prototype.hasOwnProperty.call(req.body || {}, 'section');
        const normalizedRoleInput = typeof role === 'string' ? role.trim() : role;
        const resolvedRole = roleProvided ? (normalizedRoleInput || 'student') : undefined; // fallback to student when role input is blank

        const normalizeTextField = (value) => {
            if (typeof value === 'string') {
                return value.trim();
            }
            if (value === undefined || value === null) {
                return '';
            }
            return value;
        };

        setAuditContext(req, {
            entityId: userId,
            metadata: {
                updateRequest: {
                    userId,
                    fields: Object.keys(req.body || {})
                }
            }
        });

        const canEdit = req.user.role === 'admin' ||
            req.user.role === 'librarian' ||
            req.user.id === userId;

        if (!canEdit) {
            setAuditContext(req, {
                success: false,
                status: 'PermissionDenied',
                description: 'User update failed: insufficient permissions'
            });
            return res.status(403).json({ message: 'Insufficient permissions' });
        }

        if (roleProvided && req.user.id !== userId) {
            if (req.user.role === 'librarian' && resolvedRole === 'admin') {
                setAuditContext(req, {
                    success: false,
                    status: 'PermissionDenied',
                    description: 'User update failed: librarians cannot assign admin role'
                });
                return res.status(403).json({ message: 'Cannot set admin role' });
            }
            if (req.user.role === 'staff') {
                setAuditContext(req, {
                    success: false,
                    status: 'PermissionDenied',
                    description: 'User update failed: staff cannot change roles'
                });
                return res.status(403).json({ message: 'Cannot change user roles' });
            }
        }

        const user = await req.dbAdapter.findUserById(userId);
        if (!user) {
            setAuditContext(req, {
                success: false,
                status: 'UserNotFound',
                description: `User update failed: user ${userId} not found`
            });
            return res.status(404).json({ message: 'User not found' });
        }

        const updateData = {
            updatedAt: new Date(),
            updatedBy: req.user.id
        };

        if (firstName) updateData.firstName = firstName;
        if (lastName) updateData.lastName = lastName;
        if (roleProvided && req.user.id !== userId) updateData.role = resolvedRole;
    if (curriculum) updateData.curriculum = curriculum;
        if (gradeLevelProvided) {
            updateData.gradeLevel = normalizeTextField(gradeLevel);
        }
        if (gradeProvided) {
            const normalizedGrade = normalizeTextField(grade);
            updateData.grade = normalizedGrade;
            if (!gradeLevelProvided) {
                updateData.gradeLevel = normalizedGrade;
            }
        }
        if (sectionProvided) {
            updateData.section = normalizeTextField(section);
        }
        if (email) updateData.email = email;
        if (isActive !== undefined && req.user.role !== 'student') updateData.isActive = isActive;

        await req.dbAdapter.updateUser(userId, updateData);

        setAuditContext(req, {
            entityId: userId,
            resourceId: userId,
            success: true,
            status: 'Updated',
            description: `Updated profile for user ${user.username || userId}`,
            details: {
                updatedFields: Object.keys(updateData).filter(key => key !== 'updatedAt' && key !== 'updatedBy'),
                role: updateData.role || user.role,
                isActive: updateData.isActive !== undefined ? updateData.isActive : user.isActive
            },
            metadata: {
                actorId: req.user.id,
                updatedAt: updateData.updatedAt
            }
        });

        res.json({ message: 'User updated successfully' });
    } catch (error) {
        console.error('Update user error:', error);
        setAuditContext(req, {
            success: false,
            status: 'Error',
            description: `User update failed: ${error.message}`,
            details: {
                error: error.message
            }
        });
        res.status(500).json({ message: 'Failed to update user' });
    }
});

router.delete('/:id', verifyToken, requireAdmin, logAction('DELETE', 'user'), async(req, res) => {
    try {
        const userId = req.params.id;

        setAuditContext(req, {
            entityId: userId,
            metadata: {
                deleteRequest: {
                    userId
                }
            }
        });

        const user = await req.dbAdapter.findUserById(userId);
        if (!user) {
            setAuditContext(req, {
                success: false,
                status: 'UserNotFound',
                description: `User deletion failed: user ${userId} not found`
            });
            return res.status(404).json({ message: 'User not found' });
        }

        if (userId === req.user.id) {
            setAuditContext(req, {
                success: false,
                status: 'ValidationError',
                description: 'User deletion failed: cannot delete own account'
            });
            return res.status(400).json({ message: 'Cannot delete your own account' });
        }

        await req.dbAdapter.deleteUser(userId);

        setAuditContext(req, {
            success: true,
            status: 'Deleted',
            entityId: userId,
            resourceId: userId,
            description: `Deleted user ${user.username || userId}`,
            metadata: {
                actorId: req.user.id
            }
        });

        res.json({ message: 'User deleted successfully' });
    } catch (error) {
        console.error('Delete user error:', error);
        setAuditContext(req, {
            success: false,
            status: 'Error',
            description: `User deletion failed: ${error.message}`,
            details: {
                error: error.message
            }
        });
        res.status(500).json({ message: 'Failed to delete user' });
    }
});

router.post('/:id/reset-password', verifyToken, requireLibrarian, logAction('RESET_PASSWORD', 'user'), async(req, res) => {
    try {
        const userId = req.params.id;
        const { newPassword } = req.body;

        setAuditContext(req, {
            entityId: userId,
            metadata: {
                resetPasswordRequest: {
                    userId,
                    providedPasswordLength: newPassword ? newPassword.length : null
                }
            }
        });

        if (!newPassword || newPassword.length < 6) {
            setAuditContext(req, {
                success: false,
                status: 'ValidationError',
                description: 'Password reset failed: password must be at least 6 characters'
            });
            return res.status(400).json({ message: 'Password must be at least 6 characters' });
        }

        const user = await req.dbAdapter.findUserById(userId);
        if (!user) {
            setAuditContext(req, {
                success: false,
                status: 'UserNotFound',
                description: `Password reset failed: user ${userId} not found`
            });
            return res.status(404).json({ message: 'User not found' });
        }

        const hashedPassword = await bcrypt.hash(newPassword, 10);

        await req.dbAdapter.updateUser(userId, {
            password: hashedPassword,
            updatedAt: new Date(),
            updatedBy: req.user.id
        });

        setAuditContext(req, {
            success: true,
            status: 'Completed',
            entityId: userId,
            resourceId: userId,
            description: `Reset password for user ${user.username || userId}`,
            metadata: {
                actorId: req.user.id
            }
        });

        await notifyRoles(req, ['admin'], {
            title: 'Password reset',
            message: `${formatUserName(req.user)} reset the password for ${formatUserName(user)}.`,
            type: 'password-reset',
            severity: 'medium',
            meta: {
                targetUserId: userId,
                actorId: req.user.id,
                method: 'admin-reset'
            }
        });

        res.json({ message: 'Password reset successfully' });
    } catch (error) {
        console.error('Reset password error:', error);
        setAuditContext(req, {
            success: false,
            status: 'Error',
            description: `Password reset failed: ${error.message}`,
            details: {
                error: error.message
            }
        });
        res.status(500).json({ message: 'Failed to reset password' });
    }
});

module.exports = router;
```

# Backend - Scripts

## cleanup-email-verification.js

| Field | Details |
| --- | --- |
| Program Name | cleanup-email-verification.js |
| Description | Backend maintenance or data migration script. |
| Called by | None |
| Table used | None |
|  |  |
| Programmer | Nazel Asca√±o |
| Date created | 12/14/2025 |
| Revision Date | TBD |
| Revision / description of change | None |

```javascript
const dotenv = require('dotenv');
const path = require('path');

dotenv.config({ path: path.resolve(__dirname, '..', '.env') });

const DatabaseAdapter = require('../adapters/DatabaseAdapter');

(async () => {
  console.log('üßπ Cleaning up email verification fields from users collection...');

  const dbAdapter = new DatabaseAdapter();
  try {
    await dbAdapter.connect();
    await dbAdapter.initialize();
  } catch (err) {
    console.error('‚ùå Failed to initialize database adapter:', err && err.message ? err.message : err);
    process.exit(1);
  }

  const adapterType = typeof dbAdapter.getType === 'function' ? dbAdapter.getType() : 'unknown';

  try {
    if (adapterType === 'mongo' && dbAdapter.adapter && dbAdapter.adapter.db) {

      const result = await dbAdapter.adapter.db.collection('users').updateMany({}, { $unset: { emailVerified: '', emailVerifiedAt: '' } });
      console.log(`‚úÖ Mongo: Modified ${result.modifiedCount} documents, matched ${result.matchedCount}`);
    } else if (adapterType === 'offline') {

      const users = await dbAdapter.findInCollection('users', {});
      let modified = 0;
      for (const user of users) {

        const update = { emailVerified: undefined, emailVerifiedAt: undefined };
        const updated = await dbAdapter.updateInCollection('users', { _id: user._id }, update);
        if (updated) modified += 1;
      }
      console.log(`‚úÖ Offline: Updated ${modified} user documents`);
    } else {

      const users = await dbAdapter.findInCollection('users', {});
      let modified = 0;
      for (const user of users) {
        const cleaned = { ...user };
        delete cleaned.emailVerified;
        delete cleaned.emailVerifiedAt;

        if (dbAdapter.adapter && dbAdapter.adapter.db) {
          const filter = { _id: user._id };
          await dbAdapter.adapter.db.collection('users').replaceOne(filter, cleaned).then((res) => {
            if (res.modifiedCount && res.modifiedCount > 0) modified += res.modifiedCount;
          }).catch(() => {});
        } else {
          await dbAdapter.updateInCollection('users', { _id: user._id }, cleaned);
          modified += 1;
        }
      }
      console.log(`‚úÖ Fallback: Updated ${modified} user documents`);
    }
  } catch (error) {
    console.error('‚ùå Error during cleanup:', error && error.message ? error.message : error);
    process.exit(1);
  } finally {
    if (dbAdapter.adapter && typeof dbAdapter.adapter.close === 'function') {
      await dbAdapter.adapter.close();
    }
  }

  console.log('üéâ Email verification cleanup completed successfully!');
})();
```

## init-settings.js

| Field | Details |
| --- | --- |
| Program Name | init-settings.js |
| Description | Backend maintenance or data migration script. |
| Called by | None |
| Table used | settings |
|  |  |
| Programmer | Nazel Asca√±o |
| Date created | 12/14/2025 |
| Revision Date | TBD |
| Revision / description of change | None |

```javascript
const DatabaseAdapter = require('../adapters/DatabaseAdapter');
const path = require('path');

const dataPath = path.join(__dirname, '..', 'data');
const dbAdapter = new DatabaseAdapter(dataPath);

async function initializeSettings() {
  try {
    console.log('Initializing default settings...');

    const defaultSettings = [
      { id: 'MAX_BORROW_DAYS', value: 14, type: 'number', category: 'library', description: 'Maximum number of days for regular book borrowing' },
      { id: 'FINE_PER_DAY', value: 5, type: 'number', category: 'library', description: 'Fine amount per day for overdue books' },
      { id: 'SCHOOL_YEAR_START', value: '2024-08-01', type: 'string', category: 'library', description: 'School year start date' },
      { id: 'SCHOOL_YEAR_END', value: '2025-05-31', type: 'string', category: 'library', description: 'School year end date' },
      { id: 'LIBRARY_NAME', value: 'ONHS Library', type: 'string', category: 'library', description: 'Library name for receipts' },
      { id: 'LIBRARY_ADDRESS', value: 'School Address', type: 'string', category: 'library', description: 'Library address for receipts' },
      { id: 'ENABLE_FINES', value: true, type: 'boolean', category: 'library', description: 'Enable or disable fine system' },
      { id: 'MAX_BOOKS_PER_TRANSACTION', value: 10, type: 'number', category: 'library', description: 'Maximum number of books per transaction' }
    ];

    for (const setting of defaultSettings) {
      const existing = await dbAdapter.findOneInCollection('settings', { id: setting.id });

      const settingData = {
        ...setting,
        createdAt: new Date(),
        updatedAt: new Date()
      };

      if (existing) {
        await dbAdapter.updateInCollection('settings', { id: setting.id }, settingData);
        console.log(`Updated setting: ${setting.id}`);
      } else {
        await dbAdapter.insertIntoCollection('settings', settingData);
        console.log(`Created setting: ${setting.id}`);
      }
    }

    console.log('‚úÖ Default settings initialized successfully');
  } catch (error) {
    console.error('‚ùå Error initializing settings:', error);
  }
}

initializeSettings();
```

## migrate-offline-data-to-mongo.js

| Field | Details |
| --- | --- |
| Program Name | migrate-offline-data-to-mongo.js |
| Description | Backend maintenance or data migration script. |
| Called by | None |
| Table used | None |
|  |  |
| Programmer | Nazel Asca√±o |
| Date created | 12/14/2025 |
| Revision Date | TBD |
| Revision / description of change | None |

```javascript
const fs = require('fs/promises');
const path = require('path');

const dotenv = require('dotenv');

dotenv.config({ path: path.resolve(__dirname, '..', '.env') });

delete process.env.USE_OFFLINE_DB;
const DatabaseAdapter = require('../adapters/DatabaseAdapter');

const DATA_DIRECTORY = path.resolve(__dirname, '..', 'data');
const COLLECTION_FILES = {
  users: 'users.json',
  books: 'books.json',
  transactions: 'transactions.json',
  settings: 'settings.json',
  audit: 'audit.json',
  annualSets: 'annualSets.json'
};

const COLLECTION_IDENTITY = {
  users: ['id', '_id', 'username', 'email'],
  books: ['id', '_id', 'bookId', 'isbn'],
  transactions: ['id', '_id'],
  settings: ['id', '_id'],
  audit: ['id', '_id'],
  annualSets: ['id', '_id', 'academicYear']
};

const DATE_LIKE_KEY = /(At|Date|On|Time|timestamp)$/i;

const stats = {
  inserted: 0,
  updated: 0,
  skipped: 0,
  errors: 0
};

const errors = [];

const isPlainObject = (value) => Object.prototype.toString.call(value) === '[object Object]';

const coerceDate = (value) => {
  if (typeof value !== 'string') {
    return value;
  }

  const trimmed = value.trim();
  if (!trimmed) {
    return value;
  }

  if (!/\d{4}-\d{2}-\d{2}/.test(trimmed) && !trimmed.includes('T')) {
    return value;
  }

  const parsed = new Date(trimmed);
  if (Number.isNaN(parsed.getTime())) {
    return value;
  }

  return parsed;
};

const deepConvertDates = (value, parentKey = '') => {
  if (Array.isArray(value)) {
    return value.map((entry) => deepConvertDates(entry));
  }

  if (isPlainObject(value)) {
    return Object.entries(value).reduce((acc, [key, entry]) => {
      const shouldCoerce = DATE_LIKE_KEY.test(key);
      acc[key] = shouldCoerce ? coerceDate(entry) : deepConvertDates(entry, key);
      return acc;
    }, {});
  }

  if (parentKey && DATE_LIKE_KEY.test(parentKey) && typeof value === 'string') {
    return coerceDate(value);
  }

  return value;
};

const sanitizeForUpdate = (document) => {
  const clone = { ...document };
  delete clone._id;
  return clone;
};

const loadCollectionData = async (fileName) => {
  const filePath = path.join(DATA_DIRECTORY, fileName);

  try {
    const content = await fs.readFile(filePath, 'utf8');
    if (!content.trim()) {
      return [];
    }

    const parsed = JSON.parse(content);
    if (!Array.isArray(parsed)) {
      console.warn(`‚ö†Ô∏è  Expected array in ${fileName}, skipping.`);
      return [];
    }

    return parsed.map((doc) => deepConvertDates(doc));
  } catch (error) {
    if (error.code === 'ENOENT') {
      console.warn(`‚ö†Ô∏è  File not found: ${fileName}, skipping.`);
      return [];
    }

    throw error;
  }
};

const buildCandidateFilters = (collection, doc) => {
  const keys = COLLECTION_IDENTITY[collection] || ['id', '_id'];
  const filters = [];

  keys.forEach((key) => {
    const value = doc[key];
    if (value !== undefined && value !== null && value !== '') {
      filters.push({ [key]: value });
    }
  });

  if (filters.length === 0 && doc.id) {
    filters.push({ id: doc.id });
  }

  if (filters.length === 0 && doc._id) {
    filters.push({ _id: doc._id });
  }

  return filters;
};

(async () => {
  console.log('üì¶ Migrating offline JSON collections to MongoDB...');

  const dbAdapter = new DatabaseAdapter();
  await dbAdapter.connect();
  await dbAdapter.initialize();

  const adapterType = typeof dbAdapter.getType === 'function' ? dbAdapter.getType() : 'unknown';
  if (adapterType !== 'mongo') {
    console.error('‚ùå DatabaseAdapter is not using MongoDB. Set USE_OFFLINE_DB=false and provide MONGODB_URI before running this script.');
    process.exit(1);
  }

  for (const [collection, file] of Object.entries(COLLECTION_FILES)) {
    console.log(`\n‚û°Ô∏è  Processing ${collection} (${file})`);

    const documents = await loadCollectionData(file);
    if (documents.length === 0) {
      console.log('   ‚Ä¢ no documents found, skipping');
      continue;
    }

    for (const originalDoc of documents) {
      const rawDoc = { ...originalDoc };

      if (!rawDoc.id && rawDoc._id) {
        rawDoc.id = rawDoc._id;
      }

      const candidateFilters = buildCandidateFilters(collection, rawDoc);

      if (candidateFilters.length === 0) {
        stats.skipped += 1;
        errors.push({ collection, error: 'Document missing identity field', document: rawDoc });
        continue;
      }

      try {
        let existing = null;
        let matchedFilter = null;

        for (const filter of candidateFilters) {
          existing = await dbAdapter.findOneInCollection(collection, filter);
          if (existing) {
            matchedFilter = filter;
            break;
          }
        }

        if (existing && matchedFilter) {
          const updatePayload = sanitizeForUpdate(rawDoc);
          await dbAdapter.updateInCollection(collection, matchedFilter, updatePayload);
          stats.updated += 1;
        } else {
          await dbAdapter.insertIntoCollection(collection, rawDoc);
          stats.inserted += 1;
        }
      } catch (error) {
        stats.errors += 1;
        const docIdentifier = rawDoc.id || rawDoc._id || rawDoc.username || rawDoc.email || 'unknown';
        errors.push({ collection, error: error.message, document: docIdentifier });
        console.error(`   ‚Ä¢ Error syncing document ${docIdentifier}`, error);
      }
    }

    console.log(`   ‚Ä¢ processed ${documents.length} document(s)`);
  }

  console.log('\n‚úÖ Migration complete');
  console.log(`   ‚Üí inserted: ${stats.inserted}`);
  console.log(`   ‚Üí updated:  ${stats.updated}`);
  console.log(`   ‚Üí skipped:  ${stats.skipped}`);
  console.log(`   ‚Üí errors:   ${stats.errors}`);

  if (errors.length > 0) {
    console.log('\n‚ö†Ô∏è  Issues:');
    errors.forEach((entry) => {
      console.log(`   ‚Ä¢ [${entry.collection}] ${entry.error}`);
    });
  }

  if (dbAdapter.adapter && typeof dbAdapter.adapter.close === 'function') {
    await dbAdapter.adapter.close();
  }

  process.exit(errors.length > 0 ? 1 : 0);
})();
```

## reset-and-seed-mongo.js

| Field | Details |
| --- | --- |
| Program Name | reset-and-seed-mongo.js |
| Description | Backend maintenance or data migration script. |
| Called by | None |
| Table used | None |
|  |  |
| Programmer | Nazel Asca√±o |
| Date created | 12/14/2025 |
| Revision Date | TBD |
| Revision / description of change | None |

```javascript
const path = require('path');
const { MongoClient, ObjectId } = require('mongodb');
const bcrypt = require('bcrypt');
const dotenv = require('dotenv');
const { generateTransactionId } = require('../utils/transactionIds');

dotenv.config({ path: path.resolve(__dirname, '..', '.env') });

const uri = process.env.MONGODB_URI || process.env.MONGO_URI;
const dbName = process.env.MONGO_DB_NAME || process.env.MONGODB_DB_NAME || 'olms';

if (!uri) {
  console.error('‚ùå Missing MONGODB_URI. Update backend/.env before running this script.');
  process.exit(1);
}

const dt = (value) => new Date(value);

const buildBorrowingStats = ({ totalBorrowed = 0, currentlyBorrowed = 0, totalFines = 0, totalReturned = 0 }) => ({
  totalBorrowed,
  currentlyBorrowed,
  totalFines,
  totalReturned
});

const buildCopy = ({
  copyId,
  status = 'available',
  condition = 'good',
  location,
  createdAt,
  updatedAt,
  createdBy,
  updatedBy
}) => ({
  copyId,
  status,
  condition,
  location,
  createdAt: dt(createdAt),
  updatedAt: dt(updatedAt),
  createdBy,
  ...(updatedBy ? { updatedBy } : {})
});

const cleanCollection = async (db, name) => {
  const result = await db.collection(name).deleteMany({});
  console.log(`üßπ Cleared ${name}: ${result.deletedCount} document(s)`);
};

(async () => {
  const client = new MongoClient(uri, { serverSelectionTimeoutMS: 8000 });

  try {
    console.log('üîå Connecting to MongoDB Atlas...');
    await client.connect();
    const db = client.db(dbName);

    const adapterCollections = ['users', 'books', 'transactions', 'settings', 'audit', 'annualSets'];
    for (const name of adapterCollections) {
      await cleanCollection(db, name);
    }

    console.log('üß¨ Preparing new interconnected seed data...');

    const [
      adminPassword,
      librarianPassword,
      staffPassword,
      alyssaPassword,
      benPassword,
      carlaPassword
    ] = await Promise.all([
      bcrypt.hash('admin123456', 10),
      bcrypt.hash('librarian123!', 10),
      bcrypt.hash('staff123!', 10),
      bcrypt.hash('alyssa123!', 10),
      bcrypt.hash('ben123!', 10),
      bcrypt.hash('carla123!', 10)
    ]);

    const adminId = new ObjectId();
    const librarianId = new ObjectId();
    const staffId = new ObjectId();
    const alyssaId = new ObjectId();
    const benId = new ObjectId();
    const carlaId = new ObjectId();

    const adminIdStr = adminId.toString();
    const librarianIdStr = librarianId.toString();
    const staffIdStr = staffId.toString();
    const alyssaIdStr = alyssaId.toString();
    const benIdStr = benId.toString();
    const carlaIdStr = carlaId.toString();

    const users = [
      {
        _id: adminId,
        id: adminIdStr,
        username: 'admin',
        email: 'admin@olms.com',
        password: adminPassword,
        firstName: 'Aurelia',
        lastName: 'Del Rosario',
        role: 'admin',
        isActive: true,
        profile: {
          phone: '09170000001',
          address: 'Quezon City',
          dateOfBirth: dt('1985-04-18T00:00:00Z')
        },
        library: {
          cardNumber: 'ADMIN-0001',
          membershipDate: dt('2022-06-01T00:00:00Z'),
          borrowingLimit: 999,
          fineBalance: 0
        },
        borrowingStats: buildBorrowingStats({}),
        createdAt: dt('2022-06-01T00:00:00Z'),
        updatedAt: dt('2025-09-20T01:00:00Z'),
        lastLoginAt: dt('2025-09-20T01:15:00Z'),
        lastActivityAt: dt('2025-09-20T01:30:00Z')
      },
      {
        _id: librarianId,
        id: librarianIdStr,
        username: 'librarian.jane',
        email: 'jane.delacruz@olms.edu',
        password: librarianPassword,
        firstName: 'Jane',
        lastName: 'Dela Cruz',
        role: 'librarian',
        isActive: true,
        profile: {
          phone: '09170000002',
          address: 'Mandaluyong City',
          dateOfBirth: dt('1990-02-09T00:00:00Z')
        },
        library: {
          cardNumber: 'LIB-STF-0002',
          membershipDate: dt('2023-04-10T00:00:00Z'),
          borrowingLimit: 20,
          fineBalance: 0
        },
        borrowingStats: buildBorrowingStats({ totalBorrowed: 4, currentlyBorrowed: 0, totalReturned: 4 }),
        createdAt: dt('2023-04-10T00:00:00Z'),
        updatedAt: dt('2025-09-18T05:10:00Z'),
        lastLoginAt: dt('2025-09-18T05:00:00Z'),
        lastActivityAt: dt('2025-09-18T05:45:00Z')
      },
      {
        _id: staffId,
        id: staffIdStr,
        username: 'staff.mike',
        email: 'mike.reyes@olms.edu',
        password: staffPassword,
        firstName: 'Michael',
        lastName: 'Reyes',
        role: 'staff',
        isActive: true,
        profile: {
          phone: '09170000003',
          address: 'Pasig City',
          dateOfBirth: dt('1988-11-02T00:00:00Z')
        },
        library: {
          cardNumber: 'LIB-STF-0003',
          membershipDate: dt('2023-05-22T00:00:00Z'),
          borrowingLimit: 10,
          fineBalance: 60
        },
        borrowingStats: buildBorrowingStats({ totalBorrowed: 2, currentlyBorrowed: 0, totalFines: 60, totalReturned: 2 }),
        createdAt: dt('2023-05-22T00:00:00Z'),
        updatedAt: dt('2025-09-14T09:20:00Z'),
        lastLoginAt: dt('2025-09-14T09:00:00Z'),
        lastActivityAt: dt('2025-09-14T09:30:00Z')
      },
      {
        _id: alyssaId,
        id: alyssaIdStr,
        username: 'alyssa.gomez',
        email: 'alyssa.gomez@student.olms.edu',
        password: alyssaPassword,
        firstName: 'Alyssa',
        middleName: 'Reyes',
        lastName: 'Gomez',
        role: 'student',
        isActive: true,
        libraryCardNumber: 'LIB-25-0001',
        lrn: '123456789101',
        grade: 'Grade 11',
  section: 'ICT-A',
  curriculum: 'Senior High - ICT',
        barangay: 'Barangay San Juan',
        municipality: 'Quezon City',
        province: 'Metro Manila',
        fullAddress: '123 Learning St, Barangay San Juan, Quezon City',
        parentGuardianName: 'Maria Gomez',
        parentOccupation: 'Engineer',
        parentAddress: '123 Learning St, Quezon City',
        parentPhone: '09171234567',
        parentEmail: 'maria.gomez@example.com',
        phoneNumber: '09180001111',
        borrowingStats: buildBorrowingStats({ totalBorrowed: 1, currentlyBorrowed: 1, totalReturned: 0 }),
        profile: {
          phone: '09180001111',
          address: 'Barangay San Juan, Quezon City',
          dateOfBirth: dt('2008-04-12T00:00:00Z')
        },
        library: {
          cardNumber: 'LIB-25-0001',
          membershipDate: dt('2025-06-05T00:00:00Z'),
          borrowingLimit: 5,
          fineBalance: 0
        },
        createdAt: dt('2025-06-05T00:00:00Z'),
        updatedAt: dt('2025-09-15T02:30:00Z'),
        lastLoginAt: dt('2025-09-18T01:10:00Z'),
        lastActivityAt: dt('2025-09-18T01:10:00Z')
      },
      {
        _id: benId,
        id: benIdStr,
        username: 'ben.santos',
        email: 'ben.santos@student.olms.edu',
        password: benPassword,
        firstName: 'Ben',
        middleName: 'Luis',
        lastName: 'Santos',
        role: 'student',
        isActive: true,
        libraryCardNumber: 'LIB-25-0002',
        lrn: '123456789202',
        grade: 'Grade 11',
  section: 'ICT-A',
  curriculum: 'Senior High - ICT',
        barangay: 'Barangay Malinis',
        municipality: 'Quezon City',
        province: 'Metro Manila',
        fullAddress: '45 Mabait St, Barangay Malinis, Quezon City',
        parentGuardianName: 'Roberto Santos',
        parentOccupation: 'Accountant',
        parentAddress: '45 Mabait St, Quezon City',
        parentPhone: '09175553311',
        parentEmail: 'roberto.santos@example.com',
        phoneNumber: '09181112222',
        borrowingStats: buildBorrowingStats({ totalBorrowed: 2, currentlyBorrowed: 1, totalReturned: 1 }),
        profile: {
          phone: '09181112222',
          address: 'Barangay Malinis, Quezon City',
          dateOfBirth: dt('2008-08-03T00:00:00Z')
        },
        library: {
          cardNumber: 'LIB-25-0002',
          membershipDate: dt('2025-06-05T00:00:00Z'),
          borrowingLimit: 5,
          fineBalance: 0
        },
        createdAt: dt('2025-06-05T00:00:00Z'),
        updatedAt: dt('2025-09-20T03:05:00Z'),
        lastLoginAt: dt('2025-09-20T03:00:00Z'),
        lastActivityAt: dt('2025-09-20T03:05:00Z')
      },
      {
        _id: carlaId,
        id: carlaIdStr,
        username: 'carla.navarro',
        email: 'carla.navarro@student.olms.edu',
        password: carlaPassword,
        firstName: 'Carla',
        middleName: 'Teves',
        lastName: 'Navarro',
        role: 'student',
        isActive: true,
        libraryCardNumber: 'LIB-25-0003',
        lrn: '123456789303',
        grade: 'Grade 11',
  section: 'STEM-B',
  curriculum: 'Senior High - STEM',
        barangay: 'Barangay Masigasig',
        municipality: 'Marikina City',
        province: 'Metro Manila',
        fullAddress: '78 Rivera St, Barangay Masigasig, Marikina City',
        parentGuardianName: 'Teresa Navarro',
        parentOccupation: 'Nurse',
        parentAddress: '78 Rivera St, Marikina City',
        parentPhone: '09173456780',
        parentEmail: 'teresa.navarro@example.com',
        phoneNumber: '09182223333',
        borrowingStats: buildBorrowingStats({ totalBorrowed: 0, currentlyBorrowed: 0, totalReturned: 0 }),
        profile: {
          phone: '09182223333',
          address: 'Barangay Masigasig, Marikina City',
          dateOfBirth: dt('2008-12-21T00:00:00Z')
        },
        library: {
          cardNumber: 'LIB-25-0003',
          membershipDate: dt('2025-07-10T00:00:00Z'),
          borrowingLimit: 5,
          fineBalance: 0
        },
        createdAt: dt('2025-07-10T00:00:00Z'),
        updatedAt: dt('2025-09-10T06:00:00Z'),
        lastLoginAt: dt('2025-09-16T07:20:00Z'),
        lastActivityAt: dt('2025-09-16T07:20:00Z')
      }
    ];

    const book1Id = new ObjectId();
    const book2Id = new ObjectId();
    const book3Id = new ObjectId();
    const book4Id = new ObjectId();

    const book1Copies = [
      buildCopy({
        copyId: 'ITE-001',
        status: 'borrowed',
        condition: 'good',
        location: 'ICT Resource Shelf',
        createdAt: '2025-08-01T01:00:00Z',
        updatedAt: '2025-09-15T02:35:00Z',
        createdBy: librarianIdStr,
        updatedBy: librarianIdStr
      }),
      buildCopy({
        copyId: 'ITE-002',
        status: 'available',
        condition: 'good',
        location: 'ICT Resource Shelf',
        createdAt: '2025-08-01T01:00:00Z',
        updatedAt: '2025-09-10T04:00:00Z',
        createdBy: librarianIdStr,
        updatedBy: librarianIdStr
      }),
      buildCopy({
        copyId: 'ITE-003',
        status: 'available',
        condition: 'excellent',
        location: 'ICT Resource Shelf',
        createdAt: '2025-08-01T01:00:00Z',
        updatedAt: '2025-09-10T04:00:00Z',
        createdBy: librarianIdStr,
        updatedBy: librarianIdStr
      })
    ];

    const book2Copies = [
      buildCopy({
        copyId: 'PHHIS-001',
        status: 'available',
        condition: 'good',
        location: 'History Corner',
        createdAt: '2025-07-15T01:00:00Z',
        updatedAt: '2025-08-28T03:10:00Z',
        createdBy: librarianIdStr,
        updatedBy: librarianIdStr
      }),
      buildCopy({
        copyId: 'PHHIS-002',
        status: 'available',
        condition: 'good',
        location: 'History Corner',
        createdAt: '2025-07-15T01:00:00Z',
        updatedAt: '2025-08-10T03:10:00Z',
        createdBy: librarianIdStr,
        updatedBy: librarianIdStr
      }),
      buildCopy({
        copyId: 'PHHIS-003',
        status: 'available',
        condition: 'excellent',
        location: 'History Corner',
        createdAt: '2025-07-15T01:00:00Z',
        updatedAt: '2025-08-10T03:10:00Z',
        createdBy: librarianIdStr,
        updatedBy: librarianIdStr
      })
    ];

    const book3Copies = [
      buildCopy({
        copyId: 'MATH-001',
        status: 'available',
        condition: 'good',
        location: 'STEM Reference',
        createdAt: '2025-06-20T01:00:00Z',
        updatedAt: '2025-09-12T07:45:00Z',
        createdBy: librarianIdStr,
        updatedBy: librarianIdStr
      }),
      buildCopy({
        copyId: 'MATH-002',
        status: 'available',
        condition: 'good',
        location: 'STEM Reference',
        createdAt: '2025-06-20T01:00:00Z',
        updatedAt: '2025-09-14T09:20:00Z',
        createdBy: librarianIdStr,
        updatedBy: librarianIdStr
      }),
      buildCopy({
        copyId: 'MATH-003',
        status: 'available',
        condition: 'excellent',
        location: 'STEM Reference',
        createdAt: '2025-06-20T01:00:00Z',
        updatedAt: '2025-09-12T07:45:00Z',
        createdBy: librarianIdStr,
        updatedBy: librarianIdStr
      })
    ];

    const book4Copies = [
      buildCopy({
        copyId: 'LIT-001',
        status: 'borrowed',
        condition: 'good',
        location: 'Literature Wing',
        createdAt: '2025-07-05T01:00:00Z',
        updatedAt: '2025-09-20T03:05:00Z',
        createdBy: librarianIdStr,
        updatedBy: librarianIdStr
      }),
      buildCopy({
        copyId: 'LIT-002',
        status: 'available',
        condition: 'excellent',
        location: 'Literature Wing',
        createdAt: '2025-07-05T01:00:00Z',
        updatedAt: '2025-09-10T03:05:00Z',
        createdBy: librarianIdStr,
        updatedBy: librarianIdStr
      }),
      buildCopy({
        copyId: 'LIT-003',
        status: 'available',
        condition: 'good',
        location: 'Literature Wing',
        createdAt: '2025-07-05T01:00:00Z',
        updatedAt: '2025-09-10T03:05:00Z',
        createdBy: librarianIdStr,
        updatedBy: librarianIdStr
      })
    ];

    const buildBook = ({ _id, title, author, isbn, publisher, publishedYear, category, description, copies, createdAt, updatedAt }) => ({
      _id,
      id: `book_${_id.toString()}`,
      title,
      author,
      isbn,
      publisher,
      publishedYear,
      category,
      description,
      coverImage: '',
      status: 'active',
      totalCopies: copies.length,
      availableCopies: copies.filter((copy) => copy.status === 'available').length,
      copies,
      createdAt: dt(createdAt),
      updatedAt: dt(updatedAt),
      createdBy: librarianIdStr,
      updatedBy: librarianIdStr
    });

    const books = [
      buildBook({
        _id: book1Id,
        title: 'Information Technology Essentials',
        author: 'Ramon Valdez',
        isbn: '978-971-000-1001',
        publisher: 'MindShare Publishing',
        publishedYear: 2023,
        category: 'Information Technology',
        description: 'Comprehensive introduction to ICT concepts, networking, and emerging technologies.',
        copies: book1Copies,
        createdAt: '2025-08-01T01:00:00Z',
        updatedAt: '2025-09-15T02:35:00Z'
      }),
      buildBook({
        _id: book2Id,
        title: 'Philippine History and Governance',
        author: 'Luzviminda Mercado',
        isbn: '978-971-000-2002',
        publisher: 'Heritage Prints',
        publishedYear: 2022,
        category: 'Social Studies',
        description: 'Chronological account of Philippine history with focus on civic responsibility.',
        copies: book2Copies,
        createdAt: '2025-07-15T01:00:00Z',
        updatedAt: '2025-08-28T03:10:00Z'
      }),
      buildBook({
        _id: book3Id,
        title: 'Advanced Mathematics for Senior High',
        author: 'Cristina Villoria',
        isbn: '978-971-000-3003',
        publisher: 'STEM Excellence Press',
        publishedYear: 2024,
        category: 'Mathematics',
        description: 'Problem-based approach to calculus, statistics, and trigonometry for senior high students.',
        copies: book3Copies,
        createdAt: '2025-06-20T01:00:00Z',
        updatedAt: '2025-09-14T09:20:00Z'
      }),
      buildBook({
        _id: book4Id,
        title: '21st Century Philippine Literature',
        author: 'Amelia Magbanua',
        isbn: '978-971-000-4004',
        publisher: 'Literary Gateway',
        publishedYear: 2024,
        category: 'Literature',
        description: 'Anthology of modern Philippine literary works with contextual analysis.',
        copies: book4Copies,
        createdAt: '2025-07-05T01:00:00Z',
        updatedAt: '2025-09-20T03:05:00Z'
      })
    ];

    const buildTransaction = ({
      _id,
      userId,
      items,
      status,
      borrowDate,
      dueDate,
      returnDate,
      fineAmount,
      notes,
      renewalCount,
      createdAt,
      updatedAt,
      createdBy,
      returnNotes,
          returnedBy,
          type = 'regular'
        }) => {
          const kind = type === 'annual-set' ? 'annual' : 'borrow';
          return {
            _id,
            id: generateTransactionId(kind),
            userId,
            items,
            type,
            status,
            borrowDate: borrowDate ? dt(borrowDate) : null,
            dueDate: dueDate ? dt(dueDate) : null,
            returnDate: returnDate ? dt(returnDate) : null,
            fineAmount,
            notes,
            renewalCount,
            createdAt: dt(createdAt),
            updatedAt: dt(updatedAt),
            createdBy,
            ...(returnNotes ? { returnNotes } : {}),
            ...(returnedBy ? { returnedBy } : {})
          };
        };

    const transaction1Id = new ObjectId();
    const transaction2Id = new ObjectId();
    const transaction3Id = new ObjectId();
    const transaction4Id = new ObjectId();

    const transaction1 = buildTransaction({
        _id: transaction1Id,
        userId: alyssaIdStr,
        items: [
          {
            copyId: 'ITE-001',
            bookId: `book_${book1Id.toString()}`,
            isbn: '978-971-000-1001',
            status: 'borrowed'
          }
        ],
        status: 'borrowed',
        borrowDate: '2025-09-15T02:30:00Z',
        dueDate: '2025-09-29T02:30:00Z',
        returnDate: null,
        fineAmount: 0,
        notes: 'Borrowed for ICT research project',
        renewalCount: 0,
        createdAt: '2025-09-15T02:30:00Z',
        updatedAt: '2025-09-15T02:35:00Z',
        createdBy: librarianIdStr
      });

    const transaction2 = buildTransaction({
        _id: transaction2Id,
        userId: benIdStr,
        items: [
          {
            copyId: 'PHHIS-001',
            bookId: `book_${book2Id.toString()}`,
            isbn: '978-971-000-2002',
            status: 'returned',
            returnedAt: dt('2025-08-28T03:10:00Z')
          }
        ],
        status: 'returned',
        borrowDate: '2025-08-20T03:00:00Z',
        dueDate: '2025-09-03T03:00:00Z',
        returnDate: '2025-08-28T03:10:00Z',
        fineAmount: 0,
        notes: 'Completed history assignment early',
        renewalCount: 0,
        createdAt: '2025-08-20T03:00:00Z',
        updatedAt: '2025-08-28T03:10:00Z',
        createdBy: librarianIdStr,
        returnNotes: 'Returned in good condition',
        returnedBy: librarianIdStr
      });

    const transaction3 = buildTransaction({
        _id: transaction3Id,
        userId: benIdStr,
        items: [
          {
            copyId: 'LIT-001',
            bookId: `book_${book4Id.toString()}`,
            isbn: '978-971-000-4004',
            status: 'borrowed'
          }
        ],
        status: 'borrowed',
        borrowDate: '2025-09-20T03:00:00Z',
        dueDate: '2025-10-04T03:00:00Z',
        returnDate: null,
        fineAmount: 0,
        notes: 'Reading requirement for 21st Century Literature',
        renewalCount: 0,
        createdAt: '2025-09-20T03:00:00Z',
        updatedAt: '2025-09-20T03:05:00Z',
        createdBy: librarianIdStr
      });

    const transaction4 = buildTransaction({
        _id: transaction4Id,
        userId: staffIdStr,
        items: [
          {
            copyId: 'MATH-002',
            bookId: `book_${book3Id.toString()}`,
            isbn: '978-971-000-3003',
            status: 'returned',
            returnedAt: dt('2025-09-14T09:20:00Z')
          }
        ],
        status: 'returned',
        borrowDate: '2025-08-30T09:00:00Z',
        dueDate: '2025-09-10T09:00:00Z',
        returnDate: '2025-09-14T09:20:00Z',
        fineAmount: 60,
        notes: 'Reference for remedial math program',
        renewalCount: 0,
        createdAt: '2025-08-30T09:00:00Z',
        updatedAt: '2025-09-14T09:20:00Z',
        createdBy: librarianIdStr,
        returnNotes: 'Returned with minimal notes on pages',
        returnedBy: librarianIdStr
      });

    const transactions = [transaction1, transaction2, transaction3, transaction4];

    const settings = [
      {
        _id: new ObjectId(),
        id: 'MAX_BORROW_DAYS',
        value: 14,
        type: 'number',
        category: 'library',
        description: 'Maximum number of days for regular book borrowing',
        createdAt: dt('2025-07-01T00:00:00Z'),
        updatedAt: dt('2025-09-01T00:00:00Z')
      },
      {
        _id: new ObjectId(),
        id: 'FINE_PER_DAY',
        value: 15,
        type: 'number',
        category: 'library',
        description: 'Fine amount per day for overdue books',
        createdAt: dt('2025-07-01T00:00:00Z'),
        updatedAt: dt('2025-09-01T00:00:00Z')
      },
      {
        _id: new ObjectId(),
        id: 'SCHOOL_YEAR_START',
        value: '2025-08-01',
        type: 'string',
        category: 'library',
        description: 'School year start date',
        createdAt: dt('2025-07-01T00:00:00Z'),
        updatedAt: dt('2025-07-01T00:00:00Z')
      },
      {
        _id: new ObjectId(),
        id: 'SCHOOL_YEAR_END',
        value: '2026-05-31',
        type: 'string',
        category: 'library',
        description: 'School year end date',
        createdAt: dt('2025-07-01T00:00:00Z'),
        updatedAt: dt('2025-07-01T00:00:00Z')
      },
      {
        _id: new ObjectId(),
        id: 'LIBRARY_NAME',
        value: 'ONHS Integrated Learning Resource Center',
        type: 'string',
        category: 'library',
        description: 'Library name for receipts',
        createdAt: dt('2025-07-01T00:00:00Z'),
        updatedAt: dt('2025-09-01T00:00:00Z')
      },
      {
        _id: new ObjectId(),
        id: 'LIBRARY_ADDRESS',
        value: 'Innovation Building, Quezon City Campus',
        type: 'string',
        category: 'library',
        description: 'Library address for receipts',
        createdAt: dt('2025-07-01T00:00:00Z'),
        updatedAt: dt('2025-09-01T00:00:00Z')
      },
      {
        _id: new ObjectId(),
        id: 'ENABLE_FINES',
        value: true,
        type: 'boolean',
        category: 'library',
        description: 'Enable or disable fine system',
        createdAt: dt('2025-07-01T00:00:00Z'),
        updatedAt: dt('2025-09-01T00:00:00Z')
      },
      {
        _id: new ObjectId(),
        id: 'MAX_BOOKS_PER_TRANSACTION',
        value: 5,
        type: 'number',
        category: 'library',
        description: 'Maximum number of books per transaction',
        createdAt: dt('2025-07-01T00:00:00Z'),
        updatedAt: dt('2025-09-01T00:00:00Z')
      }
    ];

    const annualSetId = new ObjectId();
    const annualSets = [
      {
        _id: annualSetId,
        id: `annual_${annualSetId.toString()}`,
        name: 'ICT Strand Starter Pack',
        gradeLevel: 'Grade 11',
  section: 'ICT-A',
  curriculum: 'Senior High - ICT',
        academicYear: '2025-2026',
        description: 'Default resource set for incoming ICT students',
        books: [
          {
            bookId: `book_${book1Id.toString()}`,
            quantity: 1,
            copyIds: [],
            required: true,
            notes: 'Core ICT reference'
          },
          {
            bookId: `book_${book2Id.toString()}`,
            quantity: 1,
            copyIds: [],
            required: true,
            notes: 'Philippine History requirement'
          },
          {
            bookId: `book_${book4Id.toString()}`,
            quantity: 1,
            copyIds: [],
            required: false,
            notes: 'Recommended reading for literature subjects'
          }
        ],
        createdAt: dt('2025-09-01T01:00:00Z'),
        updatedAt: dt('2025-09-01T01:00:00Z'),
        createdBy: librarianIdStr,
        updatedBy: librarianIdStr
      }
    ];

    const buildAuditEntry = ({
      _id,
      timestamp,
      action,
      entity,
      entityId,
      resource,
      resourceId,
      description,
      details,
      metadata,
      status,
      statusCode,
      success,
      user
    }) => ({
      _id,
      id: _id.toString(),
      timestamp: dt(timestamp),
      createdAt: dt(timestamp),
      updatedAt: dt(timestamp),
      action,
      entity,
      entityId,
      resource,
      resourceId,
      description,
      details,
      metadata,
      status,
      statusCode,
      success,
      userId: user.id,
      userEmail: user.email,
      userRole: user.role,
      userName: `${user.firstName} ${user.lastName}`,
      username: user.username,
      ipAddress: '::ffff:127.0.0.1',
      userAgent: 'Seed Script / MongoDB Loader',
      requestMethod: metadata?.requestMethod || 'POST',
      requestPath: metadata?.requestPath || '/seed'
    });

    const auditEntries = [
      buildAuditEntry({
        _id: new ObjectId(),
        timestamp: '2025-09-20T01:15:00Z',
        action: 'LOGIN',
        entity: 'auth',
        entityId: adminIdStr,
        resource: 'auth',
        resourceId: adminIdStr,
        description: 'Login successful for admin',
        details: {
          username: 'admin',
          role: 'admin'
        },
        metadata: {
          statusCode: 200,
          requestMethod: 'POST',
          requestPath: '/api/auth/login'
        },
        status: 'Success',
        statusCode: 200,
        success: true,
        user: users[0]
      }),
      buildAuditEntry({
        _id: new ObjectId(),
        timestamp: '2025-09-15T02:35:15Z',
        action: 'BORROW',
        entity: 'transaction',
        entityId: transaction1.id,
        resource: 'transaction',
        resourceId: transaction1.id,
        description: 'Borrowed 1 item for Alyssa Gomez',
        details: {
          transactionId: transaction1.id,
          borrower: {
            id: alyssaIdStr,
            name: 'Alyssa Gomez',
            libraryCardNumber: 'LIB-25-0001'
          },
          items: ['ITE-001']
        },
        metadata: {
          statusCode: 201,
          actorId: librarianIdStr,
          requestMethod: 'POST',
          requestPath: '/api/transactions/borrow'
        },
        status: 'Completed',
        statusCode: 201,
        success: true,
        user: users[1]
      }),
      buildAuditEntry({
        _id: new ObjectId(),
        timestamp: '2025-08-28T03:10:30Z',
        action: 'RETURN',
        entity: 'transaction',
        entityId: transaction2.id,
        resource: 'transaction',
        resourceId: transaction2.id,
        description: 'Returned 1 item for Ben Santos',
        details: {
          transactionId: transaction2.id,
          borrower: {
            id: benIdStr,
            name: 'Ben Santos'
          },
          items: ['PHHIS-001'],
          fineAmount: 0
        },
        metadata: {
          statusCode: 200,
          actorId: librarianIdStr,
          requestMethod: 'POST',
          requestPath: `/api/transactions/${transaction2.id}/return`
        },
        status: 'Completed',
        statusCode: 200,
        success: true,
        user: users[1]
      }),
      buildAuditEntry({
        _id: new ObjectId(),
        timestamp: '2025-09-14T09:21:00Z',
        action: 'RETURN',
        entity: 'transaction',
        entityId: transaction4.id,
        resource: 'transaction',
        resourceId: transaction4.id,
        description: 'Return completed with overdue fine for Michael Reyes',
        details: {
          transactionId: transaction4.id,
          borrower: {
            id: staffIdStr,
            name: 'Michael Reyes'
          },
          items: ['MATH-002'],
          fineAmount: 60,
          daysOverdue: 4
        },
        metadata: {
          statusCode: 200,
          actorId: librarianIdStr,
          requestMethod: 'POST',
          requestPath: `/api/transactions/${transaction4.id}/return`
        },
        status: 'Completed',
        statusCode: 200,
        success: true,
        user: users[1]
      })
    ];

    console.log('üìù Inserting users...');
    await db.collection('users').insertMany(users);

    console.log('üìö Inserting books...');
    await db.collection('books').insertMany(books);

    console.log('üîÑ Inserting transactions...');
    await db.collection('transactions').insertMany(transactions);

    console.log('‚öôÔ∏è  Inserting settings...');
    await db.collection('settings').insertMany(settings);

    console.log('üóÇÔ∏è  Inserting annual sets...');
    await db.collection('annualSets').insertMany(annualSets);

    console.log('üõ°Ô∏è  Inserting audit trail...');
    await db.collection('audit').insertMany(auditEntries);

    console.log('‚úÖ Seeding complete! New interconnected dataset is ready.');
    console.log('\nüë§ Accounts created:');
    console.log('   ‚Ä¢ admin / admin123456');
    console.log('   ‚Ä¢ librarian.jane / librarian123!');
    console.log('   ‚Ä¢ staff.mike / staff123!');
    console.log('   ‚Ä¢ alyssa.gomez / alyssa123!');
    console.log('   ‚Ä¢ ben.santos / ben123!');
    console.log('   ‚Ä¢ carla.navarro / carla123!');
  } catch (error) {
    console.error('‚ùå Seeding failed:', error);
    process.exit(1);
  } finally {
    await client.close();
  }
})();
```

## reset-offline-data.js

| Field | Details |
| --- | --- |
| Program Name | reset-offline-data.js |
| Description | Backend maintenance or data migration script. |
| Called by | None |
| Table used | None |
|  |  |
| Programmer | Nazel Asca√±o |
| Date created | 12/14/2025 |
| Revision Date | TBD |
| Revision / description of change | None |

```javascript
const fs = require('fs/promises');
const path = require('path');
const bcrypt = require('bcrypt');

const DATA_DIR = path.resolve(__dirname, '..', 'data');
const COLLECTION_FILES = {
  users: 'users.json',
  books: 'books.json',
  transactions: 'transactions.json',
  notifications: 'notifications.json',
  notificationReads: 'notificationReads.json',
  settings: 'settings.json',
  audit: 'audit.json',
  annualSets: 'annualSets.json'
};

const SETTINGS_TEMPLATE = [
  { id: 'MAX_BORROW_DAYS', value: 14, type: 'number', category: 'library', description: 'Maximum number of days for regular book borrowing' },
  { id: 'FINE_PER_DAY', value: 5, type: 'number', category: 'library', description: 'Fine amount per day for overdue books' },
  { id: 'SCHOOL_YEAR_START', value: '2024-08-01', type: 'string', category: 'library', description: 'School year start date' },
  { id: 'SCHOOL_YEAR_END', value: '2025-05-31', type: 'string', category: 'library', description: 'School year end date' },
  { id: 'LIBRARY_NAME', value: 'ONHS Library', type: 'string', category: 'library', description: 'Library name for receipts' },
  { id: 'LIBRARY_ADDRESS', value: 'School Address', type: 'string', category: 'library', description: 'Library address for receipts' },
  { id: 'ENABLE_FINES', value: true, type: 'boolean', category: 'library', description: 'Enable or disable fine system' },
  { id: 'MAX_BOOKS_PER_TRANSACTION', value: 10, type: 'number', category: 'library', description: 'Maximum number of books per transaction' }
];

const ADMIN_PASSWORD = process.env.ADMIN_PASSWORD || 'admin123456';

const fileExists = async (filePath) => {
  try {
    await fs.access(filePath);
    return true;
  } catch (error) {
    return false;
  }
};

const ensureDataDirectory = async () => {
  await fs.mkdir(DATA_DIR, { recursive: true });
};

const ensureCollectionFiles = async () => {
  await Promise.all(
    Object.values(COLLECTION_FILES).map(async (fileName) => {
      const filePath = path.join(DATA_DIR, fileName);
      if (await fileExists(filePath)) {
        return;
      }

      await fs.writeFile(filePath, '[]\n');
    })
  );
};

const backupFile = async (filePath) => {
  if (!(await fileExists(filePath))) {
    return null;
  }

  const stamp = new Date().toISOString().replace(/[:.]/g, '-');
  const backupPath = `${filePath}.bak.${stamp}`;
  await fs.copyFile(filePath, backupPath);
  return backupPath;
};

const readCollection = async (filePath) => {
  const content = await fs.readFile(filePath, 'utf8');
  if (!content.trim()) {
    return [];
  }

  try {
    return JSON.parse(content);
  } catch (error) {
    console.warn(`‚ö†Ô∏è  Could not parse ${path.basename(filePath)}. Writing empty array.`);
    return [];
  }
};

const writeCollection = async (filePath, data) => {
  await fs.writeFile(filePath, `${JSON.stringify(data, null, 2)}\n`);
};

const isAdminAccount = (user) => {
  if (!user || typeof user !== 'object') {
    return false;
  }

  const username = (user.username || '').trim().toLowerCase();
  const email = (user.email || '').trim().toLowerCase();
  const role = (user.role || '').trim().toLowerCase();

  return username === 'admin' || email === 'admin@olms.com' || role === 'admin';
};

const generateObjectId = () => `${Date.now().toString(36)}${Math.random().toString(36).slice(2, 8)}`;

const sanitizeAdmin = (user) => {
  const now = new Date().toISOString();

  return {
    _id: user._id || generateObjectId(),
    username: 'admin',
    email: user.email || 'admin@olms.com',
    password: user.password,
    firstName: user.firstName || 'System',
    lastName: user.lastName || 'Administrator',
    role: 'admin',
    isActive: true,
    profile: {
      phone: user.profile?.phone || '000-000-0000',
      address: user.profile?.address || 'System',
      dateOfBirth: user.profile?.dateOfBirth || '1990-01-01T00:00:00.000Z'
    },
    library: {
      cardNumber: user.library?.cardNumber || 'ADMIN-001',
      membershipDate: user.library?.membershipDate || now,
      borrowingLimit: user.library?.borrowingLimit || 999,
      fineBalance: user.library?.fineBalance || 0
    },
    borrowingStats: {
      totalBorrowed: 0,
      currentlyBorrowed: 0,
      totalFines: 0,
      totalReturned: 0,
      ...user.borrowingStats
    },
    createdAt: user.createdAt || now,
    updatedAt: now,
    lastLoginAt: user.lastLoginAt || now,
    lastActivityAt: user.lastActivityAt || now
  };
};

const createDefaultAdmin = async () => {
  const now = new Date().toISOString();
  const passwordHash = await bcrypt.hash(ADMIN_PASSWORD, 10);

  return {
    _id: generateObjectId(),
    username: 'admin',
    email: 'admin@olms.com',
    password: passwordHash,
    firstName: 'System',
    lastName: 'Administrator',
    role: 'admin',
    isActive: true,
    profile: {
      phone: '000-000-0000',
      address: 'System',
      dateOfBirth: '1990-01-01T00:00:00.000Z'
    },
    library: {
      cardNumber: 'ADMIN-001',
      membershipDate: now,
      borrowingLimit: 999,
      fineBalance: 0
    },
    borrowingStats: {
      totalBorrowed: 0,
      currentlyBorrowed: 0,
      totalFines: 0,
      totalReturned: 0
    },
    createdAt: now,
    updatedAt: now,
    lastLoginAt: now,
    lastActivityAt: now
  };
};

const buildDefaultSettings = () => {
  const now = new Date().toISOString();
  return SETTINGS_TEMPLATE.map((entry) => ({
    ...entry,
    createdAt: now,
    updatedAt: now
  }));
};

const resetUsers = async (filePath) => {
  const users = await readCollection(filePath);
  const existingAdmin = users.find((user) => isAdminAccount(user));
  const adminRecord = existingAdmin ? sanitizeAdmin(existingAdmin) : await createDefaultAdmin();
  await writeCollection(filePath, [adminRecord]);
  return existingAdmin ? 'preserved existing admin' : 'created fresh admin';
};

const resetCollection = async (collectionName, payloadBuilder = () => []) => {
  const filePath = path.join(DATA_DIR, COLLECTION_FILES[collectionName]);
  await backupFile(filePath);
  const payload = typeof payloadBuilder === 'function' ? await payloadBuilder() : payloadBuilder;
  await writeCollection(filePath, payload);
};

(async () => {
  console.log('üßπ Resetting offline datastore...');
  await ensureDataDirectory();
  await ensureCollectionFiles();

  const userStatus = await (async () => {
    const userFile = path.join(DATA_DIR, COLLECTION_FILES.users);
    await backupFile(userFile);
    return await resetUsers(userFile);
  })();

  const collectionsToClear = Object.keys(COLLECTION_FILES).filter((name) => name !== 'users' && name !== 'settings');
  for (const collection of collectionsToClear) {
    await resetCollection(collection);
    console.log(`   ‚Ä¢ cleared ${collection}`);
  }

  await resetCollection('settings', buildDefaultSettings);
  console.log('   ‚Ä¢ repopulated settings with defaults');

  console.log(`‚úÖ Offline users reset (${userStatus})`);
  console.log('‚úÖ Offline datastore ready. Start the backend with USE_OFFLINE_DB=true to verify.');
})().catch((error) => {
  console.error('‚ùå Failed to reset offline datastore:', error);
  process.exit(1);
});
```

## upload-sample-data.js

| Field | Details |
| --- | --- |
| Program Name | upload-sample-data.js |
| Description | Backend maintenance or data migration script. |
| Called by | None |
| Table used | None |
|  |  |
| Programmer | Nazel Asca√±o |
| Date created | 12/14/2025 |
| Revision Date | TBD |
| Revision / description of change | None |

```javascript
console.warn(
  "Legacy cloud sample data loader removed. " +
    "Use MongoDB seed scripts or the built-in upload utilities instead.",
);
```

# Backend - Utils

## auditLogger.js

| Field | Details |
| --- | --- |
| Program Name | auditLogger.js |
| Description | Backend utility module used across services. |
| Called by | customAuth.js |
| Table used | audit |
|  |  |
| Programmer | Nazel Asca√±o |
| Date created | 12/14/2025 |
| Revision Date | TBD |
| Revision / description of change | None |

```javascript
const SENSITIVE_FIELDS = [
  'password',
  'currentpassword',
  'newpassword',
  'confirmpassword',
  'token',
  'idtoken',
  'authtoken',
  'accesstoken',
  'secret',
];

const toLower = (value) => String(value || '').toLowerCase();

const maskSensitive = (value) => {
  if (value === null || value === undefined) {
    return value;
  }

  if (Array.isArray(value)) {
    return value.map((item) => maskSensitive(item));
  }

  if (typeof value === 'object') {
    const result = {};
    Object.keys(value).forEach((key) => {
      const lowerKey = toLower(key);
      if (SENSITIVE_FIELDS.includes(lowerKey)) {
        result[key] = '[redacted]';
        return;
      }

      const nested = value[key];
      if (nested && typeof nested === 'object') {
        result[key] = maskSensitive(nested);
      } else {
        result[key] = nested;
      }
    });
    return result;
  }

  return value;
};

const extractIpAddress = (req) => {
  if (!req) {
    return null;
  }

  const forwarded = req.headers?.['x-forwarded-for'];
  if (forwarded) {
    return forwarded.split(',')[0].trim();
  }

  return (
    req.ip ||
    req.connection?.remoteAddress ||
    req.socket?.remoteAddress ||
    req.connection?.socket?.remoteAddress ||
    null
  );
};

const buildUserContext = (user) => {
  if (!user) {
    return null;
  }

  const id = user.id || user._id || user.userId || null;
  const email = user.email || user.userEmail || null;
  const role = user.role || user.userRole || null;
  const username = user.username || user.userName || null;
  const firstName = user.firstName || user.givenName || '';
  const lastName = user.lastName || user.familyName || '';
  const displayName = user.name || [firstName, lastName].filter(Boolean).join(' ') || username || email || null;

  return {
    id,
    email,
    role,
    username,
    name: displayName,
  };
};

const mergeAuditContext = (existing = {}, incoming = {}) => {
  const merged = { ...existing, ...incoming };

  if (existing.details || incoming.details) {
    merged.details = {
      ...(existing.details || {}),
      ...(incoming.details || {}),
    };
  }

  if (existing.metadata || incoming.metadata) {
    merged.metadata = {
      ...(existing.metadata || {}),
      ...(incoming.metadata || {}),
    };
  }

  return merged;
};

const setAuditContext = (req, context = {}) => {
  if (!req) {
    return;
  }

  req.auditContext = mergeAuditContext(req.auditContext, context);
  return req.auditContext;
};

const captureRequestSnapshot = (req) => {
  if (!req) {
    return undefined;
  }

  const snapshot = {
    method: req.method,
    url: req.originalUrl,
  };

  const queryKeys = req.query && Object.keys(req.query);
  if (queryKeys && queryKeys.length > 0) {
    snapshot.query = maskSensitive(req.query);
  }

  if (req.method !== 'GET') {
    const bodyKeys = req.body && Object.keys(req.body);
    if (bodyKeys && bodyKeys.length > 0) {
      snapshot.body = maskSensitive(req.body);
    }
  }

  return snapshot;
};

const recordAuditEvent = async (req, payload = {}) => {
  if (!req?.dbAdapter || typeof req.dbAdapter.createAuditLog !== 'function') {
    return null;
  }

  if (req.systemSettings && req.systemSettings.auditLogging === false) {
    return null;
  }

  try {
    const normalizedUser = buildUserContext(
      payload.user ||
        payload.userContext ||
        (payload.userId
          ? {
              id: payload.userId,
              email: payload.userEmail,
              role: payload.userRole,
              username: payload.username,
              name: payload.userName,
            }
          : req.user),
    );

    const success = payload.success !== undefined ? Boolean(payload.success) : true;
    const statusCode = payload.statusCode ?? payload.metadata?.statusCode ?? null;
    const metadata = { ...(payload.metadata || {}) };

    if (payload.durationMs !== undefined) {
      metadata.durationMs = payload.durationMs;
    }

    const details = payload.details !== undefined
      ? maskSensitive(payload.details)
      : payload.includeRequest
        ? { request: captureRequestSnapshot(req) }
        : undefined;

    const record = {
      timestamp: payload.timestamp ? new Date(payload.timestamp) : new Date(),
      action: String(payload.action || 'UNKNOWN').toUpperCase(),
      entity: payload.entity || payload.resource || 'system',
      entityId: payload.entityId || payload.resourceId || null,
      resource: payload.resource || payload.entity || null,
      resourceId: payload.resourceId || payload.entityId || null,
      description:
        payload.description ||
        payload.summary ||
        payload.message ||
        `${payload.action || 'UNKNOWN'} ${payload.entity || ''}`.trim(),
      details,
      metadata,
      status: payload.status || (success ? 'Success' : 'Failed'),
      statusCode,
      success,
      userId: payload.userId || normalizedUser?.id || null,
      userEmail: payload.userEmail || normalizedUser?.email || null,
      userRole: payload.userRole || normalizedUser?.role || null,
      userName: payload.userName || normalizedUser?.name || null,
      username: payload.username || normalizedUser?.username || null,
      ipAddress: payload.ipAddress || extractIpAddress(req),
      userAgent: payload.userAgent || req?.get?.('User-Agent'),
      requestMethod: payload.requestMethod || req?.method,
      requestPath: payload.requestPath || req?.originalUrl,
    };

    if (payload.context) {
      record.context = payload.context;
    }

    return await req.dbAdapter.createAuditLog(record);
  } catch (error) {
    console.error('Audit logging error:', error);
    return null;
  }
};

module.exports = {
  recordAuditEvent,
  setAuditContext,
  captureRequestSnapshot,
  maskSensitive,
};
```

## inventoryNotifications.js

| Field | Details |
| --- | --- |
| Program Name | inventoryNotifications.js |
| Description | Backend utility module used across services. |
| Called by | books.js, transactions.js |
| Table used | notifications |
|  |  |
| Programmer | Nazel Asca√±o |
| Date created | 12/14/2025 |
| Revision Date | TBD |
| Revision / description of change | None |

```javascript
const { createNotification } = require('./notificationUtils');

const LOW_THRESHOLD = parseInt(process.env.BOOK_LOW_STOCK_THRESHOLD, 10) || 3;
const CRITICAL_THRESHOLD = parseInt(process.env.BOOK_CRITICAL_STOCK_THRESHOLD, 10) || 1;
const INVENTORY_FINGERPRINT_PREFIX = 'inventory-level';

const normalizeBookId = (book = {}) => {
  if (book.id) return String(book.id);
  if (book._id) return String(book._id);
  if (book.bookId) return String(book.bookId);
  if (book.documentId) return String(book.documentId);
  return null;
};

const computeAvailableCopies = (book = {}) => {
  if (book.availableCopies !== undefined) {
    const parsed = Number(book.availableCopies);
    if (Number.isFinite(parsed)) {
      return parsed;
    }
  }
  if (Array.isArray(book.copies)) {
    return book.copies.filter((copy) => String(copy.status || '').toLowerCase() === 'available').length;
  }
  return null;
};

const computeTotalCopies = (book = {}) => {
  if (book.totalCopies !== undefined) {
    const parsed = Number(book.totalCopies);
    if (Number.isFinite(parsed)) {
      return parsed;
    }
  }
  if (Array.isArray(book.copies)) {
    return book.copies.length;
  }
  return null;
};

const loadBookRecord = async (dbAdapter, identifier) => {
  if (!identifier) {
    return null;
  }
  try {
    return await dbAdapter.findOneInCollection('books', { id: identifier }) ||
      await dbAdapter.findOneInCollection('books', { _id: identifier }) ||
      await dbAdapter.findOneInCollection('books', { bookId: identifier });
  } catch (error) {
    console.error('Inventory notification lookup failed:', error.message);
    return null;
  }
};

const maybeNotifyLowInventory = async (dbAdapter, bookInput, { source } = {}) => {
  if (!dbAdapter) {
    return null;
  }

  let book = bookInput;
  if (!book || typeof book !== 'object') {
    book = await loadBookRecord(dbAdapter, bookInput);
  }
  if (!book) {
    return null;
  }

  const available = computeAvailableCopies(book);
  if (!Number.isFinite(available)) {
    return null;
  }

  const totalCopies = computeTotalCopies(book);
  const bookId = normalizeBookId(book);
  const fingerprint = bookId ? `${INVENTORY_FINGERPRINT_PREFIX}:${bookId}` : null;

  let severity = null;
  let level = null;
  if (available <= CRITICAL_THRESHOLD) {
    severity = 'high';
    level = 'critical';
  } else if (available <= LOW_THRESHOLD) {
    severity = 'medium';
    level = 'low';
  }

  const existing = fingerprint
    ? await dbAdapter.findOneInCollection('notifications', { fingerprint })
    : null;

  if (!level) {
    if (existing && !existing.archived) {
      await dbAdapter.updateInCollection(
        'notifications',
        existing.id ? { id: existing.id } : { _id: existing._id },
        {
          archived: true,
          updatedAt: new Date(),
          meta: {
            ...(existing.meta || {}),
            resolvedAt: new Date(),
            availableCopies: available,
            totalCopies,
          },
        },
      );
    }
    return null;
  }

  const title = level === 'critical' ? 'Critical book stock' : 'Low book stock';
  const copyLabel = available === 1 ? 'copy remains' : 'copies remain';
  const message = `'${book.title || 'Untitled book'}' only has ${available} ${copyLabel}.`;

  const payload = {
    title,
    message,
    type: 'inventory-level',
    severity,
    recipients: ['staff', 'librarian'],
    fingerprint,
    source: source || 'inventory-monitor',
    meta: {
      bookId,
      bookTitle: book.title || 'Untitled book',
      availableCopies: available,
      totalCopies,
      level,
      excludeRoles: ['admin'],
    },
    link: bookId ? `/books/${bookId}` : undefined,
  };

  if (existing) {
    await dbAdapter.updateInCollection(
      'notifications',
      existing.id ? { id: existing.id } : { _id: existing._id },
      {
        title: payload.title,
        message: payload.message,
        severity: payload.severity,
        recipients: payload.recipients,
        meta: payload.meta,
        archived: false,
        readBy: [],
        updatedAt: new Date(),
      },
    );
    return null;
  }

  return createNotification(dbAdapter, payload);
};

module.exports = {
  maybeNotifyLowInventory,
};
```

## notificationChannels.js

| Field | Details |
| --- | --- |
| Program Name | notificationChannels.js |
| Description | Backend utility module used across services. |
| Called by | customAuth.js, students.js, transactions.js, users.js |
| Table used | None |
|  |  |
| Programmer | Nazel Asca√±o |
| Date created | 12/14/2025 |
| Revision Date | TBD |
| Revision / description of change | None |

```javascript
const { getSettingsSnapshot, NOTIFICATION_DEFAULTS, getNotificationChannelState } = require('./settingsCache');
const { createNotification, createRoleNotification } = require('./notificationUtils');

const NOTIFICATION_CONTEXT_KEY = Symbol('notificationContext');

const buildChannelContext = (settings = NOTIFICATION_DEFAULTS) => {
    const normalized = settings || NOTIFICATION_DEFAULTS;
    return {
        settings: normalized,
        channelState: getNotificationChannelState(normalized)
    };
};

const ensureNotificationContext = async (req) => {
    if (!req) {
        return buildChannelContext(NOTIFICATION_DEFAULTS);
    }

    if (req[NOTIFICATION_CONTEXT_KEY]) {
        return req[NOTIFICATION_CONTEXT_KEY];
    }

    let context;
    try {
        const snapshot = await getSettingsSnapshot(req.dbAdapter);
        const notificationSettings = snapshot?.notifications || NOTIFICATION_DEFAULTS;
        context = buildChannelContext(notificationSettings);
    } catch (error) {
        console.error('Notification context load error:', error.message || error);
        context = buildChannelContext(NOTIFICATION_DEFAULTS);
    }

    Object.defineProperty(req, NOTIFICATION_CONTEXT_KEY, {
        value: context,
        enumerable: false,
        configurable: true,
        writable: false
    });

    return context;
};

const notifyRoles = async (req, roles = [], payload = {}) => {
    const normalizedRoles = Array.isArray(roles)
        ? roles.map(role => String(role).trim()).filter(Boolean)
        : [];

    if (normalizedRoles.length === 0) {
        return null;
    }

    const context = await ensureNotificationContext(req);
    if (!context.channelState.hasActiveChannel) {
        return null;
    }

    return createRoleNotification(req.dbAdapter, normalizedRoles, payload);
};

const notifyRecipients = async (req, recipients = [], payload = {}) => {
    const normalizedRecipients = Array.isArray(recipients)
        ? recipients.map(value => String(value).trim()).filter(Boolean)
        : [];

    if (normalizedRecipients.length === 0) {
        return null;
    }

    const context = await ensureNotificationContext(req);
    if (!context.channelState.hasActiveChannel) {
        return null;
    }

    return createNotification(req.dbAdapter, {
        ...payload,
        recipients: normalizedRecipients
    });
};

const formatUserName = (subject = {}) => {
    if (!subject || typeof subject !== 'object') {
        return 'User';
    }
    if (subject.fullName && typeof subject.fullName === 'string' && subject.fullName.trim()) {
        return subject.fullName.trim();
    }
    const parts = [subject.firstName, subject.middleName, subject.lastName]
        .filter(Boolean)
        .join(' ')
        .trim();
    if (parts) {
        return parts;
    }
    return subject.username || subject.email || 'User';
};

module.exports = {
    ensureNotificationContext,
    notifyRoles,
    notifyRecipients,
    formatUserName
};
```

## notificationCopy.js

| Field | Details |
| --- | --- |
| Program Name | notificationCopy.js |
| Description | Backend utility module used across services. |
| Called by | notifications.js, transactions.js |
| Table used | None |
|  |  |
| Programmer | Nazel Asca√±o |
| Date created | 12/14/2025 |
| Revision Date | TBD |
| Revision / description of change | None |

```javascript
const MAX_NOTE_PREVIEW = 180;

const formatCountLabel = (count, singular, plural) => {
  const numericValue = Number(count);
  const resolvedCount = Number.isFinite(numericValue) ? numericValue : 0;
  const resolvedPlural = plural || `${singular}s`;
  const label = resolvedCount === 1 ? singular : resolvedPlural;
  return `${resolvedCount} ${label}`;
};

const normalizeTransactionTypeValue = (value) => {
  if (!value) {
    return '';
  }
  return String(value).trim().toLowerCase();
};

const formatBorrowRequestTypeLabel = (type) => {
  const normalized = normalizeTransactionTypeValue(type);
  if (normalized === 'overnight') {
    return 'an overnight borrow request';
  }
  if (normalized === 'annual' || normalized === 'annual-set') {
    return 'an annual borrow request';
  }
  return 'a borrow request';
};

const buildNotePreview = (notes, maxLength = MAX_NOTE_PREVIEW) => {
  if (typeof notes !== 'string') {
    return '';
  }
  const trimmed = notes.trim();
  if (!trimmed) {
    return '';
  }
  if (trimmed.length <= maxLength) {
    return trimmed;
  }
  return `${trimmed.slice(0, Math.max(0, maxLength - 3))}...`;
};

const buildBorrowRequestStaffMessage = ({
  borrowerName,
  transactionId,
  transactionType,
  itemCount,
  notes,
} = {}) => {
  const subject = borrowerName || 'A borrower';
  const typeLabel = formatBorrowRequestTypeLabel(transactionType);
  const countLabel = formatCountLabel(itemCount || 0, 'book');
  const requestSegment = transactionId ? ` (${transactionId})` : '';
  const notePreview = buildNotePreview(notes);

  let message = `${subject} submitted ${typeLabel}${requestSegment} for ${countLabel}.`;
  if (notePreview) {
    message += ` Note from borrower: "${notePreview}".`;
  }
  return message.trim();
};

module.exports = {
  buildBorrowRequestStaffMessage,
  buildNotePreview,
  formatBorrowRequestTypeLabel,
  formatCountLabel,
};
```

## notificationUtils.js

| Field | Details |
| --- | --- |
| Program Name | notificationUtils.js |
| Description | Backend utility module used across services. |
| Called by | inventoryNotifications.js, notificationChannels.js |
| Table used | None |
|  |  |
| Programmer | Nazel Asca√±o |
| Date created | 12/14/2025 |
| Revision Date | TBD |
| Revision / description of change | None |

```javascript
const normalizeRecipients = (recipients = []) => {
  const unique = new Set();
  const values = Array.isArray(recipients) ? recipients : [recipients];
  values
    .flat()
    .filter((value) => value !== undefined && value !== null)
    .forEach((value) => {
      const normalized = String(value).trim();
      if (normalized) {
        unique.add(normalized);
      }
    });
  return Array.from(unique);
};

const normalizeRoleKey = (role) => {
  if (!role && role !== 0) {
    return '';
  }
  const value = String(role).trim().toLowerCase();
  if (!value) {
    return '';
  }
  switch (value) {
    case 'super admin':
    case 'super-admin':
    case 'superadmin':
    case 'administrator':
      return 'admin';
    default:
      return value;
  }
};

const normalizeRoleList = (roles = []) => {
  if (!Array.isArray(roles)) {
    return normalizeRecipients([]);
  }
  return normalizeRecipients(
    roles
      .filter(Boolean)
      .map((role) => normalizeRoleKey(role))
  );
};

const buildBaseDocument = (payload = {}) => {
  const now = new Date();
  const document = {
    title: payload.title || 'Notification',
    message: payload.message || '',
    type: payload.type || 'info',
    severity: payload.severity || 'info',
    recipients: normalizeRecipients(payload.recipients || []),
    meta: typeof payload.meta === 'object' && payload.meta !== null ? payload.meta : {},
    createdAt: payload.createdAt instanceof Date ? payload.createdAt : now,
    updatedAt: payload.updatedAt instanceof Date ? payload.updatedAt : now,
    readBy: Array.isArray(payload.readBy) ? payload.readBy : [],
  };

  if (payload.transactionId) {
    document.transactionId = payload.transactionId;
  }
  if (payload.link) {
    document.link = payload.link;
  }
  if (payload.fingerprint) {
    document.fingerprint = payload.fingerprint;
  }
  if (payload.source) {
    document.source = payload.source;
  }
  if (typeof payload.archived === 'boolean') {
    document.archived = payload.archived;
  }

  return document;
};

const createNotification = async (dbAdapter, payload = {}) => {
  if (!dbAdapter || typeof dbAdapter.insertIntoCollection !== 'function') {
    return null;
  }
  const document = buildBaseDocument(payload);
  if (!Array.isArray(document.recipients) || document.recipients.length === 0) {
    return null;
  }
  return dbAdapter.insertIntoCollection('notifications', document);
};

const createRoleNotification = async (dbAdapter, roles = [], payload = {}) => {
  const recipients = normalizeRoleList(roles);
  if (recipients.length === 0) {
    return null;
  }
  return createNotification(dbAdapter, {
    ...payload,
    recipients,
  });
};

module.exports = {
  createNotification,
  createRoleNotification,
  normalizeRecipients,
};
```

## psgcClient.js

| Field | Details |
| --- | --- |
| Program Name | psgcClient.js |
| Description | Backend utility module used across services. |
| Called by | locations.js |
| Table used | None |
|  |  |
| Programmer | Nazel Asca√±o |
| Date created | 12/14/2025 |
| Revision Date | TBD |
| Revision / description of change | None |

```javascript
const https = require('https');

const PSGC_BASE_URL = process.env.PSGC_API_BASE_URL || 'https://psgc.gitlab.io/api';
const DEFAULT_CACHE_TTL_MS = Number(process.env.PSGC_CACHE_TTL_MS || 1000 * 60 * 60 * 24); // 24 hours

const cache = new Map();

const readJsonResponse = (url) =>
  new Promise((resolve, reject) => {
    const request = https.get(url, (response) => {
      const { statusCode } = response;
      if (statusCode && statusCode >= 400) {
        response.resume();
        reject(new Error(`PSGC request failed with status ${statusCode}`));
        return;
      }

      response.setEncoding('utf8');
      let rawData = '';
      response.on('data', (chunk) => {
        rawData += chunk;
      });
      response.on('end', () => {
        try {
          const parsedData = JSON.parse(rawData);
          resolve(parsedData);
        } catch (error) {
          reject(new Error(`Failed to parse PSGC response from ${url}: ${error.message}`));
        }
      });
    });

    request.on('error', (error) => {
      reject(new Error(`PSGC request error for ${url}: ${error.message}`));
    });

    request.end();
  });

const fetchJson = async (path) => {
  const trimmedPath = path.startsWith('/') ? path : `/${path}`;
  const url = `${PSGC_BASE_URL}${trimmedPath}`;
  return readJsonResponse(url);
};

const withCache = async (key, fetcher, ttlMs = DEFAULT_CACHE_TTL_MS) => {
  const cachedEntry = cache.get(key);
  const now = Date.now();
  if (cachedEntry && cachedEntry.expiresAt > now) {
    return cachedEntry.value;
  }

  const value = await fetcher();
  cache.set(key, {
    value,
    expiresAt: now + ttlMs,
  });
  return value;
};

const projectProvince = (province) => ({
  code: province.code,
  name: province.name,
  regionCode: province.regionCode,
  regionName: province.regionName,
});

const projectMunicipality = (municipality) => ({
  code: municipality.code,
  name: municipality.name,
  oldName: municipality.oldName,
  provinceCode: municipality.provinceCode,
  districtCode: municipality.districtCode,
});

const projectBarangay = (barangay) => ({
  code: barangay.code,
  name: barangay.name,
  oldName: barangay.oldName,
  cityCode: barangay.cityCode,
  municipalityCode: barangay.municipalityCode,
  provinceCode: barangay.provinceCode,
});

const getProvinces = () =>
  withCache('psgc:provinces', async () => {
    const provinces = await fetchJson('/provinces/');
    return provinces.map(projectProvince);
  });

const getMunicipalitiesByProvince = (provinceCode) => {
  if (!provinceCode) {
    return [];
  }
  return withCache(`psgc:province:${provinceCode}:municipalities`, async () => {
    const municipalities = await fetchJson(`/provinces/${provinceCode}/cities-municipalities/`);
    return municipalities.map(projectMunicipality);
  });
};

const getBarangaysByMunicipality = (municipalityCode) => {
  if (!municipalityCode) {
    return [];
  }
  return withCache(`psgc:municipality:${municipalityCode}:barangays`, async () => {
    const barangays = await fetchJson(`/cities-municipalities/${municipalityCode}/barangays/`);
    return barangays.map(projectBarangay);
  });
};

const searchProvinces = async (query) => {
  if (!query) {
    return [];
  }
  const normalized = query.toLowerCase();
  const provinces = await getProvinces();
  return provinces.filter((item) => item.name.toLowerCase().includes(normalized));
};

module.exports = {
  getProvinces,
  getMunicipalitiesByProvince,
  getBarangaysByMunicipality,
  searchProvinces,
};
```

## settingsCache.js

| Field | Details |
| --- | --- |
| Program Name | settingsCache.js |
| Description | Backend utility module used across services. |
| Called by | customAuth.js, notificationChannels.js, notifications.js, settings.js, transactions.js, transactions_fixed.js |
| Table used | settings |
|  |  |
| Programmer | Nazel Asca√±o |
| Date created | 12/14/2025 |
| Revision Date | TBD |
| Revision / description of change | None |

```javascript
const DEFAULT_CACHE_TTL_MS = parseInt(process.env.SETTINGS_CACHE_TTL_MS, 10) || 5000;

const BORROWING_DEFAULTS = {
  maxBooksPerTransaction: 10,
  maxBorrowDays: 14,
  finePerDay: 5,
  gracePeriodDays: 0,
  maxFineAmount: 0,
  reservationPeriodDays: 3,
  enableFines: true,
  annualBorrowingEnabled: true,
  overnightBorrowingEnabled: false,
};

const DEFAULT_LIBRARY_TIMEZONE = process.env.LIBRARY_TIMEZONE || 'Asia/Manila';

const LIBRARY_DEFAULTS = {
  openingTime: '08:00',
  closingTime: '17:00',
  operatingDays: ['monday', 'tuesday', 'wednesday', 'thursday', 'friday'],
  timezone: DEFAULT_LIBRARY_TIMEZONE,
};

const SYSTEM_DEFAULTS = {
  maintenanceMode: false,
  sessionTimeoutMinutes: 60,
  maxLoginAttempts: 5,
  passwordMinLength: 8,
  backupFrequency: 'daily',
  logRetentionDays: 90,
  auditLogging: true,
  schoolYearStart: '2024-08-01',
  schoolYearEnd: '2025-05-31',
};

const NOTIFICATION_DEFAULTS = {
  dueDateReminders: true,
  overdueNotifications: true,
  reservationNotifications: true,
  returnNotifications: true,
  reminderDaysBefore: 3,
  maxReminders: 3,
};

let cache = {
  data: null,
  expiresAt: 0,
};

const isPlainObject = (value) => value && typeof value === 'object' && !Array.isArray(value);

const toBoolean = (value, fallback = false) => {
  if (typeof value === 'boolean') {
    return value;
  }
  if (typeof value === 'string') {
    const normalized = value.trim().toLowerCase();
    if (['true', '1', 'yes', 'on'].includes(normalized)) {
      return true;
    }
    if (['false', '0', 'no', 'off'].includes(normalized)) {
      return false;
    }
  }
  if (typeof value === 'number') {
    return value !== 0;
  }
  return fallback;
};

const toNumber = (value, fallback = 0) => {
  const parsed = Number(value);
  return Number.isFinite(parsed) ? parsed : fallback;
};

const mapSettingsRecords = (records) => {
  return records.reduce((acc, record) => {
    if (record && record.id) {
      acc[record.id] = record.value;
    }
    return acc;
  }, {});
};

const buildLibraryProfile = (settingsMap) => ({
  libraryName: settingsMap.LIBRARY_NAME || '',
  libraryAddress: settingsMap.LIBRARY_ADDRESS || '',
  libraryPhone: settingsMap.LIBRARY_PHONE || '',
  libraryEmail: settingsMap.LIBRARY_EMAIL || '',
  website: settingsMap.LIBRARY_WEBSITE || '',
  description: settingsMap.LIBRARY_DESCRIPTION || '',
  openingTime: settingsMap.LIBRARY_OPENING_TIME || LIBRARY_DEFAULTS.openingTime,
  closingTime: settingsMap.LIBRARY_CLOSING_TIME || LIBRARY_DEFAULTS.closingTime,
  operatingDays: Array.isArray(settingsMap.LIBRARY_OPERATING_DAYS)
    ? settingsMap.LIBRARY_OPERATING_DAYS
    : LIBRARY_DEFAULTS.operatingDays,
  timezone: settingsMap.LIBRARY_TIMEZONE || LIBRARY_DEFAULTS.timezone,
});

const buildBorrowingSettings = (settingsMap) => ({
  maxBooksPerTransaction: toNumber(
    settingsMap.MAX_BOOKS_PER_TRANSACTION,
    BORROWING_DEFAULTS.maxBooksPerTransaction,
  ),
  maxBorrowDays: toNumber(settingsMap.MAX_BORROW_DAYS, BORROWING_DEFAULTS.maxBorrowDays),
  finePerDay: toNumber(settingsMap.FINE_PER_DAY, BORROWING_DEFAULTS.finePerDay),
  gracePeriodDays: toNumber(settingsMap.GRACE_PERIOD_DAYS, BORROWING_DEFAULTS.gracePeriodDays),
  maxFineAmount: toNumber(settingsMap.MAX_FINE_AMOUNT, BORROWING_DEFAULTS.maxFineAmount),
  reservationPeriodDays: toNumber(
    settingsMap.RESERVATION_PERIOD_DAYS,
    BORROWING_DEFAULTS.reservationPeriodDays,
  ),
  enableFines: toBoolean(settingsMap.ENABLE_FINES, BORROWING_DEFAULTS.enableFines),
  annualBorrowingEnabled: toBoolean(
    settingsMap.ANNUAL_BORROWING_ENABLED,
    BORROWING_DEFAULTS.annualBorrowingEnabled,
  ),
  overnightBorrowingEnabled: toBoolean(
    settingsMap.OVERNIGHT_BORROWING_ENABLED,
    BORROWING_DEFAULTS.overnightBorrowingEnabled,
  ),
});

const buildNotificationSettings = (rawValue) => {
  const value = isPlainObject(rawValue) ? rawValue : {};
  return {
    ...NOTIFICATION_DEFAULTS,
    dueDateReminders: toBoolean(
      value.dueDateReminders,
      NOTIFICATION_DEFAULTS.dueDateReminders,
    ),
    overdueNotifications: toBoolean(
      value.overdueNotifications,
      NOTIFICATION_DEFAULTS.overdueNotifications,
    ),
    reservationNotifications: toBoolean(
      value.reservationNotifications,
      NOTIFICATION_DEFAULTS.reservationNotifications,
    ),
    returnNotifications: toBoolean(
      value.returnNotifications,
      NOTIFICATION_DEFAULTS.returnNotifications,
    ),
    reminderDaysBefore: toNumber(
      value.reminderDaysBefore,
      NOTIFICATION_DEFAULTS.reminderDaysBefore,
    ),
    maxReminders: toNumber(value.maxReminders, NOTIFICATION_DEFAULTS.maxReminders),
  };
};

const getNotificationChannelState = () => {
  const inAppEnabled = true; // In-app notifications are always available inside OLMS
  const emailEnabled = true; // Email delivery stays enabled without user-configurable toggles
  const smsEnabled = false;
  const channels = ['in-app'];
  if (emailEnabled) {
    channels.push('email');
  }
  if (smsEnabled) {
    channels.push('sms');
  }
  return {
    inAppEnabled,
    emailEnabled,
    smsEnabled,
    channels,
    hasActiveChannel: inAppEnabled || emailEnabled || smsEnabled,
  };
};

const buildSystemSettings = (settingsMap) => ({
  maintenanceMode: toBoolean(settingsMap.MAINTENANCE_MODE, SYSTEM_DEFAULTS.maintenanceMode),
  sessionTimeoutMinutes: toNumber(
    settingsMap.SESSION_TIMEOUT_MINUTES,
    SYSTEM_DEFAULTS.sessionTimeoutMinutes,
  ),
  maxLoginAttempts: toNumber(
    settingsMap.MAX_LOGIN_ATTEMPTS,
    SYSTEM_DEFAULTS.maxLoginAttempts,
  ),
  passwordMinLength: toNumber(
    settingsMap.PASSWORD_MIN_LENGTH,
    SYSTEM_DEFAULTS.passwordMinLength,
  ),
  backupFrequency: settingsMap.BACKUP_FREQUENCY || SYSTEM_DEFAULTS.backupFrequency,
  logRetentionDays: toNumber(
    settingsMap.LOG_RETENTION_DAYS,
    SYSTEM_DEFAULTS.logRetentionDays,
  ),
  auditLogging: toBoolean(settingsMap.AUDIT_LOGGING_ENABLED, SYSTEM_DEFAULTS.auditLogging),
  schoolYearStart: settingsMap.SCHOOL_YEAR_START || SYSTEM_DEFAULTS.schoolYearStart,
  schoolYearEnd: settingsMap.SCHOOL_YEAR_END || SYSTEM_DEFAULTS.schoolYearEnd,
});

const buildSnapshot = (settingsMap) => {
  const notificationsSetting = settingsMap.NOTIFICATION_SETTINGS;
  return {
    raw: settingsMap,
    library: buildLibraryProfile(settingsMap),
    borrowing: buildBorrowingSettings(settingsMap),
    notifications: buildNotificationSettings(notificationsSetting),
    system: buildSystemSettings(settingsMap),
  };
};

const getCacheTtl = () => {
  const parsed = parseInt(process.env.SETTINGS_CACHE_TTL_MS, 10);
  return Number.isFinite(parsed) && parsed > 0 ? parsed : DEFAULT_CACHE_TTL_MS;
};

const loadSettingsFromDb = async (dbAdapter) => {
  if (!dbAdapter || typeof dbAdapter.findInCollection !== 'function') {
    throw new Error('Database adapter is required to load settings');
  }
  const records = await dbAdapter.findInCollection('settings', {});
  return mapSettingsRecords(records);
};

const getSettingsSnapshot = async (dbAdapter, { forceRefresh = false } = {}) => {
  const now = Date.now();
  if (!forceRefresh && cache.data && cache.expiresAt > now) {
    return cache.data;
  }

  const settingsMap = await loadSettingsFromDb(dbAdapter);
  const snapshot = buildSnapshot(settingsMap);
  cache = {
    data: snapshot,
    expiresAt: now + getCacheTtl(),
  };
  return snapshot;
};

const invalidateSettingsCache = () => {
  cache = { data: null, expiresAt: 0 };
};

module.exports = {
  getSettingsSnapshot,
  invalidateSettingsCache,
  buildSnapshot,
  BORROWING_DEFAULTS,
  SYSTEM_DEFAULTS,
  NOTIFICATION_DEFAULTS,
  getNotificationChannelState,
  toBoolean,
  toNumber,
};
```

## transactionIds.js

| Field | Details |
| --- | --- |
| Program Name | transactionIds.js |
| Description | Backend utility module used across services. |
| Called by | annualSets.js, reset-and-seed-mongo.js, transactions.js, transactions_fixed.js |
| Table used | None |
|  |  |
| Programmer | Nazel Asca√±o |
| Date created | 12/14/2025 |
| Revision Date | TBD |
| Revision / description of change | None |

```javascript
const randomSuffix = () => Math.random().toString(36).slice(2, 8);

const resolveKindFromType = (type) => {
  if (!type) {
    return 'borrow';
  }
  if (type === 'annual-set') {
    return 'annual';
  }
  return 'borrow';
};

const generateTransactionId = (kind = 'borrow') => {
  const prefix = kind === 'annual' ? 'annual' : 'borrow';
  return `${prefix}_${Date.now()}_${randomSuffix()}`;
};

const ensureTransactionId = (transaction) => {
  if (!transaction || transaction.id) {
    return null;
  }
  const kind = resolveKindFromType(transaction.type);
  return generateTransactionId(kind);
};

module.exports = {
  generateTransactionId,
  ensureTransactionId,
  resolveKindFromType
};
```

## userAttributes.js

| Field | Details |
| --- | --- |
| Program Name | userAttributes.js |
| Description | Backend utility module used across services. |
| Called by | curriculum.js, settings.js, SettingsPage.js, StudentForm.js, StudentImportDialog.js, StudentsList.js, userAttributes.test.js, UserForm.js, UserProfile.js, users.js |
| Table used | None |
|  |  |
| Programmer | Nazel Asca√±o |
| Date created | 12/14/2025 |
| Revision Date | TBD |
| Revision / description of change | None |

```javascript
const DEFAULT_CURRICULA = [
  'Computer Science',
  'Engineering',
  'Mathematics',
  'Science',
  'Arts',
  'Business',
  'Education',
  'Medicine',
  'Law',
  'Other'
];

const DEFAULT_GRADE_LEVELS = [
  'Grade 7',
  'Grade 8',
  'Grade 9',
  'Grade 10',
  'Grade 11',
  'Grade 12',
  'College Freshman',
  'College Sophomore',
  'College Junior',
  'College Senior',
  'Graduate'
];

const DEFAULT_GRADE_COLORS = [
  '#C62828', // red
  '#AD1457', // pink
  '#6A1B9A', // purple
  '#4527A0', // deep purple
  '#283593', // indigo
  '#1565C0', // blue
  '#0277BD', // light blue
  '#00838F', // cyan
  '#00695C', // teal
  '#2E7D32', // green
  '#558B2F'  // light green
];

const DEFAULT_GRADE_COLOR = DEFAULT_GRADE_COLORS[0];

const getDefaultColorForIndex = (index = 0) => (
  DEFAULT_GRADE_COLORS[index % DEFAULT_GRADE_COLORS.length] || DEFAULT_GRADE_COLOR
);

const DEFAULT_GRADE_STRUCTURE = DEFAULT_GRADE_LEVELS.map((grade, index) => ({
  grade,
  sections: [],
  color: getDefaultColorForIndex(index)
}));

const normalizeStringList = (input, fallback = []) => {
  const source = Array.isArray(input) ? input : [];
  const normalized = source
    .map((value) => (typeof value === 'string' ? value.trim() : ''))
    .filter((value) => value.length > 0);

  const unique = [];
  normalized.forEach((value) => {
    if (!unique.includes(value)) {
      unique.push(value);
    }
  });

  return unique.length > 0 ? unique : [...fallback];
};

const toSlug = (value, fallback) => {
  if (typeof value !== 'string') {
    return fallback;
  }

  const trimmed = value.trim();
  if (!trimmed) {
    return fallback;
  }

  const slug = trimmed
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/(^-|-$)/g, '');

  return slug || fallback;
};

const sanitizeHexColor = (value, fallback = DEFAULT_GRADE_COLOR) => {
  if (typeof value !== 'string') {
    return fallback;
  }

  const normalized = value.trim().replace(/^#/u, '').toUpperCase();
  if (/^[0-9A-F]{6}$/u.test(normalized)) {
    return `#${normalized}`;
  }

  return fallback;
};

const normalizeGradeStructure = (input, fallback = DEFAULT_GRADE_STRUCTURE, { useFallbackWhenEmpty = true } = {}) => {
  const source = Array.isArray(input) ? input : [];
  const normalized = [];
  const seenGrades = new Set();
  const fallbackColorMap = new Map();

  (Array.isArray(fallback) ? fallback : []).forEach((entry = {}, index) => {
    if (!entry || typeof entry !== 'object') {
      return;
    }
    const key = typeof entry.grade === 'string' ? entry.grade.trim().toLowerCase() : '';
    if (!key) {
      return;
    }
    fallbackColorMap.set(key, sanitizeHexColor(entry.color, getDefaultColorForIndex(index)));
  });

  source.forEach((entry) => {
    let gradeName = '';
    let sections = [];
    let rawColor = '';

    if (typeof entry === 'string') {
      gradeName = entry.trim();
    } else if (entry && typeof entry === 'object') {
      gradeName = typeof entry.grade === 'string' ? entry.grade.trim() : '';
      if (!gradeName && typeof entry.name === 'string') {
        gradeName = entry.name.trim();
      }
      if (Array.isArray(entry.sections)) {
        sections = entry.sections;
      } else if (Array.isArray(entry.sectionList)) {
        sections = entry.sectionList;
      }
      if (typeof entry.color === 'string') {
        rawColor = entry.color;
      } else if (typeof entry.barColor === 'string') {
        rawColor = entry.barColor;
      } else if (typeof entry.stripeColor === 'string') {
        rawColor = entry.stripeColor;
      }
    }

    if (!gradeName || seenGrades.has(gradeName.toLowerCase())) {
      return;
    }

    const gradeKey = gradeName.toLowerCase();
    const normalizedColor = sanitizeHexColor(
      rawColor,
      fallbackColorMap.get(gradeKey) || getDefaultColorForIndex(normalized.length)
    );

    normalized.push({
      grade: gradeName,
      sections: normalizeStringList(sections, []),
      color: normalizedColor
    });
    seenGrades.add(gradeKey);
    fallbackColorMap.set(gradeKey, normalizedColor);
  });

  if (normalized.length === 0) {
    if (useFallbackWhenEmpty && Array.isArray(fallback) && fallback.length > 0) {
      return fallback.map((entry = {}, index) => ({
        grade: entry.grade,
        sections: Array.isArray(entry.sections) ? [...entry.sections] : [],
        color: sanitizeHexColor(entry.color, getDefaultColorForIndex(index))
      }));
    }
    return [];
  }

  return normalized;
};

module.exports = {
  DEFAULT_CURRICULA,
  DEFAULT_GRADE_LEVELS,
  DEFAULT_GRADE_STRUCTURE,
  DEFAULT_GRADE_COLORS,
  DEFAULT_GRADE_COLOR,
  normalizeStringList,
  normalizeGradeStructure,
  sanitizeHexColor,
  toSlug
};
```

# Frontend - Components

## ApproveRequestDialog.js

| Field | Details |
| --- | --- |
| Program Name | ApproveRequestDialog.js |
| Description | Reusable frontend UI component. |
| Called by | TransactionDetails.js, TransactionsList.js |
| Table used | transactions |
|  |  |
| Programmer | Nazel Asca√±o |
| Date created | 12/14/2025 |
| Revision Date | TBD |
| Revision / description of change | None |

```javascript
import React, { useEffect, useMemo, useState } from "react";
import {
  Alert,
  Autocomplete,
  Box,
  Button,
  CircularProgress,
  Dialog,
  DialogActions,
  DialogContent,
  DialogTitle,
  IconButton,
  InputAdornment,
  TextField,
  Typography,
} from "@mui/material";
import { QrCodeScanner } from "@mui/icons-material";
import toast from "react-hot-toast";
import { useNavigate } from "react-router-dom";
import QRScanner from "../QRScanner";
import { api } from "../../utils/api";

const buildApproveItemKey = (item, index) => {
  if (!item) return `item-${index}`;
  if (item.requestItemId) return String(item.requestItemId);
  const bookId = item.bookId ? String(item.bookId) : "book";
  return `${bookId}-${index}`;
};

const ApproveRequestDialog = ({
  open,
  transactionId,
  onClose,
  onApproved,
  onNavigateToRequests,
}) => {
  const navigate = useNavigate();
  const [items, setItems] = useState([]);
  const [assignments, setAssignments] = useState({});
  const [books, setBooks] = useState({});
  const [loading, setLoading] = useState(false);
  const [submitting, setSubmitting] = useState(false);
  const [error, setError] = useState("");
  const [assignScanner, setAssignScanner] = useState({
    open: false,
    targetKey: null,
    label: "",
  });

  const resetDialogState = () => {
    setItems([]);
    setAssignments({});
    setBooks({});
    setLoading(false);
    setSubmitting(false);
    setError("");
    setAssignScanner({ open: false, targetKey: null, label: "" });
  };

  useEffect(() => {
    if (!open) {
      resetDialogState();
      return;
    }

    if (!transactionId) {
      setError("Transaction identifier is missing");
      return;
    }

    let cancelled = false;
    const loadTransactionItems = async () => {
      setLoading(true);
      setError("");
      setAssignments({});
      setBooks({});
      setItems([]);

      try {
        const { data } = await api.get(`/transactions/${transactionId}`);
        if (cancelled) return;
        const fetchedItems = Array.isArray(data?.items) ? data.items : [];
        setItems(fetchedItems);

        const collectItemBookIds = (item) => {
          const candidates = [
            item?.bookId,
            item?.book?.id,
            item?.book?._id,
            item?.book?.bookId,
          ];
          return candidates
            .map((candidate) =>
              candidate !== undefined && candidate !== null
                ? String(candidate).trim()
                : "",
            )
            .filter(Boolean);
        };

        const fallbackBookFromItems = (bookId) => {
          const match = fetchedItems.find((entry) =>
            collectItemBookIds(entry).includes(String(bookId)),
          );
          if (!match) {
            return null;
          }
          const resolved = match.book || {};
          return {
            id: String(bookId),
            title: resolved.title || match.title || "Unknown title",
            author: resolved.author || match.author || "",
            isbn: resolved.isbn || match.isbn || "",
            copies: Array.isArray(resolved.copies) ? resolved.copies : [],
          };
        };

        const uniqueBookIds = Array.from(
          new Set(fetchedItems.flatMap((item) => collectItemBookIds(item))),
        );

        const booksMap = {};
        if (uniqueBookIds.length > 0) {
          const responses = await Promise.all(
            uniqueBookIds.map(async (bookId) => {
              try {
                const resp = await api.get(`/books/${bookId}`);
                return { bookId, data: resp.data };
              } catch (err) {
                return { bookId, error: err };
              }
            }),
          );

          const failed = [];
          responses.forEach(({ bookId, data, error: bookError }) => {
            if (data) {
              const registerKeys = [bookId, data.id, data._id, data.bookId].filter(Boolean);
              registerKeys.forEach((key) => {
                booksMap[String(key)] = data;
              });
              return;
            }

            failed.push(bookId);
            const fallback =
              fallbackBookFromItems(bookId) || {
                id: String(bookId),
                title: "Unknown title",
                author: "",
                isbn: "",
                copies: [],
              };
            const registerKeys = [bookId, fallback.id].filter(Boolean);
            registerKeys.forEach((key) => {
              booksMap[String(key)] = fallback;
            });
            console.warn("Failed to load book details", bookId, bookError);
          });

          if (failed.length > 0) {
            setError(
              (prev) =>
                prev ||
                "Some book details were unavailable. Manual copy assignment may be required.",
            );
          }
        }

        const initialAssignments = {};
        fetchedItems.forEach((item, index) => {
          const key = buildApproveItemKey(item, index);
          initialAssignments[key] = item?.copyId ? String(item.copyId) : "";
        });

        if (!cancelled) {
          setBooks(booksMap);
          setAssignments(initialAssignments);
        }
      } catch (err) {
        if (!cancelled) {
          console.error("Failed to prepare approval dialog", err);
          setError(err.response?.data?.message || "Failed to load transaction data");
        }
      } finally {
        if (!cancelled) {
          setLoading(false);
        }
      }
    };

    loadTransactionItems();

    return () => {
      cancelled = true;
    };
  }, [open, transactionId]);

  const dialogItems = useMemo(() => (Array.isArray(items) ? items : []), [items]);

  const takenCopyMap = useMemo(() => {
    const mapping = {};
    Object.entries(assignments || {}).forEach(([key, value]) => {
      if (!value) return;
      mapping[String(value).toLowerCase()] = key;
    });
    return mapping;
  }, [assignments]);

  const assignmentsReady = useMemo(() => {
    if (!open || loading) return false;
    return dialogItems.every((item, index) => {
      const key = buildApproveItemKey(item, index);
      const assigned = assignments[key] || item?.copyId;
      return Boolean((assigned || "").toString().trim());
    });
  }, [assignments, dialogItems, loading, open]);

  const handleAssignmentChange = (itemKey, value) => {
    const normalized = (value || "").toString().trim();
    setAssignments((prev) => ({ ...prev, [itemKey]: normalized }));
    setError("");
  };

  const openAssignScannerForItem = (itemKey, label) => {
    if (!itemKey) return;
    setAssignScanner({ open: true, targetKey: itemKey, label: label || "Reference ID" });
  };

  const closeAssignScannerDialog = () => {
    setAssignScanner({ open: false, targetKey: null, label: "" });
  };

  const handleAssignmentScanDetected = (value) => {
    const trimmed = String(value || "").trim();
    if (!trimmed) {
      toast.error("QR code did not contain a reference ID");
      return;
    }
    if (!assignScanner.targetKey) {
      toast.error("No target field selected for scanning");
      return;
    }
    setAssignments((prev) => ({ ...prev, [assignScanner.targetKey]: trimmed }));
    toast.success("Reference ID captured");
    closeAssignScannerDialog();
  };

  const handleSubmit = async () => {
    if (!transactionId) {
      setError("Missing transaction identifier.");
      return;
    }
    setSubmitting(true);
    setError("");

    try {
      const payloadItems = dialogItems.map((item, index) => {
        const key = buildApproveItemKey(item, index);
        const copyId = (assignments[key] || item?.copyId || "").toString().trim();
        const bookId = item?.bookId ? String(item.bookId) : undefined;
        return {
          requestItemId: item?.requestItemId,
          bookId,
          copyId,
        };
      });

      const missingAssignments = payloadItems.filter((entry) => !entry.copyId);
      if (missingAssignments.length > 0) {
        setError("Please assign a copy for each requested book.");
        setSubmitting(false);
        return;
      }

      await api.post(`/transactions/approve/${transactionId}`, { items: payloadItems });
      toast.success("Request approved");
      onApproved?.();
      onClose?.();
    } catch (err) {
      const message = err.response?.data?.message || "Failed to approve request";
      setError(message);
    } finally {
      setSubmitting(false);
    }
  };

  const handleClose = () => {
    if (submitting) return;
    onClose?.();
  };

  const handleOpenRequestsPage = () => {
    if (submitting) return;
    if (onNavigateToRequests) {
      onNavigateToRequests();
      return;
    }
    navigate("/transactions/requests");
  };

  return (
    <>
      <Dialog open={open} onClose={handleClose} maxWidth="md" fullWidth>
        <DialogTitle>Assign Copies</DialogTitle>
        <DialogContent dividers>
          {error && (
            <Alert severity="warning" sx={{ mb: 2 }}>
              {error}
            </Alert>
          )}
          {loading ? (
            <Box display="flex" alignItems="center" justifyContent="center" minHeight={200}>
              <CircularProgress />
            </Box>
          ) : dialogItems.length === 0 ? (
            <Typography variant="body2" color="text.secondary">
              No items to assign for this request.
            </Typography>
          ) : (
            <Box>
              {dialogItems.map((item, index) => {
                const key = buildApproveItemKey(item, index);
                const assignedCopyId = assignments[key] || item?.copyId || "";
                const bookId = item?.bookId ? String(item.bookId) : "";
                const bookDetails =
                  books[bookId] ||
                  books[item?.book?._id || ""] ||
                  books[item?.book?.id || ""];
                const availableCopies = Array.isArray(bookDetails?.copies)
                  ? bookDetails.copies.filter(
                      (copy) => String(copy.status).toLowerCase() === "available",
                    )
                  : [];
                const hasBookDetails = Boolean(bookDetails);
                const title = bookDetails?.title || item?.title || "Unknown title";
                const author = bookDetails?.author || item?.author || "";
                const isbn = bookDetails?.isbn || item?.isbn || "";
                const copyOptions = availableCopies
                  .filter((copy) => {
                    const owner = takenCopyMap[String(copy.copyId).toLowerCase()];
                    return !owner || owner === key;
                  })
                  .map((copy) => copy.copyId)
                  .filter(Boolean);

                return (
                  <Box
                    key={key}
                    sx={{
                      border: "1px solid #e5e7eb",
                      borderRadius: 1,
                      p: 2,
                      mb: 2,
                    }}
                  >
                    <Typography variant="subtitle1" fontWeight="600">
                      {title}
                    </Typography>
                    <Typography variant="body2" color="text.secondary">
                      {[author && `Author: ${author}`, isbn && `ISBN: ${isbn}`]
                        .filter(Boolean)
                        .join(" ‚Ä¢ ")}
                    </Typography>

                    {item?.copyId ? (
                      <Typography variant="body2" color="text.secondary" sx={{ mt: 1 }}>
                        Copy already assigned: {item.copyId}
                      </Typography>
                    ) : hasBookDetails && copyOptions.length > 0 ? (
                      <Box sx={{ width: "100%", mt: 2 }}>
                        <Autocomplete
                          freeSolo
                          disableClearable
                          autoHighlight
                          options={copyOptions}
                          value={assignedCopyId || ""}
                          onChange={(event, newValue) =>
                            handleAssignmentChange(key, newValue || "")
                          }
                          onInputChange={(event, newInputValue, reason) => {
                            if (reason === "input") {
                              handleAssignmentChange(key, newInputValue || "");
                            }
                          }}
                          renderOption={(props, option) => {
                            const meta = availableCopies.find(
                              (copy) => copy.copyId === option,
                            );
                            return (
                              <li {...props} key={option}>
                                <Box display="flex" flexDirection="column">
                                  <Typography variant="body2">{option}</Typography>
                                  {meta?.location && (
                                    <Typography variant="caption" color="text.secondary">
                                      Location: {meta.location}
                                    </Typography>
                                  )}
                                  {meta?.condition && (
                                    <Typography variant="caption" color="text.secondary">
                                      Condition: {meta.condition}
                                    </Typography>
                                  )}
                                </Box>
                              </li>
                            );
                          }}
                          renderInput={(params) => (
                            <TextField
                              {...params}
                              label="Reference ID"
                              placeholder="Search or scan reference ID"
                              InputProps={{
                                ...params.InputProps,
                                endAdornment: (
                                  <>
                                    <InputAdornment position="end">
                                      <IconButton
                                        size="small"
                                        onClick={() =>
                                          openAssignScannerForItem(key, title)
                                        }
                                        disabled={submitting}
                                      >
                                        <QrCodeScanner fontSize="small" />
                                      </IconButton>
                                    </InputAdornment>
                                    {params.InputProps.endAdornment}
                                  </>
                                ),
                              }}
                              helperText="Type to search available copies or scan a QR label"
                              size="small"
                            />
                          )}
                          disabled={submitting}
                        />
                      </Box>
                    ) : (
                      <Alert severity={hasBookDetails ? "warning" : "error"} sx={{ mt: 2 }}>
                        {hasBookDetails
                          ? "No available copies for this book."
                          : "Unable to load available copies for this book."}
                      </Alert>
                    )}
                  </Box>
                );
              })}
            </Box>
          )}
        </DialogContent>
        <DialogActions>
          <Button onClick={handleOpenRequestsPage} disabled={submitting}>
            Open Requests Page
          </Button>
          <Button onClick={handleClose} disabled={submitting}>
            Cancel
          </Button>
          <Button
            variant="contained"
            onClick={handleSubmit}
            disabled={!assignmentsReady || submitting}
          >
            {submitting ? "Assigning‚Ä¶" : "Assign Copies"}
          </Button>
        </DialogActions>
      </Dialog>

      <Dialog
        open={assignScanner.open}
        onClose={closeAssignScannerDialog}
        maxWidth="xs"
        fullWidth
      >
        <DialogTitle>Scan Reference ID</DialogTitle>
        <DialogContent>
          {assignScanner.open && (
            <QRScanner
              elementId="transaction-assign-qr"
              onDetected={handleAssignmentScanDetected}
              onClose={closeAssignScannerDialog}
            />
          )}
          <Typography variant="body2" color="text.secondary" sx={{ mt: 1 }}>
            Position the QR label for {assignScanner.label || "this item"} inside the frame.
          </Typography>
        </DialogContent>
        <DialogActions>
          <Button onClick={closeAssignScannerDialog}>Close</Button>
        </DialogActions>
      </Dialog>
    </>
  );
};

export default ApproveRequestDialog;
```

## Layout.js

| Field | Details |
| --- | --- |
| Program Name | Layout.js |
| Description | Reusable frontend UI component. |
| Called by | App.js |
| Table used | None |
|  |  |
| Programmer | Nazel Asca√±o |
| Date created | 12/14/2025 |
| Revision Date | TBD |
| Revision / description of change | None |

```javascript
import React, { useCallback, useEffect, useMemo, useRef, useState } from "react";
import { Outlet, useNavigate, useLocation } from "react-router-dom";
import {
  Box,
  AppBar,
  Toolbar,
  Typography,
  IconButton,
  Avatar,
  Menu,
  MenuItem,
  TextField,
  InputAdornment,
  Badge,
  useTheme,
  useMediaQuery,
  Popper,
  Paper,
  List,
  ListItemButton,
  ListItemIcon,
  ListItemText,
  Divider,
  CircularProgress,
  ClickAwayListener,
  Chip,
  Fade,
} from "@mui/material";
import {
  Menu as MenuIcon,
  Search,
  Notifications,
  AccountCircle,
  ExitToApp,
  KeyboardArrowDown,
  MenuBook,
  People,
  SwapHoriz,
  School,
  InfoOutlined,
} from "@mui/icons-material";
import { useAuth } from "../../contexts/AuthContext";
import { api, searchAPI, notificationsAPI } from "../../utils/api";
import Sidebar from "./Sidebar";
import MobileNavBar from "./MobileNavBar";
import MobileScanButton from "../MobileScanButton";
import MobileScanDialog from "../MobileScanDialog";
import { SCAN_EVENT, dispatchScanEvent } from "../../utils/scanEvents";

const SEARCH_SECTION_LABELS = {
  books: "Books",
  users: "Staff & Users",
  students: "Students",
  transactions: "Transactions",
};

const NOTIFICATION_SEVERITY_COLORS = {
  high: "#EF4444",
  medium: "#F97316",
  low: "#10B981",
  info: "#3B82F6",
};

const getSeverityColor = (severity) =>
  NOTIFICATION_SEVERITY_COLORS[severity] || NOTIFICATION_SEVERITY_COLORS.info;

const NOTIFICATION_READ_STORAGE_PREFIX = "olms.notification.read.v1";

const getNotificationFingerprint = (item) => {
  if (!item || typeof item !== "object") {
    return null;
  }

  const candidates = [
    item.id,
    item._id,
    item.transactionId,
    item?.meta?.transactionId,
    item?.link ? `${item.type || "notification"}:${item.link}` : null,
  ];

  for (const candidate of candidates) {
    if (candidate !== undefined && candidate !== null) {
      const normalized = String(candidate).trim();
      if (normalized) {
        return normalized;
      }
    }
  }

  if (item.title || item.message) {
    return `${item.type || "notification"}:${item.title || ""}:${item.message || ""}`;
  }

  return null;
};

const INPUT_SELECTOR =
  'input:not([type="hidden"]):not([disabled]), textarea:not([disabled]), [contenteditable="true"]';

const isHtmlInputElement = (element) =>
  element instanceof HTMLInputElement && element.type !== "hidden" && !element.disabled;

const isHtmlTextAreaElement = (element) =>
  element instanceof HTMLTextAreaElement && !element.disabled;

const isHtmlSelectElement = (element) =>
  element instanceof HTMLSelectElement && !element.disabled;

const isContentEditableElement = (element) =>
  element instanceof HTMLElement && element.isContentEditable;

const isEligibleInputElement = (element) => {
  if (!element) return false;
  if (
    !(isHtmlInputElement(element) ||
      isHtmlTextAreaElement(element) ||
      isHtmlSelectElement(element) ||
      isContentEditableElement(element))
  ) {
    return false;
  }

  if (typeof window === "undefined") {
    return true;
  }

  const style = window.getComputedStyle(element);
  if (!style || style.visibility === "hidden" || style.display === "none") {
    return false;
  }

  const rect = element.getBoundingClientRect();
  if ((rect.width || rect.height) === 0) {
    return false;
  }

  return true;
};

const collectInputCandidates = () => {
  if (typeof document === "undefined") return [];
  const nodes = Array.from(document.querySelectorAll(INPUT_SELECTOR));
  return nodes.filter((node) => isEligibleInputElement(node));
};

const findInputAtCoordinates = (x, y) => {
  if (typeof document === "undefined" || typeof document.elementsFromPoint !== "function") {
    return null;
  }
  const stack = document.elementsFromPoint(x, y);
  return stack.find((element) => isEligibleInputElement(element)) || null;
};

const findClosestInputCandidate = (x, y, candidates) => {
  let closest = null;
  let minDistance = Number.POSITIVE_INFINITY;

  candidates.forEach((element) => {
    const rect = element.getBoundingClientRect();
    const cx = rect.left + rect.width / 2;
    const cy = rect.top + rect.height / 2;
    const dx = cx - x;
    const dy = cy - y;
    const distance = Math.sqrt(dx * dx + dy * dy);

    if (distance < minDistance) {
      minDistance = distance;
      closest = element;
    }
  });

  return closest;
};

const findNearestInputElement = ({ root, pointer } = {}) => {
  const candidates = collectInputCandidates();
  if (candidates.length === 0) {
    return null;
  }

  const resolvePoint = (point) => {
    if (!point) return null;
    const { x, y } = point;
    if (!Number.isFinite(x) || !Number.isFinite(y)) {
      return null;
    }

    const atPoint = findInputAtCoordinates(x, y);
    if (atPoint && candidates.includes(atPoint)) {
      return atPoint;
    }

    return findClosestInputCandidate(x, y, candidates);
  };

  const prioritized = resolvePoint(pointer);
  if (prioritized) {
    return prioritized;
  }

  if (root instanceof HTMLElement) {
    const rect = root.getBoundingClientRect();
    const center = {
      x: rect.left + rect.width / 2,
      y: rect.top + rect.height / 2,
    };
    const byRoot = resolvePoint(center);
    if (byRoot) {
      return byRoot;
    }
  }

  return candidates[0] || null;
};

const focusInputElement = (element) => {
  if (!element || typeof element.focus !== "function") {
    return;
  }

  try {
    element.focus({ preventScroll: true });
  } catch (error) {
    try {
      element.focus();
    } catch (err) {

    }
  }
};

const applyValueToInput = (element, value) => {
  if (!element) return;

  if (element instanceof HTMLInputElement) {
    const setter = Object.getOwnPropertyDescriptor(HTMLInputElement.prototype, "value")?.set;
    if (setter) {
      setter.call(element, value);
    } else {
      element.value = value;
    }
    element.dispatchEvent(new Event("input", { bubbles: true }));
    element.dispatchEvent(new Event("change", { bubbles: true }));
    try {
      element.setSelectionRange(value.length, value.length);
    } catch (error) {

    }
    return;
  }

  if (element instanceof HTMLTextAreaElement) {
    const setter = Object.getOwnPropertyDescriptor(HTMLTextAreaElement.prototype, "value")?.set;
    if (setter) {
      setter.call(element, value);
    } else {
      element.value = value;
    }
    element.dispatchEvent(new Event("input", { bubbles: true }));
    element.dispatchEvent(new Event("change", { bubbles: true }));
    try {
      element.setSelectionRange(value.length, value.length);
    } catch (error) {

    }
    return;
  }

  if (element instanceof HTMLSelectElement) {
    element.value = value;
    element.dispatchEvent(new Event("change", { bubbles: true }));
    return;
  }

  if (element instanceof HTMLElement && element.isContentEditable) {
    element.textContent = value;
    element.dispatchEvent(new Event("input", { bubbles: true }));
  }
};

const formatRelativeTime = (value) => {
  if (!value) return "";
  const date = new Date(value);
  if (Number.isNaN(date.getTime())) return "";

  const diff = date.getTime() - Date.now();
  const abs = Math.abs(diff);
  const minute = 60 * 1000;
  const hour = 60 * minute;
  const day = 24 * hour;

  const label = (count, unit) => `${count} ${unit}${count === 1 ? "" : "s"}`;

  if (abs < minute) {
    return diff >= 0 ? "in under a minute" : "just now";
  }

  if (abs < hour) {
    const minutes = Math.round(abs / minute);
    return diff >= 0
      ? `in ${label(minutes, "minute")}`
      : `${label(minutes, "minute")} ago`;
  }

  if (abs < day) {
    const hours = Math.round(abs / hour);
    return diff >= 0
      ? `in ${label(hours, "hour")}`
      : `${label(hours, "hour")} ago`;
  }

  const days = Math.round(abs / day);
  return diff >= 0 ? `in ${label(days, "day")}` : `${label(days, "day")} ago`;
};

const commonSearchSx = {
  "& .MuiOutlinedInput-root": {
    backgroundColor: "#FFFFFF",
    borderRadius: "10px",
    boxShadow: "0 1px 8px rgba(15, 23, 42, 0.08)",
    border: "1px solid #E2E8F0",
    transition: "all 0.2s ease",
    "& fieldset": {
      borderColor: "transparent",
    },
    "&:hover": {
      boxShadow: "0 2px 14px rgba(15, 23, 42, 0.12)",
      "& fieldset": {
        borderColor: "#305FB7",
      },
    },
    "&.Mui-focused": {
      boxShadow: "0 4px 16px rgba(37, 99, 235, 0.16)",
      "& fieldset": {
        borderColor: "#305FB7",
        borderWidth: "1px",
      },
    },
  },
  "& .MuiInputBase-input": {
    py: 1,
    fontSize: "0.9rem",
    color: "#0F172A",
    "&::placeholder": {
      color: "#94A3B8",
      opacity: 1,
    },
  },
};

const baseNotificationButtonSx = {
  backgroundColor: "#F8FAFC",
  border: "1px solid #E2E8F0",
  color: "#64748B",
  width: 40,
  height: 40,
  borderRadius: "12px",
  transition: "all 0.2s ease",
  display: "inline-flex",
  alignItems: "center",
  justifyContent: "center",
  "&:hover": {
    backgroundColor: "#EEF2FF",
    borderColor: "#CBD5E1",
    transform: "translateY(-1px)",
    boxShadow: "0 4px 12px rgba(15, 23, 42, 0.15)",
  },
};

const IGNORED_CONTROL_KEYS = new Set([
  "Shift",
  "Control",
  "Alt",
  "Meta",
  "CapsLock",
  "Tab",
  "NumLock",
  "ScrollLock",
  "Pause",
  "Insert",
  "Home",
  "End",
  "PageUp",
  "PageDown",
  "ArrowUp",
  "ArrowDown",
  "ArrowLeft",
  "ArrowRight",
  "Escape",
  "Unidentified",
  "OSLeft",
  "OSRight",
  "ContextMenu",
  "F1",
  "F2",
  "F3",
  "F4",
  "F5",
  "F6",
  "F7",
  "F8",
  "F9",
  "F10",
  "F11",
  "F12",
]);

const GLOBAL_SEARCH_INPUT_ID = "global-search-input";

const isElementNode = (node) => typeof Element !== "undefined" && node instanceof Element;

const isValidAnchorElement = (node) => {
  if (typeof document === "undefined" || !isElementNode(node)) {
    return false;
  }
  return document.body.contains(node);
};

const Layout = () => {
  const theme = useTheme();
  const isMobile = useMediaQuery(theme.breakpoints.down("md"));
  const isSmall = useMediaQuery(theme.breakpoints.down("sm"));
  const showMobileNav = isSmall;
  const navigate = useNavigate();
  const location = useLocation();
  const { user, authToken, logout } = useAuth();
  const sessionReady = !!authToken && !!user;

  const [mobileOpen, setMobileOpen] = useState(false);
  const [anchorEl, setAnchorEl] = useState(null);
  const [searchValue, setSearchValue] = useState("");
  const [searchOpen, setSearchOpen] = useState(false);
  const [searchResults, setSearchResults] = useState([]);
  const [searchLoading, setSearchLoading] = useState(false);
  const [searchError, setSearchError] = useState("");
  const [searchScannerOpen, setSearchScannerOpen] = useState(false);
  const searchInputRef = useRef(null);
  const lastPointerRef = useRef({ x: 0, y: 0 });
  const lastFocusedInputRef = useRef(null);
  const scanBufferRef = useRef("");
  const lastKeyTimeRef = useRef(0);
  const scanStartTimeRef = useRef(0);
  const lastHandledScanRef = useRef({ value: "", ts: 0 });
  const isTopLevelDashboard = /^\/(admin|librarian|staff|student)\/dashboard\/?$/.test(
    location.pathname,
  );
  const [notifications, setNotifications] = useState([]);
  const [notificationsLoading, setNotificationsLoading] = useState(false);
  const [notificationsError, setNotificationsError] = useState("");
  const [notificationsAnchorEl, setNotificationsAnchorEl] = useState(null);
  const [notificationsFetchedAt, setNotificationsFetchedAt] = useState(null);
  const [focusedIndex, setFocusedIndex] = useState(-1);
  const [liveRegionMessage, setLiveRegionMessage] = useState("");
  const [readNotificationIds, setReadNotificationIds] = useState([]);
  const readNotificationIdSet = useMemo(
    () => new Set(readNotificationIds),
    [readNotificationIds]
  );
  const userNotificationId = useMemo(
    () => user?.id || user?._id || user?.userId || null,
    [user]
  );

  useEffect(() => {
    if (typeof window === "undefined") {
      return;
    }
    if (!userNotificationId) {
      setReadNotificationIds([]);
      return;
    }

    const storageKey = `${NOTIFICATION_READ_STORAGE_PREFIX}:${userNotificationId}`;
    try {
      const raw = window.localStorage.getItem(storageKey);
      if (!raw) {
        setReadNotificationIds([]);
        return;
      }
      const parsed = JSON.parse(raw);
      if (Array.isArray(parsed)) {
        const maxEntries = 200;
        const trimmed =
          parsed.length > maxEntries
            ? parsed.slice(parsed.length - maxEntries)
            : parsed;
        setReadNotificationIds(trimmed);
      } else {
        setReadNotificationIds([]);
      }
    } catch (error) {
      console.error("Failed to load notification read cache:", error);
      setReadNotificationIds([]);
    }
  }, [userNotificationId]);

  useEffect(() => {
    if (typeof window === "undefined") {
      return;
    }
    if (!userNotificationId) {
      return;
    }

    const storageKey = `${NOTIFICATION_READ_STORAGE_PREFIX}:${userNotificationId}`;
    try {
      const maxEntries = 200;
      const trimmed =
        readNotificationIds.length > maxEntries
          ? readNotificationIds.slice(readNotificationIds.length - maxEntries)
          : readNotificationIds;
      window.localStorage.setItem(storageKey, JSON.stringify(trimmed));
    } catch (error) {
      console.error("Failed to persist notification read cache:", error);
    }
  }, [userNotificationId, readNotificationIds]);

  const markNotificationsRead = useCallback(async (items) => {
    if (!Array.isArray(items) || items.length === 0) {
      return;
    }

    const ids = Array.from(
      new Set(
        items
          .map((item) =>
            item?._id || item?.id || item?.fingerprint || getNotificationFingerprint(item),
          )
          .filter((value) => value !== undefined && value !== null)
          .map((value) => String(value).trim())
          .filter(Boolean),
      ),
    );

    if (ids.length === 0) {
      return;
    }

    for (const id of ids) {
      try {
        await notificationsAPI.markRead(id, true);
      } catch (error) {
        console.error("Failed to mark notification read:", error);
      }
    }
  }, []);

  const registerReadNotifications = useCallback(
    (items) => {
      if (!Array.isArray(items) || items.length === 0) {
        return;
      }

      const aggregate = new Set(readNotificationIdSet);
      let changed = false;
      const markable = [];

      items.forEach((item) => {
        const fingerprint = item?.fingerprint || getNotificationFingerprint(item);
        if (fingerprint && !aggregate.has(fingerprint)) {
          aggregate.add(fingerprint);
          changed = true;
        }
        if (!item?.read) {
          markable.push(item);
        }
      });

      if (changed) {
        const idsArray = Array.from(aggregate);
        const maxEntries = 200;
        const trimmed =
          idsArray.length > maxEntries
            ? idsArray.slice(idsArray.length - maxEntries)
            : idsArray;
        setReadNotificationIds(trimmed);
      }

      markNotificationsRead(markable);
    },
    [markNotificationsRead, readNotificationIdSet],
  );

  const handleSearchResultsWheel = (event) => {
    event.stopPropagation();
  };

  const handleSearchResultsTouchMove = (event) => {
    event.stopPropagation();
  };

  useEffect(() => {
    setFocusedIndex(-1);
  }, [searchResults]);

  useEffect(() => {
    if (typeof document === "undefined") {
      return undefined;
    }

    const handlePointerDown = (event) => {
      lastPointerRef.current = {
        x: event.clientX,
        y: event.clientY,
      };

      if (isEligibleInputElement(event.target)) {
        lastFocusedInputRef.current = event.target;
      }
    };

    const handleFocusIn = (event) => {
      if (isEligibleInputElement(event.target)) {
        lastFocusedInputRef.current = event.target;
      }
    };

    document.addEventListener("pointerdown", handlePointerDown, true);
    document.addEventListener("focusin", handleFocusIn, true);

    return () => {
      document.removeEventListener("pointerdown", handlePointerDown, true);
      document.removeEventListener("focusin", handleFocusIn, true);
    };
  }, []);

  useEffect(() => {
    if (typeof window === "undefined") {
      return undefined;
    }

    const SCAN_RESET_MS = 80;
  const MAX_SCAN_DURATION_MS = 1500;
    const MIN_SCAN_LENGTH = 4;

    const handleKeyDown = (event) => {
      const now = Date.now();
      const keyValue = typeof event.key === "string" ? event.key : "";

      if (now - lastKeyTimeRef.current > SCAN_RESET_MS) {
        scanBufferRef.current = "";
        scanStartTimeRef.current = now;
      }

      if (keyValue === "Enter") {
        const bufferedValue = scanBufferRef.current;
        scanBufferRef.current = "";
        lastKeyTimeRef.current = now;

        if (
          bufferedValue.length >= MIN_SCAN_LENGTH &&
          now - scanStartTimeRef.current <= MAX_SCAN_DURATION_MS
        ) {
          event.preventDefault();
          dispatchScanEvent(bufferedValue, {
            source: "keyboard",
            pointer: { ...lastPointerRef.current },
          });
        }
        return;
      }

      if (
        keyValue.length === 1 &&
        !event.altKey &&
        !event.ctrlKey &&
        !event.metaKey
      ) {
        if (!scanBufferRef.current) {
          scanStartTimeRef.current = now;
        }
        scanBufferRef.current += keyValue;
        lastKeyTimeRef.current = now;
      } else if (keyValue && !IGNORED_CONTROL_KEYS.has(keyValue)) {
        scanBufferRef.current = "";
      }
    };

    window.addEventListener("keydown", handleKeyDown, true);
    return () => window.removeEventListener("keydown", handleKeyDown, true);
  }, []);

  useEffect(() => {
    if (typeof window === "undefined") {
      return undefined;
    }

    const handleScan = (event) => {
      const detail = event.detail || {};
      const rawValue = detail.value;
      if (rawValue == null) {
        return;
      }

      const normalizedValue =
        typeof rawValue === "string" ? rawValue : String(rawValue);
      const sanitizedValue = normalizedValue.replace(/[\r\n]+/g, "");
      if (!sanitizedValue.trim()) {
        return;
      }

      const now = Date.now();
      if (
        lastHandledScanRef.current.value === sanitizedValue &&
        now - lastHandledScanRef.current.ts < 250
      ) {
        return;
      }
      lastHandledScanRef.current = { value: sanitizedValue, ts: now };

      const meta = detail.meta || {};
      const pointer = meta.pointer || lastPointerRef.current;

      let target = null;

      if (isTopLevelDashboard && searchInputRef.current) {
        target = searchInputRef.current;
      }

      if (!target && meta.targetSelector && typeof document !== "undefined") {
        const candidate = document.querySelector(meta.targetSelector);
        if (isEligibleInputElement(candidate)) {
          target = candidate;
        }
      }

      if (!target && meta.elementId && typeof document !== "undefined") {
        const root = document.getElementById(meta.elementId);
        target = findNearestInputElement({ root, pointer });
      }

      if (!target && meta.rect) {
        const rect = meta.rect;
        if (
          Number.isFinite(rect.left) &&
          Number.isFinite(rect.top) &&
          Number.isFinite(rect.width) &&
          Number.isFinite(rect.height)
        ) {
          const centerPointer = {
            x: rect.left + rect.width / 2,
            y: rect.top + rect.height / 2,
          };
          target = findNearestInputElement({ pointer: centerPointer });
        }
      }

      if (!target && pointer) {
        target = findNearestInputElement({ pointer });
      }

      if (!target && isEligibleInputElement(document.activeElement)) {
        target = document.activeElement;
      }

      if (!target && isEligibleInputElement(lastFocusedInputRef.current)) {
        target = lastFocusedInputRef.current;
      }

      if (!target) {
        target = findNearestInputElement({ pointer: lastPointerRef.current });
      }

      if (!target) {
        return;
      }

      focusInputElement(target);
  applyValueToInput(target, sanitizedValue);

      if (target instanceof HTMLElement) {
        const rect = target.getBoundingClientRect();
        lastPointerRef.current = {
          x: rect.left + rect.width / 2,
          y: rect.top + rect.height / 2,
        };
      }
      lastFocusedInputRef.current = target;

      if (target === searchInputRef.current) {
        setSearchValue(sanitizedValue);
        setFocusedIndex(-1);
        setSearchError("");
        setSearchOpen(true);
      }
    };

    window.addEventListener(SCAN_EVENT, handleScan);
    return () => window.removeEventListener(SCAN_EVENT, handleScan);
  }, [isTopLevelDashboard, setFocusedIndex, setSearchError, setSearchOpen, searchInputRef]);

  useEffect(() => {
    if (notifications.length > 0) {
      const unreadCount = notifications.filter(n => !n.read).length;
      if (unreadCount > 0) {
        setLiveRegionMessage(`${unreadCount} unread notifications`);
      }
    }
  }, [notifications]);

  const handleDrawerToggle = () => {
    setMobileOpen(!mobileOpen);
  };

  const handleProfileMenuOpen = (event) => {
    setAnchorEl(event.currentTarget);
  };

  const handleProfileMenuClose = () => {
    setAnchorEl(null);
  };

  const handleProfileNavigate = () => {
    handleProfileMenuClose();
    navigate("/profile");
  };

  const handleLogout = async () => {
    try {
      await logout();
      navigate("/login");
    } catch (error) {
      console.error("Logout failed:", error);
    }
    handleProfileMenuClose();
  };

  const handleSearchChange = (event) => {
    const value = event.target.value;
    setSearchValue(value);
    if (!value.trim()) {
      setSearchOpen(false);
      setSearchResults([]);
      setSearchError("");
    }
  };

  const handleSearchFocus = () => {
    if ((searchResults.length > 0 || searchError) && searchValue.trim()) {
      setSearchOpen(true);
    }
  };

  const handleSearchClose = () => {
    setSearchOpen(false);
    setFocusedIndex(-1);
  };

  const handleSearchKeyDown = (event) => {
    if (!searchResults.length) return;

    const totalItems = searchResults.reduce((sum, section) => sum + section.items.length, 0);

    switch (event.key) {
      case "Escape":
        setSearchOpen(false);
        setFocusedIndex(-1);
        break;
      case "ArrowDown":
        event.preventDefault();
        setFocusedIndex(prev => (prev < totalItems - 1 ? prev + 1 : 0));
        break;
      case "ArrowUp":
        event.preventDefault();
        setFocusedIndex(prev => (prev > 0 ? prev - 1 : totalItems - 1));
        break;
      case "Enter":
        event.preventDefault();
        if (focusedIndex >= 0) {
          let currentIndex = 0;
          for (const section of searchResults) {
            for (const item of section.items) {
              if (currentIndex === focusedIndex) {
                handleSearchResultClick(item);
                return;
              }
              currentIndex++;
            }
          }
        }
        break;
      default:
        break;
    }
  };

  const openSearchScanner = () => setSearchScannerOpen(true);
  const closeSearchScanner = () => setSearchScannerOpen(false);

  const handleSearchScanDetected = (value) => {
    const nextValue = value == null ? "" : String(value);
    setSearchValue(nextValue);
    setSearchOpen(true);
    setFocusedIndex(-1);
    setSearchError("");
    if (searchInputRef.current) {
      searchInputRef.current.focus();
    }
  };

  const handleSearchResultClick = (item) => {
    if (!item) return;

    try {
      const category = item.category;
      const id = item.id;

      if (category === "students") {

        const currentUserId = (user && (user._id || user.id || "")) + "";
        if (user && user.role === "student") {
          if (id && id === currentUserId) {
            navigate("/profile");
          } else {

            navigate("/unauthorized");
          }
        } else {

          if (id) navigate(`/students/${id}`);
        }
      } else if (category === "transactions") {

        if (user && user.role === "student") {

          navigate("/student/dashboard");
        } else {
          if (item.link) navigate(item.link);
        }
      } else {

        if (item.link) navigate(item.link);
      }
    } catch (err) {
      console.error("Failed to navigate from search result:", err);
      if (item.link) navigate(item.link);
    } finally {
      setSearchOpen(false);
      setSearchResults([]);
      setSearchValue("");
    }
  };

  const renderSectionIcon = (key) => {
    switch (key) {
      case "books":
        return <MenuBook fontSize="small" sx={{ color: "#2563EB" }} />;
      case "users":
        return <People fontSize="small" sx={{ color: "#7C3AED" }} />;
      case "students":
        return <School fontSize="small" sx={{ color: "#059669" }} />;
      case "transactions":
        return <SwapHoriz fontSize="small" sx={{ color: "#F97316" }} />;
      default:
        return <InfoOutlined fontSize="small" sx={{ color: "#64748B" }} />;
    }
  };

  const loadNotifications = useCallback(async () => {
    if (!sessionReady) {
      setNotifications([]);
      setNotificationsError("");
      return;
    }
    try {
      setNotificationsLoading(true);
      const { data } = await notificationsAPI.getAll({ limit: 10 });
      const sourceItems = Array.isArray(data?.notifications)
        ? data.notifications
        : [];
      const items = sourceItems.map((item) => {
        const fingerprint = item?.fingerprint || getNotificationFingerprint(item);
        const serverRead = Boolean(item?.read);
        const cachedRead = fingerprint ? readNotificationIdSet.has(fingerprint) : false;
        const resolvedRead = serverRead || cachedRead;
        return { ...item, read: resolvedRead, fingerprint };
      });
      setNotifications(items);
      setNotificationsError("");
      setNotificationsFetchedAt(Date.now());
    } catch (error) {
      console.error("Failed to fetch notifications:", error);
      setNotificationsError(
        error?.response?.data?.message || "Failed to load notifications."
      );
    } finally {
      setNotificationsLoading(false);
    }
  }, [readNotificationIdSet, sessionReady]);

  useEffect(() => {
    if (!sessionReady) {
      return;
    }
    loadNotifications();
  }, [loadNotifications, sessionReady]);

  useEffect(() => {
    if (typeof document === "undefined") {
      return undefined;
    }

    if (!searchOpen) {
      return undefined;
    }

    const originalOverflow = document.body.style.overflow;
    document.body.style.overflow = "hidden";

    return () => {
      document.body.style.overflow = originalOverflow;
    };
  }, [searchOpen]);

  const handleNotificationsOpen = (event) => {
    setNotificationsAnchorEl(event.currentTarget);
    const staleAfter = 5 * 60 * 1000;
    if (!notificationsFetchedAt || Date.now() - notificationsFetchedAt > staleAfter) {
      loadNotifications();
    }
  };

  const handleNotificationsClose = () => {
    setNotificationsAnchorEl(null);
    setNotifications((prev) => {
      if (!prev || prev.length === 0) {
        return [];
      }
      registerReadNotifications(prev);
      return prev.map((item) => ({ ...item, read: true }));
    });
  };

  useEffect(() => {
    if (!notificationsAnchorEl || notifications.length === 0) {
      return;
    }

    const unreadItems = notifications.filter((item) => !item.read);
    if (unreadItems.length === 0) {
      return;
    }

    registerReadNotifications(unreadItems);

    setNotifications((prev) => {
      if (!Array.isArray(prev) || prev.length === 0) {
        return prev;
      }
      const markSet = new Set(
        unreadItems
          .map(
            (item) =>
              item.fingerprint ||
              getNotificationFingerprint(item) ||
              item._id ||
              item.id,
          )
          .filter(Boolean),
      );
      if (markSet.size === 0) {
        return prev;
      }
      return prev.map((item) => {
        const identifier =
          item.fingerprint ||
          getNotificationFingerprint(item) ||
          item._id ||
          item.id;
        if (identifier && markSet.has(identifier)) {
          return { ...item, read: true };
        }
        return item;
      });
    });
  }, [notificationsAnchorEl, notifications, registerReadNotifications]);

  useEffect(() => {
    if (!notifications.length) {
      return;
    }

    const normalizedPath = (location.pathname || '').replace(/\/+$/, '') || '/';
    const onNotificationsPage = normalizedPath === '/notifications';
    if (!onNotificationsPage) {
      return;
    }

    const unreadItems = notifications.filter((item) => !item.read);
    if (unreadItems.length === 0) {
      return;
    }

    registerReadNotifications(unreadItems);

    const markSet = new Set(
      unreadItems
        .map(
          (item) =>
            item.fingerprint ||
            getNotificationFingerprint(item) ||
            item._id ||
            item.id,
        )
        .filter(Boolean),
    );

    if (markSet.size === 0) {
      return;
    }

    setNotifications((prev) => {
      if (!Array.isArray(prev) || prev.length === 0) {
        return prev;
      }
      return prev.map((item) => {
        const identifier =
          item.fingerprint ||
          getNotificationFingerprint(item) ||
          item._id ||
          item.id;
        if (identifier && markSet.has(identifier)) {
          return { ...item, read: true };
        }
        return item;
      });
    });
  }, [location.pathname, notifications, registerReadNotifications]);

  const handleNotificationNavigate = (item) => {
    if (item) {
      registerReadNotifications([item]);
    }
    handleNotificationsClose();
    if (item?.link) {
      navigate(item.link);
    }
  };

  useEffect(() => {
    if (!anchorEl) {
      return;
    }
    if (!isValidAnchorElement(anchorEl)) {
      setAnchorEl(null);
    }
  }, [anchorEl]);

  useEffect(() => {
    if (!notificationsAnchorEl) {
      return;
    }
    if (!isValidAnchorElement(notificationsAnchorEl)) {
      setNotificationsAnchorEl(null);
    }
  }, [notificationsAnchorEl]);

  useEffect(() => {
    const trimmed = searchValue.trim();
    if (!trimmed) {
      setSearchOpen(false);
      setSearchResults([]);
      if (!isTopLevelDashboard) {
        setSearchValue("");
      }
      return;
    }

    let isActive = true;
    setSearchLoading(true);
    setSearchError("");

    const handler = setTimeout(() => {
      searchAPI
        .global({ q: trimmed, limit: 6 })
        .then((response) => {
          if (!isActive) return;
          const data = response?.data || {};
          const sections = Object.entries(data.results || {})
            .filter(([, items]) => Array.isArray(items) && items.length > 0)
            .map(([key, items]) => ({ key, items }));

          setSearchResults(sections);
          setSearchOpen(true);
        })
        .catch((error) => {
          if (!isActive) return;
          console.error("Global search failed:", error);
          setSearchResults([]);
          setSearchError(
            error?.response?.data?.message || "Search failed. Please try again."
          );
          setSearchOpen(true);
        })
        .finally(() => {
          if (isActive) {
            setSearchLoading(false);
          }
        });
    }, 250);

    return () => {
      isActive = false;
      clearTimeout(handler);
    };
  }, [searchValue, isTopLevelDashboard]);

  const unreadCount = notifications.reduce(
    (acc, item) => acc + (item.read ? 0 : 1),
    0,
  );

  const resolveInitial = (value) => {
    if (!value || (typeof value !== "string" && typeof value !== "number")) {
      return "";
    }

    const normalized = String(value).trim();
    if (!normalized) {
      return "";
    }

    return normalized.charAt(0).toUpperCase();
  };

  const userInitial =
    [user?.firstName, user?.lastName, user?.username, user?.email]
      .map(resolveInitial)
      .find((initial) => Boolean(initial)) || "U";
  const resolveApiOrigin = () => {
    const base = api.defaults.baseURL || "";
    if (base) {
      const sanitized = base.replace(/\/api$/i, "");
      return sanitized || base;
    }
    if (typeof window !== "undefined") {
      return window.location.origin;
    }
    return "";
  };
  const avatarSrc = (() => {
    const raw = user?.avatar?.url || user?.avatarUrl;
    if (!raw) {
      return "";
    }
    if (/^https?:\/\//i.test(raw) || raw.startsWith("data:")) {
      return raw;
    }
    const origin = resolveApiOrigin();
    const normalized = raw.startsWith("/") ? raw : `/${raw}`;
    return `${origin}${normalized}`;
  })();
  const userDisplayName = (() => {
    const composed = [user?.firstName, user?.lastName]
      .filter((value) => Boolean(value && value.trim()))
      .join(" ");
    if (composed) return composed;
    if (user?.username) return user.username;
    if (user?.email) return user.email;
    return "Account";
  })();
  const rawRoleLabel = user?.roleLabel || user?.role || "";
  const userRoleLabel = rawRoleLabel
    ? rawRoleLabel.charAt(0).toUpperCase() + rawRoleLabel.slice(1)
    : "Member";

  const profileMenuAnchor = isValidAnchorElement(anchorEl) ? anchorEl : null;
  const notificationsMenuAnchor = isValidAnchorElement(notificationsAnchorEl)
    ? notificationsAnchorEl
    : null;
  const searchPopperAnchor = isValidAnchorElement(searchInputRef.current)
    ? searchInputRef.current
    : null;

  const profileTrigger = isSmall ? (
    <IconButton
      onClick={handleProfileMenuOpen}
      aria-label="Account menu"
      sx={{
        ...baseNotificationButtonSx,
        borderRadius: "50%",
        width: 42,
        height: 42,
      }}
    >
      <Avatar
        src={avatarSrc || undefined}
        sx={{
          width: 30,
          height: 30,
          backgroundColor: avatarSrc ? "transparent" : "#2563EB",
          color: "#FFFFFF",
          fontSize: "0.85rem",
          fontWeight: 600,
          boxShadow: "0 2px 6px rgba(37, 99, 235, 0.35)",
        }}
      >
        {!avatarSrc && userInitial}
      </Avatar>
    </IconButton>
  ) : (
    <Box
      onClick={handleProfileMenuOpen}
      sx={{
        display: "flex",
        alignItems: "center",
        gap: 1,
        cursor: "pointer",
        px: 1.5,
        py: 0.75,
        borderRadius: "10px",
        backgroundColor: "#F8FAFC",
        border: "1px solid #E2E8F0",
        transition: "all 0.2s ease",
        minWidth: 160,
        "&:hover": {
          backgroundColor: "#EEF2FF",
          borderColor: "#CBD5E1",
          boxShadow: "0 4px 12px rgba(15, 23, 42, 0.12)",
          transform: "translateY(-1px)",
        },
      }}
    >
      <Avatar
        src={avatarSrc || undefined}
        sx={{
          width: 32,
          height: 32,
          backgroundColor: avatarSrc ? "transparent" : "#2563EB",
          color: "#FFFFFF",
          fontSize: "0.85rem",
          fontWeight: 600,
          boxShadow: "0 2px 6px rgba(37, 99, 235, 0.35)",
        }}
      >
        {!avatarSrc && userInitial}
      </Avatar>
      <Box sx={{ display: "flex", flexDirection: "column", minWidth: 0 }}>
        <Typography
          variant="body2"
          sx={{
            fontWeight: 600,
            color: "#0F172A",
            fontSize: "0.8rem",
            lineHeight: 1.2,
            textOverflow: "ellipsis",
            overflow: "hidden",
            whiteSpace: "nowrap",
          }}
        >
          {userDisplayName}
        </Typography>
        <Typography
          variant="caption"
          sx={{
            color: "#64748B",
            fontSize: "0.7rem",
            letterSpacing: "0.02em",
            textTransform: "capitalize",
          }}
        >
          {userRoleLabel}
        </Typography>
      </Box>
      <KeyboardArrowDown sx={{ fontSize: 18, color: "#94A3B8" }} />
    </Box>
  );

  return (
    <>
      <Box sx={{ display: "flex", minHeight: "100vh", width: "100%" }}>
      {}
      <a
        href="#main-content"
        className="skip-link"
        onFocus={(e) => e.target.style.top = "6px"}
        onBlur={(e) => e.target.style.top = "-40px"}
      >
        Skip to main content
      </a>
      <a
        href="#navigation"
        className="skip-link"
        onFocus={(e) => e.target.style.top = "6px"}
        onBlur={(e) => e.target.style.top = "-40px"}
      >
        Skip to navigation
      </a>

      {}
      {!isMobile && <Sidebar />}
      {}
      {isMobile && (
        <Box
          sx={{
            position: "fixed",
            top: 0,
            left: mobileOpen ? 0 : "-240px",
            width: "240px",
            height: "100vh",
            zIndex: 1300,
            transition: "left 0.3s ease",
            backgroundColor: "#FFFFFF",
          }}
        >
          <Sidebar onItemClick={() => setMobileOpen(false)} />
        </Box>
      )}
      {}
      {isMobile && mobileOpen && (
        <Box
          sx={{
            position: "fixed",
            top: 0,
            left: 0,
            right: 0,
            bottom: 0,
            backgroundColor: "rgba(0, 0, 0, 0.5)",
            zIndex: 1250,
          }}
          onClick={() => setMobileOpen(false)}
        />
      )}
      {}
      <Box
        component="main"
        role="main"
        id="main-content"
        aria-label="Main content"
        sx={{
          flexGrow: 1,
          ml: isMobile ? 0 : "240px", // Sidebar width only on desktop
          minHeight: "100vh",
          minWidth: 0,
          backgroundColor: "#305FB7",
          pb: showMobileNav ? "96px" : 0,
        }}
      >
        {}
        <AppBar
          position="sticky"
          elevation={0}
          role="banner"
          sx={{
            backgroundColor: "#FFFFFF",
            backdropFilter: "blur(20px)",
            borderBottom: "1px solid rgba(0, 0, 0, 0.05)",
            boxShadow: "0 1px 3px rgba(0, 0, 0, 0.1)",
            borderRadius: 0,
            width: "100%",
            boxSizing: "border-box",
          }}
        >
          <Toolbar
            sx={{
              width: "100%",
              px: { xs: 2, md: 3 },
              py: { xs: 1.25, md: 1 },
              minHeight: "64px !important",
              flexWrap: "wrap",
              gap: { xs: 1, sm: 2 },
              alignItems: "center",
            }}
          >
            {isSmall ? (
              <>
                <Box
                  sx={{
                    display: "flex",
                    alignItems: "center",
                    justifyContent: "space-between",
                    width: "100%",
                    gap: 1.5,
                  }}
                >
                  <Box sx={{ display: "flex", alignItems: "center", gap: 1.5 }}>
                    {isMobile && (
                      <IconButton
                        edge="start"
                        aria-label="Toggle navigation"
                        onClick={handleDrawerToggle}
                        sx={{
                          ...baseNotificationButtonSx,
                          borderRadius: "12px",
                          width: 44,
                          height: 44,
                          color: "#1E293B",
                        }}
                      >
                        <MenuIcon />
                      </IconButton>
                    )}
                    <Box sx={{ display: "flex", flexDirection: "column" }}>
                      <Typography
                        variant="subtitle2"
                        sx={{
                          fontWeight: 700,
                          color: "#0F172A",
                          letterSpacing: "0.02em",
                        }}
                      >
                        OLMS Library
                      </Typography>
                      <Typography
                        variant="caption"
                        sx={{ color: "#64748B", fontSize: "0.68rem" }}
                      >
                        Welcome back, {userDisplayName}
                      </Typography>
                    </Box>
                  </Box>
                  <Box sx={{ display: "flex", alignItems: "center", gap: 1 }}>
                    <IconButton
                      aria-label="Open notifications"
                      onClick={handleNotificationsOpen}
                      aria-haspopup="true"
                      aria-controls={
                        notificationsMenuAnchor ? "notifications-menu" : undefined
                      }
                      sx={{
                        ...baseNotificationButtonSx,
                        width: 44,
                        height: 44,
                      }}
                    >
                      <Badge
                        badgeContent={unreadCount}
                        color="error"
                        sx={{
                          "& .MuiBadge-badge": {
                            backgroundColor: "#EF4444",
                            color: "#FFFFFF",
                            fontSize: "0.6rem",
                            minWidth: 16,
                            height: 16,
                          },
                        }}
                      >
                        <Notifications sx={{ fontSize: 20 }} />
                      </Badge>
                    </IconButton>
                    {profileTrigger}
                  </Box>
                </Box>
                <TextField
                  fullWidth
                  size="small"
                  placeholder="Search by title, author, student, etc."
                  value={searchValue}
                  onChange={handleSearchChange}
                  onFocus={handleSearchFocus}
                  onKeyDown={handleSearchKeyDown}
                  inputRef={searchInputRef}
                  inputProps={{ id: GLOBAL_SEARCH_INPUT_ID }}
                  autoComplete="off"
                  InputProps={{
                    startAdornment: (
                      <InputAdornment position="start">
                        <Search sx={{ color: "#64748B", fontSize: 18 }} />
                      </InputAdornment>
                    ),
                  }}
                  sx={{
                    ...commonSearchSx,
                    mt: 1,
                  }}
                />
                <MobileScanButton
                  label="Scan to Search"
                  onClick={openSearchScanner}
                />
              </>
            ) : (
              <>
                {isMobile && (
                  <IconButton
                    edge="start"
                    aria-label="Toggle navigation"
                    onClick={handleDrawerToggle}
                    sx={{
                      ...baseNotificationButtonSx,
                      borderRadius: "12px",
                      width: 44,
                      height: 44,
                      color: "#1E293B",
                      mr: 2,
                    }}
                  >
                    <MenuIcon />
                  </IconButton>
                )}
                <Box
                  sx={{

                    flexGrow: 1,
                    width: { sm: "100%", md: "100%" },

                    maxWidth: { sm: "100%", md: 720 },
                    mr: { sm: 0, md: 3 },
                  }}
                >
                  <TextField
                    fullWidth
                    size="medium"
                    placeholder="Search by title, author, student, etc."
                    value={searchValue}
                    onChange={handleSearchChange}
                    onFocus={handleSearchFocus}
                    onKeyDown={handleSearchKeyDown}
                    inputRef={searchInputRef}
                    inputProps={{ id: GLOBAL_SEARCH_INPUT_ID }}
                    autoComplete="off"
                    InputProps={{
                      startAdornment: (
                        <InputAdornment position="start">
                          <Search sx={{ color: "#64748B", fontSize: 18 }} />
                        </InputAdornment>
                      ),
                    }}
                    sx={commonSearchSx}
                  />
                </Box>
                <Box
                  sx={{
                    width: "1px",
                    height: 36,
                    backgroundColor: "#E2E8F0",
                    opacity: 0.8,
                    display: { sm: "none", lg: "block" },
                    mr: { lg: 3 },
                  }}
                />
                <Box
                  sx={{
                    display: "flex",
                    alignItems: "center",
                    gap: 1.5,
                    ml: "auto",
                  }}
                >
                  <IconButton
                    aria-label="Open notifications"
                    onClick={handleNotificationsOpen}
                    aria-haspopup="true"
                    aria-controls={
                      notificationsMenuAnchor ? "notifications-menu" : undefined
                    }
                    sx={{ ...baseNotificationButtonSx }}
                  >
                    <Badge
                      badgeContent={unreadCount}
                      color="error"
                      sx={{
                        "& .MuiBadge-badge": {
                          backgroundColor: "#EF4444",
                          color: "#FFFFFF",
                          fontSize: "0.6rem",
                          minWidth: 16,
                          height: 16,
                        },
                      }}
                    >
                      <Notifications sx={{ fontSize: 20 }} />
                    </Badge>
                  </IconButton>
                  {profileTrigger}
                </Box>
              </>
            )}
            {}
            <Menu
              anchorEl={profileMenuAnchor}
              open={Boolean(profileMenuAnchor)}
              onClose={handleProfileMenuClose}
              anchorOrigin={{
                vertical: "bottom",
                horizontal: "right",
              }}
              transformOrigin={{
                vertical: "top",
                horizontal: "right",
              }}
              PaperProps={{
                sx: {
                  mt: 1,
                  borderRadius: "4px",
                  minWidth: 180,
                },
              }}
            >
              <MenuItem onClick={handleProfileNavigate}>
                <AccountCircle sx={{ mr: 2 }} />
                Profile
              </MenuItem>
              <MenuItem onClick={handleLogout}>
                <ExitToApp sx={{ mr: 2 }} />
                Logout
              </MenuItem>
            </Menu>
            <Menu
                id="notifications-menu"
              anchorEl={notificationsMenuAnchor}
              open={Boolean(notificationsMenuAnchor)}
                onClose={handleNotificationsClose}
                anchorOrigin={{
                  vertical: "bottom",
                  horizontal: "right",
                }}
                transformOrigin={{
                  vertical: "top",
                  horizontal: "right",
                }}
                PaperProps={{
                  sx: {
                    mt: 1,
                    width: 340,
                    maxWidth: "95vw",
                    borderRadius: "10px",
                  },
                }}
              >
                <Box sx={{ px: 2, py: 1.5 }}>
                  <Typography
                    variant="subtitle2"
                    sx={{ fontWeight: 600, color: "#0F172A" }}
                  >
                    Notifications
                  </Typography>
                  <Typography variant="caption" color="text.secondary">
                    Latest updates from the library
                  </Typography>
                </Box>
                <Divider />
                {notificationsLoading ? (
                  <Box
                    sx={{
                      display: "flex",
                      alignItems: "center",
                      justifyContent: "center",
                      p: 2,
                    }}
                  >
                    <CircularProgress size={20} />
                  </Box>
                ) : notificationsError ? (
                  <Box sx={{ p: 2 }}>
                    <Typography
                      variant="body2"
                      color="error"
                      sx={{ cursor: "pointer" }}
                      onClick={loadNotifications}
                    >
                      {notificationsError} Tap to retry.
                    </Typography>
                  </Box>
                ) : notifications.length > 0 ? (
                  <List sx={{ maxHeight: 360, overflowY: "auto", py: 0 }}>
                    {notifications.map((item) => (
                      <ListItemButton
                        key={
                          item.id ||
                          item._id ||
                          item.fingerprint ||
                          item.transactionId ||
                          item.timestamp ||
                          item.title
                        }
                        onClick={() => handleNotificationNavigate(item)}
                        alignItems="flex-start"
                        sx={{ gap: 1.5, py: 1, px: 2 }}
                      >
                        <Box
                          sx={{
                            width: 8,
                            height: 8,
                            borderRadius: "50%",
                            backgroundColor: getSeverityColor(item.severity || "info"),
                            mt: 0.75,
                          }}
                        />
                        <ListItemText
                          primary={item.title}
                          primaryTypographyProps={{
                            variant: "body2",
                            fontWeight: item.read ? 500 : 600,
                            color: "text.primary",
                          }}
                          secondary={
                            <Box component="span" sx={{ display: "block" }}>
                              <Typography
                                variant="caption"
                                color="text.secondary"
                                sx={{ display: "block" }}
                              >
                                {item.message}
                              </Typography>
                              {item.timestamp ? (
                                <Typography
                                  variant="caption"
                                  color="text.secondary"
                                  sx={{ display: "block", mt: 0.5 }}
                                >
                                  {formatRelativeTime(item.timestamp)}
                                </Typography>
                              ) : null}
                            </Box>
                          }
                        />
                        {!item.read ? (
                          <Chip
                            label="NEW"
                            size="small"
                            color="primary"
                            sx={{ fontSize: "0.625rem", height: 18 }}
                          />
                        ) : null}
                      </ListItemButton>
                    ))}
                  </List>
                ) : (
                  <Box sx={{ p: 2 }}>
                    <Typography variant="body2" color="text.secondary">
                      You're all caught up.
                    </Typography>
                  </Box>
                )}
              </Menu>
          </Toolbar>
        </AppBar>
        <Popper
          open={searchOpen && Boolean(searchPopperAnchor)}
          anchorEl={searchPopperAnchor}
          placement="bottom-start"
          transition
          modifiers={[{ name: "offset", options: { offset: [0, 8] } }]}
          sx={{ zIndex: 1400 }}
        >
          {({ TransitionProps }) => (
            <Fade {...TransitionProps} timeout={120}>
              <Paper
                elevation={3}
                sx={{

                  width: { xs: "100vw", sm: 720 },
                  maxWidth: "95vw",
                  borderRadius: "10px",
                  boxShadow: "0 10px 30px rgba(15, 23, 42, 0.12)",
                  overflow: "hidden",
                }}
              >
                <ClickAwayListener onClickAway={handleSearchClose}>
                  <Box>
                    <Box sx={{ px: 2, py: 1.5 }}>
                      <Typography
                        variant="subtitle2"
                        sx={{ fontWeight: 600, color: "#0F172A" }}
                      >
                        Search
                      </Typography>
                      {searchValue.trim() ? (
                        <Typography variant="caption" color="text.secondary">
                          Results for "{searchValue.trim()}"
                        </Typography>
                      ) : null}
                    </Box>
                    <Divider />
                    <Box
                      sx={{
                        maxHeight: { xs: "65vh", sm: 360 },
                        overflowY: "auto",
                      }}
                      onWheel={handleSearchResultsWheel}
                      onTouchMove={handleSearchResultsTouchMove}
                    >
                      {searchLoading ? (
                        <Box
                          sx={{
                            display: "flex",
                            alignItems: "center",
                            justifyContent: "center",
                            p: 2,
                          }}
                        >
                          <CircularProgress size={20} />
                        </Box>
                      ) : searchError ? (
                        <Box sx={{ p: 2 }}>
                          <Typography variant="body2" color="error">
                            {searchError}
                          </Typography>
                        </Box>
                      ) : searchResults.length > 0 ? (
                        <List dense disablePadding>
                          {searchResults.map((section, index) => (
                            <Box key={section.key}>
                              <Box
                                sx={{
                                  px: 2,
                                  pt: index === 0 ? 1 : 1.5,
                                  pb: 0.5,
                                  display: "flex",
                                  alignItems: "center",
                                  gap: 1,
                                  color: "#64748B",
                                }}
                              >
                                <Typography
                                  variant="caption"
                                  sx={{ fontWeight: 600, letterSpacing: "0.08em" }}
                                >
                                  {SEARCH_SECTION_LABELS[section.key] || section.key}
                                </Typography>
                              </Box>
                              {section.items.map((item, itemIndex) => {
                                let globalIndex = 0;
                                for (let i = 0; i < searchResults.indexOf(section); i++) {
                                  globalIndex += searchResults[i].items.length;
                                }
                                globalIndex += itemIndex;
                                const isFocused = globalIndex === focusedIndex;

                                return (
                                  <ListItemButton
                                    key={`${section.key}-${item.id}`}
                                    onClick={() => handleSearchResultClick(item)}
                                    alignItems="flex-start"
                                    sx={{
                                      px: 2,
                                      py: 1.25,
                                      gap: 1.5,
                                      backgroundColor: isFocused ? '#EEF2FF' : 'transparent',
                                      '&:hover': {
                                        backgroundColor: isFocused ? '#E0E7FF' : '#F8FAFC',
                                      },
                                    }}
                                  >
                                    <ListItemIcon
                                      sx={{
                                        minWidth: 32,
                                        color: "#2563EB",
                                        mt: 0.25,
                                      }}
                                    >
                                      {renderSectionIcon(section.key)}
                                    </ListItemIcon>
                                    <ListItemText
                                      primary={item.primary}
                                      primaryTypographyProps={{
                                        variant: "body2",
                                        fontWeight: 600,
                                        color: "text.primary",
                                      }}
                                      secondary={
                                        item.secondary ? (
                                          <Typography
                                            variant="caption"
                                            color="text.secondary"
                                            sx={{ display: "block", mt: 0.25 }}
                                          >
                                            {item.secondary}
                                          </Typography>
                                        ) : null
                                      }
                                    />
                                    {item.chip ? (
                                      <Chip
                                        label={item.chip}
                                        size="small"
                                        sx={{
                                          fontSize: "0.65rem",
                                          height: 18,
                                          backgroundColor: "#EFF6FF",
                                          color: "#1D4ED8",
                                        }}
                                      />
                                    ) : null}
                                  </ListItemButton>
                                );
                              })}
                              {index < searchResults.length - 1 ? <Divider /> : null}
                            </Box>
                          ))}
                        </List>
                      ) : (
                        <Box sx={{ p: 2 }}>
                          <Typography variant="body2" color="text.secondary">
                            No results found.
                          </Typography>
                        </Box>
                      )}
                    </Box>
                  </Box>
                </ClickAwayListener>
              </Paper>
            </Fade>
          )}
        </Popper>
        <MobileScanDialog
          open={searchScannerOpen}
          onClose={closeSearchScanner}
          onDetected={handleSearchScanDetected}
          title="Scan to Search"
          elementId="global-search-qr"
          targetSelector={`#${GLOBAL_SEARCH_INPUT_ID}`}
        />
        {}
        <div
          aria-live="polite"
          aria-atomic="true"
          style={{ position: "absolute", left: "-10000px", width: "1px", height: "1px", overflow: "hidden" }}
        >
          {liveRegionMessage}
        </div>

        {}
        <Box
          sx={{
            p: { xs: 2, sm: 3, lg: 4 },
            pb: showMobileNav ? 12 : { xs: 2, sm: 3, lg: 4 },
            backgroundColor: "transparent",
          }}
        >
          <Outlet />
        </Box>
      </Box>
    </Box>
    {showMobileNav && <MobileNavBar onNavigate={() => setMobileOpen(false)} />}
    </>
  );
};

export default Layout;
```

## Loading.js

| Field | Details |
| --- | --- |
| Program Name | Loading.js |
| Description | Reusable frontend UI component. |
| Called by | AdminDashboard.js, App.js, BooksList.js, LibrarianDashboard.js, StudentsList.js |
| Table used | None |
|  |  |
| Programmer | Nazel Asca√±o |
| Date created | 12/14/2025 |
| Revision Date | TBD |
| Revision / description of change | None |

```javascript
import React from "react";
import {
  Box,
  CircularProgress,
  LinearProgress,
  Typography,
  Paper,
} from "@mui/material";

const Loading = ({
  type = "spinner", // "spinner", "linear", "fullscreen"
  size = 40,
  message = "Loading...",
  showMessage = true,
  color = "primary",
  thickness = 3.6,
  sx = {},
  ...props
}) => {
  const renderSpinner = () => (
    <Box
      display="flex"
      flexDirection="column"
      alignItems="center"
      justifyContent="center"
      gap={2}
      sx={sx}
      {...props}
    >
      <CircularProgress
        size={size}
        color={color}
        thickness={thickness}
        aria-hidden="true"
      />
      {showMessage && (
        <Typography
          variant="body2"
          color="text.secondary"
          sx={{ textAlign: "center" }}
        >
          {message}
        </Typography>
      )}
    </Box>
  );

  const renderLinear = () => (
    <Box sx={sx} {...props}>
      <LinearProgress color={color} />
      {showMessage && (
        <Typography
          variant="body2"
          color="text.secondary"
          sx={{ mt: 1, textAlign: "center" }}
        >
          {message}
        </Typography>
      )}
    </Box>
  );

  const renderFullscreen = () => (
    <Box
      sx={{
        position: "fixed",
        top: 0,
        left: 0,
        width: "100vw",
        height: "100vh",
        backgroundColor: "rgba(255, 255, 255, 0.8)",
        backdropFilter: "blur(4px)",
        display: "flex",
        flexDirection: "column",
        alignItems: "center",
        justifyContent: "center",
        gap: 2,
        zIndex: 9999,
        ...sx,
      }}
      {...props}
    >
      <CircularProgress size={size} color={color} thickness={thickness} />
      {showMessage && (
        <Typography variant="body1" color="text.secondary">
          {message}
        </Typography>
      )}
    </Box>
  );

  switch (type) {
    case "linear":
      return renderLinear();
    case "fullscreen":
      return renderFullscreen();
    case "spinner":
    default:
      return renderSpinner();
  }
};

export const PageLoading = ({ message = "Loading page...", ...props }) => (
  <Box
    display="flex"
    justifyContent="center"
    alignItems="center"
    minHeight="60vh"
    role="status"
    aria-live="polite"
    aria-label={message}
  >
    <Loading message={message} {...props} />
  </Box>
);

export const ButtonLoading = ({ size = 20, ...props }) => (
  <CircularProgress size={size} {...props} />
);

export const InlineLoading = ({ message = "Loading...", ...props }) => (
  <Box display="flex" alignItems="center" gap={1}>
    <CircularProgress size={16} />
    <Typography variant="body2" color="text.secondary">
      {message}
    </Typography>
  </Box>
);

export const CardLoading = ({ message = "Loading...", height = 200, ...props }) => (
  <Paper
    sx={{
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      height,
      ...props.sx,
    }}
    {...props}
  >
    <Loading message={message} />
  </Paper>
);

export default Loading;
```

## MobileNavBar.js

| Field | Details |
| --- | --- |
| Program Name | MobileNavBar.js |
| Description | Reusable frontend UI component. |
| Called by | Layout.js |
| Table used | None |
|  |  |
| Programmer | Nazel Asca√±o |
| Date created | 12/14/2025 |
| Revision Date | TBD |
| Revision / description of change | None |

```javascript
import React, { useMemo } from "react";
import {
  BottomNavigation,
  BottomNavigationAction,
  Paper,
} from "@mui/material";
import {
  Dashboard,
  MenuBook,
  Notifications,
  SwapHoriz,
  AccountCircle,
} from "@mui/icons-material";
import { useLocation, useNavigate } from "react-router-dom";
import { useAuth } from "../../contexts/AuthContext";

const resolveDashboardPath = (role) => {
  switch ((role || "").toLowerCase()) {
    case "admin":
      return "/admin/dashboard";
    case "librarian":
      return "/librarian/dashboard";
    case "staff":
      return "/staff/dashboard";
    case "student":
      return "/student/dashboard";
    default:
      return "/login";
  }
};

const resolveTransactionsPath = (role) => {
  switch ((role || "").toLowerCase()) {
    case "admin":
    case "librarian":
    case "staff":
      return "/transactions";
    case "student":
      return "/transactions/request";
    default:
      return null;
  }
};

const MobileNavBar = ({ onNavigate }) => {
  const navigate = useNavigate();
  const location = useLocation();
  const { user } = useAuth();

  const navItems = useMemo(() => {
    if (!user) {
      return [];
    }

    const role = user.role || "";
    const items = [];
    const dashboardPath = resolveDashboardPath(role);
    items.push({
      key: "dashboard",
      label: "Home",
      icon: <Dashboard fontSize="small" />,
      path: dashboardPath,
      matchers: ["/admin/dashboard", "/librarian/dashboard", "/staff/dashboard", "/student/dashboard"],
    });

    if (["librarian", "staff", "student"].includes(role)) {
      items.push({
        key: "books",
        label: "Books",
        icon: <MenuBook fontSize="small" />,
        path: "/books",
        matchers: ["/books"],
      });
    }

    const transactionsPath = resolveTransactionsPath(role);
    if (transactionsPath) {
      items.push({
        key: "transactions",
        label: "Records",
        icon: <SwapHoriz fontSize="small" />,
        path: transactionsPath,
        matchers: ["/transactions", "/annual-borrowing"],
      });
    }

    items.push({
      key: "notifications",
      label: "Alerts",
      icon: <Notifications fontSize="small" />,
      path: "/notifications",
      matchers: ["/notifications"],
    });

    items.push({
      key: "profile",
      label: "Profile",
      icon: <AccountCircle fontSize="small" />,
      path: "/profile",
      matchers: ["/profile"],
    });

    return items;
  }, [user]);

  const currentKey = useMemo(() => {
    const pathname = location.pathname || "/";
    const activeItem = navItems.find((item) => {
      if (!item.matchers || item.matchers.length === 0) {
        return pathname === item.path || pathname.startsWith(`${item.path}/`);
      }
      return item.matchers.some((matcher) => pathname.startsWith(matcher));
    });
    return activeItem?.key || navItems[0]?.key || "";
  }, [location.pathname, navItems]);

  const handleChange = (event, newValue) => {
    const target = navItems.find((item) => item.key === newValue);
    if (!target || !target.path) {
      return;
    }
    if (location.pathname !== target.path) {
      navigate(target.path);
    }
    if (typeof onNavigate === "function") {
      onNavigate(target.path);
    }
  };

  if (!navItems.length) {
    return null;
  }

  return (
    <Paper
      elevation={12}
      sx={{
        position: "fixed",
        left: 0,
        right: 0,
        bottom: 0,
        borderTopLeftRadius: 18,
        borderTopRightRadius: 18,
        paddingBottom: "max(var(--safe-area-inset-bottom, 0px), 8px)",
        zIndex: 1500,
      }}
    >
      <BottomNavigation
        value={currentKey}
        onChange={handleChange}
        showLabels
        sx={{
          minHeight: 64,
          borderTop: "1px solid #E2E8F0",
          "& .MuiBottomNavigationAction-root": {
            minWidth: "auto",
            padding: "6px 8px",
            fontSize: "0.7rem",
          },
        }}
      >
        {navItems.map((item) => (
          <BottomNavigationAction
            key={item.key}
            value={item.key}
            icon={item.icon}
            label={item.label}
          />
        ))}
      </BottomNavigation>
    </Paper>
  );
};

export default MobileNavBar;
```

## MobileScanButton.js

| Field | Details |
| --- | --- |
| Program Name | MobileScanButton.js |
| Description | Reusable frontend UI component. |
| Called by | BooksList.js, BorrowForm.js, Layout.js, ReturnForm.js, StudentsList.js, TransactionsList.js, UsersList.js |
| Table used | None |
|  |  |
| Programmer | Nazel Asca√±o |
| Date created | 12/14/2025 |
| Revision Date | TBD |
| Revision / description of change | None |

```javascript
import React from "react";
import { Button } from "@mui/material";
import QrCodeScanner from "@mui/icons-material/QrCodeScanner";
import { useTheme } from "@mui/material/styles";
import useMediaQuery from "@mui/material/useMediaQuery";

const MobileScanButton = ({
  label = "Scan QR Code",
  onClick,
  disabled = false,
  sx,
  icon,
}) => {
  const theme = useTheme();
  const isMobile = useMediaQuery(theme.breakpoints.down("sm"));

  if (!isMobile) {
    return null;
  }

  return (
    <Button
      fullWidth
      variant="outlined"
      startIcon={icon || <QrCodeScanner />}
      onClick={onClick}
      disabled={disabled}
      sx={{ mt: 2, ...sx }}
    >
      {label}
    </Button>
  );
};

export default MobileScanButton;
```

## MobileScanDialog.js

| Field | Details |
| --- | --- |
| Program Name | MobileScanDialog.js |
| Description | Reusable frontend UI component. |
| Called by | BooksList.js, Layout.js, StudentsList.js, TransactionsList.js, UsersList.js |
| Table used | None |
|  |  |
| Programmer | Nazel Asca√±o |
| Date created | 12/14/2025 |
| Revision Date | TBD |
| Revision / description of change | None |

```javascript
import React, { useMemo } from "react";
import { Dialog, DialogTitle, DialogContent, DialogActions, Button } from "@mui/material";
import QRScanner from "./QRScanner";

const MobileScanDialog = ({
  open,
  onClose,
  onDetected,
  title = "Scan QR Code",
  cancelLabel = "Cancel",
  elementId,
  targetSelector,
}) => {
  const fallbackId = useMemo(
    () => `mobile-scan-${Math.random().toString(36).slice(2, 10)}`,
    []
  );
  const resolvedId = elementId || fallbackId;

  const handleDetected = (value) => {
    if (typeof onDetected === "function") {
      onDetected(value);
    }
    if (typeof onClose === "function") {
      onClose();
    }
  };

  return (
    <Dialog open={open} onClose={onClose} maxWidth="xs" fullWidth>
      <DialogTitle>{title}</DialogTitle>
      <DialogContent>
        {open ? (
          <QRScanner
            elementId={resolvedId}
            onDetected={handleDetected}
            onClose={onClose}
            targetSelector={targetSelector}
          />
        ) : null}
      </DialogContent>
      <DialogActions>
        <Button onClick={onClose}>{cancelLabel}</Button>
      </DialogActions>
    </Dialog>
  );
};

export default MobileScanDialog;
```

## ProtectedRoute.js

| Field | Details |
| --- | --- |
| Program Name | ProtectedRoute.js |
| Description | Reusable frontend UI component. |
| Called by | App.js |
| Table used | None |
|  |  |
| Programmer | Nazel Asca√±o |
| Date created | 12/14/2025 |
| Revision Date | TBD |
| Revision / description of change | None |

```javascript
import React from "react";
import { Navigate } from "react-router-dom";
import { useAuth } from "../../contexts/AuthContext";

const ProtectedRoute = ({ children, roles }) => {
  const { user, loading } = useAuth();

  if (loading) {
    return (
      <div role="status" aria-live="polite" aria-label="Authenticating user">
        Loading...
      </div>
    );
  }

  if (!user) {
    return <Navigate to="/login" replace />;
  }

  if (roles && !roles.includes(user.role)) {
    return <Navigate to="/unauthorized" replace />;
  }

  return children;
};

export default ProtectedRoute;
```

## QRScanner.js

| Field | Details |
| --- | --- |
| Program Name | QRScanner.js |
| Description | Reusable frontend UI component. |
| Called by | ApproveRequestDialog.js, BookCopies.js, BorrowForm.js, MobileScanDialog.js, RequestsPage.js, ReturnForm.js, TransactionsList.js |
| Table used | None |
|  |  |
| Programmer | Nazel Asca√±o |
| Date created | 12/14/2025 |
| Revision Date | TBD |
| Revision / description of change | None |

```javascript
import React, { useEffect, useRef } from 'react';
import { Html5QrcodeScanner } from 'html5-qrcode';
import { dispatchScanEvent } from '../utils/scanEvents';

const QRScanner = ({
  elementId = 'qr-scanner',
  onDetected,
  onClose,
  qrbox = 250,
  fps = 10,
  targetSelector,
}) => {
  const mountedRef = useRef(false);
  useEffect(() => {
    mountedRef.current = true;
    const config = { fps, qrbox };
    const verbose = false;
    const scanner = new Html5QrcodeScanner(elementId, config, verbose);

    scanner.render(
      (decodedText) => {

        try {
          if (mountedRef.current) {
            const root = document.getElementById(elementId);
            const rect = root ? root.getBoundingClientRect() : null;
            const pointer = rect
              ? { x: rect.left + rect.width / 2, y: rect.top + rect.height / 2 }
              : undefined;

            dispatchScanEvent(decodedText, {
              source: 'qr-scanner',
              elementId,
              targetSelector,
              rect: rect
                ? {
                    left: rect.left,
                    top: rect.top,
                    width: rect.width,
                    height: rect.height,
                  }
                : undefined,
              pointer,
            });

            onDetected && onDetected(decodedText);
          }
        } finally {

          scanner.clear().catch(() => {});
        }
      },
      (errorMessage) => {

      }
    );

    return () => {
      mountedRef.current = false;

      scanner.clear().catch(() => {});
      onClose && onClose();
    };

  }, []);

  return <div id={elementId} />;
};

export default QRScanner;
```

## Sidebar.js

| Field | Details |
| --- | --- |
| Program Name | Sidebar.js |
| Description | Reusable frontend UI component. |
| Called by | Layout.js |
| Table used | None |
|  |  |
| Programmer | Nazel Asca√±o |
| Date created | 12/14/2025 |
| Revision Date | TBD |
| Revision / description of change | None |

```javascript
import React from "react";
import { useNavigate, useLocation } from "react-router-dom";
import {
  Box,
  List,
  ListItem,
  ListItemButton,
  ListItemIcon,
  ListItemText,
  Typography,
  Paper,
} from "@mui/material";
import {
  Dashboard,
  People,
  MenuBook,
  SwapHoriz,
  Settings,
  Assessment,
  History,
} from "@mui/icons-material";
import { useAuth } from "../../contexts/AuthContext";
import { useSettings } from "../../contexts/SettingsContext";
import logo from "../../assets/images/logo.png";

const ACTIVE_TAB_BACKGROUND = "linear-gradient(90deg, #2563EB 0%, #1D4ED8 100%)";
const ACTIVE_TAB_BACKGROUND_HOVER = "linear-gradient(90deg, #1D4ED8 0%, #1E40AF 100%)";
const CONTENT_BACKGROUND = "#F8FAFC";

const Sidebar = ({ onItemClick }) => {
  const navigate = useNavigate();
  const location = useLocation();
  const { user } = useAuth();
  const { libraryTagline, libraryLogoUrl } = useSettings();
  const displayLogo = libraryLogoUrl || logo;

  const handleNavigation = (path) => {
    navigate(path);
    if (onItemClick) onItemClick();
  };

  const isActive = (path) => {
    return (
      location.pathname === path || location.pathname.startsWith(path + "/")
    );
  };

  const getDashboardPath = () => {
    if (!user) return "/dashboard";

    switch (user.role) {
      case "admin":
        return "/admin/dashboard";
      case "librarian":
        return "/librarian/dashboard";
      case "staff":
        return "/staff/dashboard";
      case "student":
        return "/student/dashboard";
      default:
        return "/dashboard";
    }
  };

  const navigationItems = [
    {
      label: "Dashboard",
      icon: <Dashboard />,
      path: getDashboardPath(),
      roles: ["admin", "librarian", "staff", "student"],
    },
    {
      label: "Students",
      icon: <People />,
      path: "/students",
      roles: ["admin", "librarian", "staff"],
    },
    {
      label: "Users",
      icon: <People />,
      path: "/users",
      roles: ["admin"],
    },
    {
      label: "Books",
      icon: <MenuBook />,
      path: "/books",
      roles: ["librarian", "staff", "student"],
    },
    {
      label: "Transactions",
      icon: <SwapHoriz />,
      path: "/transactions",
      roles: ["librarian", "staff"],
    },
    {
      label: "Reports",
      icon: <Assessment />,
      path: "/reports",
      roles: ["librarian"],
    },
    {
      label: "Audit Logs",
      icon: <History />,
      path: "/audit-logs",
      roles: ["admin"],
    },
    {
      label: "Settings",
      icon: <Settings />,
      path: "/settings",
      roles: ["admin", "librarian"],
    },
  ];

  const hasPermission = (roles) => {
    return roles.includes(user?.role);
  };

  return (
    <Paper
      elevation={0}
      role="navigation"
      id="navigation"
      aria-label="Main navigation"
      sx={{
        width: 240,
        height: "100vh",
        backgroundColor: "#FFFFFF",
        display: "flex",
        flexDirection: "column",
        position: "fixed",
        zIndex: 1200,
        boxShadow: "0 4px 20px rgba(0, 0, 0, 0.08)",
        borderRight: "1px solid #E2E8F0",
      }}
    >
      <Box
        sx={{
          p: 2,
          borderBottom: "1px solid #F1F5F9",
          background: "linear-gradient(135deg, #FAFBFC 0%, #F8FAFC 100%)",
        }}
      >
        <Box sx={{ display: "flex", alignItems: "center", gap: 2 }}>
          <img
            src={displayLogo}
            alt="ONHS Library Management System Logo - Navigate to Dashboard"
            style={{
              width: "32px",
              height: "32px",
              borderRadius: "4px",
              objectFit: "contain",
            }}
          />{" "}
          <Box>
            <Typography
              variant="h6"
              sx={{
                fontWeight: 700,
                color: "#1E293B",
                fontSize: "1.1rem",
                lineHeight: 1.2,
              }}
            >
              {" "}
              Library System{" "}
            </Typography>{" "}
            <Typography
              variant="body2"
              sx={{ color: "#64748B", fontSize: "0.75rem", opacity: 0.8 }}
            >
              {libraryTagline}
            </Typography>{" "}
          </Box>{" "}
        </Box>{" "}
      </Box>{" "}
      <Box sx={{ flex: 1, overflowY: "auto", py: 0.5, px: 1 }}>
        <Typography
          variant="overline"
          sx={{
            color: "#94A3B8",
            fontWeight: 600,
            fontSize: "0.6rem",
            letterSpacing: "0.1em",
            mb: 0.5,
            px: 1,
            display: "block",
          }}
        >
          {" "}
          NAVIGATION{" "}
        </Typography>{" "}
        <List sx={{ p: 0 }}>
          {" "}
          {navigationItems
            .filter((item) => hasPermission(item.roles))
            .map((item) => {
              const active = isActive(item.path);
              return (
                <ListItem key={item.label} disablePadding sx={{ mb: 0.25 }}>
                  <ListItemButton
                    onClick={() => handleNavigation(item.path)}
                    selected={active}
                    sx={{
                      py: 0.5,
                      px: 1,
                      minHeight: 32,
                      transition: "all 0.2s ease",
                      borderRadius: "10px",
                      position: "relative",
                      overflow: "visible",
                      "&::after": {
                        content: '""',
                        position: "absolute",
                        top: 0,
                        bottom: 0,
                        right: -8,
                        width: 8,
                        borderRadius: "0 10px 10px 0",
                        backgroundColor: CONTENT_BACKGROUND,
                        opacity: active ? 1 : 0,
                        transition: "opacity 0.2s ease",
                        pointerEvents: "none",
                      },
                      "&.Mui-selected": {
                        background: ACTIVE_TAB_BACKGROUND,
                        color: "#FFFFFF",
                        boxShadow: "0 8px 18px rgba(37, 99, 235, 0.25)",
                        "& .MuiListItemIcon-root": { color: "#FFFFFF" },
                        "& .MuiTypography-root": { color: "#FFFFFF" },
                        "&:hover": { background: ACTIVE_TAB_BACKGROUND_HOVER },
                      },
                      "&:not(.Mui-selected):hover": {
                        backgroundColor: "rgba(37, 99, 235, 0.08)",
                        "& .MuiListItemIcon-root": { color: "#2563EB" },
                      },
                    }}
                  >
                    <ListItemIcon
                      sx={{
                        color: active ? "#FFFFFF" : "#64748B",
                        minWidth: 24,
                        "& svg": { fontSize: "0.9rem" },
                      }}
                    >
                      {" "}
                      {item.icon}{" "}
                    </ListItemIcon>{" "}
                    <ListItemText
                      primary={item.label}
                      sx={{
                        "& .MuiTypography-root": {
                          fontSize: "0.75rem",
                          fontWeight: active ? 600 : 500,
                          color: active ? "#FFFFFF" : "#374151",
                        },
                      }}
                    />{" "}
                  </ListItemButton>{" "}
                </ListItem>
              );
            })}{" "}
        </List>{" "}
      </Box>{" "}
    </Paper>
  );
};

export default Sidebar;
```

## SplashScreen.js

| Field | Details |
| --- | --- |
| Program Name | SplashScreen.js |
| Description | Reusable frontend UI component. |
| Called by | App.js |
| Table used | None |
|  |  |
| Programmer | Nazel Asca√±o |
| Date created | 12/14/2025 |
| Revision Date | TBD |
| Revision / description of change | None |

```javascript
import React from 'react';
import { Box, Typography } from '@mui/material';
import logo from '../assets/images/logo.png';
import { useSettings } from '../contexts/SettingsContext';

const SplashScreen = () => {
  const { libraryTagline, libraryLogoUrl } = useSettings();
  const displayLogo = libraryLogoUrl || logo;

  return (
    <Box
      sx={{
        minHeight: '100vh',
        display: 'flex',
        flexDirection: 'column',
        alignItems: 'center',
        justifyContent: 'center',
        backgroundColor: '#305FB7',
        color: 'white',
      }}
    >
      <Box
        component="img"
        src={displayLogo}
        alt="ONHS Library Management System Logo"
        sx={{
          width: 200,
          height: 'auto',
          mb: 2,
        }}
      />
      <Typography variant="h5" sx={{ fontFamily: 'Inknut Antiqua, serif' }}>
        {libraryTagline}
      </Typography>
    </Box>
  );
};

export default SplashScreen;
```

# Frontend - Contexts

## AuthContext.js

| Field | Details |
| --- | --- |
| Program Name | AuthContext.js |
| Description | React context provider for shared state. |
| Called by | AdminDashboard.js, App.js, BookCopies.js, BookDetails.js, BooksList.js, BorrowForm.js, index.js, Layout.js, LoginPage.js, MobileNavBar.js, NotificationsPage.js, ProtectedRoute.js, ReportsPage.js, RequestsPage.js, SettingsContext.js, SettingsPage.js, Sidebar.js, StudentDashboard.js, StudentForm.js, StudentsList.js, TransactionDetails.js, TransactionsList.js, UserForm.js, UserProfile.js, UsersList.js |
| Table used | None |
|  |  |
| Programmer | Nazel Asca√±o |
| Date created | 12/14/2025 |
| Revision Date | TBD |
| Revision / description of change | None |

```javascript
import React, { createContext, useContext, useState, useEffect, useRef, useCallback } from "react";
import { authAPI, verifySession, api } from "../utils/api";

const TOKEN_REFRESH_EVENT = "olms-token-refresh";
const VERIFY_INTERVAL_MS = 2 * 60 * 1000; // ping backend every 2 minutes
const MIN_MANUAL_VERIFY_GAP_MS = 15 * 1000; // avoid spamming on rapid focus changes
const COOKIE_SESSION_FLAG = "olmsCookieSession";

const readStoredToken = () => {
  if (typeof window === "undefined") {
    return null;
  }
  try {
    return (
      window.localStorage.getItem("authToken") ||
      window.sessionStorage.getItem("authToken")
    );
  } catch (error) {
    console.warn("Failed to read stored auth token", error);
    return null;
  }
};

const readStoredUserPayload = () => {
  if (typeof window === "undefined") {
    return null;
  }
  try {
    const stored =
      window.localStorage.getItem("userData") ||
      window.sessionStorage.getItem("userData");
    if (!stored) {
      return null;
    }
    return JSON.parse(stored);
  } catch (error) {
    console.warn("Failed to read stored user payload", error);
    return null;
  }
};

const getCookieSessionFlag = () => {
  if (typeof window === "undefined") {
    return false;
  }
  try {
    return window.sessionStorage.getItem(COOKIE_SESSION_FLAG) === "true";
  } catch (error) {
    console.warn("Failed to read cookie session flag", error);
    return false;
  }
};

const setCookieSessionFlag = (isActive) => {
  if (typeof window === "undefined") {
    return;
  }
  try {
    if (isActive) {
      window.sessionStorage.setItem(COOKIE_SESSION_FLAG, "true");
    } else {
      window.sessionStorage.removeItem(COOKIE_SESSION_FLAG);
    }
  } catch (error) {
    console.warn("Failed to update cookie session flag", error);
  }
};

const normalizeRole = (role) => {
  if (!role && role !== 0) {
    return "";
  }
  const value = String(role).trim().toLowerCase();
  if (!value) {
    return "";
  }
  switch (value) {
    case "super admin":
    case "super-admin":
    case "superadmin":
    case "administrator":
      return "admin";
    default:
      return value;
  }
};

const normalizeUserPayload = (user) => {
  if (!user || typeof user !== "object") {
    return null;
  }

  const originalRole = user.roleLabel || user.role || "";
  const normalizedRole = normalizeRole(user.effectiveRole || originalRole);

  return {
    ...user,
    role: normalizedRole || "",
    roleLabel: originalRole || normalizedRole || "",
  };
};

const applyAxiosAuthHeader = (token) => {
  if (token) {
    api.defaults.headers.common.Authorization = `Bearer ${token}`;
  } else {
    delete api.defaults.headers.common.Authorization;
  }
};

const emitTokenRefresh = (token) => {
  if (typeof window === "undefined") {
    return;
  }

  window.dispatchEvent(
    new CustomEvent(TOKEN_REFRESH_EVENT, {
      detail: { token },
    }),
  );
};

const AuthContext = createContext();

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error("useAuth must be used within an AuthProvider");
  }
  return context;
};

export const AuthProvider = ({ children }) => {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  const [loginLoading, setLoginLoading] = useState(false);
  const [authToken, setAuthToken] = useState(null);
  const [hasCookieSession, setHasCookieSession] = useState(() => getCookieSessionFlag());
  const verifyTimerRef = useRef(null);
  const verifyInFlightRef = useRef(false);
  const lastManualVerifyRef = useRef(0);

  const logout = useCallback(({ reason } = {}) => {
    authAPI.logout().catch(() => {});
    setUser(null);
    setAuthToken(null);
    applyAxiosAuthHeader(null);
    setHasCookieSession(false);
    setCookieSessionFlag(false);
    localStorage.removeItem("authToken");
    localStorage.removeItem("userData");
    try {
      sessionStorage.removeItem("authToken");
      sessionStorage.removeItem("userData");
    } catch (error) {
      console.warn("Failed to clear sessionStorage on logout", error);
    }
    emitTokenRefresh(null);
    if (reason) {
      console.info("Logged out:", reason);
    }
  }, []);

  const runSessionVerify = useCallback(async () => {
    if ((!authToken && !hasCookieSession) || verifyInFlightRef.current) {
      return;
    }
    verifyInFlightRef.current = true;
    try {
      await verifySession();
      setHasCookieSession(true);
      setCookieSessionFlag(true);
    } catch (error) {
      if (error?.response?.status === 401) {
        logout({ reason: "Session expired" });
      } else {
        console.warn("Session verify failed", error);
      }
    } finally {
      verifyInFlightRef.current = false;
    }
  }, [authToken, hasCookieSession, logout]);

  const attemptCookieBootstrap = useCallback(async () => {
    if (!hasCookieSession || verifyInFlightRef.current) {
      return false;
    }
    verifyInFlightRef.current = true;
    try {
      const { data } = await verifySession({ __skipAuthHandler: true });
      const normalizedUser = normalizeUserPayload(data?.user);
      if (!normalizedUser) {
        throw new Error("Invalid server session payload");
      }
      setUser(normalizedUser);
      localStorage.setItem("userData", JSON.stringify(normalizedUser));
      setHasCookieSession(true);
      setCookieSessionFlag(true);
      const resolvedToken = data?.token || readStoredToken();
      if (resolvedToken) {
        applyAxiosAuthHeader(resolvedToken);
        setAuthToken(resolvedToken);
        localStorage.setItem("authToken", resolvedToken);
        try {
          sessionStorage.setItem("authToken", resolvedToken);
        } catch (storageError) {
          console.warn("Failed to persist refreshed auth token", storageError);
        }
        emitTokenRefresh(resolvedToken);
      }
      return true;
    } catch (error) {
      if (error?.response?.status === 401) {
        setHasCookieSession(false);
        setCookieSessionFlag(false);
      } else {
        console.warn("Cookie session bootstrap failed", error);
      }
      return false;
    } finally {
      verifyInFlightRef.current = false;
    }
  }, [hasCookieSession]);

  useEffect(() => {
    let isMounted = true;

    const hydrateFromStorage = async () => {
      const token = readStoredToken();
      const storedUser = readStoredUserPayload();

      if (token && storedUser) {
        try {
          const normalizedUser = normalizeUserPayload(storedUser);
          if (!normalizedUser) {
            throw new Error("Invalid stored user payload");
          }
          applyAxiosAuthHeader(token);
          setAuthToken(token);
          setUser(normalizedUser);
          setHasCookieSession(true);
          setCookieSessionFlag(true);
          if (isMounted) {
            setLoading(false);
          }
          return;
        } catch (error) {
          console.error("Error parsing stored user data:", error);
          localStorage.removeItem("authToken");
          localStorage.removeItem("userData");
          try {
            sessionStorage.removeItem("authToken");
            sessionStorage.removeItem("userData");
          } catch (storageError) {
            console.warn("Failed to clear sessionStorage after parse error", storageError);
          }
          setHasCookieSession(false);
          setCookieSessionFlag(false);
        }
      }

      if (hasCookieSession) {
        await attemptCookieBootstrap();
      }

      if (isMounted) {
        setLoading(false);
      }
    };

    hydrateFromStorage();

    return () => {
      isMounted = false;
    };
  }, [hasCookieSession, attemptCookieBootstrap]);

  useEffect(() => {
    if (typeof window === "undefined") {
      return undefined;
    }

    const handleTokenRefresh = (event) => {
      const nextToken =
        event?.detail?.token ?? localStorage.getItem("authToken") ?? sessionStorage.getItem("authToken");
      applyAxiosAuthHeader(nextToken);
      setAuthToken(nextToken || null);
      if (nextToken) {
        setHasCookieSession(true);
        setCookieSessionFlag(true);
      }
    };

    const handleStorage = (event) => {
      if (event.key === "authToken") {
        const fallback = sessionStorage.getItem("authToken");
        const nextToken = event.newValue || fallback || null;
        applyAxiosAuthHeader(nextToken);
        setAuthToken(nextToken);
        if (event.newValue || fallback) {
          setHasCookieSession(true);
          setCookieSessionFlag(true);
        } else {
          setHasCookieSession(false);
          setCookieSessionFlag(false);
        }
      }
      if (event.key === "userData") {
        if (!event.newValue) {
          setUser(null);
          return;
        }
        try {
          const parsed = JSON.parse(event.newValue);
          const normalized = normalizeUserPayload(parsed);
          setUser(normalized);
        } catch (err) {
          console.error("Failed to parse user data from storage event", err);
          setUser(null);
        }
      }
    };

    window.addEventListener(TOKEN_REFRESH_EVENT, handleTokenRefresh);
    window.addEventListener("storage", handleStorage);

    return () => {
      window.removeEventListener(TOKEN_REFRESH_EVENT, handleTokenRefresh);
      window.removeEventListener("storage", handleStorage);
    };
  }, []);

  useEffect(() => {
    if (typeof window === "undefined") {
      return undefined;
    }
    if (loading || (!authToken && !hasCookieSession)) {
      return undefined;
    }

    runSessionVerify();
    verifyTimerRef.current = window.setInterval(runSessionVerify, VERIFY_INTERVAL_MS);

    return () => {
      if (verifyTimerRef.current) {
        window.clearInterval(verifyTimerRef.current);
        verifyTimerRef.current = null;
      }
    };
  }, [authToken, hasCookieSession, loading, runSessionVerify]);

  useEffect(() => {
    if (typeof window === "undefined") {
      return undefined;
    }

    const handleFocus = () => {
      if (loading || (!authToken && !hasCookieSession)) {
        return;
      }
      const now = Date.now();
      if (now - lastManualVerifyRef.current < MIN_MANUAL_VERIFY_GAP_MS) {
        return;
      }
      lastManualVerifyRef.current = now;
      runSessionVerify();
    };

    const handleVisibility = () => {
      if (typeof document === "undefined") {
        return;
      }
      if (document.visibilityState === "visible") {
        handleFocus();
      }
    };

    window.addEventListener("focus", handleFocus);
    if (typeof document !== "undefined") {
      document.addEventListener("visibilitychange", handleVisibility);
    }

    return () => {
      window.removeEventListener("focus", handleFocus);
      if (typeof document !== "undefined") {
        document.removeEventListener("visibilitychange", handleVisibility);
      }
    };
  }, [authToken, hasCookieSession, loading, runSessionVerify]);

  const login = async (username, password) => {
    try {
      setLoginLoading(true);
      const { data } = await authAPI.login(username, password);

      const normalizedUser = normalizeUserPayload(data.user);

      applyAxiosAuthHeader(data.token);
      setAuthToken(data.token);
      setUser(normalizedUser);
      setHasCookieSession(true);
      setCookieSessionFlag(true);
      localStorage.setItem("authToken", data.token);
      localStorage.setItem("userData", JSON.stringify(normalizedUser));
      try {
        sessionStorage.setItem("authToken", data.token);
        sessionStorage.setItem("userData", JSON.stringify(normalizedUser));
      } catch (error) {
        console.warn("Failed to persist data to sessionStorage", error);
      }
      emitTokenRefresh(data.token);
      return { success: true, user: normalizedUser };
    } catch (error) {
      console.error("Login error:", error);
      const message =
        error?.response?.data?.message || error?.message || "Login failed";
      return { success: false, error: message };
    } finally {
      setLoginLoading(false);
    }
  };

  const updateUserData = (updater) => {
    setUser((prev) => {
      const nextValue =
        typeof updater === "function"
          ? updater(prev)
          : { ...(prev || {}), ...(updater || {}) };

      if (nextValue && typeof nextValue === "object") {
        const normalized = normalizeUserPayload(nextValue);
        if (normalized) {
          localStorage.setItem("userData", JSON.stringify(normalized));
          return normalized;
        }
      }

      localStorage.removeItem("userData");
      return null;
    });
  };

  const getAuthHeaders = () => {
    return authToken ? { Authorization: `Bearer ${authToken}` } : {};
  };

  const isAuthenticated = () => {
    return !!authToken && !!user;
  };

  const hasRole = (role) => {
    return normalizeRole(user?.role) === normalizeRole(role);
  };

  const hasPermission = (permission) => {
    if (!user) return false;

    const normalizedRole = normalizeRole(user.role);
    if (normalizedRole === "admin") {
      return true;
    }

    if (user.permissions && Array.isArray(user.permissions)) {
      return user.permissions.includes(permission);
    }

    const rolePermissions = {
      admin: [
        "*",
      ],
      librarian: [
        "users.view",
        "users.create",
        "users.update",
        "users.delete",
        "users.resetPassword",
        "students.view",
        "students.create",
        "students.update",
        "students.delete",
        "books.view",
        "books.create",
        "books.update",
        "books.delete",
        "transactions.view",
        "transactions.create",
        "transactions.update",
        "transactions.delete",
        "reports.view",
        "settings.view",
        "settings.update",
        "audit.view",
      ],
      staff: [
        "users.view",
        "users.update",
        "students.view",
        "books.view",
        "books.update",
        "transactions.view",
        "transactions.create",
        "transactions.update",
        "reports.view",
      ],
      student: ["books.view", "transactions.view"],
    };

    const userPermissions = rolePermissions[normalizedRole] || [];

    return (
      userPermissions.includes("*") || userPermissions.includes(permission)
    );
  };

  const value = {
    user,
    authToken,
    hasCookieSession,
    loading,
    loginLoading,
    login,
    logout,
    getAuthHeaders,
    isAuthenticated,
    hasRole,
    hasPermission,
    updateUserData,
  };

  return (
    <AuthContext.Provider value={value}> {children} </AuthContext.Provider>
  );
};
```

## SettingsContext.js

| Field | Details |
| --- | --- |
| Program Name | SettingsContext.js |
| Description | React context provider for shared state. |
| Called by | index.js, LibrarianDashboard.js, ReportsPage.js, ReturnForm.js, SettingsPage.js, Sidebar.js, SplashScreen.js, StudentDashboard.js, StudentsList.js, TransactionDetails.js, TransactionsList.js, UserProfile.js |
| Table used | settings |
|  |  |
| Programmer | Nazel Asca√±o |
| Date created | 12/14/2025 |
| Revision Date | TBD |
| Revision / description of change | None |

```javascript
import React, {
  createContext,
  useCallback,
  useContext,
  useEffect,
  useMemo,
  useState,
} from "react";
import { api } from "../utils/api";
import { resolveAssetUrl } from "../utils/media";
import { useAuth } from "./AuthContext";

export const SETTINGS_UPDATED_EVENT = "olms-settings-updated";
const SettingsContext = createContext(null);
const FALLBACK_TAGLINE = "The School of Choice";

const getBoolean = (value, fallback = true) => {
  if (value === undefined || value === null) {
    return fallback;
  }
  if (typeof value === "boolean") {
    return value;
  }
  if (typeof value === "string") {
    const normalized = value.trim().toLowerCase();
    if (["true", "1", "yes"].includes(normalized)) {
      return true;
    }
    if (["false", "0", "no"].includes(normalized)) {
      return false;
    }
  }
  return fallback;
};

export const SettingsProvider = ({ children }) => {
  const { user, loading: authLoading } = useAuth();
  const [borrowingRules, setBorrowingRules] = useState(null);
  const [borrowingRulesLoading, setBorrowingRulesLoading] = useState(false);
  const [borrowingRulesError, setBorrowingRulesError] = useState("");
  const [librarySettings, setLibrarySettings] = useState(null);
  const [librarySettingsLoading, setLibrarySettingsLoading] = useState(false);
  const [librarySettingsError, setLibrarySettingsError] = useState("");

  const loadBorrowingRules = useCallback(async () => {
    setBorrowingRulesLoading(true);
    setBorrowingRulesError("");
    try {
      const response = await api.get("/settings/borrowing-rules");
      setBorrowingRules(response.data || {});
    } catch (error) {
      console.error("Failed to load borrowing rules", error);
      setBorrowingRules(null);
      setBorrowingRulesError(
        error?.response?.data?.message || "Unable to load borrowing rules",
      );
    } finally {
      setBorrowingRulesLoading(false);
    }
  }, []);

  const loadLibrarySettings = useCallback(async () => {
    setLibrarySettingsLoading(true);
    setLibrarySettingsError("");
    try {
      const response = await api.get("/settings/library");
      setLibrarySettings(response.data || null);
    } catch (error) {
      console.error("Failed to load library settings", error);
      setLibrarySettings(null);
      setLibrarySettingsError(
        error?.response?.data?.message || "Unable to load library settings",
      );
    } finally {
      setLibrarySettingsLoading(false);
    }
  }, []);

  useEffect(() => {
    if (authLoading) {
      return;
    }
    if (!user) {
      setBorrowingRules(null);
      setBorrowingRulesError("");
      setBorrowingRulesLoading(false);
      return;
    }
    loadBorrowingRules();
  }, [authLoading, user, loadBorrowingRules]);

  useEffect(() => {
    loadLibrarySettings();
  }, [loadLibrarySettings]);

  useEffect(() => {
    if (typeof window === "undefined") {
      return undefined;
    }

    const handleSettingsUpdate = (event) => {
      const category = event?.detail?.category;
      if (!category || category === "borrowing" || category === "borrowing-rules" || category === "all") {
        loadBorrowingRules();
      }
      if (!category || category === "library" || category === "all") {
        loadLibrarySettings();
      }
    };

    window.addEventListener(SETTINGS_UPDATED_EVENT, handleSettingsUpdate);
    return () => {
      window.removeEventListener(SETTINGS_UPDATED_EVENT, handleSettingsUpdate);
    };
  }, [loadBorrowingRules, loadLibrarySettings]);

  const value = useMemo(() => {
    const finesEnabled = getBoolean(borrowingRules?.enableFines, true);
    const libraryTagline = (librarySettings?.loginMotto || "").trim() || FALLBACK_TAGLINE;
    const libraryLogoUrl = resolveAssetUrl(librarySettings?.loginLogoUrl || "");
    return {
      borrowingRules,
      borrowingRulesLoading,
      borrowingRulesError,
      refreshBorrowingRules: loadBorrowingRules,
      finesEnabled,
      librarySettings,
      librarySettingsLoading,
      librarySettingsError,
      refreshLibrarySettings: loadLibrarySettings,
      libraryTagline,
      libraryLogoUrl,
    };
  }, [
    borrowingRules,
    borrowingRulesLoading,
    borrowingRulesError,
    loadBorrowingRules,
    librarySettings,
    librarySettingsLoading,
    librarySettingsError,
    loadLibrarySettings,
  ]);

  return (
    <SettingsContext.Provider value={value}>
      {children}
    </SettingsContext.Provider>
  );
};

export const useSettings = () => {
  const context = useContext(SettingsContext);
  if (!context) {
    throw new Error("useSettings must be used within a SettingsProvider");
  }
  return context;
};
```

# Frontend - Core

## App.js

| Field | Details |
| --- | --- |
| Program Name | App.js |
| Description | Frontend application root component. |
| Called by | index.js |
| Table used | None |
|  |  |
| Programmer | Nazel Asca√±o |
| Date created | 12/14/2025 |
| Revision Date | TBD |
| Revision / description of change | None |

```javascript
import React, { useState, useEffect } from "react";
import { Routes, Route, Navigate } from "react-router-dom";
import { ThemeProvider, CssBaseline } from "@mui/material";
import customTheme from "./theme/customTheme";
import { useAuth } from "./contexts/AuthContext";
import Loading from "./components/Loading";
import SplashScreen from "./components/SplashScreen";

import Layout from "./components/Layout/Layout";
import ProtectedRoute from "./components/Auth/ProtectedRoute";

import LoginPage from "./pages/Auth/LoginPage";

import AdminDashboard from "./pages/Dashboard/AdminDashboard";
import LibrarianDashboard from "./pages/Dashboard/LibrarianDashboard";
import StaffDashboard from "./pages/Dashboard/StaffDashboard";
import StudentDashboard from "./pages/Dashboard/StudentDashboard";

import UsersList from "./pages/Users/UsersList";
import UserForm from "./pages/Users/UserForm";
import UserProfile from "./pages/Users/UserProfile";

import StudentsList from "./pages/Students/StudentsList";
import StudentForm from "./pages/Students/StudentForm";

import BooksList from "./pages/Books/BooksList";
import BookForm from "./pages/Books/BookForm";
import BookDetails from "./pages/Books/BookDetails";
import BookCopies from "./pages/Books/BookCopies";

import TransactionsList from "./pages/Transactions/TransactionsList";
import BorrowForm from "./pages/Transactions/BorrowForm";
import RequestsPage from "./pages/Transactions/RequestsPage";
import ReturnForm from "./pages/Transactions/ReturnForm";
import TransactionDetails from "./pages/Transactions/TransactionDetails";
import AnnualBorrowing from "./pages/Transactions/AnnualBorrowing";

import ReportsPage from "./pages/Reports/ReportsPage";
import AuditLogs from "./pages/Reports/AuditLogs";
import NotificationsPage from "./pages/Notifications/NotificationsPage";

import SettingsPage from "./pages/Settings/SettingsPage";

import NotFoundPage from "./pages/Error/NotFoundPage";
import UnauthorizedPage from "./pages/Error/UnauthorizedPage";

function App() {
  const { user, loading } = useAuth();

  const [showSplash, setShowSplash] = useState(true);

  useEffect(() => {
    const timer = setTimeout(() => setShowSplash(false), 5000);
    return () => clearTimeout(timer);
  }, []);

  if (loading) {
    return <Loading type="fullscreen" message="Loading application..." />;
  }

  if (showSplash) {
    return <SplashScreen />;
  }

  const getDashboardRoute = () => {
    if (!user) return "/login";

    switch (user.role) {
      case "admin":
        return "/admin/dashboard";
      case "librarian":
        return "/librarian/dashboard";
      case "staff":
        return "/staff/dashboard";
      case "student":
        return "/student/dashboard";
      default:
        return "/login";
    }
  };

  return (
    <ThemeProvider theme={customTheme}>
      <CssBaseline />
      <Routes>
        {" "}
        {}{" "}
        <Route
          path="/login"
          element={
            user ? <Navigate to={getDashboardRoute()} replace /> : <LoginPage />
          }
        />
        {}{" "}
        <Route
          path="/"
          element={
            <ProtectedRoute>
              <Layout />
            </ProtectedRoute>
          }
        >
          {}{" "}
          <Route
            index
            element={<Navigate to={getDashboardRoute()} replace />}
          />
          {}{" "}
          <Route
            path="admin/dashboard"
            element={
              <ProtectedRoute roles={["admin"]}>
                <AdminDashboard />
              </ProtectedRoute>
            }
          />
          {}{" "}
          <Route
            path="librarian/dashboard"
            element={
              <ProtectedRoute roles={["librarian"]}>
                <LibrarianDashboard />
              </ProtectedRoute>
            }
          />
          {}{" "}
          <Route
            path="staff/dashboard"
            element={
              <ProtectedRoute roles={["staff"]}>
                <StaffDashboard />
              </ProtectedRoute>
            }
          />
          {}{" "}
          <Route
            path="student/dashboard"
            element={
              <ProtectedRoute roles={["student"]}>
                <StudentDashboard />
              </ProtectedRoute>
            }
          />
          {}{" "}
          <Route
            path="users"
            element={
              <ProtectedRoute roles={["admin", "librarian", "staff"]}>
                <UsersList />
              </ProtectedRoute>
            }
          />{" "}
          <Route
            path="users/new"
            element={
              <ProtectedRoute roles={["admin", "librarian", "staff"]}>
                <UserForm />
              </ProtectedRoute>
            }
          />{" "}
          <Route
            path="users/:id/edit"
            element={
              <ProtectedRoute roles={["admin", "librarian", "staff"]}>
                <UserForm />
              </ProtectedRoute>
            }
          />{" "}
          <Route
            path="users/:id"
            element={
              <ProtectedRoute roles={["admin", "librarian", "staff"]}>
                <UserProfile />
              </ProtectedRoute>
            }
          />
          {}{" "}
          <Route
            path="students"
            element={
              <ProtectedRoute roles={["admin", "librarian", "staff"]}>
                <StudentsList />
              </ProtectedRoute>
            }
          />{" "}
          <Route
            path="students/new"
            element={
              <ProtectedRoute roles={["admin", "librarian", "staff"]}>
                <StudentForm />
              </ProtectedRoute>
            }
          />{" "}
          <Route
            path="students/:id"
            element={
              <ProtectedRoute roles={["admin", "librarian", "staff"]}>
                <UserProfile />
              </ProtectedRoute>
            }
          />{" "}
          <Route
            path="students/:id/edit"
            element={
              <ProtectedRoute roles={["admin", "librarian", "staff"]}>
                <StudentForm />
              </ProtectedRoute>
            }
          />
          {}{" "}
          <Route
            path="books"
            element={
                <ProtectedRoute roles={["librarian", "staff", "student"]}>
                <BooksList />
              </ProtectedRoute>
            }
          />{" "}
          <Route
            path="books/new"
            element={
              <ProtectedRoute roles={["librarian"]}>
                <BookForm />
              </ProtectedRoute>
            }
          />{" "}
          <Route
            path="books/:id/edit"
            element={
              <ProtectedRoute roles={["librarian"]}>
                <BookForm />
              </ProtectedRoute>
            }
          />{" "}
          <Route
            path="books/:id"
            element={
                <ProtectedRoute roles={["librarian", "staff", "student"]}>
                <BookDetails />
              </ProtectedRoute>
            }
          />{" "}
          <Route
            path="books/:id/copies"
            element={
              <ProtectedRoute roles={["librarian"]}>
                <BookCopies />
              </ProtectedRoute>
            }
          />
          {}{" "}
          <Route
            path="transactions"
            element={
              <ProtectedRoute roles={["admin", "librarian", "staff"]}>
                <TransactionsList />
              </ProtectedRoute>
            }
          />{" "}
          <Route
            path="transactions/borrow"
            element={
              <ProtectedRoute roles={["admin", "librarian", "staff"]}>
                <BorrowForm />
              </ProtectedRoute>
            }
          />{" "}
          <Route
            path="transactions/requests"
            element={
              <ProtectedRoute roles={["admin", "librarian", "staff"]}>
                <RequestsPage />
              </ProtectedRoute>
            }
          />{" "}
          <Route
            path="transactions/request"
            element={
              <ProtectedRoute roles={["student"]}>
                <BorrowForm />
              </ProtectedRoute>
            }
          />{" "}
          <Route
            path="transactions/return"
            element={
              <ProtectedRoute roles={["admin", "librarian", "staff"]}>
                <ReturnForm />
              </ProtectedRoute>
            }
          />{" "}
          <Route
            path="transactions/:id"
            element={
              <ProtectedRoute roles={["admin", "librarian", "staff"]}>
                <TransactionDetails />
              </ProtectedRoute>
            }
          />{" "}
          <Route
            path="annual-borrowing"
            element={
              <ProtectedRoute roles={["admin", "librarian"]}>
                <AnnualBorrowing />
              </ProtectedRoute>
            }
          />
          {}{" "}
          <Route
            path="reports"
            element={
              <ProtectedRoute roles={["librarian", "staff"]}>
                <ReportsPage />
              </ProtectedRoute>
            }
          />{" "}
          <Route
            path="audit-logs"
            element={
              <ProtectedRoute roles={["admin", "librarian"]}>
                <AuditLogs />
              </ProtectedRoute>
            }
          />
            <Route
              path="notifications"
              element={
                <ProtectedRoute roles={["admin", "librarian", "staff", "student"]}>
                  <NotificationsPage />
                </ProtectedRoute>
              }
            />{" "}
          {}{" "}
          <Route
            path="settings"
            element={
              <ProtectedRoute roles={["admin", "librarian"]}>
                <SettingsPage />
              </ProtectedRoute>
            }
          />
          {}{" "}
          <Route path="profile" element={<UserProfile />} />
          {}{" "}
          <Route path="unauthorized" element={<UnauthorizedPage />} />{" "}
          <Route path="*" element={<NotFoundPage />} />{" "}
        </Route>{" "}
      </Routes>{" "}
    </ThemeProvider>
  );
}

export default App;
```

## index.css

| Field | Details |
| --- | --- |
| Program Name | index.css |
| Description | Source file located at frontend/src/index.css. |
| Called by | None |
| Table used | None |
|  |  |
| Programmer | Nazel Asca√±o |
| Date created | 12/14/2025 |
| Revision Date | TBD |
| Revision / description of change | None |

```css
input:-webkit-autofill,
input:-webkit-autofill:focus,
input:-webkit-autofill:hover,
input:-webkit-autofill:active {
    -webkit-box-shadow: 0 0 0 1000px transparent inset !important;
    box-shadow: 0 0 0 1000px transparent inset !important;
    background-color: transparent !important;
    -webkit-text-fill-color: #333 !important;
    transition: background-color 5000s ease-in-out 0s;
}

input.MuiOutlinedInput-input,
input.MuiInputBase-input {
    background-color: transparent !important;
}
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: 'Roboto', -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    background-color: #f5f5f5;
}

code {
    font-family: source-code-pro, Menlo, Monaco, Consolas, 'Courier New', monospace;
}

.skip-link {
    position: absolute;
    top: -40px;
    left: 6px;
    background: #000;
    color: #fff;
    padding: 8px;
    text-decoration: none;
    z-index: 1000;
    border-radius: 0 0 4px 4px;
    font-weight: bold;
    transition: top 0.2s ease;
}

.skip-link:focus {
    top: 6px;
    outline: 2px solid #fff;
    outline-offset: 2px;
}

*:focus {
    outline: 2px solid #305FB7;
    outline-offset: 2px;
}

*:focus:not(:focus-visible) {
    outline: none;
}

*:focus-visible {
    outline: 2px solid #305FB7;
    outline-offset: 2px;
}

.fade-in {
    animation: fadeIn 0.3s ease-in-out;
}

@keyframes fadeIn {
    from {
        opacity: 0;
        transform: translateY(10px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

.slide-in {
    animation: slideIn 0.3s ease-in-out;
}

@keyframes slideIn {
    from {
        transform: translateX(-100%);
    }
    to {
        transform: translateX(0);
    }
}

@media print {
    .no-print {
        display: none !important;
    }
    .print-only {
        display: block !important;
    }
    body {
        background: white !important;
        color: black !important;
    }
    .MuiAppBar-root {
        display: none !important;
    }
}

.text-center {
    text-align: center;
}

.text-left {
    text-align: left;
}

.text-right {
    text-align: right;
}

.mb-1 {
    margin-bottom: 8px;
}

.mb-2 {
    margin-bottom: 16px;
}

.mb-3 {
    margin-bottom: 24px;
}

.mt-1 {
    margin-top: 8px;
}

.mt-2 {
    margin-top: 16px;
}

.mt-3 {
    margin-top: 24px;
}

.p-1 {
    padding: 8px;
}

.p-2 {
    padding: 16px;
}

.p-3 {
    padding: 24px;
}

.full-width {
    width: 100%;
}

.flex-center {
    display: flex;
    justify-content: center;
    align-items: center;
}

.flex-between {
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.stats-card {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    border-radius: 16px;
    padding: 24px;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
    transition: transform 0.3s ease, box-shadow 0.3s ease;
}

.stats-card:hover {
    transform: translateY(-4px);
    box-shadow: 0 12px 40px rgba(0, 0, 0, 0.15);
}

.btn-gradient {
    background: linear-gradient(45deg, #FE6B8B 30%, #FF8E53 90%);
    border: 0;
    border-radius: 3px;
    box-shadow: 0 3px 5px 2px rgba(255, 105, 135, .3);
    color: white;
    height: 48px;
    padding: 0 30px;
    font-weight: 600;
    font-size: 0.95rem;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    transition: box-shadow 0.15s ease, transform 0.12s ease;
}
.btn-gradient:hover{
    box-shadow: 0 10px 26px rgba(0,0,0,0.18);
    transform: translateY(-2px);
}
.btn-gradient:focus-visible{outline:2px solid #305FB7;outline-offset:2px}

.btn{
    padding: 6px 12px;
    min-height: 32px;
    border-radius: 8px;
    font-size: 0.75rem;
    font-weight: 500;
    display:inline-flex;
    align-items:center;
    justify-content:center;
}
.btn-primary{background:#305FB7;color:#fff;}
.btn-outline{background:transparent;border:1.5px solid #E2E8F0;color:#374151;}
.btn:focus-visible{outline:2px solid #305FB7;outline-offset:2px}

.receipt {
    background: white;
    padding: 20px;
    border: 1px solid #ddd;
    font-family: 'Courier New', monospace;
    max-width: 400px;
    margin: 0 auto;
}

.receipt-header {
    text-align: center;
    border-bottom: 2px solid #000;
    padding-bottom: 10px;
    margin-bottom: 15px;
}

.receipt-section {
    margin: 10px 0;
    padding: 5px 0;
}

.receipt-footer {
    border-top: 1px solid #000;
    padding-top: 10px;
    margin-top: 15px;
    text-align: center;
    font-size: 12px;
}

:root {
    --safe-area-inset-bottom: env(safe-area-inset-bottom);
}

html,
body,
#root {
    min-height: 100%;
    width: 100%;
}

body {
    overflow-x: hidden;
}

img {
    max-width: 100%;
    height: auto;
}

@media (max-width: 1024px) {
    .MuiGrid-container {
        margin-left: 0 !important;
        margin-right: 0 !important;
        width: 100% !important;
    }
    .MuiGrid-item {
        padding-left: 0 !important;
        padding-right: 0 !important;
    }
}

@media (max-width: 768px) {
    .MuiToolbar-root {
        padding-left: 16px !important;
        padding-right: 16px !important;
    }
    .MuiCard-root,
    .MuiPaper-root {
        border-radius: 12px;
    }
    .btn,
    .btn-gradient {
        width: 100%;
    }
}

@media (max-width: 600px) {
    .MuiTableContainer-root {
        max-width: 100vw;
        overflow-x: auto;
        -webkit-overflow-scrolling: touch;
    }
    .MuiTable-root {
        min-width: 640px;
    }
    .stats-card {
        padding: 16px;
    }
}
```

## index.js

| Field | Details |
| --- | --- |
| Program Name | index.js |
| Description | Frontend application bootstrap and render entry. |
| Called by | None |
| Table used | None |
|  |  |
| Programmer | Nazel Asca√±o |
| Date created | 12/14/2025 |
| Revision Date | TBD |
| Revision / description of change | None |

```javascript
import React from "react";
import ReactDOM from "react-dom/client";
import { BrowserRouter } from "react-router-dom";
import { QueryClient, QueryClientProvider } from "react-query";
import { ThemeProvider, createTheme } from "@mui/material/styles";
import CssBaseline from "@mui/material/CssBaseline";
import { Toaster } from "react-hot-toast";
import App from "./App";
import { AuthProvider } from "./contexts/AuthContext";
import { SettingsProvider } from "./contexts/SettingsContext";
import "./index.css";

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      retry: 1,
      refetchOnWindowFocus: false,
    },
  },
});

const theme = createTheme({
  palette: {
    primary: {
      main: "#1976d2",
    },
    secondary: {
      main: "#dc004e",
    },
  },
  typography: {
    fontFamily: "Roboto, Arial, sans-serif",
  },
});

const root = ReactDOM.createRoot(document.getElementById("root"));
root.render(
  <React.StrictMode>
    <BrowserRouter>
      <QueryClientProvider client={queryClient}>
        <ThemeProvider theme={theme}>
          <CssBaseline />
          <AuthProvider>
            <SettingsProvider>
              <App />
              <Toaster
                position="top-right"
                toastOptions={{
                  duration: 4000,
                  style: {
                    background: "#363636",
                    color: "#fff",
                  },
                }}
              />{" "}
            </SettingsProvider>
          </AuthProvider>{" "}
        </ThemeProvider>{" "}
      </QueryClientProvider>{" "}
    </BrowserRouter>{" "}
  </React.StrictMode>,
);
```

# Frontend - Data

## addressOptions.js

| Field | Details |
| --- | --- |
| Program Name | addressOptions.js |
| Description | Frontend static data configuration. |
| Called by | None |
| Table used | None |
|  |  |
| Programmer | Nazel Asca√±o |
| Date created | 12/14/2025 |
| Revision Date | TBD |
| Revision / description of change | None |

```javascript
const CUSTOM_FALLBACK = "Other / Not Listed";

const NCR_MUNICIPALITIES = [
  {
    name: "Quezon City",
    barangays: [
      "Alicia",
      "Bagong Pag-asa",
      "Bagumbayan",
      "Batasan Hills",
      "Bayanihan",
      "Commonwealth",
      "Fairview",
      "Novaliches",
      "Project 4",
      "Project 6",
      "San Bartolome",
      "Santol",
      "Sauyo",
      "Santo Domingo",
      "Teachers Village",
      "UP Campus",
      CUSTOM_FALLBACK,
    ],
  },
  {
    name: "Manila",
    barangays: [
      "Barangay 1",
      "Barangay 2",
      "Ermita",
      "Malate",
      "Paco",
      "Pandacan",
      "Port Area",
      "Quiapo",
      "Sampaloc",
      "San Andres",
      "San Miguel",
      "Santa Ana",
      "Santa Cruz",
      "Tondo",
      CUSTOM_FALLBACK,
    ],
  },
  {
    name: "Marikina City",
    barangays: [
      "Barangka",
      "Concepcion Uno",
      "Concepcion Dos",
      "Fortune",
      "Industrial Valley",
      "Malanday",
      "Marikina Heights",
      "Nangka",
      "Parang",
      "Tumana",
      CUSTOM_FALLBACK,
    ],
  },
];

const ROMBLON_MUNICIPALITIES = [
  {
    name: "Odiongan",
    barangays: [
      "Anahao",
      "Anilao",
      "Amatong",
      "Batiano",
      "Cagbo-aya",
      "Canduyong",
      "Dao",
      "Dapawan",
      "Gabawan",
      "Ligaya",
      "Libertad",
      "Liwanag",
      "Mabini",
      "Malilico",
      "Pajo",
      "Panique",
      "Patoo",
      "Poctoy",
      "Rizal",
      "Tabin-dagat",
      "Talcogon",
      "Tuguis",
      "Tulay",
      "Tumingad",
      "Victoria",
      CUSTOM_FALLBACK,
    ],
  },
  {
    name: "Calatrava",
    barangays: [
      "Balogo",
      "Balalit",
      "Lenasing",
      "Linao",
      "Palian",
      "Punta",
      "San Roque",
      "Talisay",
      CUSTOM_FALLBACK,
    ],
  },
];

export const ADDRESS_HIERARCHY = [
  {
    province: "Romblon",
    municipalities: ROMBLON_MUNICIPALITIES,
  },
  {
    province: "Metro Manila",
    municipalities: NCR_MUNICIPALITIES,
  },
  {
    province: "Philippines",
    municipalities: NCR_MUNICIPALITIES,
  },
];

const normalize = (value = "") => value.toLowerCase().replace(/\s+/g, " ").trim();
const findProvinceEntry = (province) =>
  ADDRESS_HIERARCHY.find(
    (entry) => normalize(entry.province) === normalize(province),
  );

const findMunicipalityEntry = (province, municipality) => {
  const provinceEntry = findProvinceEntry(province);
  return provinceEntry?.municipalities?.find(
    (item) => normalize(item.name) === normalize(municipality),
  );
};

export const getProvinceOptions = () =>
  ADDRESS_HIERARCHY.map((entry) => entry.province);

export const getMunicipalityOptions = (province) => {
  const provinceEntry = findProvinceEntry(province);
  return provinceEntry?.municipalities?.map((item) => item.name) || [];
};

export const getBarangayOptions = (province, municipality) => {
  const municipalityEntry = findMunicipalityEntry(province, municipality);
  return municipalityEntry?.barangays || [];
};

const buildPatternVariants = (segments) => {
  const cleaned = segments
    .filter(Boolean)
    .map((segment) => segment.trim())
    .filter(Boolean);

  if (cleaned.length === 0) {
    return [];
  }

  const base = cleaned.join(", ");
  const noComma = cleaned.join(" ");

  return [base, noComma, cleaned.join(","), cleaned.join(" , "), cleaned.join(" ,")];
};

const stripAddressTail = (value, segments) => {
  if (!value) {
    return "";
  }

  const lowerValue = value.toLowerCase();
  const variants = buildPatternVariants(segments);

  for (const variant of variants) {
    const trimmedVariant = variant.trim();
    if (!trimmedVariant) {
      continue;
    }

    const idx = lowerValue.lastIndexOf(trimmedVariant.toLowerCase());
    if (idx !== -1) {
      return value.slice(0, idx).replace(/[\s,]+$/g, "").trim();
    }
  }

  return value.trim();
};

export const composeFullAddress = ({
  street = "",
  barangay = "",
  municipality = "",
  province = "",
} = {}) => {
  const segments = [street, barangay, municipality, province]
    .map((segment) => segment?.trim())
    .filter(Boolean);
  return segments.join(", ");
};

export const resolveAddressComponents = (rawAddress = "") => {
  const normalizedAddress = normalize(rawAddress);

  for (const provinceEntry of ADDRESS_HIERARCHY) {
    const provinceLabel = provinceEntry.province;
    const provinceMatch = normalize(provinceLabel);
    if (provinceMatch && !normalizedAddress.includes(provinceMatch)) {
      continue;
    }

    for (const municipality of provinceEntry.municipalities) {
      const municipalityMatch = normalize(municipality.name);
      if (
        municipalityMatch &&
        !normalizedAddress.includes(municipalityMatch)
      ) {
        continue;
      }

      for (const barangay of municipality.barangays) {
        if (barangay === CUSTOM_FALLBACK) {
          continue;
        }
        const barangayMatch = normalize(barangay);
        if (barangayMatch && !normalizedAddress.includes(barangayMatch)) {
          continue;
        }

        const street = stripAddressTail(rawAddress, [
          barangay,
          municipality.name,
          provinceLabel,
        ]);

        return {
          province: provinceLabel,
          municipality: municipality.name,
          barangay,
          street,
        };
      }
    }
  }

  return {
    province: "",
    municipality: "",
    barangay: "",
    street: rawAddress.trim(),
  };
};

export const ensureAddressValue = (value) => value || "";
export const ADDRESS_FALLBACK_LABEL = CUSTOM_FALLBACK;
export const addressHasOptions = (province) =>
  Boolean(getMunicipalityOptions(province).length);
export const municipalityHasOptions = (province, municipality) =>
  Boolean(getBarangayOptions(province, municipality).length);

export const getAllBarangays = () => {
  const barangays = [];
  ADDRESS_HIERARCHY.forEach((provinceEntry) => {
    provinceEntry.municipalities.forEach((municipality) => {
      municipality.barangays.forEach((barangay) => {
        if (barangay !== CUSTOM_FALLBACK) {
          barangays.push(barangay);
        }
      });
    });
  });
  return Array.from(new Set(barangays));
};
```

# Frontend - Other

## craco.config.js

| Field | Details |
| --- | --- |
| Program Name | craco.config.js |
| Description | Source file located at frontend/craco.config.js. |
| Called by | None |
| Table used | None |
|  |  |
| Programmer | Nazel Asca√±o |
| Date created | 12/14/2025 |
| Revision Date | TBD |
| Revision / description of change | None |

```javascript
const devServerHost = process.env.HOST || '0.0.0.0';

module.exports = {
  devServer: {
    host: devServerHost,
    allowedHosts: 'all',
  },
  webpack: {
    configure: (webpackConfig) => {

      webpackConfig.ignoreWarnings = webpackConfig.ignoreWarnings || [];
      webpackConfig.ignoreWarnings.push(/Failed to parse source map/);
      return webpackConfig;
    },
  },
};
```

## orig_StudentImportDialog.js

| Field | Details |
| --- | --- |
| Program Name | orig_StudentImportDialog.js |
| Description | Source file located at frontend/orig_StudentImportDialog.js. |
| Called by | None |
| Table used | None |
|  |  |
| Programmer | Nazel Asca√±o |
| Date created | 12/14/2025 |
| Revision Date | TBD |
| Revision / description of change | None |

## package.json

| Field | Details |
| --- | --- |
| Program Name | package.json |
| Description | Project configuration or data file. |
| Called by | None |
| Table used | None |
|  |  |
| Programmer | Nazel Asca√±o |
| Date created | 12/14/2025 |
| Revision Date | TBD |
| Revision / description of change | None |

```json
{
    "name": "olms-frontend",
    "version": "1.0.0",
    "description": "OLMS Frontend React Application",
    "private": true,
    "dependencies": {
        "@emotion/react": "^11.11.1",
        "@emotion/styled": "^11.11.0",
        "@mui/icons-material": "^5.14.3",
        "@mui/material": "^5.14.5",
        "@mui/x-data-grid": "^6.10.2",
        "@mui/x-date-pickers": "^6.10.2",
        "@testing-library/jest-dom": "^5.17.0",
        "@testing-library/react": "^13.4.0",
        "@testing-library/user-event": "^14.5.2",
        "axios": "^1.5.0",
        "date-fns": "^2.30.0",
        "dayjs": "^1.11.9",
        "file-saver": "^2.0.5",
        "html2canvas": "^1.4.1",
        "html5-qrcode": "^2.3.8",
        "jspdf": "^3.0.3",
        "mongoose": "^8.19.0",
        "papaparse": "^5.4.1",
        "qrcode": "^1.5.4",
        "qrcode.react": "^3.1.0",
        "react": "^18.2.0",
        "react-barcode": "^1.4.6",
        "react-dom": "^18.2.0",
        "react-easy-crop": "^5.0.8",
        "react-hook-form": "^7.45.4",
        "react-hot-toast": "^2.6.0",
        "react-query": "^3.39.3",
        "react-router-dom": "^6.15.0",
        "react-scripts": "5.0.1",
        "recharts": "^2.15.4"
    },
    "scripts": {
        "start": "set \"HOST=0.0.0.0\" && set \"PORT=3001\" && craco start",
        "build": "set GENERATE_SOURCEMAP=false && craco build",
        "test": "craco test",
        "eject": "react-scripts eject",
        "dev": "set \"HOST=0.0.0.0\" && set \"PORT=3001\" && craco start"
    },
    "eslintConfig": {
        "extends": [
            "react-app",
            "react-app/jest"
        ]
    },
    "browserslist": {
        "production": [
            ">0.2%",
            "not dead",
            "not op_mini all"
        ],
        "development": [
            "last 1 chrome version",
            "last 1 firefox version",
            "last 1 safari version"
        ]
    },
    "overrides": {
        "@svgr/core": "6.5.1",
        "@svgr/plugin-jsx": "6.5.1",
        "@svgr/plugin-svgo": "6.5.1",
        "@svgr/webpack": "6.5.1",
        "css-select": "^4.3.0",
        "nth-check": "^2.1.1",
        "postcss": "^8.5.6",
        "resolve-url-loader": "^5.0.0",
        "svgo": "^2.8.0",
        "webpack-dev-server": "4.15.2"
    },
    "devDependencies": {
        "@craco/craco": "^7.1.0",
        "@types/file-saver": "^2.0.5",
        "@types/papaparse": "^5.3.8",
        "axe-core": "^4.11.0",
        "baseline-browser-mapping": "^2.9.4",
        "jest-axe": "^10.0.0",
        "prettier": "^3.6.2"
    }
}
```

# Frontend - Pages

## AdminDashboard.js

| Field | Details |
| --- | --- |
| Program Name | AdminDashboard.js |
| Description | Frontend page view for routing and page-level UI. |
| Called by | App.js |
| Table used | None |
|  |  |
| Programmer | Nazel Asca√±o |
| Date created | 12/14/2025 |
| Revision Date | TBD |
| Revision / description of change | None |

```javascript
import React, { useState, useEffect, useMemo } from "react";
import {
  Box,
  Grid,
  Card,
  CardActionArea,
  CardContent,
  Typography,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
} from "@mui/material";
import { useTheme } from "@mui/material/styles";
import { useNavigate } from "react-router-dom";
import { reportsAPI, auditAPI } from "../../utils/api";
import { useAuth } from "../../contexts/AuthContext";
import {
  LineChart,
  Line,
  XAxis,
  YAxis,
  CartesianGrid,
  ResponsiveContainer,
} from "recharts";
import { PageLoading } from "../../components/Loading";

const normalizeApiList = (payload) => {
  const data = payload?.data ?? payload;
  if (Array.isArray(data?.logs)) return data.logs;
  if (Array.isArray(data?.data)) return data.data;
  if (Array.isArray(data?.items)) return data.items;
  if (Array.isArray(data)) return data;
  return [];
};

const buildVisitorLoginSeries = (logs = [], days = 14) => {
  const counts = logs.reduce((acc, log) => {
    const timestamp = log?.timestamp || log?.createdAt;
    if (!timestamp) {
      return acc;
    }
    const parsed = new Date(timestamp);
    if (Number.isNaN(parsed.getTime())) {
      return acc;
    }
    const key = parsed.toISOString().split("T")[0];
    acc[key] = (acc[key] || 0) + 1;
    return acc;
  }, {});

  const today = new Date();
  const series = [];
  for (let i = days - 1; i >= 0; i -= 1) {
    const target = new Date(today);
    target.setDate(today.getDate() - i);
    const isoKey = target.toISOString().split("T")[0];
    series.push({
      name: target.toLocaleDateString("en-US", { month: "short", day: "numeric" }),
      logins: counts[isoKey] || 0,
    });
  }
  return series;
};

const formatTimestamp = (value) => {
  if (!value) {
    return "N/A";
  }
  const date = new Date(value);
  if (Number.isNaN(date.getTime())) {
    return "N/A";
  }
  return date.toLocaleString();
};

const shouldHideAuditAction = (action) => {
  if (!action) {
    return false;
  }
  const normalized = String(action).trim().toUpperCase();
  return normalized === "LOGIN" || normalized === "LOGOUT";
};

const getCurrentSchoolYearLabel = () => {
  const currentDate = new Date();
  const currentMonth = currentDate.getMonth();
  const baseYear = currentMonth >= 5 ? currentDate.getFullYear() : currentDate.getFullYear() - 1;
  const nextYear = baseYear + 1;
  return `${baseYear}-${nextYear}`;
};

const AdminDashboard = () => {
  const theme = useTheme();
  const navigate = useNavigate();
  const { isAuthenticated, loading: authLoading, user, authToken } = useAuth();
  const [stats, setStats] = useState(null);
  const [loginChartData, setLoginChartData] = useState([]);
  const [recentAuditLogs, setRecentAuditLogs] = useState([]);
  const [auditInfoMessage, setAuditInfoMessage] = useState("");
  const [loading, setLoading] = useState(true);

  const sessionReady = useMemo(() => {
    if (authLoading) {
      return false;
    }
    if (typeof isAuthenticated === "function") {
      return isAuthenticated();
    }
    return Boolean(authToken && user);
  }, [authLoading, isAuthenticated, authToken, user]);

  useEffect(() => {
    if (!sessionReady) {
      if (!authLoading) {
        setStats(null);
        setLoginChartData([]);
        setRecentAuditLogs([]);
        setAuditInfoMessage("");
        setLoading(false);
      }
      return;
    }

    const fetchWithFallback = async (loader, fallback) => {
      try {
        const response = await loader();
        return response?.data ?? fallback;
      } catch (error) {
        console.error("Dashboard data fetch failed:", error);
        return fallback;
      }
    };

    const loadDashboardData = async () => {
      try {
        setLoading(true);
        const [statsData, loginLogsData, auditLogsData] = await Promise.all([
          fetchWithFallback(() => reportsAPI.getStats(), null),
          fetchWithFallback(() => auditAPI.getLogs({ action: "LOGIN", limit: 200 }), []),
          fetchWithFallback(() => auditAPI.getRecentActivity({ limit: 100 }), []),
        ]);

        setStats(statsData);

        const loginSeries = buildVisitorLoginSeries(normalizeApiList(loginLogsData));
        setLoginChartData(loginSeries);

        const auditRaw = normalizeApiList(auditLogsData);
        const filteredAudits = auditRaw.filter((log) => !shouldHideAuditAction(log?.action));
        if (filteredAudits.length === 0) {
          setAuditInfoMessage(
            auditRaw.length > 0
              ? "No audit entries beyond login/logout for this period."
              : "No audit activity recorded yet."
          );
        } else {
          setAuditInfoMessage("");
        }
        setRecentAuditLogs(filteredAudits.slice(0, 6));
      } catch (error) {
        console.error("Error loading dashboard data:", error);
      } finally {
        setLoading(false);
      }
    };

    loadDashboardData();
  }, [sessionReady, authLoading]);

  const StatCard = ({ title, value, onClick }) => {
    const isInteractive = typeof onClick === "function";
    const content = (
      <CardContent
        sx={{
          p: 1.5,
          height: "100%",
          display: "flex",
          flexDirection: { xs: "column", sm: "row" },
          justifyContent: { xs: "flex-start", sm: "space-between" },
          alignItems: { xs: "flex-start", sm: "center" },
          gap: 0.75,
        }}
      >
        <Typography
          variant="body2"
          sx={{
            color: "#6B7280",
            fontSize: "0.75rem",
            mb: 0.25,
            fontWeight: 500,
          }}
        >
          {title}
        </Typography>
        <Typography
          variant="h2"
          sx={{
            fontWeight: 700,
            color: "#111827",
            fontSize: { xs: "1.5rem", sm: "1.8rem" },
            lineHeight: 1,
          }}
        >
          {value ?? 0}
        </Typography>
      </CardContent>
    );

    return (
      <Card
        sx={{
          backgroundColor: "#FFFFFF",
          border: "none",
          borderRadius: "6px",
          boxShadow: "0 1px 4px rgba(0, 0, 0, 0.08)",
          height: { xs: "auto", sm: "70px" },
          cursor: isInteractive ? "pointer" : "default",
          "&:hover": {
            boxShadow: "0 2px 8px rgba(0, 0, 0, 0.12)",
            transition: "all 0.2s ease",
          },
        }}
      >
        {isInteractive ? (
          <CardActionArea onClick={onClick} sx={{ height: "100%" }} aria-label={`View ${title}`}>
            {content}
          </CardActionArea>
        ) : (
          content
        )}
      </Card>
    );
  };

  const handleCardNavigate = (path, filters = {}) => {
    if (!path) {
      return;
    }

    const params = new URLSearchParams();
    Object.entries(filters).forEach(([key, value]) => {
      if (value !== undefined && value !== null && value !== "" && value !== "all") {
        params.set(key, value);
      }
    });

    const query = params.toString();
    navigate(query ? `${path}?${query}` : path);
  };

  const totalStudentCount =
    stats?.totalStudents ?? stats?.studentCount ?? stats?.newStudents ?? 0;
  const visitorCount = stats?.visitors ?? stats?.activeUsers ?? 0;
  const newStudentsCount = stats?.newStudents ?? stats?.studentsThisYear ?? 0;
  const schoolYearLabel = stats?.currentSchoolYear ?? getCurrentSchoolYearLabel();

  useEffect(() => {
    if (!sessionReady) {
      return undefined;
    }

    let active = true;
    const refreshVisitorCount = async () => {
      try {
        const response = await reportsAPI.getStats();
        const refreshedStats = response?.data;
        if (!active || !refreshedStats) {
          return;
        }
        setStats((previous) => ({ ...(previous || {}), ...refreshedStats }));
      } catch (error) {
        console.error("Visitor count refresh failed:", error);
      }
    };

    refreshVisitorCount();
    const intervalId = window.setInterval(refreshVisitorCount, 60_000);

    return () => {
      active = false;
      window.clearInterval(intervalId);
    };
  }, [sessionReady]);

  const renderAuditRows = () => {
    if (recentAuditLogs.length === 0) {
      return (
        <TableRow key="audit-empty">
          <TableCell
            colSpan={4}
            sx={{
              py: 3,
              border: "none",
              textAlign: "center",
              color: "#9CA3AF",
              fontSize: "0.875rem",
            }}
          >
            {auditInfoMessage || "No audit activity found"}
          </TableCell>
        </TableRow>
      );
    }

    return recentAuditLogs.map((log, index) => (
      <TableRow key={log.id || log._id || index}>
        <TableCell
          scope="row"
          headers="audit-timestamp-header"
          sx={{ py: 1, border: "none", color: "#6B7280", fontSize: "0.75rem" }}
        >
          {formatTimestamp(log.timestamp || log.createdAt)}
        </TableCell>
        <TableCell
          headers="audit-user-header"
          sx={{ py: 1, border: "none", color: "#111827", fontSize: "0.75rem", fontWeight: 500 }}
        >
          <Typography sx={{ fontSize: "0.75rem", fontWeight: 600, color: "#111827" }}>
            {log.userName || log.userEmail || "Unknown user"}
          </Typography>
          {(log.userRole || log.userEmail) && (
            <Typography sx={{ fontSize: "0.7rem", color: "#6B7280" }}>
              {log.userRole || log.userEmail}
            </Typography>
          )}
        </TableCell>
        <TableCell
          headers="audit-action-header"
          sx={{ py: 1, border: "none", color: "#6B7280", fontSize: "0.75rem" }}
        >
          {log.action || "N/A"}
        </TableCell>
        <TableCell
          headers="audit-details-header"
          sx={{ py: 1, border: "none", color: "#6B7280", fontSize: "0.75rem" }}
        >
          {log.description || log.entity || log.resource || "No details"}
        </TableCell>
      </TableRow>
    ));
  };

  if (loading || authLoading) {
    return <PageLoading message="Loading dashboard data..." />;
  }

  if (!sessionReady) {
    return (
      <Box sx={{ p: { xs: 1.5, md: 2 } }}>
        <Typography variant="h1" sx={{ mb: 2, fontSize: "1.5rem", fontWeight: 600, color: "white" }}>
          Admin Dashboard
        </Typography>
        <Card>
          <CardContent>
            <Typography variant="body1">Please sign in to view dashboard reports.</Typography>
          </CardContent>
        </Card>
      </Box>
    );
  }

  return (
    <Box sx={{ p: { xs: 1.5, md: 2 } }}>
      <Typography variant="h1" sx={{ mb: 3, fontSize: "1.5rem", fontWeight: 600, color: "white" }}>
        Admin Dashboard
      </Typography>

      <Grid container spacing={2} mb={3}>
        <Grid item xs={12} sm={6} md={6}>
          <StatCard
            title="Total Users"
            value={stats?.totalUsers}
            onClick={() => handleCardNavigate("/users")}
          />
        </Grid>
        <Grid item xs={12} sm={6} md={6}>
          <StatCard
            title="Total Students"
            value={totalStudentCount}
            onClick={() => handleCardNavigate("/students")}
          />
        </Grid>
        <Grid item xs={12} sm={6} md={6}>
          <StatCard
            title="Visitors"
            value={visitorCount}
            onClick={() => handleCardNavigate("/audit-logs", { action: "LOGIN" })}
          />
        </Grid>
        <Grid item xs={12} sm={6} md={6}>
          <StatCard
            title={`New Students (S.Y. ${schoolYearLabel})`}
            value={newStudentsCount}
            onClick={() => handleCardNavigate("/users", { role: "student" })}
          />
        </Grid>
      </Grid>

      <Grid container spacing={2}>
        <Grid item xs={12} lg={6}>
          <Card
            sx={{
              backgroundColor: "#FFFFFF",
              borderRadius: "6px",
              boxShadow: "0 1px 4px rgba(0, 0, 0, 0.08)",
            }}
          >
            <CardContent sx={{ p: 2 }}>
              <Typography
                variant="h2"
                sx={{
                  mb: 1.5,
                  fontWeight: 600,
                  color: "#111827",
                  fontSize: "0.875rem",
                }}
              >
                Visitor login trend
              </Typography>
              <Box sx={{ display: "flex", alignItems: "center", gap: 1, mb: 1.5 }}>
                <Box
                  sx={{
                    width: 6,
                    height: 6,
                    borderRadius: "50%",
                    backgroundColor: (theme) => theme.palette.primary.main,
                  }}
                />
                <Typography variant="body2" sx={{ color: "#6B7280", fontSize: "0.75rem" }}>
                  Visitor logins
                </Typography>
              </Box>
              <Box sx={{ height: { xs: 220, md: 180 } }}>
                <ResponsiveContainer width="100%" height="100%">
                  <LineChart data={loginChartData}>
                    <CartesianGrid strokeDasharray="3 3" stroke="#E5E7EB" />
                    <XAxis
                      dataKey="name"
                      axisLine={false}
                      tickLine={false}
                      tick={{ fontSize: 10, fill: "#6B7280" }}
                    />
                    <YAxis
                      axisLine={false}
                      tickLine={false}
                      tick={{ fontSize: 10, fill: "#6B7280" }}
                    />
                    <Line type="monotone" dataKey="logins" stroke={theme.palette.primary.main} strokeWidth={2} dot={false} />
                  </LineChart>
                </ResponsiveContainer>
              </Box>
            </CardContent>
          </Card>
        </Grid>

        <Grid item xs={12} lg={6}>
          <Card
            sx={{
              backgroundColor: "#FFFFFF",
              borderRadius: "6px",
              boxShadow: "0 1px 4px rgba(0, 0, 0, 0.08)",
            }}
          >
            <CardContent sx={{ p: 2 }}>
              <Typography
                variant="h2"
                sx={{
                  mb: 1.5,
                  fontWeight: 600,
                  color: "#111827",
                  fontSize: "0.875rem",
                }}
              >
                Most recent audit logs
              </Typography>
              {auditInfoMessage && (
                <Typography sx={{ mb: 1.5, fontSize: "0.75rem", color: "#6B7280" }}>
                  {auditInfoMessage}
                </Typography>
              )}
              <TableContainer sx={{ maxHeight: 220 }}>
                <Table size="small" aria-label="Recent audit logs table">
                  <TableHead>
                    <TableRow>
                      <TableCell
                        scope="col"
                        id="audit-timestamp-header"
                        sx={{ fontWeight: 600, color: "#6B7280", fontSize: "0.75rem", py: 0.75, border: "none" }}
                      >
                        Timestamp
                      </TableCell>
                      <TableCell
                        scope="col"
                        id="audit-user-header"
                        sx={{ fontWeight: 600, color: "#6B7280", fontSize: "0.75rem", py: 0.75, border: "none" }}
                      >
                        User
                      </TableCell>
                      <TableCell
                        scope="col"
                        id="audit-action-header"
                        sx={{ fontWeight: 600, color: "#6B7280", fontSize: "0.75rem", py: 0.75, border: "none" }}
                      >
                        Action
                      </TableCell>
                      <TableCell
                        scope="col"
                        id="audit-details-header"
                        sx={{ fontWeight: 600, color: "#6B7280", fontSize: "0.75rem", py: 0.75, border: "none" }}
                      >
                        Details
                      </TableCell>
                    </TableRow>
                  </TableHead>
                  <TableBody>{renderAuditRows()}</TableBody>
                </Table>
              </TableContainer>
            </CardContent>
          </Card>
        </Grid>
      </Grid>
    </Box>
  );
};

export default AdminDashboard;
```

## AnnualBorrowing.js

| Field | Details |
| --- | --- |
| Program Name | AnnualBorrowing.js |
| Description | Frontend page view for routing and page-level UI. |
| Called by | App.js |
| Table used | transactions |
|  |  |
| Programmer | Nazel Asca√±o |
| Date created | 12/14/2025 |
| Revision Date | TBD |
| Revision / description of change | None |

```javascript
import React, { useCallback, useEffect, useMemo, useRef, useState } from "react";
import { useNavigate } from "react-router-dom";
import {
  Box,
  Button,
  Card,
  CardActions,
  CardContent,
  CardHeader,
  Chip,
  CircularProgress,
  Dialog,
  DialogActions,
  DialogContent,
  DialogTitle,
  Divider,
  Grid,
  IconButton,
  InputAdornment,
  MenuItem,
  Stack,
  TextField,
  Tooltip,
  Typography,
  Menu,
} from "@mui/material";
import Alert from "@mui/material/Alert";
import Autocomplete, { createFilterOptions } from "@mui/material/Autocomplete";
import {
  Add as AddIcon,
  AddCircleOutline as AddCircleOutlineIcon,
  ArrowBack as ArrowBackIcon,
  DeleteOutline as DeleteOutlineIcon,
  Search as SearchIcon,
  Visibility as VisibilityIcon,
} from "@mui/icons-material";
import LibraryBooksIcon from "@mui/icons-material/LibraryBooks";
import { FilterList } from "@mui/icons-material";
import toast from "react-hot-toast";
import { annualSetsAPI, booksAPI } from "../../utils/api";

const defaultFilters = {
  academicYear: "",
  gradeLevel: "",
  section: "",
  curriculum: "",
};

const emptySetForm = {
  name: "",
  academicYear: "",
  gradeLevel: "",
  section: "",
  curriculum: "",
  description: "",
  books: [],
};

const buildStudentSearchValue = (student = {}) =>
  [
    student.name,
    student.grade,
    student.section,
    student.curriculum,
    student.libraryCardNumber,
    student.studentNumber,
    student.studentId,
    student.cardNumber,
    student.lrn,
    student.lrNumber,
    student.id,
    student.email,
  ]
    .filter((value) => value !== undefined && value !== null)
    .map((value) => String(value).trim())
    .filter(Boolean)
    .join(" ");

const buildFilterOptionsFromSets = (sets = []) => {
  const academicYears = new Set();
  const gradeLevels = new Set();
  const sections = new Set();
  const curricula = new Set();

  sets.forEach((set) => {
    if (!set) {
      return;
    }
    const addValue = (collection, value) => {
      if (value === null || value === undefined) {
        return;
      }
      const trimmed = String(value).trim();
      if (trimmed) {
        collection.add(trimmed);
      }
    };

    addValue(academicYears, set.academicYear);
    addValue(gradeLevels, set.gradeLevel);
    addValue(sections, set.section);
    addValue(curricula, set.curriculum);
  });

  const toSortedArray = (collection) =>
    Array.from(collection).sort((a, b) => a.localeCompare(b, undefined, { numeric: true, sensitivity: "base" }));

  return {
    academicYears: toSortedArray(academicYears),
    gradeLevels: toSortedArray(gradeLevels),
    sections: toSortedArray(sections),
    curricula: toSortedArray(curricula),
  };
};

const sanitizeQuery = (query = {}) => {
  return Object.entries(query).reduce((accumulator, [key, value]) => {
    if (value === null || value === undefined) {
      return accumulator;
    }
    if (typeof value === "string" && value.trim() === "") {
      return accumulator;
    }
    accumulator[key] = value;
    return accumulator;
  }, {});
};

const AnnualBorrowing = () => {
  const navigate = useNavigate();
  const [loading, setLoading] = useState(false);
  const [sets, setSets] = useState([]);
  const studentFilterOptions = useMemo(
    () =>
      createFilterOptions({
        stringify: buildStudentSearchValue,
        trim: true,
        ignoreAccents: true,
        ignoreCase: true,
        matchFrom: "any",
        limit: 500,
      }),
    []
  );
  const [filters, setFilters] = useState(defaultFilters);
  const [appliedFilters, setAppliedFilters] = useState(defaultFilters);
  const [filterOptions, setFilterOptions] = useState({
    academicYears: [],
    gradeLevels: [],
    sections: [],
    curricula: [],
  });
  const [searchInput, setSearchInput] = useState("");
  const [appliedSearch, setAppliedSearch] = useState("");
  const [bookOptions, setBookOptions] = useState([]);
  const [isCreateDialogOpen, setCreateDialogOpen] = useState(false);
  const [createForm, setCreateForm] = useState(emptySetForm);
  const [previewInfo, setPreviewInfo] = useState(null);
  const [previewLoading, setPreviewLoading] = useState(false);
  const [issueDialogOpen, setIssueDialogOpen] = useState(false);
  const [issueTargetSet, setIssueTargetSet] = useState(null);
  const [issueContext, setIssueContext] = useState(null);
  const [issueSelections, setIssueSelections] = useState({});
  const [issueStudent, setIssueStudent] = useState(null);
  const [issueNotes, setIssueNotes] = useState("");
  const [issueLoading, setIssueLoading] = useState(false);
  const [issueSubmitting, setIssueSubmitting] = useState(false);
  const [issueStudentInput, setIssueStudentInput] = useState("");
  const [issueStudentQuery, setIssueStudentQuery] = useState("");
  const [scanValue, setScanValue] = useState("");
  const [scanFeedback, setScanFeedback] = useState(null);
  const scanFieldRef = useRef(null);
  const searchDebounceRef = useRef(null);
  const issueContextRef = useRef(null);

  const loadFilterOptions = useCallback(async () => {
    try {
      const { data } = await annualSetsAPI.getAll();
      const setsList = Array.isArray(data) ? data : [];
      setFilterOptions(buildFilterOptionsFromSets(setsList));
    } catch (error) {
      console.error("Failed to load annual set filters", error);
    }
  }, []);

  const fetchSets = useCallback(async (query = {}) => {
    setLoading(true);
    try {
      const sanitizedQuery = sanitizeQuery(query);
      const { data } = await annualSetsAPI.getAll(sanitizedQuery);
      setSets(Array.isArray(data) ? data : []);
    } catch (error) {
      console.error("Failed to fetch annual sets", error);
      toast.error("Failed to fetch annual borrowing sets");
    } finally {
      setLoading(false);
    }
  }, []);

  const loadBooks = async () => {
    try {
      const { data } = await booksAPI.getAll();
      setBookOptions(Array.isArray(data) ? data : data?.books || []);
    } catch (error) {
      console.error("Failed to load books", error);
      toast.error("Failed to load books catalogue");
    }
  };

  useEffect(() => {
    loadBooks();
  }, []);

  useEffect(() => {
    loadFilterOptions();
  }, [loadFilterOptions]);

  useEffect(() => {
    fetchSets({ ...appliedFilters, search: appliedSearch });
  }, [fetchSets, appliedFilters, appliedSearch]);

  const [filterAnchorEl, setFilterAnchorEl] = useState(null);
  const filterMenuOpen = Boolean(filterAnchorEl);
  const openFilterMenu = (event) => setFilterAnchorEl(event.currentTarget);
  const closeFilterMenu = () => setFilterAnchorEl(null);

  useEffect(() => {
    issueContextRef.current = issueContext;
  }, [issueContext]);

  useEffect(() => {
    if (!issueDialogOpen) {
      return;
    }

    if (searchDebounceRef.current) {
      clearTimeout(searchDebounceRef.current);
    }

    const trimmed = issueStudentInput.trim();
    searchDebounceRef.current = setTimeout(() => {
      setIssueStudentQuery((previous) => (previous === trimmed ? previous : trimmed));
    }, 300);

    return () => {
      if (searchDebounceRef.current) {
        clearTimeout(searchDebounceRef.current);
        searchDebounceRef.current = null;
      }
    };
  }, [issueStudentInput, issueDialogOpen]);

  useEffect(() => {
    if (!issueDialogOpen || !issueTargetSet) {
      return;
    }

    const preserveSelections = Boolean(issueContextRef.current);
    loadIssueContextData(issueTargetSet.id, issueStudentQuery, { preserveSelections });
  }, [issueDialogOpen, issueTargetSet, issueStudentQuery]);

  const handleFilterChange = (field, value) => {
    setFilters((prev) => ({ ...prev, [field]: value }));
  };

  const handleResetFilters = () => {
    setFilters({ ...defaultFilters });
    setAppliedFilters({ ...defaultFilters });
  };

  const handleApplyFilters = () => {
    setAppliedFilters({ ...filters });
  };

  const handleSearchSubmit = (event) => {
    event.preventDefault();
    const trimmed = searchInput.trim();
    if (trimmed !== searchInput) {
      setSearchInput(trimmed);
    }
    if (trimmed === appliedSearch) {
      return;
    }
    setAppliedSearch(trimmed);
  };

  const openCreateDialog = () => {
    setCreateForm({ ...emptySetForm });
    setCreateDialogOpen(true);
  };

  const closeCreateDialog = () => {
    setCreateDialogOpen(false);
  };

  const handleCreateFieldChange = (field, value) => {
    setCreateForm((prev) => ({ ...prev, [field]: value }));
  };

  const handleAddBookEntry = () => {
    setCreateForm((prev) => ({
      ...prev,
      books: [
        ...prev.books,
        {
          bookId: "",
          quantity: 1,
          required: true,
          notes: "",
        },
      ],
    }));
  };

  const handleUpdateBookEntry = (index, field, value) => {
    setCreateForm((prev) => {
      const nextBooks = prev.books.map((entry, idx) =>
        idx === index ? { ...entry, [field]: value } : entry,
      );
      return { ...prev, books: nextBooks };
    });
  };

  const handleRemoveBookEntry = (index) => {
    setCreateForm((prev) => ({
      ...prev,
      books: prev.books.filter((_, idx) => idx !== index),
    }));
  };

  const handleSubmitCreate = async () => {
    if (!createForm.gradeLevel) {
      toast.error("Grade level is required");
      return;
    }
    if (!createForm.academicYear) {
      toast.error("Academic year is required");
      return;
    }
    if (!Array.isArray(createForm.books) || createForm.books.length === 0) {
      toast.error("Add at least one book to the set");
      return;
    }
    if (createForm.books.some((entry) => !entry.bookId)) {
      toast.error("Each entry must reference a book");
      return;
    }

    try {
      const payload = {
        ...createForm,
        books: createForm.books.map((entry) => ({
          ...entry,
          quantity: Number(entry.quantity) || 1,
          required: Boolean(entry.required),
        })),
      };

      await annualSetsAPI.create(payload);
      toast.success("Annual borrowing set created");
      setCreateDialogOpen(false);
      setCreateForm({ ...emptySetForm });
      await Promise.all([
        loadFilterOptions(),
        fetchSets({ ...appliedFilters, search: appliedSearch }),
      ]);
    } catch (error) {
      console.error("Failed to create annual set", error);
      toast.error(error?.response?.data?.message || "Failed to create set");
    }
  };

  const handlePreview = async (set) => {
    setPreviewLoading(true);
    try {
      const { data } = await annualSetsAPI.preview({ setId: set.id });
      setPreviewInfo(data);
    } catch (error) {
      console.error("Failed to preview annual plan", error);
      toast.error("Failed to load preview");
    } finally {
      setPreviewLoading(false);
    }
  };

  const loadIssueContextData = async (setId, query = "", options = {}) => {
    const { preserveSelections = false } = options;

    setIssueLoading(true);

    if (!preserveSelections) {
      setIssueContext(null);
      setIssueSelections({});
      setScanFeedback(null);
      setScanValue("");
    }

    try {
      const params = query ? { q: query } : {};
      const { data } = await annualSetsAPI.getIssueContext(setId, params);

      setIssueContext(data);

      if (preserveSelections) {
        setIssueSelections((previous) => {
          const nextSelections = {};

          (data.entries || []).forEach((entry) => {
            const quantity = Math.max(entry.quantity || 1, 1);
            const existing = Array.isArray(previous?.[entry.entryKey])
              ? [...previous[entry.entryKey]]
              : [];
            const trimmed = existing.slice(0, quantity);

            while (trimmed.length < quantity) {
              const suggestion = (entry.suggestedCopies || []).find((copyId) => !trimmed.includes(copyId));
              trimmed.push(suggestion || "");
            }

            nextSelections[entry.entryKey] = trimmed;
          });

          return nextSelections;
        });
      } else {
        const defaults = {};
        (data.entries || []).forEach((entry) => {
          const quantity = Math.max(entry.quantity || 1, 1);
          const selections = Array.from({ length: quantity }).map((_, index) => entry.suggestedCopies?.[index] || "");
          defaults[entry.entryKey] = selections;
        });
        setIssueSelections(defaults);
      }
    } catch (error) {
      console.error("Failed to load annual set issuance data", error);
      toast.error("Failed to load issuance details");
      if (!preserveSelections) {
        setIssueContext(null);
      }
    } finally {
      setIssueLoading(false);
    }
  };

  const openIssueDialogForSet = (targetSet) => {
    if (!targetSet) {
      return;
    }
    if (searchDebounceRef.current) {
      clearTimeout(searchDebounceRef.current);
      searchDebounceRef.current = null;
    }
    setIssueTargetSet(targetSet);
    setIssueDialogOpen(true);
    setIssueStudent(null);
    setIssueStudentInput("");
    setIssueStudentQuery("");
    setIssueNotes("");
    setIssueContext(null);
    setIssueSelections({});
    setScanValue("");
    setScanFeedback(null);
  };

  const closeIssueDialog = () => {
    if (searchDebounceRef.current) {
      clearTimeout(searchDebounceRef.current);
      searchDebounceRef.current = null;
    }
    setIssueDialogOpen(false);
    setIssueTargetSet(null);
    setIssueContext(null);
    setIssueSelections({});
    setIssueStudent(null);
    setIssueStudentInput("");
    setIssueStudentQuery("");
    setIssueNotes("");
    setScanValue("");
    setScanFeedback(null);
    setIssueLoading(false);
    setIssueSubmitting(false);
  };

  const handleCopySelectionChange = (entryKey, slotIndex, value) => {
    const quantity = (issueContext?.entries || []).find((entry) => entry.entryKey === entryKey)?.quantity || 1;

    setIssueSelections((prev) => {
      const current = prev[entryKey] ? [...prev[entryKey]] : [];
      const next = [...current];
      while (next.length < quantity) {
        next.push("");
      }
      next[slotIndex] = value;
      return { ...prev, [entryKey]: next.slice(0, quantity) };
    });
  };

  const getSlotOptions = (entryKey, slotIndex) => {
    const entry = (issueContext?.entries || []).find((item) => item.entryKey === entryKey);
    if (!entry) {
      return [];
    }

    const currentValue = issueSelections[entryKey]?.[slotIndex] || "";
    const used = new Set();
    Object.entries(issueSelections).forEach(([key, values]) => {
      values.forEach((copyId, idx) => {
        if (!copyId) {
          return;
        }
        if (key === entryKey && idx === slotIndex) {
          return;
        }
        used.add(copyId);
      });
    });

    return (entry.availableCopies || []).filter((option) => {
      if (option.copyId === currentValue) {
        return true;
      }
      return !used.has(option.copyId);
    });
  };

  const assignScannedCopy = (rawCopyId) => {
    const trimmed = String(rawCopyId || "").trim();
    if (!trimmed) {
      setScanFeedback({ type: "warning", message: "Scan a copy barcode before assigning." });
      return;
    }

    if (!issueContext || !Array.isArray(issueContext.entries) || issueContext.entries.length === 0) {
      setScanFeedback({ type: "error", message: "Issuance details are not ready yet." });
      return;
    }

    const lowerValue = trimmed.toLowerCase();

    let existingEntryKey = null;
    Object.entries(issueSelections).forEach(([key, values]) => {
      (values || []).forEach((value) => {
        if (value && String(value).toLowerCase() === lowerValue) {
          existingEntryKey = key;
        }
      });
    });

    if (existingEntryKey) {
      const existingEntry = (issueContext.entries || []).find(
        (entry) => entry.entryKey === existingEntryKey,
      );
      setScanFeedback({
        type: "info",
        message: `Copy ${trimmed} is already assigned to ${existingEntry?.book?.title || existingEntry?.bookId || "this annual set"}.`,
      });
      setScanValue("");
      if (scanFieldRef.current) {
        scanFieldRef.current.focus();
      }
      return;
    }

    let matchedEntry = null;
    let matchedCopyId = null;

    for (const entry of issueContext.entries) {
      for (const option of entry.availableCopies || []) {
        if (String(option.copyId).toLowerCase() === lowerValue) {
          matchedEntry = entry;
          matchedCopyId = option.copyId;
          break;
        }
      }
      if (matchedEntry) {
        break;
      }
    }

    if (!matchedEntry) {
      setScanFeedback({ type: "error", message: `Copy ${trimmed} is not available for this annual set.` });
      setScanValue("");
      if (scanFieldRef.current) {
        scanFieldRef.current.focus();
      }
      return;
    }

    const quantity = Math.max(matchedEntry.quantity || 1, 1);
    const currentSelections = issueSelections[matchedEntry.entryKey] || [];

    let slotIndex = currentSelections.findIndex((value) => !value);
    if (slotIndex === -1 && currentSelections.length < quantity) {
      slotIndex = currentSelections.length;
    }

    let replacedCopy = null;

    if (slotIndex === -1 || slotIndex >= quantity) {
      const existingIndex = currentSelections.findIndex(
        (value) => value && String(value).toLowerCase() === lowerValue,
      );
      if (existingIndex !== -1) {
        setScanFeedback({
          type: "info",
          message: `Copy ${matchedCopyId} is already set for ${matchedEntry.book?.title || matchedEntry.bookId}.`,
        });
        setScanValue("");
        if (scanFieldRef.current) {
          scanFieldRef.current.focus();
        }
        return;
      }

      slotIndex = 0;
      replacedCopy = currentSelections[slotIndex] || null;
    }

    handleCopySelectionChange(matchedEntry.entryKey, slotIndex, matchedCopyId);
    setScanFeedback({
      type: replacedCopy ? "info" : "success",
      message: replacedCopy
        ? `Replaced copy ${replacedCopy} with ${matchedCopyId} for ${matchedEntry.book?.title || matchedEntry.bookId}.`
        : `Assigned copy ${matchedCopyId} to ${matchedEntry.book?.title || matchedEntry.bookId}.`,
    });
    setScanValue("");
    if (scanFieldRef.current) {
      scanFieldRef.current.focus();
    }
  };

  const handleScanInputSubmit = (event) => {
    event.preventDefault();
    assignScannedCopy(scanValue);
  };

  const missingRequiredSelections = useMemo(() => {
    if (!issueContext) {
      return false;
    }
    return (issueContext.entries || []).some((entry) => {
      if (entry.required === false) {
        return false;
      }
      const picks = issueSelections[entry.entryKey] || [];
      const filled = picks.filter(Boolean).length;
      return filled < entry.quantity;
    });
  }, [issueContext, issueSelections]);

  const selectedCopyCount = useMemo(() => {
    return Object.values(issueSelections).reduce((total, picks) => {
      if (!Array.isArray(picks)) {
        return total;
      }
      return total + picks.filter(Boolean).length;
    }, 0);
  }, [issueSelections]);

  const handleIssueSubmit = async () => {
    if (!issueTargetSet || !issueContext) {
      return;
    }

    if (!issueStudent?.id) {
      toast.error("Select a student before issuing the set");
      return;
    }

    if (missingRequiredSelections) {
      toast.error("Assign copies for all required books");
      return;
    }

    const payloadItems = [];
    (issueContext.entries || []).forEach((entry) => {
      const picks = issueSelections[entry.entryKey] || [];
      picks.slice(0, entry.quantity).forEach((copyId) => {
        if (copyId) {
          payloadItems.push({ bookId: entry.bookId, copyId });
        }
      });
    });

    if (payloadItems.length === 0) {
      toast.error("Select at least one copy to issue");
      return;
    }

    setIssueSubmitting(true);
    try {
      const { data } = await annualSetsAPI.issue(issueTargetSet.id, {
        studentId: issueStudent.id,
        items: payloadItems,
        notes: issueNotes,
      });

      const dueDateText = data?.transaction?.dueDate
        ? new Date(data.transaction.dueDate).toLocaleDateString()
        : null;
      toast.success(
        `Issued annual set to ${issueStudent.name || "student"}${dueDateText ? ` ¬∑ Due ${dueDateText}` : ""}`,
      );

      await loadIssueContextData(issueTargetSet.id, issueStudentQuery, {
        preserveSelections: false,
      });
      setIssueStudent(null);
      setIssueNotes("");
      await fetchSets({ ...appliedFilters, search: appliedSearch });
    } catch (error) {
      console.error("Failed to issue annual set", error);
      toast.error(error?.response?.data?.message || "Failed to issue annual set");
    } finally {
      setIssueSubmitting(false);
    }
  };

  const bookOptionsMap = useMemo(() => {
    const map = new Map();
    (bookOptions || []).forEach((book) => {
      const key = book.id || book._id || book.bookId || book.isbn;
      if (key) {
        map.set(String(key), book);
      }
    });
    return map;
  }, [bookOptions]);

  return (
  <Box>
      <Stack spacing={0.5} mb={2}>
        <Stack direction="row" alignItems="center" justifyContent="space-between" spacing={2}>
          <Stack direction="row" alignItems="center" spacing={2}>
            <IconButton
              aria-label="Go back"
              onClick={() => navigate(-1)}
              sx={{ color: "#0F172A" }}
            >
              <ArrowBackIcon />
            </IconButton>
            <Typography variant="h4" color="white">
              Annual Borrowing Plan
            </Typography>
          </Stack>
          <Button
            variant="contained"
            startIcon={<AddIcon />}
            onClick={openCreateDialog}
            sx={{ backgroundColor: "#22C55E", "&:hover": { backgroundColor: "#16A34A" } }}
          >
            New Annual Set
          </Button>
        </Stack>

        <Typography color="white">
          Define and manage annual book allocations by grade and section.
        </Typography>
      </Stack>
      <Stack
        direction="row"
        spacing={1}
        alignItems="center"
        sx={{ flexWrap: "wrap", justifyContent: "space-between", gap: 1, mb: 3 }}
      >
        <Box
          component="form"
          onSubmit={handleSearchSubmit}
          sx={{
            display: "flex",
            alignItems: "center",
            flexWrap: "wrap",
            gap: 2,
            width: "100%",
            flexGrow: 1,
          }}
        >
          <TextField
            value={searchInput}
            onChange={(event) => setSearchInput(event.target.value)}
            placeholder="Search annual sets by name, grade, or year..."
            sx={{ flex: 1, minWidth: 300 }}
            InputProps={{
              startAdornment: (
                <InputAdornment position="start">
                  <SearchIcon fontSize="small" sx={{ color: "text.secondary" }} />
                </InputAdornment>
              ),
            }}
          />
          <IconButton
            aria-label="Open filters"
            onClick={openFilterMenu}
            size="small"
            sx={{ border: "1px solid #E2E8F0", backgroundColor: "#F8FAFC" }}
          >
            <FilterList />
          </IconButton>
          <Menu
            anchorEl={filterAnchorEl}
            open={filterMenuOpen}
            onClose={closeFilterMenu}
            anchorOrigin={{ vertical: "bottom", horizontal: "right" }}
            transformOrigin={{ vertical: "top", horizontal: "right" }}
            PaperProps={{ sx: { p: 2, minWidth: 300 } }}
          >
            <Box sx={{ display: "flex", flexDirection: "column", gap: 1 }}>
              <TextField
                label="Academic Year"
                value={filters.academicYear}
                onChange={(event) =>
                  handleFilterChange("academicYear", event.target.value)
                }
                select
                fullWidth
                helperText="Select an academic year"
              >
                <MenuItem value="">
                  <em>All</em>
                </MenuItem>
                {filterOptions.academicYears.map((year) => (
                  <MenuItem key={year} value={year}>
                    {year}
                  </MenuItem>
                ))}
              </TextField>

              <TextField
                label="Grade Level"
                value={filters.gradeLevel}
                onChange={(event) =>
                  handleFilterChange("gradeLevel", event.target.value)
                }
                select
                fullWidth
                helperText="Select a grade level"
              >
                <MenuItem value="">
                  <em>All</em>
                </MenuItem>
                {filterOptions.gradeLevels.map((grade) => (
                  <MenuItem key={grade} value={grade}>
                    {grade}
                  </MenuItem>
                ))}
              </TextField>

              <TextField
                label="Section"
                value={filters.section}
                onChange={(event) =>
                  handleFilterChange("section", event.target.value)
                }
                select
                fullWidth
                helperText="Select a section"
              >
                <MenuItem value="">
                  <em>All</em>
                </MenuItem>
                {filterOptions.sections.map((section) => (
                  <MenuItem key={section} value={section}>
                    {section}
                  </MenuItem>
                ))}
              </TextField>

              <TextField
                label="Curriculum"
                value={filters.curriculum}
                onChange={(event) =>
                  handleFilterChange("curriculum", event.target.value)
                }
                select
                fullWidth
                helperText="Select a curriculum"
              >
                <MenuItem value="">
                  <em>All</em>
                </MenuItem>
                {filterOptions.curricula.map((curriculum) => (
                  <MenuItem key={curriculum} value={curriculum}>
                    {curriculum}
                  </MenuItem>
                ))}
              </TextField>

              <Box display="flex" justifyContent="flex-end" gap={1} mt={1}>
                <Button size="small" onClick={() => { handleResetFilters(); closeFilterMenu(); }}>
                  Clear
                </Button>
                <Button size="small" variant="contained" onClick={() => { handleApplyFilters(); closeFilterMenu(); }}>
                  Apply
                </Button>
              </Box>
            </Box>
          </Menu>
          <Box component="input" type="submit" sx={{ display: "none" }} />
        </Box>
      </Stack>

      {loading ? (
        <Stack
          direction="row"
          justifyContent="center"
          alignItems="center"
          mt={4}
        >
          <CircularProgress />
        </Stack>
      ) : sets.length === 0 ? (
        <Card variant="outlined">
          <CardContent>
            <Typography variant="h6">No annual sets found</Typography>
            <Typography color="text.secondary" mt={1}>
              Create a new annual borrowing set to plan book allocations for
              each class.
            </Typography>
            <Button
              variant="contained"
              sx={{ mt: 2 }}
              startIcon={<AddIcon />}
              onClick={openCreateDialog}
            >
              Create First Annual Set
            </Button>
          </CardContent>
        </Card>
      ) : (
        <Grid container spacing={2}>
          {sets.map((set) => (
            <Grid item xs={12} sm={6} md={4} key={set.id}>
              <Card
                variant="outlined"
                sx={{ height: "100%", display: "flex", flexDirection: "column" }}
              >
                <CardHeader
                  title={
                    set.name ||
                    `${set.gradeLevel || ""} ${set.section || ""}`.trim() ||
                      "Annual Set"
                  }
                  subheader={`${set.academicYear || ""}  ${
                    set.gradeLevel || "Unassigned"
                  }${set.section ? ` - Section ${set.section}` : ""}`}
                />
                <CardContent sx={{ flexGrow: 1 }}>
                  <Stack spacing={1}>
                    <Typography variant="body2" color="text.secondary">
                      Curriculum: {set.curriculum || "N/A"}
                    </Typography>
                    {set.description && (
                      <Typography variant="body2" color="text.secondary">
                        {set.description}
                      </Typography>
                    )}
                  </Stack>

                  <Divider sx={{ my: 2 }} />

                  <Typography variant="subtitle2" gutterBottom>
                    Planned Titles
                  </Typography>
                  <Stack spacing={0.5}>
                    {(set.books || []).slice(0, 5).map((entry) => {
                      const book =
                        entry.book || bookOptionsMap.get(entry.bookId);
                      return (
                        <Stack
                          direction="row"
                          spacing={1}
                          alignItems="center"
                          key={`${set.id}_${entry.bookId}`}
                        >
                          <Typography variant="body2" sx={{ flexGrow: 1 }}>
                            {book?.title || entry.bookId}
                          </Typography>
                          <Chip size="small" label={`x${entry.quantity || 1}`} />
                          {entry.required !== false ? (
                            <Chip size="small" color="primary" label="Required" />
                          ) : (
                            <Chip size="small" label="Optional" />
                          )}
                        </Stack>
                      );
                    })}
                    {(set.books || []).length > 5 && (
                      <Typography variant="caption" color="text.secondary">
                        +{(set.books || []).length - 5} more title(s)
                      </Typography>
                    )}
                  </Stack>

                  {set.stats && (
                    <Stack direction="row" spacing={1} mt={2}>
                      <Chip label={`Titles: ${set.stats.totalTitles || 0}`} />
                      <Chip
                        label={`Required: ${set.stats.totalRequired || 0}`}
                        color="primary"
                        variant="outlined"
                      />
                      <Chip
                        label={`Copies: ${
                          set.stats.totalQuantity || set.stats.totalCopiesPlanned || 0
                        }`}
                      />
                      <Chip
                        label={`Issued: ${set.issuedCount || 0}`}
                        color="primary"
                        variant="outlined"
                      />
                      <Chip
                        label={`Borrowed: ${set.activeIssues || 0}`}
                        variant="outlined"
                      />
                    </Stack>
                  )}
                </CardContent>
                <CardActions sx={{ justifyContent: "space-between", px: 2, pb: 2 }}>
                  <Button
                    size="small"
                    startIcon={<VisibilityIcon />}
                    onClick={() => handlePreview(set)}
                  >
                    Preview
                  </Button>
                  <Tooltip
                    title={
                      (set.books || []).length > 0
                        ? "Issue this set to a student"
                        : "Add books to this set before issuing"
                    }
                  >
                    <span>
                      <Button
                        size="small"
                        variant="contained"
                        startIcon={<LibraryBooksIcon />}
                        onClick={() => openIssueDialogForSet(set)}
                        disabled={(set.books || []).length === 0}
                      >
                        Issue Set
                      </Button>
                    </span>
                  </Tooltip>
                </CardActions>
              </Card>
            </Grid>
          ))}
        </Grid>
      )}

      <Dialog
        open={issueDialogOpen}
        onClose={closeIssueDialog}
        maxWidth="md"
        fullWidth
      >
        <DialogTitle>Issue Annual Set</DialogTitle>
        <DialogContent dividers>
          {issueLoading && !issueContext ? (
            <Stack direction="row" justifyContent="center" alignItems="center" minHeight={160}>
              <CircularProgress />
            </Stack>
          ) : issueContext ? (
            <Stack spacing={3}>
              <Box>
                <Typography variant="h6">
                  {issueContext.set?.name || issueTargetSet?.name || "Annual Set"}
                </Typography>
                <Typography variant="body2" color="text.secondary">
                  {issueContext.set?.academicYear || issueTargetSet?.academicYear || ""}
                  {issueContext.set?.gradeLevel
                    ? ` ¬∑ ${issueContext.set.gradeLevel}${issueContext.set.section ? ` - Section ${issueContext.set.section}` : ""}`
                    : ""}
                </Typography>
                {issueContext.set?.description && (
                  <Typography variant="body2" color="text.secondary" sx={{ mt: 0.5 }}>
                    {issueContext.set.description}
                  </Typography>
                )}
              </Box>

              <Stack direction={{ xs: "column", sm: "row" }} spacing={2} alignItems="flex-start">
                <Box sx={{ flex: 1, width: "100%" }}>
                  <Autocomplete
                    options={issueContext.students || []}
                    value={issueStudent}
                    onChange={(_, newValue) => setIssueStudent(newValue)}
                    inputValue={issueStudentInput}
                    onInputChange={(_, newInputValue = "", reason) => {
                      if (reason === "reset") {
                        setIssueStudentInput(newInputValue || "");
                        return;
                      }
                      setIssueStudentInput(newInputValue);
                    }}
                    loading={issueLoading && Boolean(issueContext)}
                    loadingText="Searching students..."
                    filterOptions={studentFilterOptions}
                    getOptionLabel={(option) =>
                      option?.name
                        ? `${option.name}${option.grade ? ` ¬∑ ${option.grade}` : ""}${
                            option.section ? ` - ${option.section}` : ""
                          }`
                        : ""
                    }
                    isOptionEqualToValue={(option, value) => option?.id === value?.id}
                    getOptionDisabled={(option) => option.hasBorrowedSet || option.isActive === false}
                    renderOption={(props, option) => (
                      <li {...props} key={option.id}>
                        <Stack spacing={0.5} sx={{ width: "100%" }}>
                          <Typography variant="body2">
                            {option.name}
                            {option.hasBorrowedSet ? " (Borrowed)" : ""}
                          </Typography>
                          <Typography variant="caption" color="text.secondary">
                            {option.grade || ""} {option.section || ""}
                            {option.libraryCardNumber
                              ? ` ¬∑ Card ${option.libraryCardNumber}`
                              : ""}
                          </Typography>
                        </Stack>
                      </li>
                    )}
                    renderInput={(params) => (
                      <TextField
                        {...params}
                        label="Student"
                        placeholder="Search by name or ID"
                      />
                    )}
                  />
                  {issueLoading && issueContext && (
                    <Stack direction="row" alignItems="center" spacing={1} sx={{ mt: 1 }}>
                      <CircularProgress size={16} />
                      <Typography variant="caption" color="text.secondary">
                        Searching students‚Ä¶
                      </Typography>
                    </Stack>
                  )}
                  {(issueContext.students || []).length === 0 && (
                    <Typography variant="caption" color="text.secondary" sx={{ display: "block", mt: 1 }}>
                      No matching students found for this set.
                    </Typography>
                  )}
                  {issueStudent?.hasBorrowedSet && (
                    <Alert sx={{ mt: 1 }} severity="warning">
                      This student already borrowed this set.
                    </Alert>
                  )}
                </Box>
                <TextField
                  label="Notes"
                  value={issueNotes}
                  onChange={(event) => setIssueNotes(event.target.value)}
                  placeholder="Optional notes for this issuance"
                  multiline
                  minRows={2}
                  sx={{ flex: 1, width: "100%" }}
                />
              </Stack>

              <Stack direction={{ xs: "column", sm: "row" }} spacing={1} alignItems="flex-start">
                <Chip label={`Copies selected: ${selectedCopyCount}`} />
                <Chip
                  label={`Issued total: ${issueContext.metrics?.issuedCount || 0}`}
                  variant="outlined"
                />
                <Chip
                  label={`Borrowed outstanding: ${issueContext.metrics?.activeIssues || 0}`}
                  color="primary"
                  variant="outlined"
                />
              </Stack>

              <Box
                component="form"
                onSubmit={handleScanInputSubmit}
                sx={{
                  display: "flex",
                  gap: 1,
                  flexWrap: "wrap",
                  alignItems: "center",
                }}
              >
                <TextField
                  label="Scan Reference Barcode"
                  value={scanValue}
                  onChange={(event) => setScanValue(event.target.value)}
                  placeholder="Focus here and scan a reference barcode"
                  inputRef={scanFieldRef}
                  autoComplete="off"
                  sx={{ flexGrow: 1, minWidth: 260 }}
                />
                <Button
                  type="submit"
                  variant="outlined"
                  disabled={!scanValue.trim() || !issueContext}
                >
                  Assign
                </Button>
                <Button
                  type="button"
                  onClick={() => {
                    setScanValue("");
                    setScanFeedback(null);
                    if (scanFieldRef.current) {
                      scanFieldRef.current.focus();
                    }
                  }}
                >
                  Clear
                </Button>
              </Box>

              <Typography variant="caption" color="text.secondary">
                Barcode scanners act like keyboards: ensure the field above is focused, then scan each
                copy to assign it automatically to the matching title.
              </Typography>

              {scanFeedback && (
                <Alert
                  severity={
                    scanFeedback.type === "success"
                      ? "success"
                      : scanFeedback.type === "warning"
                        ? "warning"
                        : scanFeedback.type === "info"
                          ? "info"
                          : "error"
                  }
                  onClose={() => setScanFeedback(null)}
                >
                  {scanFeedback.message}
                </Alert>
              )}

              {missingRequiredSelections && (
                <Alert severity="warning">
                  Add copies for all required books before issuing this set.
                </Alert>
              )}

              <Stack spacing={2}>
                {(issueContext.entries || []).length === 0 && (
                  <Typography variant="body2" color="text.secondary">
                    This annual set does not have any books configured yet.
                  </Typography>
                )}
                {(issueContext.entries || []).map((entry) => {
                  const selections = issueSelections[entry.entryKey] || [];
                  return (
                    <Card key={entry.entryKey} variant="outlined">
                      <CardContent>
                        <Stack spacing={1.5}>
                          <Stack direction="row" justifyContent="space-between" alignItems="flex-start">
                            <Box>
                              <Typography variant="subtitle1">
                                {entry.book?.title || entry.bookId}
                              </Typography>
                              <Typography variant="body2" color="text.secondary">
                                {entry.book?.author || entry.book?.isbn || ""}
                              </Typography>
                            </Box>
                            <Stack direction="row" spacing={1} alignItems="center">
                              <Chip
                                size="small"
                                label={`${entry.availableCopies.length} available`}
                                color={entry.availableCopies.length > 0 ? "success" : "default"}
                              />
                              {entry.required === false ? (
                                <Chip size="small" label="Optional" />
                              ) : (
                                <Chip size="small" color="primary" variant="outlined" label="Required" />
                              )}
                            </Stack>
                          </Stack>

                          {entry.shortage > 0 && (
                            <Alert severity={entry.required !== false ? "warning" : "info"}>
                              {entry.required !== false
                                ? "Not enough copies available for this title."
                                : "No copies available right now."}
                            </Alert>
                          )}

                          {entry.notes && (
                            <Typography variant="body2" color="text.secondary">
                              {entry.notes}
                            </Typography>
                          )}

                          {Array.from({ length: entry.quantity }).map((_, slotIndex) => {
                            const options = getSlotOptions(entry.entryKey, slotIndex);
                            const currentValue = selections[slotIndex] || "";
                            return (
                              <TextField
                                key={`${entry.entryKey}_${slotIndex}`}
                                label={`Copy ${slotIndex + 1}`}
                                select
                                value={currentValue}
                                onChange={(event) =>
                                  handleCopySelectionChange(entry.entryKey, slotIndex, event.target.value)
                                }
                                disabled={options.length === 0}
                              >
                                <MenuItem value="">
                                  <em>Select copy</em>
                                </MenuItem>
                                {options.map((option) => (
                                  <MenuItem key={option.copyId} value={option.copyId}>
                                    {option.copyId}
                                    {option.location ? ` ¬∑ ${option.location}` : ""}
                                    {option.condition ? ` (${option.condition})` : ""}
                                  </MenuItem>
                                ))}
                              </TextField>
                            );
                          })}
                        </Stack>
                      </CardContent>
                    </Card>
                  );
                })}
              </Stack>
            </Stack>
          ) : (
            <Typography color="text.secondary">No issuance data available for this set.</Typography>
          )}
        </DialogContent>
        <DialogActions>
          <Button onClick={closeIssueDialog}>Close</Button>
          <Button
            variant="contained"
            onClick={handleIssueSubmit}
            disabled={
              issueSubmitting ||
              issueLoading ||
              !issueContext ||
              !issueStudent?.id ||
              issueStudent?.hasBorrowedSet ||
              missingRequiredSelections ||
              selectedCopyCount === 0
            }
          >
            {issueSubmitting ? "Issuing..." : "Issue Set"}
          </Button>
        </DialogActions>
      </Dialog>

      <Dialog
        open={isCreateDialogOpen}
        onClose={closeCreateDialog}
        maxWidth="md"
        fullWidth
      >
        <DialogTitle>Create Annual Borrowing Set</DialogTitle>
        <DialogContent dividers>
          <Stack spacing={2}>
            <TextField
              label="Set Name"
              value={createForm.name}
              onChange={(event) => handleCreateFieldChange("name", event.target.value)}
              placeholder="e.g. Grade 7 Section A 2025"
              fullWidth
            />
            <Stack direction={{ xs: "column", sm: "row" }} spacing={2}>
              <TextField
                label="Academic Year"
                value={createForm.academicYear}
                onChange={(event) => handleCreateFieldChange("academicYear", event.target.value)}
                placeholder="YYYY-YYYY"
                fullWidth
              />
              <TextField
                label="Grade Level"
                value={createForm.gradeLevel}
                onChange={(event) => handleCreateFieldChange("gradeLevel", event.target.value)}
                placeholder="e.g. Grade 7"
                fullWidth
              />
            </Stack>
            <Stack direction={{ xs: "column", sm: "row" }} spacing={2}>
              <TextField
                label="Section"
                value={createForm.section}
                onChange={(event) => handleCreateFieldChange("section", event.target.value)}
                placeholder="e.g. A"
                fullWidth
              />
              <TextField
                label="Curriculum"
                value={createForm.curriculum}
                onChange={(event) => handleCreateFieldChange("curriculum", event.target.value)}
                placeholder="e.g. Junior High"
                fullWidth
              />
            </Stack>
            <TextField
              label="Description"
              value={createForm.description}
              onChange={(event) => handleCreateFieldChange("description", event.target.value)}
              placeholder="Notes for this annual allocation"
              fullWidth
              multiline
              minRows={2}
            />

            <Stack direction="row" justifyContent="space-between" alignItems="center" mt={1}>
              <Typography variant="h6">Books</Typography>
              <Button startIcon={<AddCircleOutlineIcon />} onClick={handleAddBookEntry}>
                Add Book
              </Button>
            </Stack>

            {createForm.books.length === 0 ? (
              <Typography color="text.secondary">
                No books added yet. Use "Add Book" to get started.
              </Typography>
            ) : (
              <Stack spacing={2}>
                {createForm.books.map((entry, index) => {
                  const selectedBook = bookOptionsMap.get(entry.bookId);
                  return (
                    <Card key={`book-entry-${index}`} variant="outlined">
                      <CardContent>
                        <Stack spacing={2}>
                          <Stack direction={{ xs: "column", sm: "row" }} spacing={2} alignItems="flex-start">
                            <TextField
                              label="Book"
                              value={entry.bookId}
                              onChange={(event) => handleUpdateBookEntry(index, "bookId", event.target.value)}
                              select
                              fullWidth
                            >
                              <MenuItem value="">
                                <em>Select a book</em>
                              </MenuItem>
                              {bookOptions.map((book) => {
                                const key =
                                  book.id || book._id || book.bookId || book.isbn;
                                return (
                                  <MenuItem key={key} value={String(key)}>
                                    {book.title}
                                  </MenuItem>
                                );
                              })}
                            </TextField>
                            <TextField
                              label="Quantity"
                              type="number"
                              value={entry.quantity}
                              onChange={(event) => handleUpdateBookEntry(index, "quantity", event.target.value)}
                              inputProps={{ min: 1 }}
                              sx={{ width: { xs: "100%", sm: 140 } }}
                            />
                          </Stack>
                          {selectedBook && (
                            <Typography variant="body2" color="text.secondary">
                              Available copies: {Array.isArray(selectedBook.copies)
                                ? selectedBook.copies.filter((copy) => copy.status === "available").length
                                : 0}
                            </Typography>
                          )}
                          <Stack direction={{ xs: "column", sm: "row" }} spacing={2}>
                            <TextField
                              label="Required"
                              value={entry.required ? "required" : "optional"}
                              onChange={(event) =>
                                handleUpdateBookEntry(
                                  index,
                                  "required",
                                  event.target.value === "required",
                                )
                              }
                              select
                              sx={{ width: { xs: "100%", sm: 200 } }}
                            >
                              <MenuItem value="required">Required</MenuItem>
                              <MenuItem value="optional">Optional</MenuItem>
                            </TextField>
                            <TextField
                              label="Notes"
                              value={entry.notes || ""}
                              onChange={(event) => handleUpdateBookEntry(index, "notes", event.target.value)}
                              placeholder="Special instructions"
                              fullWidth
                            />
                            <Tooltip title="Remove book">
                              <IconButton color="error" onClick={() => handleRemoveBookEntry(index)}>
                                <DeleteOutlineIcon />
                              </IconButton>
                            </Tooltip>
                          </Stack>
                        </Stack>
                      </CardContent>
                    </Card>
                  );
                })}
              </Stack>
            )}
          </Stack>
        </DialogContent>
        <DialogActions>
          <Button variant="outlined" onClick={closeCreateDialog}>Cancel</Button>
          <Button variant="contained" onClick={handleSubmitCreate}>
            Save Annual Set
          </Button>
        </DialogActions>
      </Dialog>

      <Dialog
        open={Boolean(previewInfo)}
        onClose={() => setPreviewInfo(null)}
        maxWidth="md"
        fullWidth
      >
        <DialogTitle>Annual Plan Preview</DialogTitle>
        <DialogContent dividers>
          {previewLoading ? (
            <Stack direction="row" justifyContent="center" alignItems="center" minHeight={120}>
              <CircularProgress />
            </Stack>
          ) : previewInfo ? (
            <Stack spacing={2}>
              <Box>
                <Typography variant="subtitle2" color="text.secondary">
                  Academic Year
                </Typography>
                <Typography variant="h6">{previewInfo.academicYear}</Typography>
              </Box>
              <Stack direction={{ xs: "column", sm: "row" }} spacing={2}>
                <Box>
                  <Typography variant="subtitle2" color="text.secondary">
                    Grade Level
                  </Typography>
                  <Typography variant="body1">{previewInfo.gradeLevel || "N/A"}</Typography>
                </Box>
                <Box>
                  <Typography variant="subtitle2" color="text.secondary">
                    Section
                  </Typography>
                  <Typography variant="body1">{previewInfo.section || "N/A"}</Typography>
                </Box>
                <Box>
                  <Typography variant="subtitle2" color="text.secondary">
                    Curriculum
                  </Typography>
                  <Typography variant="body1">{previewInfo.curriculum || "N/A"}</Typography>
                </Box>
              </Stack>
              <Divider />
              <Box>
                <Typography variant="subtitle2" color="text.secondary">
                  Target Set
                </Typography>
                <Typography variant="h6">{previewInfo.targetSet?.name || "Unnamed Set"}</Typography>
                <Typography variant="body2" color="text.secondary" mt={1}>
                  Titles planned: {previewInfo.targetSet?.stats?.totalTitles ||
                    previewInfo.targetSet?.books?.length ||
                    0}
                </Typography>
              </Box>
              <Divider />
              <Box>
                <Typography variant="subtitle2" color="text.secondary">
                  Students matched
                </Typography>
                <Typography variant="h5">{previewInfo.studentCount || 0}</Typography>
                <Typography variant="body2" color="text.secondary">
                  Showing up to 10 sample students
                </Typography>
                <Stack spacing={1} mt={2}>
                  {(previewInfo.studentSample || []).map((student) => (
                    <Card key={student.id} variant="outlined">
                      <CardContent>
                        <Typography variant="subtitle1">
                          {student.name || "Unnamed"}
                        </Typography>
                        <Typography variant="body2" color="text.secondary">
                          Grade {student.grade || ""}  Section {student.section || ""}
                        </Typography>
                      </CardContent>
                    </Card>
                  ))}
                </Stack>
              </Box>
            </Stack>
          ) : (
            <Typography color="text.secondary">No preview data available.</Typography>
          )}
        </DialogContent>
        <DialogActions>
          <Button onClick={() => setPreviewInfo(null)}>Close</Button>
        </DialogActions>
      </Dialog>
    </Box>
  );
};

export default AnnualBorrowing;
```

## AuditLogs.js

| Field | Details |
| --- | --- |
| Program Name | AuditLogs.js |
| Description | Frontend page view for routing and page-level UI. |
| Called by | App.js |
| Table used | audit |
|  |  |
| Programmer | Nazel Asca√±o |
| Date created | 12/14/2025 |
| Revision Date | TBD |
| Revision / description of change | None |

```javascript
import React, { useState, useEffect, useMemo, useCallback } from "react";
import {
  Alert,
  Avatar,
  Box,
  Button,
  Card,
  CardContent,
  Chip,
  Collapse,
  Dialog,
  DialogActions,
  DialogContent,
  DialogTitle,
  FormControl,
  Grid,
  IconButton,
  InputAdornment,
  InputLabel,
  LinearProgress,
  List,
  ListItem,
  ListItemText,
  MenuItem,
  Paper,
  Select,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TablePagination,
  TableRow,
  TextField,
  Tooltip,
  Typography,
} from "@mui/material";
import Autocomplete, { createFilterOptions } from "@mui/material/Autocomplete";
import {
  Download,
  ExpandLess,
  ExpandMore,
  FilterList,
  Refresh,
  Search,
  Visibility,
} from "@mui/icons-material";
import { LocalizationProvider } from "@mui/x-date-pickers/LocalizationProvider";
import { DateTimePicker } from "@mui/x-date-pickers/DateTimePicker";
import { AdapterDateFns } from "@mui/x-date-pickers/AdapterDateFns";
import { auditAPI, downloadFile, usersAPI } from "../../utils/api";
import { useLocation, useNavigate } from "react-router-dom";

const DATE_TIME_FORMATTER = new Intl.DateTimeFormat("en-US", {
  month: "short",
  day: "2-digit",
  year: "numeric",
  hour: "2-digit",
  minute: "2-digit",
  second: "2-digit",
});

const FALLBACK_ROLE_OPTIONS = ["admin", "librarian", "staff", "student"];
const toIsoIfValid = (value) =>
  value instanceof Date && !Number.isNaN(value.getTime()) ? value.toISOString() : undefined;

const formatDateTime = (value) => {
  if (!value) {
    return "‚Äî";
  }

  const date = value instanceof Date ? value : new Date(value);
  if (Number.isNaN(date.getTime())) {
    return "‚Äî";
  }

  return DATE_TIME_FORMATTER.format(date);
};

const humanizeKey = (key = "") =>
  key
    .replace(/[_-]+/g, " ")
    .replace(/([a-z\d])([A-Z])/g, "$1 $2")
    .replace(/\s+/g, " ")
    .trim()
    .replace(/^./, (char) => char.toUpperCase());

const formatDetailValue = (value) => {
  if (value === null || value === undefined) {
    return "‚Äî";
  }
  if (typeof value === "string") {
    return value;
  }
  if (typeof value === "number" || typeof value === "boolean") {
    return String(value);
  }
  if (Array.isArray(value)) {
    return value.map((entry) => formatDetailValue(entry)).join(", ");
  }
  if (typeof value === "object") {
    const nested = Object.entries(value)
      .map(([key, nestedValue]) => `${humanizeKey(key)}: ${formatDetailValue(nestedValue)}`)
      .join("; ");
    return nested || "‚Äî";
  }
  return String(value);
};

const stringifyDetails = (details) => {
  if (!details) {
    return "No additional details provided.";
  }
  if (typeof details === "string") {
    return details;
  }
  if (typeof details !== "object") {
    return String(details);
  }

  if (Array.isArray(details)) {
    if (details.length === 0) {
      return "No additional details provided.";
    }
    return details
      .map((item, index) => `${index + 1}. ${formatDetailValue(item)}`)
      .join("\n");
  }

  const entries = Object.entries(details).map(
    ([key, value]) => `${humanizeKey(key)}: ${formatDetailValue(value)}`,
  );

  return entries.length > 0 ? entries.join("\n") : "No additional details provided.";
};

const getLogIdentifier = (log) => log?.id || log?._id || log?.timestamp;

const getUserPrimary = (log) =>
  log?.userName || log?.userEmail || log?.userId || log?.performedBy || "System";

const getUserSecondary = (log) =>
  log?.userRole || log?.userEmail || (log?.userId ? `ID: ${log.userId}` : "");

const getEntityDisplay = (log) => {
  const entity = log?.entity || log?.resource || "‚Äî";
  if (log?.entityId || log?.resourceId) {
    return `${entity} ‚Ä¢ ${log.entityId || log.resourceId}`;
  }
  return entity;
};

const getStatusMeta = (log) => {
  const rawStatus =
    log?.status ||
    (log?.success === false ? "Failed" : log?.success === true ? "Success" : "Info");
  const normalized = String(rawStatus).toLowerCase();

  if (normalized.includes("fail") || normalized.includes("error")) {
    return { label: rawStatus || "Failed", color: "error" };
  }

  if (normalized.includes("warn")) {
    return { label: rawStatus || "Warning", color: "warning" };
  }

  if (normalized.includes("success") || normalized.includes("ok")) {
    return { label: rawStatus || "Success", color: "success" };
  }

  return { label: rawStatus || "Info", color: "default" };
};

const getActionLabel = (log) =>
  log?.action || log?.eventType || log?.activity || "Unknown";

const getDescription = (log) =>
  log?.description || log?.message || log?.summary || "No description provided.";

const toPlainObject = (value) =>
  value && typeof value === "object" && !Array.isArray(value) ? value : {};

const getUserSearchFields = (log) => {
  const details = toPlainObject(log?.details);
  const metadata = toPlainObject(log?.metadata);
  const nestedUser = toPlainObject(log?.user);
  const nestedLibrary = toPlainObject(nestedUser.library);
  const detailStudent = toPlainObject(details.student);
  const metadataStudent = toPlainObject(metadata.student);
  const detailProfile = toPlainObject(details.profile);
  const metadataProfile = toPlainObject(metadata.profile);
  const request = toPlainObject(metadata.createRequest || metadata.request);
  const requestStudent = toPlainObject(request.student);
  const requestLibrary = toPlainObject(request.library);
  const profileLibrary = toPlainObject(detailProfile.library);
  const metadataLibrary = toPlainObject(metadataProfile.library);
  const detailUser = toPlainObject(details.user);
  const metadataUser = toPlainObject(metadata.user);
  const borrower = toPlainObject(details.borrower || metadata.borrower || log.borrower);

  const buildName = (source) => {
    if (!source) {
      return "";
    }
    const fullName = [source.firstName, source.middleName, source.lastName]
      .filter(Boolean)
      .join(" ")
      .trim();
    return fullName || source.name || "";
  };

  const studentName =
    log?.studentName ||
    details.studentName ||
    metadata.studentName ||
    detailProfile.studentName ||
    metadataProfile.studentName ||
    detailUser.studentName ||
    metadataUser.studentName ||
    borrower.name ||
    borrower.fullName ||
    details.borrowerName ||
    metadata.borrowerName ||
    log?.borrowerName ||
    buildName(detailStudent) ||
    buildName(metadataStudent) ||
    buildName(detailProfile) ||
    buildName(detailUser) ||
    buildName(metadataProfile) ||
    buildName(request) ||
    buildName(requestStudent) ||
    nestedUser.studentName ||
    nestedUser.name ||
    getUserPrimary(log);

  const studentId =
    log?.studentId ||
    details.studentId ||
    metadata.studentId ||
    detailStudent.studentId ||
    metadataStudent.studentId ||
    detailProfile.studentId ||
    metadataProfile.studentId ||
    detailUser.studentId ||
    metadataUser.studentId ||
    request.studentId ||
    requestStudent.studentId ||
    nestedUser.studentId ||
    borrower.studentId ||
    log?.userId;

  const username =
    log?.username ||
    details.username ||
    metadata.username ||
    detailUser.username ||
    metadataUser.username ||
    nestedUser.username ||
    log?.userName ||
    log?.userEmail;

  const libraryId =
    log?.libraryId ||
    log?.libraryCardNumber ||
    details.libraryId ||
    details.libraryCardNumber ||
    detailStudent.libraryCardNumber ||
    metadataStudent.libraryCardNumber ||
    detailProfile.libraryCardNumber ||
    metadataProfile.libraryCardNumber ||
    detailUser.libraryCardNumber ||
    metadataUser.libraryCardNumber ||
    profileLibrary.cardNumber ||
    metadataLibrary.cardNumber ||
    request.libraryId ||
    request.libraryCardNumber ||
    requestStudent.libraryCardNumber ||
    requestLibrary.cardNumber ||
    borrower.libraryCardNumber ||
    metadata.libraryId ||
    metadata.libraryCardNumber ||
    nestedUser.libraryCardNumber ||
    nestedLibrary.cardNumber;

  return {
    studentName,
    studentId,
    username,
    libraryId,
  };
};

const resolveOptionSearchValue = (option, typedValue) => {
  if (!option) {
    return typedValue ?? "";
  }

  const normalizedTyped = (typedValue || "").trim().toLowerCase();
  if (normalizedTyped && Array.isArray(option.candidates)) {
    const match = option.candidates.find((candidate) => {
      if (!candidate) {
        return false;
      }
      return String(candidate).toLowerCase() === normalizedTyped;
    });
    if (match) {
      return typedValue;
    }
  }

  return option.searchValue || option.label || option.value || typedValue || "";
};

const DEFAULT_FILTERS = {
  action: "all",
  entity: "all",
  role: "all",
  userQuery: "",
  startDate: null,
  endDate: null,
};

const extractFiltersFromSearch = (search) => {
  if (typeof search !== "string") {
    return {};
  }
  const params = new URLSearchParams(search);
  const output = {};
  ["action", "entity", "role"].forEach((key) => {
    if (params.has(key)) {
      const value = params.get(key);
      output[key] = value && value.trim() ? value : "all";
    }
  });
  return output;
};

const AuditLogs = () => {
  const location = useLocation();
  const navigate = useNavigate();
  const [logs, setLogs] = useState([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  const [page, setPage] = useState(0);
  const [rowsPerPage, setRowsPerPage] = useState(25);
  const [totalCount, setTotalCount] = useState(0);
  const [expandedRows, setExpandedRows] = useState(() => new Set());
  const [selectedLog, setSelectedLog] = useState(null);
  const [detailsOpen, setDetailsOpen] = useState(false);
  const [summary, setSummary] = useState(null);
  const [recentActivity, setRecentActivity] = useState([]);
  const [roleOptions, setRoleOptions] = useState(FALLBACK_ROLE_OPTIONS);

  const [filters, setFilters] = useState(() => ({
    ...DEFAULT_FILTERS,
    ...extractFiltersFromSearch(location.search),
  }));
  const handleFiltersUpdate = useCallback((updates) => {
    setFilters((prev) => {
      const nextUpdates =
        typeof updates === "function" ? updates(prev) : { ...updates };
      return { ...prev, ...nextUpdates };
    });
    setPage(0);
  }, []);

  const handleFilterChange = (key, value) => {
    handleFiltersUpdate({ [key]: value });
  };

  useEffect(() => {
    const nextFilters = extractFiltersFromSearch(location.search);
    setFilters((prev) => {
      let updated = prev;
      ["action", "entity", "role"].forEach((key) => {
        if (Object.prototype.hasOwnProperty.call(nextFilters, key)) {
          const nextValue = nextFilters[key];
          if (nextValue !== undefined && nextValue !== prev[key]) {
            if (updated === prev) {
              updated = { ...prev };
            }
            updated[key] = nextValue;
          }
        }
      });
      return updated;
    });
  }, [location.search]);

  useEffect(() => {
    const params = new URLSearchParams(location.search || "");
    let changed = false;
    const syncParam = (key, value) => {
      const normalized = value && value !== "all" ? value : null;
      const current = params.get(key);
      if (normalized === null) {
        if (current !== null) {
          params.delete(key);
          changed = true;
        }
      } else if (current !== normalized) {
        params.set(key, normalized);
        changed = true;
      }
    };

    syncParam("action", filters.action);
    syncParam("entity", filters.entity);
    syncParam("role", filters.role);

    if (changed) {
      const nextSearch = params.toString();
      navigate(
        {
          pathname: location.pathname,
          search: nextSearch ? `?${nextSearch}` : "",
        },
        { replace: true },
      );
    }
  }, [filters.action, filters.entity, filters.role, location.pathname, location.search, navigate]);

  const loadLogs = useCallback(async () => {
    try {
      setLoading(true);
      setError(null);
      const trimmedQuery = filters.userQuery?.trim();

      const params = {
        page: page + 1,
        limit: rowsPerPage,
        action: filters.action !== "all" ? filters.action : undefined,
        entity: filters.entity !== "all" ? filters.entity : undefined,
        role: filters.role !== "all" ? filters.role : undefined,
        userQuery: trimmedQuery ? trimmedQuery : undefined,
        startDate: toIsoIfValid(filters.startDate),
        endDate: toIsoIfValid(filters.endDate),
      };

      const { data } = await auditAPI.getLogs(params);
      const items = Array.isArray(data?.logs) ? data.logs : Array.isArray(data) ? data : [];
      const pagination = data?.pagination;

      setLogs(items);
      setTotalCount(pagination?.total ?? items.length ?? 0);
    } catch (err) {
      console.error("Failed to load audit logs", err);
      setError("Failed to load audit logs. Please try again.");
    } finally {
      setLoading(false);
    }
  }, [filters, page, rowsPerPage]);

  const loadSummary = useCallback(async () => {
    try {
      const trimmedQuery = filters.userQuery?.trim();
      const params = {
        days: 30,
        action: filters.action !== "all" ? filters.action : undefined,
        entity: filters.entity !== "all" ? filters.entity : undefined,
        role: filters.role !== "all" ? filters.role : undefined,
        userQuery: trimmedQuery ? trimmedQuery : undefined,
        startDate: toIsoIfValid(filters.startDate),
        endDate: toIsoIfValid(filters.endDate),
      };

      const [summaryResponse, recentResponse] = await Promise.all([
        auditAPI.getSummary(params),
        auditAPI.getRecentActivity({ limit: 5 }),
      ]);

      setSummary(summaryResponse?.data ?? null);
      setRecentActivity(Array.isArray(recentResponse?.data) ? recentResponse.data : []);
    } catch (err) {
      console.error("Failed to load audit summary", err);
    }
  }, [filters]);

  useEffect(() => {
    loadLogs();
  }, [loadLogs]);

  useEffect(() => {
    loadSummary();
  }, [loadSummary]);

  useEffect(() => {
    let isMounted = true;

    const fetchRoles = async () => {
      try {
        const { data } = await usersAPI.getRoles();
        const rawRoles = Array.isArray(data?.roles) ? data.roles : Array.isArray(data) ? data : [];
        const normalized = Array.from(
          new Set(
            rawRoles
              .map((role) => (role ? String(role).trim().toLowerCase() : ""))
              .filter(Boolean),
          ),
        ).sort((a, b) => a.localeCompare(b));
        if (isMounted) {
          setRoleOptions(normalized.length > 0 ? normalized : FALLBACK_ROLE_OPTIONS);
        }
      } catch (err) {
        console.error("Failed to load user roles", err);
        if (isMounted) {
          setRoleOptions(FALLBACK_ROLE_OPTIONS);
        }
      }
    };

    fetchRoles();

    return () => {
      isMounted = false;
    };
  }, []);

  const metrics = useMemo(() => {
    if (!summary) {
      return {
        totalLogs: 0,
        logsToday: 0,
        uniqueUsers: 0,
        topAction: "‚Äî",
        topEntity: "‚Äî",
      };
    }

    const totalLogs = summary.totalLogs ?? 0;
    const uniqueUsers = Object.keys(summary.userCounts ?? {}).length;
    const todayKey = new Date().toDateString();
    const logsToday = summary.dailyActivity?.[todayKey] ?? 0;

    const topActionEntry = Object.entries(summary.actionCounts ?? {}).sort(
      (a, b) => b[1] - a[1],
    )[0];

    const topEntityEntry = Object.entries(summary.entityCounts ?? {}).sort(
      (a, b) => b[1] - a[1],
    )[0];

    return {
      totalLogs,
      logsToday,
      uniqueUsers,
      topAction: topActionEntry ? `${topActionEntry[0]} ‚Ä¢ ${topActionEntry[1]}` : "‚Äî",
      topEntity: topEntityEntry ? `${topEntityEntry[0]} ‚Ä¢ ${topEntityEntry[1]}` : "‚Äî",
    };
  }, [summary]);

  const filterOptions = useMemo(() => {
    const actionSet = new Set();
    const entitySet = new Set();

    if (summary) {
      Object.keys(summary.actionCounts ?? {}).forEach((action) => action && actionSet.add(action));
      Object.keys(summary.entityCounts ?? {}).forEach((entity) => entity && entitySet.add(entity));
    }

    logs.forEach((log) => {
      if (log?.action) {
        actionSet.add(log.action);
      }
      if (log?.entity || log?.resource) {
        entitySet.add(log.entity || log.resource);
      }
    });

    return {
      actions: Array.from(actionSet).sort((a, b) => a.localeCompare(b)),
      entities: Array.from(entitySet).sort((a, b) => a.localeCompare(b)),
    };
  }, [logs, summary]);

  const userOptions = useMemo(() => {
    const userMap = new Map();

    const registerOption = (key, option) => {
      if (!key || userMap.has(key)) {
        return;
      }
      userMap.set(key, option);
    };

    logs.forEach((log) => {
      if (!log) {
        return;
      }
      const meta = getUserSearchFields(log);
      const key =
        meta.libraryId ||
        meta.studentId ||
        meta.studentName ||
        meta.username ||
        log.userId ||
        getLogIdentifier(log);
      if (!key) {
        return;
      }

      const label =
        meta.studentName ||
        getUserPrimary(log) ||
        meta.libraryId ||
        meta.studentId ||
        meta.username ||
        "Unknown user";

      const secondaryParts = [
        meta.studentId ? `Student ID: ${meta.studentId}` : null,
        meta.username ? `Username: ${meta.username}` : null,
        meta.libraryId ? `Library ID: ${meta.libraryId}` : null,
      ].filter(Boolean);

      const searchValue =
        meta.libraryId ||
        meta.studentId ||
        meta.studentName ||
        meta.username ||
        label;

      registerOption(key, {
        value: key,
        label,
        secondary: secondaryParts.join(" ‚Ä¢ ") || getUserSecondary(log) || "",
        meta,
        searchValue,
        candidates: [
          meta.libraryId,
          meta.studentId,
          meta.studentName,
          meta.username,
          getUserPrimary(log),
          getUserSecondary(log),
          log.userId,
        ].filter(Boolean),
        searchText: [
          label,
          secondaryParts.join(" "),
          meta.studentId,
          meta.username,
          meta.libraryId,
          meta.studentName,
          log.userEmail,
        ]
          .filter(Boolean)
          .map((entry) => String(entry).toLowerCase())
          .join(" "),
      });
    });

    Object.keys(summary?.userCounts ?? {}).forEach((userId) => {
      if (!userId) {
        return;
      }
      registerOption(userId, {
        value: userId,
        label: userId,
        secondary: "",
        meta: { studentId: userId },
        searchValue: userId,
        candidates: [userId],
        searchText: String(userId).toLowerCase(),
      });
    });

    return Array.from(userMap.values()).sort((a, b) => a.label.localeCompare(b.label));
  }, [logs, summary]);

  const filterUserOptions = useMemo(
    () =>
      createFilterOptions({
        stringify: (option) =>
          [
            option.label,
            option.secondary,
            option.meta?.studentId,
            option.meta?.username,
            option.meta?.libraryId,
          ]
            .filter(Boolean)
            .join(" "),
      }),
    [],
  );

  const visibleUserOptions = useMemo(() => {
    const trimmed = filters.userQuery.trim();
    if (!trimmed) {
      return [];
    }
    return userOptions;
  }, [filters.userQuery, userOptions]);

  const toggleRowExpansion = (logId) => {
    if (!logId) {
      return;
    }
    setExpandedRows((prev) => {
      const next = new Set(prev);
      if (next.has(logId)) {
        next.delete(logId);
      } else {
        next.add(logId);
      }
      return next;
    });
  };

  const handleOpenDetails = (log) => {
    setSelectedLog(log);
    setDetailsOpen(true);
  };

  const handleCloseDetails = () => {
    setDetailsOpen(false);
    setSelectedLog(null);
  };

  const handleExport = async () => {
    try {
      setError(null);
      const trimmedQuery = filters.userQuery?.trim();
      const params = {
        action: filters.action !== "all" ? filters.action : undefined,
        entity: filters.entity !== "all" ? filters.entity : undefined,
        role: filters.role !== "all" ? filters.role : undefined,
        userQuery: trimmedQuery ? trimmedQuery : undefined,
        startDate: toIsoIfValid(filters.startDate),
        endDate: toIsoIfValid(filters.endDate),
      };

      const { data } = await auditAPI.exportCsv(params);
      downloadFile(data, `audit_logs_${new Date().toISOString().split("T")[0]}.csv`);
    } catch (err) {
      console.error("Failed to export audit logs", err);
      setError("Failed to export audit logs. Please try again.");
    }
  };

  const handleRefresh = () => {
    loadLogs();
    loadSummary();
  };

  const handleResetFilters = () => {
    setFilters({
      action: "all",
      entity: "all",
      role: "all",
      userQuery: "",
      startDate: null,
      endDate: null,
    });
    setPage(0);
  };

  const canExport = logs.length > 0 && !loading;

  return (
    <LocalizationProvider dateAdapter={AdapterDateFns}>
      <Box display="flex" flexDirection="column" gap={3}>
        <Box display="flex" justifyContent="space-between" alignItems="center">
          <Box>
            <Typography variant="h4" color={"white"}>Audit Logs</Typography>
            <Typography variant="body2" color="white">
              Monitor recent activity, usage patterns, and notable security events.
            </Typography>
          </Box>
          <Box display="flex" gap={1}>
            <Button
              variant="outlined"
              startIcon={<Download />}
              onClick={handleExport}
              disabled={!canExport}
            >
              Export CSV
            </Button>
            <Button
              variant="outlined"
              startIcon={<Refresh />}
              onClick={handleRefresh}
              disabled={loading}
            >
              Refresh
            </Button>
          </Box>
        </Box>

        {error && <Alert severity="error">{error}</Alert>}

        <Grid container spacing={2}>
          <Grid item xs={12} sm={6} md={3}>
            <Card>
              <CardContent>
                <Typography variant="subtitle2" color="text.secondary">
                  Total Logs (30 days)
                </Typography>
                <Typography variant="h5">{metrics.totalLogs}</Typography>
              </CardContent>
            </Card>
          </Grid>
          <Grid item xs={12} sm={6} md={3}>
            <Card>
              <CardContent>
                <Typography variant="subtitle2" color="text.secondary">
                  Logged Today
                </Typography>
                <Typography variant="h5">{metrics.logsToday}</Typography>
              </CardContent>
            </Card>
          </Grid>
          <Grid item xs={12} sm={6} md={3}>
            <Card>
              <CardContent>
                <Typography variant="subtitle2" color="text.secondary">
                  Active Users
                </Typography>
                <Typography variant="h5">{metrics.uniqueUsers}</Typography>
              </CardContent>
            </Card>
          </Grid>
          <Grid item xs={12} sm={6} md={3}>
            <Card>
              <CardContent>
                <Typography variant="subtitle2" color="text.secondary">
                  Top Activity
                </Typography>
                <Typography variant="h6" noWrap>{metrics.topAction}</Typography>
                <Typography variant="body2" color="text.secondary" noWrap>
                  {metrics.topEntity}
                </Typography>
              </CardContent>
            </Card>
          </Grid>
        </Grid>

        <Paper sx={{ p: 2 }}>
          <Box sx={{ width: "100%", mb: 2 }}>
            <Autocomplete
              fullWidth
              freeSolo
              options={visibleUserOptions}
              filterOptions={filterUserOptions}
              value={null}
              inputValue={filters.userQuery}
              onInputChange={(_, newInputValue, reason) => {
                if (reason === "reset") {
                  return;
                }
                handleFilterChange("userQuery", newInputValue ?? "");
              }}
              onChange={(_, newValue) => {
                if (!newValue) {
                  handleFilterChange("userQuery", "");
                  return;
                }
                if (typeof newValue === "string") {
                  handleFilterChange("userQuery", newValue);
                  return;
                }
                handleFilterChange(
                  "userQuery",
                  resolveOptionSearchValue(newValue, filters.userQuery),
                );
              }}
              getOptionLabel={(option) =>
                typeof option === "string"
                  ? option
                  : option.label || option.searchValue || option.value || ""
              }
              isOptionEqualToValue={(option, value) => option.value === value?.value}
              renderOption={(props, option) => (
                <Box component="li" {...props} sx={{ display: "flex", flexDirection: "column" }}>
                  <Typography variant="body2">{option.label}</Typography>
                  {option.secondary && (
                    <Typography variant="caption" color="text.secondary">
                      {option.secondary}
                    </Typography>
                  )}
                </Box>
              )}
              ListboxProps={{ style: { maxHeight: 240 } }}
              renderInput={(params) => (
                <TextField
                  {...params}
                  label="Search user"
                  placeholder="Student ID, name, username, or library ID"
                  size="small"
                  fullWidth
                  InputProps={{
                    ...params.InputProps,
                    startAdornment: (
                      <>
                        <InputAdornment position="start">
                          <Search fontSize="small" />
                        </InputAdornment>
                        {params.InputProps.startAdornment}
                      </>
                    ),
                  }}
                />
              )}
            />
          </Box>
          <Grid container spacing={2} alignItems="center">
            <Grid item xs={12} md={3}>
              <FormControl fullWidth size="small">
                <InputLabel id="audit-action-filter">Action</InputLabel>
                <Select
                  labelId="audit-action-filter"
                  label="Action"
                  value={filters.action}
                  onChange={(event) => handleFilterChange("action", event.target.value)}
                >
                  <MenuItem value="all">All actions</MenuItem>
                  {filterOptions.actions.map((action) => (
                    <MenuItem key={action} value={action}>
                      {action}
                    </MenuItem>
                  ))}
                </Select>
              </FormControl>
            </Grid>
            <Grid item xs={12} md={3}>
              <FormControl fullWidth size="small">
                <InputLabel id="audit-role-filter">Role</InputLabel>
                <Select
                  labelId="audit-role-filter"
                  label="Role"
                  value={filters.role}
                  onChange={(event) => handleFilterChange("role", event.target.value)}
                >
                  <MenuItem value="all">All roles</MenuItem>
                  {roleOptions.map((role) => (
                    <MenuItem key={role} value={role}>
                      {humanizeKey(role)}
                    </MenuItem>
                  ))}
                </Select>
              </FormControl>
            </Grid>
            <Grid item xs={12} md={3}>
              <FormControl fullWidth size="small">
                <InputLabel id="audit-entity-filter">Entity</InputLabel>
                <Select
                  labelId="audit-entity-filter"
                  label="Entity"
                  value={filters.entity}
                  onChange={(event) => handleFilterChange("entity", event.target.value)}
                >
                  <MenuItem value="all">All entities</MenuItem>
                  {filterOptions.entities.map((entity) => (
                    <MenuItem key={entity} value={entity}>
                      {entity}
                    </MenuItem>
                  ))}
                </Select>
              </FormControl>
            </Grid>
            <Grid item xs={12} md={3} display="flex" justifyContent="flex-end" gap={1}>
              <Button
                variant="outlined"
                startIcon={<FilterList />}
                onClick={handleResetFilters}
                disabled={loading}
              >
                Reset
              </Button>
            </Grid>
            <Grid item xs={12} md={3}>
              <DateTimePicker
                label="Start date"
                value={filters.startDate}
                onChange={(value) => handleFilterChange("startDate", value ?? null)}
                slotProps={{ textField: { size: "small", fullWidth: true } }}
              />
            </Grid>
            <Grid item xs={12} md={3}>
              <DateTimePicker
                label="End date"
                value={filters.endDate}
                onChange={(value) => handleFilterChange("endDate", value ?? null)}
                slotProps={{ textField: { size: "small", fullWidth: true } }}
              />
            </Grid>
            {recentActivity.length > 0 && (
              <Grid item xs={12} md={6}>
                <Box>
                  <Typography variant="subtitle2" color="text.secondary" sx={{ mb: 1 }}>
                    Recent activity snapshot
                  </Typography>
                  <List dense>
                    {recentActivity.map((item) => {
                      const key = getLogIdentifier(item);
                      return (
                        <ListItem key={key} disablePadding sx={{ py: 0.5 }}>
                          <ListItemText
                            primary={`${getActionLabel(item)} ‚Ä¢ ${formatDateTime(item.timestamp)}`}
                            secondary={getEntityDisplay(item)}
                          />
                        </ListItem>
                      );
                    })}
                  </List>
                </Box>
              </Grid>
            )}
          </Grid>
        </Paper>

        <Paper>
          <TableContainer>
            <Table size="small">
              <TableHead>
                <TableRow>
                  <TableCell width={48} />
                  <TableCell>Timestamp</TableCell>
                  <TableCell>User</TableCell>
                  <TableCell>Action</TableCell>
                  <TableCell>Entity</TableCell>
                  <TableCell>IP Address</TableCell>
                  <TableCell>Status</TableCell>
                  <TableCell align="right">Details</TableCell>
                </TableRow>
              </TableHead>
              <TableBody>
                {loading && (
                  <TableRow>
                    <TableCell colSpan={8} sx={{ p: 0 }}>
                      <LinearProgress />
                    </TableCell>
                  </TableRow>
                )}

                {!loading && logs.length === 0 && (
                  <TableRow>
                    <TableCell colSpan={8} align="center" sx={{ py: 4 }}>
                      <Typography variant="body2" color="text.secondary">
                        No audit activity matches the selected filters.
                      </Typography>
                    </TableCell>
                  </TableRow>
                )}

                {logs.map((log) => {
                  const logId = getLogIdentifier(log);
                  const statusMeta = getStatusMeta(log);
                  const initials = getUserPrimary(log).match(/[A-Za-z]/)?.[0]?.toUpperCase() || "?";

                  return (
                    <React.Fragment key={logId}>
                      <TableRow hover>
                        <TableCell>
                          <IconButton
                            size="small"
                            onClick={() => toggleRowExpansion(logId)}
                            aria-label={expandedRows.has(logId) ? "Hide details" : "Show details"}
                          >
                            {expandedRows.has(logId) ? <ExpandLess /> : <ExpandMore />}
                          </IconButton>
                        </TableCell>
                        <TableCell>{formatDateTime(log?.timestamp)}</TableCell>
                        <TableCell>
                          <Box display="flex" alignItems="center" gap={1.5}>
                            <Avatar sx={{ width: 32, height: 32 }}>{initials}</Avatar>
                            <Box>
                              <Typography variant="body2">{getUserPrimary(log)}</Typography>
                              {getUserSecondary(log) && (
                                <Typography variant="caption" color="text.secondary">
                                  {getUserSecondary(log)}
                                </Typography>
                              )}
                            </Box>
                          </Box>
                        </TableCell>
                        <TableCell>{getActionLabel(log)}</TableCell>
                        <TableCell>
                          <Typography variant="body2">{getEntityDisplay(log)}</Typography>
                        </TableCell>
                        <TableCell>{log?.ipAddress || "‚Äî"}</TableCell>
                        <TableCell>
                          <Chip label={statusMeta.label} color={statusMeta.color} size="small" />
                        </TableCell>
                        <TableCell align="right">
                          <Tooltip title="View full details">
                            <span>
                              <IconButton size="small" onClick={() => handleOpenDetails(log)}>
                                <Visibility fontSize="small" />
                              </IconButton>
                            </span>
                          </Tooltip>
                        </TableCell>
                      </TableRow>
                      <TableRow>
                        <TableCell colSpan={8} sx={{ py: 0, border: 0 }}>
                          <Collapse in={expandedRows.has(logId)} timeout="auto" unmountOnExit>
                            <Box sx={{ px: 3, py: 2, bgcolor: "grey.50" }}>
                              <Typography variant="subtitle2" gutterBottom>
                                Summary
                              </Typography>
                              <Typography variant="body2" sx={{ mb: 2 }}>
                                {getDescription(log)}
                              </Typography>
                              {log?.details && (
                                <Box>
                                  <Typography variant="subtitle2" gutterBottom>
                                    Details
                                  </Typography>
                                  <Paper variant="outlined" sx={{ p: 2, maxHeight: 240, overflow: "auto" }}>
                                    <Typography variant="body2" sx={{ whiteSpace: "pre-line" }}>
                                      {stringifyDetails(log.details)}
                                    </Typography>
                                  </Paper>
                                </Box>
                              )}
                            </Box>
                          </Collapse>
                        </TableCell>
                      </TableRow>
                    </React.Fragment>
                  );
                })}
              </TableBody>
            </Table>
          </TableContainer>
          <TablePagination
            component="div"
            count={totalCount}
            page={page}
            onPageChange={(_, newPage) => setPage(newPage)}
            rowsPerPage={rowsPerPage}
            onRowsPerPageChange={(event) => {
              setRowsPerPage(parseInt(event.target.value, 10));
              setPage(0);
            }}
            rowsPerPageOptions={[10, 25, 50, 100]}
          />
        </Paper>

        <Dialog open={detailsOpen} onClose={handleCloseDetails} maxWidth="md" fullWidth>
          <DialogTitle>Audit Log Details</DialogTitle>
          <DialogContent dividers>
            {selectedLog && (
              <Grid container spacing={2}>
                <Grid item xs={12} sm={6}>
                  <Typography variant="subtitle2" color="text.secondary">
                    Timestamp
                  </Typography>
                  <Typography variant="body1">{formatDateTime(selectedLog.timestamp)}</Typography>
                </Grid>
                <Grid item xs={12} sm={6}>
                  <Typography variant="subtitle2" color="text.secondary">
                    User
                  </Typography>
                  <Typography variant="body1">{getUserPrimary(selectedLog)}</Typography>
                  {getUserSecondary(selectedLog) && (
                    <Typography variant="body2" color="text.secondary">
                      {getUserSecondary(selectedLog)}
                    </Typography>
                  )}
                </Grid>
                <Grid item xs={12} sm={6}>
                  <Typography variant="subtitle2" color="text.secondary">
                    Action
                  </Typography>
                  <Typography variant="body1">{getActionLabel(selectedLog)}</Typography>
                </Grid>
                <Grid item xs={12} sm={6}>
                  <Typography variant="subtitle2" color="text.secondary">
                    Entity
                  </Typography>
                  <Typography variant="body1">{getEntityDisplay(selectedLog)}</Typography>
                </Grid>
                <Grid item xs={12} sm={6}>
                  <Typography variant="subtitle2" color="text.secondary">
                    Status
                  </Typography>
                  <Chip
                    label={getStatusMeta(selectedLog).label}
                    color={getStatusMeta(selectedLog).color}
                    size="small"
                    sx={{ mt: 0.5 }}
                  />
                </Grid>
                <Grid item xs={12} sm={6}>
                  <Typography variant="subtitle2" color="text.secondary">
                    IP Address
                  </Typography>
                  <Typography variant="body1">{selectedLog?.ipAddress || "‚Äî"}</Typography>
                </Grid>
                <Grid item xs={12}>
                  <Typography variant="subtitle2" color="text.secondary">
                    Summary
                  </Typography>
                  <Typography variant="body1">{getDescription(selectedLog)}</Typography>
                </Grid>
                {selectedLog?.details && (
                  <Grid item xs={12}>
                    <Typography variant="subtitle2" color="text.secondary" gutterBottom>
                      Details
                    </Typography>
                    <Paper variant="outlined" sx={{ p: 2, maxHeight: 320, overflow: "auto" }}>
                      <Typography variant="body2" sx={{ whiteSpace: "pre-line" }}>
                        {stringifyDetails(selectedLog.details)}
                      </Typography>
                    </Paper>
                  </Grid>
                )}
              </Grid>
            )}
          </DialogContent>
          <DialogActions>
            <Button onClick={handleCloseDetails}>Close</Button>
          </DialogActions>
        </Dialog>
      </Box>
    </LocalizationProvider>
  );
};

export default AuditLogs;
```

## BookCopies.js

| Field | Details |
| --- | --- |
| Program Name | BookCopies.js |
| Description | Frontend page view for routing and page-level UI. |
| Called by | App.js |
| Table used | books |
|  |  |
| Programmer | Nazel Asca√±o |
| Date created | 12/14/2025 |
| Revision Date | TBD |
| Revision / description of change | None |

```javascript
import React, { useState, useEffect } from "react";
import { useParams, useNavigate } from "react-router-dom";
import {
  Box,
  Typography,
  Paper,
  Grid,
  Button,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  Chip,
  IconButton,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  TextField,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  Alert,
  Card,
  CardContent,
  Menu,
  ListItemIcon,
  ListItemText,
  Divider,
} from "@mui/material";
import QRScanner from "../../components/QRScanner";
import {
  Add,
  Edit,
  Delete,
  QrCode,
  MoreVert,
  ArrowBack,
  Visibility,
  Assignment,
  Warning,
  CheckCircle,
  Book,
  Print,
} from "@mui/icons-material";
import { useAuth } from "../../contexts/AuthContext";
import { api } from "../../utils/api";

const BookCopies = () => {
  const { bookId } = useParams();
  const navigate = useNavigate();
  const { user } = useAuth();
  const [book, setBook] = useState(null);
  const [copies, setCopies] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState("");
  const [success, setSuccess] = useState("");
  const [copyDialog, setCopyDialog] = useState(false);
  const [editingCopy, setEditingCopy] = useState(null);
  const [anchorEl, setAnchorEl] = useState(null);
  const [selectedCopy, setSelectedCopy] = useState(null);
  const [copyForm, setCopyForm] = useState({
    copyId: "",
    condition: "good",
    location: "",
    notes: "",
    price: "",
    acquisitionDate: new Date().toISOString().split("T")[0],
  });
  const [scannerOpen, setScannerOpen] = useState(false);

  const conditions = [
    { value: "excellent", label: "Excellent", color: "success" },
    { value: "good", label: "Good", color: "info" },
    { value: "fair", label: "Fair", color: "warning" },
    { value: "poor", label: "Poor", color: "error" },
  ];

  const statuses = [
    { value: "available", label: "Available", color: "success" },
    { value: "borrowed", label: "Borrowed", color: "warning" },
    { value: "reserved", label: "Reserved", color: "info" },
    { value: "lost", label: "Lost", color: "error" },
    { value: "damaged", label: "Damaged", color: "error" },
    { value: "maintenance", label: "Maintenance", color: "default" },
  ];

  useEffect(() => {
    fetchBookDetails();
    fetchCopies();
  }, [bookId]);

  const fetchBookDetails = async () => {
    try {
      const response = await api.get(`/books/${bookId}`);
      setBook(response.data);
    } catch (error) {
      setError("Failed to fetch book details");
      console.error("Error fetching book details:", error);
    }
  };

  const fetchCopies = async () => {
    try {
      setLoading(true);
      const response = await api.get(`/books/${bookId}/copies`);
      setCopies(response.data);
    } catch (error) {
      setError("Failed to fetch book copies");
      console.error("Error fetching copies:", error);
    } finally {
      setLoading(false);
    }
  };

  const handleAddCopy = async () => {
    try {
      await api.post(`/books/${bookId}/copies`, copyForm);
      setSuccess("Copy added successfully");
      setCopyDialog(false);
      resetForm();
      fetchCopies();
      setTimeout(() => setSuccess(""), 3000);
    } catch (error) {
      setError(error.response?.data?.message || "Failed to add copy");
      console.error("Error adding copy:", error);
    }
  };

  const handleUpdateCopy = async () => {
    try {
      await api.put(`/books/${bookId}/copies/${editingCopy._id}`, copyForm);
      setSuccess("Copy updated successfully");
      setCopyDialog(false);
      setEditingCopy(null);
      resetForm();
      fetchCopies();
      setTimeout(() => setSuccess(""), 3000);
    } catch (error) {
      setError(error.response?.data?.message || "Failed to update copy");
      console.error("Error updating copy:", error);
    }
  };

  const handleDeleteCopy = async (copyId) => {
    if (!window.confirm("Are you sure you want to delete this copy?")) return;

    try {
      await api.delete(`/books/${bookId}/copies/${copyId}`);
      setSuccess("Copy deleted successfully");
      fetchCopies();
      setTimeout(() => setSuccess(""), 3000);
    } catch (error) {
      setError(error.response?.data?.message || "Failed to delete copy");
      console.error("Error deleting copy:", error);
    }
  };

  const handleMenuClick = (event, copy) => {
    setAnchorEl(event.currentTarget);
    setSelectedCopy(copy);
  };

  const handleMenuClose = () => {
    setAnchorEl(null);
    setSelectedCopy(null);
  };

  const handlePrintSelectedCopy = async () => {
    if (!selectedCopy?.copyId) {
      handleMenuClose();
      return;
    }

    try {
      setError("");
      const response = await api.get(`/books/${bookId}/copies/barcodes`, {
        params: { copyIds: selectedCopy.copyId },
        responseType: "blob",
      });

      const blob = new Blob([response.data], { type: "application/pdf" });
      const url = window.URL.createObjectURL(blob);
      const link = document.createElement("a");
      link.href = url;
      link.setAttribute("download", `${selectedCopy.copyId}_barcode.pdf`);
      document.body.appendChild(link);
      link.click();
      link.remove();
      setSuccess(`Barcode downloaded for ${selectedCopy.copyId}`);
      setTimeout(() => setSuccess(""), 3000);
      setTimeout(() => window.URL.revokeObjectURL(url), 2000);
    } catch (error) {
      setError("Failed to generate barcode for this copy");
      console.error("Error generating barcode:", error);
    } finally {
      handleMenuClose();
    }
  };

  const handleEditCopy = () => {
    setEditingCopy(selectedCopy);
    setCopyForm({
      copyId: selectedCopy.copyId,
      condition: selectedCopy.condition,
      location: selectedCopy.location || "",
      notes: selectedCopy.notes || "",
      price: selectedCopy.price || "",
      acquisitionDate: selectedCopy.acquisitionDate
        ? selectedCopy.acquisitionDate.split("T")[0]
        : new Date().toISOString().split("T")[0],
    });
    setCopyDialog(true);
    handleMenuClose();
  };

  const resetForm = () => {
    setCopyForm({
      copyId: "",
      condition: "good",
      location: "",
      notes: "",
      price: "",
      acquisitionDate: new Date().toISOString().split("T")[0],
    });
  };

  const generateBarcodes = async () => {
    try {
      const response = await api.get(`/books/${bookId}/copies/barcodes`, {
        responseType: "blob",
      });

      const url = window.URL.createObjectURL(new Blob([response.data]));
      const link = document.createElement("a");
      link.href = url;
      link.setAttribute("download", `${book.title}_barcodes.pdf`);
      document.body.appendChild(link);
      link.click();
      link.remove();
    } catch (error) {
      setError("Failed to generate barcodes");
      console.error("Error generating barcodes:", error);
    }
  };

  const getStatusColor = (status) => {
    const statusObj = statuses.find((s) => s.value === status);
    return statusObj ? statusObj.color : "default";
  };

  const getConditionColor = (condition) => {
    const conditionObj = conditions.find((c) => c.value === condition);
    return conditionObj ? conditionObj.color : "default";
  };

  const canManageCopies = user?.role === "admin" || user?.role === "librarian";

  if (loading) {
    return (
      <Box
        display="flex"
        justifyContent="center"
        alignItems="center"
        minHeight="200px"
      >
        <Typography> Loading copies... </Typography>{" "}
      </Box>
    );
  }

  return (
    <Box>
      <Box display="flex" alignItems="center" mb={3}>
        <IconButton onClick={() => navigate("/books")} sx={{ mr: 2 }}>
          <ArrowBack />
        </IconButton>{" "}
        <Typography variant="h4" gutterBottom sx={{ flexGrow: 1, mb: 0 }}>
          Book Copies - {book?.title}{" "}
        </Typography>{" "}
        {canManageCopies && (
          <Box>
            <Button
              variant="outlined"
              startIcon={<Print />}
              onClick={generateBarcodes}
              sx={{ mr: 2 }}
              disabled={copies.length === 0}
            >
              Print Barcodes{" "}
            </Button>{" "}
            <Button
              variant="contained"
              startIcon={<Add />}
              onClick={() => {
                resetForm();
                setEditingCopy(null);
                setCopyDialog(true);
              }}
            >
              Add Copy{" "}
            </Button>{" "}
          </Box>
        )}{" "}
      </Box>
      {error && (
        <Alert severity="error" sx={{ mb: 2 }}>
          {" "}
          {error}{" "}
        </Alert>
      )}
      {success && (
        <Alert severity="success" sx={{ mb: 2 }}>
          {" "}
          {success}{" "}
        </Alert>
      )}
      {}{" "}
      <Grid container spacing={3} sx={{ mb: 3 }}>
        <Grid item xs={12} sm={6} md={3}>
          <Card>
            <CardContent>
              <Box display="flex" alignItems="center">
                <Book color="primary" sx={{ mr: 2 }} />{" "}
                <Box>
                  <Typography variant="h6"> {copies.length} </Typography>{" "}
                  <Typography variant="body2" color="textSecondary">
                    Total Copies{" "}
                  </Typography>{" "}
                </Box>{" "}
              </Box>{" "}
            </CardContent>{" "}
          </Card>{" "}
        </Grid>{" "}
        <Grid item xs={12} sm={6} md={3}>
          <Card>
            <CardContent>
              <Box display="flex" alignItems="center">
                <CheckCircle color="success" sx={{ mr: 2 }} />{" "}
                <Box>
                  <Typography variant="h6">
                    {" "}
                    {copies.filter((c) => c.status === "available").length}{" "}
                  </Typography>{" "}
                  <Typography variant="body2" color="textSecondary">
                    Available{" "}
                  </Typography>{" "}
                </Box>{" "}
              </Box>{" "}
            </CardContent>{" "}
          </Card>{" "}
        </Grid>{" "}
        <Grid item xs={12} sm={6} md={3}>
          <Card>
            <CardContent>
              <Box display="flex" alignItems="center">
                <Assignment color="warning" sx={{ mr: 2 }} />{" "}
                <Box>
                  <Typography variant="h6">
                    {" "}
                    {copies.filter((c) => c.status === "borrowed").length}{" "}
                  </Typography>{" "}
                  <Typography variant="body2" color="textSecondary">
                    Borrowed{" "}
                  </Typography>{" "}
                </Box>{" "}
              </Box>{" "}
            </CardContent>{" "}
          </Card>{" "}
        </Grid>{" "}
        <Grid item xs={12} sm={6} md={3}>
          <Card>
            <CardContent>
              <Box display="flex" alignItems="center">
                <Warning color="error" sx={{ mr: 2 }} />{" "}
                <Box>
                  <Typography variant="h6">
                    {" "}
                    {
                      copies.filter((c) =>
                        ["lost", "damaged"].includes(c.status),
                      ).length
                    }{" "}
                  </Typography>{" "}
                  <Typography variant="body2" color="textSecondary">
                    Lost / Damaged{" "}
                  </Typography>{" "}
                </Box>{" "}
              </Box>{" "}
            </CardContent>{" "}
          </Card>{" "}
        </Grid>{" "}
      </Grid>
      {}{" "}
      <Paper>
        <TableContainer>
          <Table>
            <TableHead>
              <TableRow>
                <TableCell> Reference ID </TableCell> <TableCell> Status </TableCell>{" "}
                <TableCell> Condition </TableCell>{" "}
                <TableCell> Location </TableCell>{" "}
                <TableCell> Acquisition Date </TableCell>{" "}
                <TableCell> Current Borrower </TableCell>{" "}
                <TableCell> Notes </TableCell>{" "}
                {canManageCopies && (
                  <TableCell align="center"> Actions </TableCell>
                )}{" "}
              </TableRow>{" "}
            </TableHead>{" "}
            <TableBody>
              {" "}
              {copies.map((copy) => (
                <TableRow key={copy._id}>
                  <TableCell>
                    <Box display="flex" alignItems="center">
                      <QrCode sx={{ mr: 1, color: "text.secondary" }} />{" "}
                      <Typography variant="body2" fontWeight="medium">
                        {" "}
                        {copy.copyId}{" "}
                      </Typography>{" "}
                    </Box>{" "}
                  </TableCell>{" "}
                  <TableCell>
                    <Chip
                      label={copy.status}
                      color={getStatusColor(copy.status)}
                      size="small"
                    />
                  </TableCell>{" "}
                  <TableCell>
                    <Chip
                      label={copy.condition}
                      color={getConditionColor(copy.condition)}
                      size="small"
                      variant="outlined"
                    />
                  </TableCell>{" "}
                  <TableCell> {copy.location || "-"} </TableCell>{" "}
                  <TableCell>
                    {" "}
                    {copy.acquisitionDate
                      ? new Date(copy.acquisitionDate).toLocaleDateString()
                      : "-"}{" "}
                  </TableCell>{" "}
                  <TableCell>
                    {" "}
                    {copy.currentBorrower ? (
                      <Box>
                        <Typography variant="body2">
                          {" "}
                          {copy.currentBorrower.name}{" "}
                        </Typography>{" "}
                        <Typography variant="caption" color="textSecondary">
                          Due:{" "}
                          {new Date(copy.dueDate).toLocaleDateString()}{" "}
                        </Typography>{" "}
                      </Box>
                    ) : (
                      "-"
                    )}{" "}
                  </TableCell>{" "}
                  <TableCell>
                    <Typography variant="body2" noWrap sx={{ maxWidth: 150 }}>
                      {" "}
                      {copy.notes || "-"}{" "}
                    </Typography>{" "}
                  </TableCell>{" "}
                  {canManageCopies && (
                    <TableCell align="center">
                      <IconButton
                        onClick={(e) => handleMenuClick(e, copy)}
                        size="small"
                      >
                        <MoreVert />
                      </IconButton>{" "}
                    </TableCell>
                  )}{" "}
                </TableRow>
              ))}{" "}
            </TableBody>{" "}
          </Table>{" "}
        </TableContainer>
        {copies.length === 0 && (
          <Box p={3} textAlign="center">
            <Typography color="textSecondary">
              No copies found for this book{" "}
            </Typography>{" "}
          </Box>
        )}{" "}
      </Paper>
      {}{" "}
      <Menu
        anchorEl={anchorEl}
        open={Boolean(anchorEl)}
        onClose={handleMenuClose}
      >
        <MenuItem onClick={handleEditCopy}>
          <ListItemIcon>
            <Edit />
          </ListItemIcon>{" "}
          <ListItemText> Edit Copy </ListItemText>{" "}
        </MenuItem>{" "}
        <MenuItem onClick={handlePrintSelectedCopy}>
          <ListItemIcon>
            <Print />
          </ListItemIcon>{" "}
          <ListItemText> Print Barcode </ListItemText>{" "}
        </MenuItem>{" "}
        <MenuItem
          onClick={() => {
            navigate(`/books/${bookId}/copies/${selectedCopy._id}/history`);
            handleMenuClose();
          }}
        >
          <ListItemIcon>
            <Visibility />
          </ListItemIcon>{" "}
          <ListItemText> View History </ListItemText>{" "}
        </MenuItem>{" "}
        <Divider />
        <MenuItem
          onClick={() => {
            handleDeleteCopy(selectedCopy._id);
            handleMenuClose();
          }}
          sx={{ color: "error.main" }}
        >
          <ListItemIcon>
            <Delete color="error" />
          </ListItemIcon>{" "}
          <ListItemText> Delete Copy </ListItemText>{" "}
        </MenuItem>{" "}
      </Menu>
      {}{" "}
      <Dialog
        open={copyDialog}
        onClose={() => setCopyDialog(false)}
        maxWidth="sm"
        fullWidth
      >
        <DialogTitle>
          {" "}
          {editingCopy ? "Edit Copy" : "Add New Copy"}{" "}
        </DialogTitle>{" "}
        <DialogContent>
          <Grid container spacing={2}>
            <Grid item xs={12}>
                <Box display="flex" gap={1} alignItems="center">
                  <TextField
                    fullWidth
                    label="Reference ID"
                    value={copyForm.copyId}
                    onChange={(e) => setCopyForm({ ...copyForm, copyId: e.target.value })}
                    margin="normal"
                    required
                    disabled={editingCopy} // Can't change reference ID when editing
                  />
                  {}
                  <Button
                    variant="outlined"
                    size="small"
                    onClick={async () => {

                      setScannerOpen(true);
                    }}
                    sx={{ height: 40 }}
                  >
                    Scan QR
                  </Button>
                </Box>
            </Grid>
            <Grid item xs={12} sm={6}>
              <FormControl fullWidth margin="normal">
                <InputLabel> Condition </InputLabel>{" "}
                <Select
                  value={copyForm.condition}
                  onChange={(e) =>
                    setCopyForm({ ...copyForm, condition: e.target.value })
                  }
                  label="Condition"
                >
                  {conditions.map((condition) => (
                    <MenuItem key={condition.value} value={condition.value}>
                      {" "}
                      {condition.label}{" "}
                    </MenuItem>
                  ))}{" "}
                </Select>{" "}
              </FormControl>{" "}
            </Grid>
            <Grid item xs={12} sm={6}>
              <TextField
                fullWidth
                label="Location"
                value={copyForm.location}
                onChange={(e) =>
                  setCopyForm({ ...copyForm, location: e.target.value })
                }
                margin="normal"
                placeholder="e.g., Shelf A-1, Section B"
              />
            </Grid>
            <Grid item xs={12} sm={6}>
              <TextField
                fullWidth
                label="Price"
                type="number"
                step="0.01"
                value={copyForm.price}
                onChange={(e) =>
                  setCopyForm({ ...copyForm, price: e.target.value })
                }
                margin="normal"
              />
            </Grid>
            <Grid item xs={12} sm={6}>
              <TextField
                fullWidth
                label="Acquisition Date"
                type="date"
                value={copyForm.acquisitionDate}
                onChange={(e) =>
                  setCopyForm({ ...copyForm, acquisitionDate: e.target.value })
                }
                margin="normal"
                InputLabelProps={{ shrink: true }}
              />{" "}
            </Grid>
            <Grid item xs={12}>
              <TextField
                fullWidth
                label="Notes"
                multiline
                rows={3}
                value={copyForm.notes}
                onChange={(e) =>
                  setCopyForm({ ...copyForm, notes: e.target.value })
                }
                margin="normal"
                placeholder="Any additional notes about this copy..."
              />
            </Grid>{" "}
          </Grid>{" "}
        </DialogContent>{" "}
        <DialogActions>
          <Button variant="outlined" onClick={() => setCopyDialog(false)}> Cancel </Button>{" "}
          <Button
            onClick={editingCopy ? handleUpdateCopy : handleAddCopy}
            variant="contained"
            disabled={!copyForm.copyId}
          >
            {editingCopy ? "Update Copy" : "Add Copy"}{" "}
          </Button>{" "}
        </DialogActions>{" "}
      </Dialog>{" "}
      {}
      <Dialog open={scannerOpen} onClose={() => setScannerOpen(false)} maxWidth="sm" fullWidth>
        <DialogTitle>Scan Reference QR</DialogTitle>
        <DialogContent>
          <QRScanner
            onDetected={(decodedText) => {

              setCopyForm((prev) => ({ ...prev, copyId: decodedText }));
              setScannerOpen(false);
              setSuccess("Scanned reference ID populated");
              setTimeout(() => setSuccess(""), 2500);
            }}
          />
        </DialogContent>
        <DialogActions>
          <Button variant="outlined" onClick={() => setScannerOpen(false)}>Cancel</Button>
        </DialogActions>
      </Dialog>
    </Box>
  );
};

export default BookCopies;
```

## BookDetails.js

| Field | Details |
| --- | --- |
| Program Name | BookDetails.js |
| Description | Frontend page view for routing and page-level UI. |
| Called by | App.js |
| Table used | books |
|  |  |
| Programmer | Nazel Asca√±o |
| Date created | 12/14/2025 |
| Revision Date | TBD |
| Revision / description of change | None |

```javascript
import React, { useState, useEffect, useCallback } from "react";
import { useParams, useNavigate } from "react-router-dom";
import {
  Box,
  Typography,
  Paper,
  Grid,
  Button,
  Chip,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  TextField,
  Alert,
  List,
  ListItem,
  ListItemText,
  ListItemIcon,
  IconButton,
} from "@mui/material";
import {
  ArrowBack,
  Add,
  Delete,
  Book,
  LocalLibrary,
  History,
  CheckCircle,
  Print,
} from "@mui/icons-material";
import { useAuth } from "../../contexts/AuthContext";
import { api } from "../../utils/api";
import { extractUniqueAuthors, formatAuthorsList } from "../../utils/authorDisplay";

const BookDetails = () => {
  const { id } = useParams();
  const navigate = useNavigate();
  const { user } = useAuth();
  const [book, setBook] = useState(null);
  const [copies, setCopies] = useState([]);
  const [borrowingHistory, setBorrowingHistory] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState("");
  const [copyDialog, setCopyDialog] = useState(false);
  const [newCopy, setNewCopy] = useState({
    copyId: "",
    condition: "good",
    notes: "",
  });

  const fetchBookDetails = useCallback(async () => {
    try {
      const response = await api.get(`/books/${id}`);
      setBook(response.data);
    } catch (error) {
      setError("Failed to fetch book details");
      console.error("Error fetching book details:", error);
    }
  }, [id]);

  const fetchBookCopies = useCallback(async () => {
    try {
      const response = await api.get(`/books/${id}/copies`);
      setCopies(response.data);
    } catch (error) {
      console.error("Error fetching book copies:", error);
    }
  }, [id]);

  const fetchBorrowingHistory = useCallback(async () => {
    try {
  const response = await api.get(`/books/${id}/history`);
  setBorrowingHistory(response.data || []);
    } catch (error) {
      console.error("Error fetching borrowing history:", error);
    } finally {
      setLoading(false);
    }
  }, [id]);

  useEffect(() => {
    fetchBookDetails();
    fetchBookCopies();
    fetchBorrowingHistory();
  }, [fetchBookDetails, fetchBookCopies, fetchBorrowingHistory]);

  const handleAddCopy = async () => {
    try {
      await api.post(`/books/${id}/copies`, newCopy);
      setNewCopy({ copyId: "", condition: "good", notes: "" });
      setCopyDialog(false);
      fetchBookCopies();
    } catch (error) {
      setError("Failed to add book copy");
      console.error("Error adding copy:", error);
    }
  };

  const handleDeleteCopy = async (copyId) => {
    if (window.confirm("Are you sure you want to delete this copy?")) {
      try {
        await api.delete(`/books/${id}/copies/${copyId}`);
        fetchBookCopies();
      } catch (error) {
        setError("Failed to delete book copy");
        console.error("Error deleting copy:", error);
      }
    }
  };

  const handlePrintCopy = async (copyId) => {
    if (!copyId) {
      return;
    }

    try {
      setError("");
      const response = await api.get(`/books/${id}/copies/barcodes`, {
        params: { copyIds: copyId },
        responseType: "blob",
      });

      const blob = new Blob([response.data], { type: "application/pdf" });
      const url = window.URL.createObjectURL(blob);
      const link = document.createElement("a");
      link.href = url;
      link.setAttribute("download", `${copyId}_barcode.pdf`);
      document.body.appendChild(link);
      link.click();
      link.remove();
      setTimeout(() => window.URL.revokeObjectURL(url), 2000);
    } catch (error) {
      setError("Failed to generate barcode for this copy");
      console.error("Error generating barcode:", error);
    }
  };

  const getStatusColor = (status) => {
    switch (status) {
      case "available":
        return "success";
      case "borrowed":
        return "warning";
      case "lost":
        return "error";
      case "damaged":
        return "error";
      default:
        return "default";
    }
  };

  const getConditionColor = (condition) => {
    switch (condition) {
      case "excellent":
        return "success";
      case "good":
        return "info";
      case "fair":
        return "warning";
      case "poor":
        return "error";
      default:
        return "default";
    }
  };

  const canManageCopies = user?.role === "admin" || user?.role === "librarian";

  const formatDate = (value) => {
    if (!value) {
      return "-";
    }

    const parsed = new Date(value);
    if (Number.isNaN(parsed.getTime())) {
      return "-";
    }

    return parsed.toLocaleDateString();
  };

  if (loading) {
    return (
      <Box display="flex" justifyContent="center" alignItems="center" minHeight="200px">
        <Typography>Loading book details...</Typography>
      </Box>
    );
  }

  if (!book) {
    return (
      <Box>
        <Alert severity="error">Book not found</Alert>
      </Box>
    );
  }

  const authorsList = extractUniqueAuthors(book);

  return (
    <Box>
      <Box display="flex" alignItems="center" mb={3}>
        <IconButton onClick={() => navigate("/books")} sx={{ mr: 2 }}>
          <ArrowBack />
        </IconButton>
        <Typography variant="h4" gutterBottom sx={{ flexGrow: 1, mb: 0 , color: "white"}}>
          {book.title}
        </Typography>
      </Box>
      {error && (
        <Alert severity="error" sx={{ mb: 2 }}>
          {error}
        </Alert>
      )}
      <Grid container spacing={3}>
        <Grid item xs={12} md={8}>
          <Paper sx={{ p: 3, mb: 3 }}>
            <Typography variant="h6" gutterBottom>
              Book Information
            </Typography>
            <Grid container spacing={2}>
              <Grid item xs={12} sm={6}>
                <Typography variant="subtitle2" color="textSecondary">
                  Author
                </Typography>
                {authorsList.length > 0 ? (
                  <Box display="flex" gap={1} flexWrap="wrap" mt={1}>
                    {authorsList.map((author) => (
                      <Chip key={author} label={author} size="small" />
                    ))}
                  </Box>
                ) : (
                  <Typography variant="body1" gutterBottom>
                    {formatAuthorsList(book)}
                  </Typography>
                )}
              </Grid>
              <Grid item xs={12} sm={6}>
                <Typography variant="subtitle2" color="textSecondary">
                  ISBN
                </Typography>
                <Typography variant="body1" gutterBottom>
                  {book.isbn}
                </Typography>
              </Grid>
              <Grid item xs={12} sm={6}>
                <Typography variant="subtitle2" color="textSecondary">
                  Category
                </Typography>
                <Typography variant="body1" gutterBottom>
                  {book.category}
                </Typography>
              </Grid>
              <Grid item xs={12} sm={6}>
                <Typography variant="subtitle2" color="textSecondary">
                  Publication Year
                </Typography>
                <Typography variant="body1" gutterBottom>
                  {book.publicationYear}
                </Typography>
              </Grid>
              <Grid item xs={12} sm={6}>
                <Typography variant="subtitle2" color="textSecondary">
                  Publisher
                </Typography>
                <Typography variant="body1" gutterBottom>
                  {book.publisher || "Not specified"}
                </Typography>
              </Grid>
              <Grid item xs={12} sm={6}>
                <Typography variant="subtitle2" color="textSecondary">
                  Language
                </Typography>
                <Typography variant="body1" gutterBottom>
                  {book.language || "English"}
                </Typography>
              </Grid>
              <Grid item xs={12}>
                <Typography variant="subtitle2" color="textSecondary">
                  Description
                </Typography>
                <Typography variant="body1">
                  {book.description || "No description available"}
                </Typography>
              </Grid>
            </Grid>
          </Paper>
          <Paper sx={{ p: 3 }}>
            <Typography variant="h6" gutterBottom>
              Borrowing History
            </Typography>
            {borrowingHistory.length > 0 ? (
              <TableContainer>
                <Table>
                  <TableHead>
                    <TableRow>
                      <TableCell>Reference ID</TableCell>
                      <TableCell>Borrower</TableCell>
                      <TableCell>Borrowed Date</TableCell>
                      <TableCell>Due Date</TableCell>
                      <TableCell>Returned Date</TableCell>
                      <TableCell>Status</TableCell>
                    </TableRow>
                  </TableHead>
                  <TableBody>
                    {borrowingHistory.map((transaction) => (
                      <TableRow key={transaction._id}>
                        <TableCell>{transaction.copyId}</TableCell>
                        <TableCell>{transaction.borrowerName}</TableCell>
                        <TableCell>{formatDate(transaction.borrowDate)}</TableCell>
                        <TableCell>{formatDate(transaction.dueDate)}</TableCell>
                        <TableCell>{formatDate(transaction.returnDate)}</TableCell>
                        <TableCell>
                          <Chip
                            label={transaction.status}
                            color={getStatusColor(transaction.status)}
                            size="small"
                          />
                        </TableCell>
                      </TableRow>
                    ))}
                  </TableBody>
                </Table>
              </TableContainer>
            ) : (
              <Typography color="textSecondary">
                No borrowing history available
              </Typography>
            )}
          </Paper>
        </Grid>
        <Grid item xs={12} md={4}>
          <Paper sx={{ p: 3, mb: 3 }}>
            <Box display="flex" justifyContent="space-between" alignItems="center" mb={2}>
              <Typography variant="h6">Book Copies</Typography>
              {canManageCopies && (
                <Button
                  variant="contained"
                  size="small"
                  startIcon={<Add />}
                  onClick={() => setCopyDialog(true)}
                >
                  Add Copy
                </Button>
              )}
            </Box>
            <List>
              {copies.map((copy) => (
                <ListItem
                  key={copy.copyId}
                  secondaryAction={
                    canManageCopies && (
                      <Box display="flex" alignItems="center" gap={1}>
                        <IconButton edge="end" onClick={() => handlePrintCopy(copy.copyId)} aria-label="Print barcode">
                          <Print fontSize="small" />
                        </IconButton>
                        <IconButton edge="end" onClick={() => handleDeleteCopy(copy.copyId)} color="error" aria-label="Delete copy">
                          <Delete />
                        </IconButton>
                      </Box>
                    )
                  }
                >
                  <ListItemIcon>
                    <Book />
                  </ListItemIcon>
                  <ListItemText
                    primary={`Copy ${copy.copyId}`}
                    secondaryTypographyProps={{ component: "div" }}
                    secondary={
                      <Box display="flex" flexWrap="wrap" gap={1} mt={1}>
                        <Chip
                          label={copy.status}
                          color={getStatusColor(copy.status)}
                          size="small"
                        />
                        <Chip
                          label={copy.condition}
                          color={getConditionColor(copy.condition)}
                          size="small"
                        />
                        {copy.notes && (
                          <Typography variant="caption" component="span">
                            {copy.notes}
                          </Typography>
                        )}
                      </Box>
                    }
                  />
                </ListItem>
              ))}
            </List>
            {copies.length === 0 && (
              <Typography color="textSecondary" textAlign="center">
                No copies available
              </Typography>
            )}
          </Paper>
          <Paper sx={{ p: 3 }}>
            <Typography variant="h6" gutterBottom>
              Statistics
            </Typography>
            <List>
              <ListItem>
                <ListItemIcon>
                  <Book />
                </ListItemIcon>
                <ListItemText primary="Total Copies" secondary={copies.length} />
              </ListItem>
              <ListItem>
                <ListItemIcon>
                  <CheckCircle color="success" />
                </ListItemIcon>
                <ListItemText
                  primary="Available"
                  secondary={copies.filter((c) => c.status === "available").length}
                />
              </ListItem>
              <ListItem>
                <ListItemIcon>
                  <LocalLibrary color="warning" />
                </ListItemIcon>
                <ListItemText
                  primary="Borrowed"
                  secondary={copies.filter((c) => c.status === "borrowed").length}
                />
              </ListItem>
              <ListItem>
                <ListItemIcon>
                  <History />
                </ListItemIcon>
                <ListItemText primary="Total Transactions" secondary={borrowingHistory.length} />
              </ListItem>
            </List>
          </Paper>
        </Grid>
      </Grid>
      <Dialog open={copyDialog} onClose={() => setCopyDialog(false)} maxWidth="sm" fullWidth>
        <DialogTitle>Add New Copy</DialogTitle>
        <DialogContent>
          <TextField
            autoFocus
            margin="dense"
            label="Reference ID"
            fullWidth
            variant="outlined"
            value={newCopy.copyId}
            onChange={(e) => setNewCopy({ ...newCopy, copyId: e.target.value })}
            sx={{ mb: 2 }}
          />
          <TextField
            select
            margin="dense"
            label="Condition"
            fullWidth
            variant="outlined"
            value={newCopy.condition}
            onChange={(e) => setNewCopy({ ...newCopy, condition: e.target.value })}
            SelectProps={{ native: true }}
            sx={{ mb: 2 }}
          >
            <option value="excellent">Excellent</option>
            <option value="good">Good</option>
            <option value="fair">Fair</option>
            <option value="poor">Poor</option>
          </TextField>
          <TextField
            margin="dense"
            label="Notes (Optional)"
            fullWidth
            multiline
            rows={3}
            variant="outlined"
            value={newCopy.notes}
            onChange={(e) => setNewCopy({ ...newCopy, notes: e.target.value })}
          />
        </DialogContent>
        <DialogActions>
          <Button variant="outlined" onClick={() => setCopyDialog(false)}>Cancel</Button>
          <Button onClick={handleAddCopy} variant="contained" disabled={!newCopy.copyId}>
            Add Copy
          </Button>
        </DialogActions>
      </Dialog>
    </Box>
  );
};

export default BookDetails;
```

## BookForm.js

| Field | Details |
| --- | --- |
| Program Name | BookForm.js |
| Description | Frontend page view for routing and page-level UI. |
| Called by | App.js |
| Table used | books |
|  |  |
| Programmer | Nazel Asca√±o |
| Date created | 12/14/2025 |
| Revision Date | TBD |
| Revision / description of change | None |

```javascript
import React, { useState, useEffect, useCallback, useMemo } from "react";
import {
  Box,
  Typography,
  Button,
  TextField,
  Card,
  CardContent,
  Grid,
  MenuItem,
  FormControl,
  InputLabel,
  Select,
  Chip,
  IconButton,
  Paper,
  Alert,
  CircularProgress,
  InputAdornment,
  FormHelperText,
} from "@mui/material";
import {
  Save,
  Cancel,
  Add,
  Remove,
  ArrowBack,
  WarningAmber,
} from "@mui/icons-material";
import { useNavigate, useParams } from "react-router-dom";
import { api, booksAPI, downloadFile } from "../../utils/api";
import toast from "react-hot-toast";

const BASE_CATEGORIES = [
  "Fiction",
  "Non-Fiction",
  "Science",
  "Mathematics",
  "History",
  "Literature",
  "Technology",
  "Arts",
  "Religion",
  "Philosophy",
  "Biography",
  "Self-Help",
  "Children",
  "Reference",
  "Textbook",
];

const sanitizeFilename = (value, fallback) => {
  if (!value) {
    return fallback;
  }
  const cleaned = value.trim().replace(/[^a-zA-Z0-9._-]+/g, "_");
  return cleaned.length > 0 ? cleaned : fallback;
};

const extractFilename = (disposition, fallback) => {
  if (!disposition) {
    return fallback;
  }

  const utf8Match = disposition.match(/filename\*=UTF-8''([^;]+)/i);
  if (utf8Match && utf8Match[1]) {
    try {
      const decoded = decodeURIComponent(utf8Match[1]);
      return sanitizeFilename(decoded, fallback);
    } catch (error) {
      return fallback;
    }
  }

  const quotedMatch = disposition.match(/filename="?([^";]+)"?/i);
  if (quotedMatch && quotedMatch[1]) {
    return sanitizeFilename(quotedMatch[1], fallback);
  }

  return fallback;
};

const sanitizeCategoryValue = (value) => {
  if (typeof value !== "string") {
    return "";
  }
  return value.trim();
};

const extractAuthorsFromRecord = (record) => {
  if (!record) {
    return [];
  }

  if (Array.isArray(record.authors) && record.authors.length > 0) {
    return record.authors
      .map((author) => (typeof author === "string" ? author.trim() : ""))
      .filter(Boolean);
  }

  if (typeof record.author === "string" && record.author.trim() !== "") {
    return record.author
      .split(/[,;|]/)
      .map((author) => author.trim())
      .filter(Boolean);
  }

  return [];
};

const BookForm = () => {
  const navigate = useNavigate();
  const { id } = useParams();
  const isEditing = Boolean(id);

  const [formData, setFormData] = useState({
    title: "",
    authors: [],
    isbn: "",
    category: "",
    publisher: "",
    publicationDate: "",
    description: "",
    language: "English",
    pages: "",
    deweyDecimal: "",
    copies: [{ copyId: "", status: "available", location: "" }],
  });

  const [authorInput, setAuthorInput] = useState("");

  const [loading, setLoading] = useState(false);
  const [errors, setErrors] = useState({});
  const [duplicateBook, setDuplicateBook] = useState(null);
  const [checkingIsbn, setCheckingIsbn] = useState(false);
  const [prefilledIsbn, setPrefilledIsbn] = useState(null);

  const [categories, setCategories] = useState(() => [...BASE_CATEGORIES]);

  const appendCategoryOption = useCallback((value) => {
    const normalized = sanitizeCategoryValue(value);
    if (!normalized) {
      return;
    }

    setCategories((prev) =>
      prev.includes(normalized) ? prev : [...prev, normalized],
    );
  }, []);

  const categoryOptions = useMemo(() => {
    const seen = new Set();
    return categories.reduce((list, entry) => {
      const normalized = sanitizeCategoryValue(entry);
      if (!normalized || seen.has(normalized)) {
        return list;
      }
      seen.add(normalized);
      list.push(normalized);
      return list;
    }, []);
  }, [categories]);

  const copyStatuses = [
    "available",
    "borrowed",
    "lost",
    "damaged",
    "maintenance",
  ];

  const fetchBook = useCallback(async () => {
    try {
      setLoading(true);
      const response = await api.get(`/books/${id}`);
      const book = response.data?.book || response.data;
      if (!book) {
        throw new Error("Book payload missing in response");
      }
      const normalizedAuthors = extractAuthorsFromRecord(book);
      setFormData({
        ...book,
        authors: normalizedAuthors,
        publicationDate: book.publicationDate
          ? book.publicationDate.split("T")[0]
          : "",
        copies:
          book.copies && book.copies.length > 0
            ? book.copies
            : [{ copyId: "", status: "available", location: "" }],
      });
      appendCategoryOption(book.category);
    } catch (error) {
      console.error("Failed to fetch book:", error);
      toast.error("Failed to load book details");
      navigate("/books");
    } finally {
      setLoading(false);
    }
  }, [id, navigate, appendCategoryOption]);

  useEffect(() => {
    if (isEditing) {
      fetchBook();
    }
  }, [isEditing, fetchBook]);

  useEffect(() => {
    if (isEditing) {
      setDuplicateBook(null);
      setPrefilledIsbn(null);
      setCheckingIsbn(false);
      return;
    }

    const trimmedIsbn = formData.isbn.trim();
    if (!trimmedIsbn) {
      setDuplicateBook(null);
      setPrefilledIsbn(null);
      setCheckingIsbn(false);
      return;
    }

    let isActive = true;
    setCheckingIsbn(true);

    const timeoutId = setTimeout(async () => {
      try {
        const response = await booksAPI.getAll({ search: trimmedIsbn, limit: 10 });
        if (!isActive) {
          return;
        }
        const match = (response.data?.books || []).find(
          (book) => (book.isbn || "").toLowerCase() === trimmedIsbn.toLowerCase(),
        );
        setDuplicateBook(match || null);
      } catch (error) {
        if (isActive) {
          setDuplicateBook(null);
        }
      } finally {
        if (isActive) {
          setCheckingIsbn(false);
        }
      }
    }, 400);

    return () => {
      isActive = false;
      clearTimeout(timeoutId);
    };
  }, [formData.isbn, isEditing]);

  useEffect(() => {
    if (!duplicateBook) {
      setPrefilledIsbn(null);
      return;
    }

    if (isEditing || prefilledIsbn === duplicateBook.isbn) {
      return;
    }

    appendCategoryOption(duplicateBook.category);
    const duplicateAuthors = extractAuthorsFromRecord(duplicateBook);

    setFormData((prev) => ({
      ...prev,
      title: prev.title || duplicateBook.title || "",
      authors: prev.authors.length > 0 ? prev.authors : duplicateAuthors,
      category: prev.category || duplicateBook.category || "",
      publisher: prev.publisher || duplicateBook.publisher || "",
      description: prev.description || duplicateBook.description || "",
    }));
    setErrors((prev) => {
      const next = { ...prev };
      delete next.title;
      delete next.authors;
      delete next.category;
      return next;
    });
    setPrefilledIsbn(duplicateBook.isbn);
  }, [duplicateBook, isEditing, prefilledIsbn, appendCategoryOption]);

  const handleChange = (e) => {
    const { name, value } = e.target;
    setFormData((prev) => ({
      ...prev,
      [name]: value,
    }));

    if (errors[name]) {
      setErrors((prev) => ({
        ...prev,
        [name]: "",
      }));
    }
  };

  const appendAuthor = (value) => {
    if (typeof value !== "string") {
      return false;
    }
    const normalized = value.replace(/\s+/g, " ").trim();
    if (!normalized) {
      return false;
    }

    let added = false;
    setFormData((prev) => {
      const exists = prev.authors.some(
        (author) => author.toLowerCase() === normalized.toLowerCase(),
      );
      if (exists) {
        return prev;
      }
      added = true;
      return {
        ...prev,
        authors: [...prev.authors, normalized],
      };
    });

    if (added) {
      setErrors((prev) => ({
        ...prev,
        authors: "",
      }));
      setAuthorInput("");
    }

    return added;
  };

  const handleAuthorInputKeyDown = (event) => {
    if (event.key === "Enter" || event.key === ",") {
      event.preventDefault();
      appendAuthor(authorInput);
    }
  };

  const handleAddAuthor = () => {
    appendAuthor(authorInput);
  };

  const handleRemoveAuthor = (authorToRemove) => {
    setFormData((prev) => ({
      ...prev,
      authors: prev.authors.filter((author) => author !== authorToRemove),
    }));
  };

  const handleCopyChange = (index, field, value) => {
    setFormData((prev) => ({
      ...prev,
      copies: prev.copies.map((copy, i) =>
        i === index ? { ...copy, [field]: value } : copy,
      ),
    }));
  };

  const addCopy = () => {
    setFormData((prev) => ({
      ...prev,
      copies: [
        ...prev.copies,
        { copyId: "", status: "available", location: "" },
      ],
    }));
  };

  const removeCopy = (index) => {
    if (formData.copies.length > 1) {
      setFormData((prev) => ({
        ...prev,
        copies: prev.copies.filter((_, i) => i !== index),
      }));
    }
  };

  const validateForm = () => {
    const newErrors = {};
    const isDuplicateIsbn = Boolean(!isEditing && duplicateBook);

    if (!formData.isbn.trim()) {
      newErrors.isbn = "ISBN is required";
    }

    if (!isDuplicateIsbn) {
      if (!formData.title.trim()) newErrors.title = "Title is required";
      if (!formData.category) newErrors.category = "Category is required";
    }

    if (formData.pages) {
      const parsedPages = parseInt(formData.pages, 10);
      if (Number.isNaN(parsedPages) || parsedPages <= 0) {
        newErrors.pages = "Invalid page count";
      }
    }

    if (formData.copies.length === 0) {
      newErrors.copies = "At least one copy is required";
    }

    if (isEditing) {
      const seenCopyIds = new Set();
      formData.copies.forEach((copy, index) => {
        const trimmedCopyId = (copy.copyId || "").trim();
        if (!trimmedCopyId) {
          newErrors[`copy_${index}_id`] = "Reference ID is required";
          return;
        }

        const normalizedCopyId = trimmedCopyId.toUpperCase();
        if (seenCopyIds.has(normalizedCopyId)) {
          newErrors[`copy_${index}_id`] = "Duplicate reference ID";
          return;
        }

        seenCopyIds.add(normalizedCopyId);
      });
    }

    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  const handleSubmit = async (e) => {
    e.preventDefault();

    if (!validateForm()) {
      toast.error("Please fix the errors before submitting");
      return;
    }

    setLoading(true);
    try {
      const sanitizedCopies = formData.copies.map((copy) => {
        const payload = {
          status: copy.status,
          location: copy.location,
        };

        if (isEditing && copy.copyId) {
          payload.copyId = copy.copyId.trim();
        }

        return payload;
      });

      const parsedPages = formData.pages ? parseInt(formData.pages, 10) : undefined;
      const normalizedAuthors = formData.authors
        .map((author) => author.replace(/\s+/g, " ").trim())
        .filter(Boolean);

      const requestPayload = {
        title: formData.title.trim(),
        author: normalizedAuthors.join(", "),
        authors: normalizedAuthors,
        isbn: formData.isbn.trim(),
        category: formData.category,
        publisher: formData.publisher,
        publicationDate: formData.publicationDate || null,
        description: formData.description,
        language: formData.language,
        pages: Number.isNaN(parsedPages) ? undefined : parsedPages,
        deweyDecimal: formData.deweyDecimal,
        copies: sanitizedCopies,
        numberOfCopies: sanitizedCopies.length,
        location: sanitizedCopies[0]?.location || "main-library",
      };

      if (!requestPayload.title && duplicateBook) {
        requestPayload.title = duplicateBook.title;
      }
      if ((!requestPayload.authors || requestPayload.authors.length === 0) && duplicateBook) {
        const duplicateAuthors = extractAuthorsFromRecord(duplicateBook);
        if (duplicateAuthors.length > 0) {
          requestPayload.authors = duplicateAuthors;
          requestPayload.author = duplicateAuthors.join(", ");
        }
      }
      if (!requestPayload.category && duplicateBook) {
        requestPayload.category = duplicateBook.category;
      }
      if (!requestPayload.publisher && duplicateBook) {
        requestPayload.publisher = duplicateBook.publisher;
      }
      if (!requestPayload.description && duplicateBook) {
        requestPayload.description = duplicateBook.description;
      }

      let barcodeDownloadContext = null;

      if (isEditing) {
        await api.put(`/books/${id}`, requestPayload);
        toast.success("Book updated successfully");
      } else {
        const response = await booksAPI.create(requestPayload);
        const duplicateUpdate = response.data?.duplicate;
        const successMessage =
          response.data?.message ||
          (duplicateUpdate
            ? "Existing book found. Added copies successfully."
            : "Book created successfully");
        toast.success(successMessage);

        const responseCopyIds = Array.isArray(response.data?.copyIds)
          ? response.data.copyIds
          : Array.isArray(response.data?.addedCopyIds)
            ? response.data.addedCopyIds
            : [];

        if (response.data?.bookId && responseCopyIds.length > 0) {
          barcodeDownloadContext = {
            bookId: response.data.bookId,
            copyIds: responseCopyIds,
            title:
              requestPayload.title ||
              duplicateBook?.title ||
              formData.title ||
              "book",
          };
        }
      }

      if (barcodeDownloadContext) {
        try {
          const barcodeResponse = await booksAPI.downloadBarcodes(
            barcodeDownloadContext.bookId,
            { copyIds: barcodeDownloadContext.copyIds },
          );

          const fallbackName = sanitizeFilename(
            `${barcodeDownloadContext.title}_${barcodeDownloadContext.copyIds.length}_barcodes.pdf`,
            "book_barcodes.pdf",
          );
          const filename = extractFilename(
            barcodeResponse.headers?.["content-disposition"],
            fallbackName,
          );
          downloadFile(barcodeResponse.data, filename);
          toast.success("Barcode labels downloaded");
        } catch (downloadError) {
          console.error("Barcode download failed:", downloadError);
          toast.error("Book saved, but barcode download failed");
        }
      }

      navigate("/books");
    } catch (error) {
      console.error("Failed to save book:", error);
      toast.error(error.response?.data?.message || "Failed to save book");
    } finally {
      setLoading(false);
    }
  };

  const isbnHelperText =
    errors.isbn ||
    (duplicateBook && !isEditing
      ? "Existing book detected. Saving will add new copies."
      : checkingIsbn
        ? "Checking ISBN..."
        : "");

  if (isEditing && loading) {
    return (
      <Box
        display="flex"
        justifyContent="center"
        alignItems="center"
        minHeight="60vh"
      >
        <Typography> Loading book details... </Typography>{" "}
      </Box>
    );
  }

  return (
    <Box>
      <Box display="flex" alignItems="center" mb={3}>
        <IconButton onClick={() => navigate("/books")} sx={{ mr: 2 }}>
          <ArrowBack />
        </IconButton>
        <Typography variant="h4" gutterBottom sx={{ flexGrow: 1, mb: 0, color:"white" }}>
          {isEditing ? "Edit Book" : "Add New Book"}
        </Typography>
      </Box>

      {duplicateBook && !isEditing && (
        <Alert
          severity="warning"
          icon={<WarningAmber fontSize="inherit" />}
          sx={{ mb: 3 }}
        >
          A book with ISBN <strong>{duplicateBook.isbn}</strong> already exists.
          Saving will append {formData.copies.length} additional {formData.copies.length === 1 ? "copy" : "copies"} to "{duplicateBook.title || "existing book"}".
        </Alert>
      )}

      <form onSubmit={handleSubmit}>
        <Grid container spacing={3}>
          {" "}
          {}{" "}
          <Grid item xs={12}>
            <Card>
              <CardContent>
                <Typography variant="h6" gutterBottom>
                  Basic Information{" "}
                </Typography>{" "}
                <Grid container spacing={2}>
                  <Grid item xs={12} md={6}>
                    <TextField
                      fullWidth
                      label="Title"
                      name="title"
                      value={formData.title}
                      onChange={handleChange}
                      error={Boolean(errors.title)}
                      helperText={errors.title}
                      required={!duplicateBook || isEditing}
                    />
                  </Grid>{" "}
                  <Grid item xs={12} md={6}>
                    <Box display="flex" gap={1} flexWrap="wrap">
                      <TextField
                        fullWidth
                        label="Add Author"
                        value={authorInput}
                        onChange={(e) => setAuthorInput(e.target.value)}
                        onKeyDown={handleAuthorInputKeyDown}
                        error={Boolean(errors.authors)}
                        helperText={errors.authors || "Press Enter after each author"}
                        sx={{ flexGrow: 1, minWidth: 220 }}
                      />
                      <Button
                        variant="outlined"
                        onClick={handleAddAuthor}
                        sx={{ alignSelf: "flex-start", minWidth: 80 }}
                      >
                        Add
                      </Button>
                    </Box>
                    <Box mt={1} display="flex" gap={1} flexWrap="wrap">
                      {formData.authors.length === 0 ? (
                        <Typography variant="caption" color="text.secondary">
                          No authors added yet.
                        </Typography>
                      ) : (
                        formData.authors.map((author) => (
                          <Chip
                            key={author}
                            label={author}
                            variant="outlined"
                            onDelete={() => handleRemoveAuthor(author)}
                          />
                        ))
                      )}
                    </Box>
                  </Grid>{" "}
                  <Grid item xs={12} md={6}>
                    <TextField
                      fullWidth
                      label="ISBN"
                      name="isbn"
                      value={formData.isbn}
                      onChange={handleChange}
                      error={Boolean(errors.isbn)}
                      helperText={isbnHelperText}
                      InputProps={{
                        endAdornment: checkingIsbn ? (
                          <InputAdornment position="end">
                            <CircularProgress size={18} />
                          </InputAdornment>
                        ) : undefined,
                      }}
                      required
                    />
                  </Grid>{" "}
                  <Grid item xs={12} md={6}>
                    <FormControl
                      fullWidth
                      required={!duplicateBook || isEditing}
                      error={Boolean(errors.category)}
                    >
                      <InputLabel> Category </InputLabel>{" "}
                      <Select
                        name="category"
                        value={formData.category}
                        onChange={handleChange}
                        label="Category"
                      >
                        {categoryOptions.map((category) => (
                          <MenuItem key={category} value={category}>
                            {category}
                          </MenuItem>
                        ))}
                      </Select>
                      {errors.category && (
                        <FormHelperText error>
                          {errors.category}
                        </FormHelperText>
                      )}
                    </FormControl>{" "}
                  </Grid>{" "}
                  <Grid item xs={12} md={6}>
                    <TextField
                      fullWidth
                      label="Publisher"
                      name="publisher"
                      value={formData.publisher}
                      onChange={handleChange}
                    />{" "}
                  </Grid>{" "}
                  <Grid item xs={12} md={6}>
                    <TextField
                      fullWidth
                      label="Publication Date"
                      name="publicationDate"
                      type="date"
                      value={formData.publicationDate}
                      onChange={handleChange}
                      InputLabelProps={{ shrink: true }}
                    />{" "}
                  </Grid>{" "}
                  <Grid item xs={12} md={6}>
                    <TextField
                      fullWidth
                      label="Language"
                      name="language"
                      value={formData.language}
                      onChange={handleChange}
                    />{" "}
                  </Grid>{" "}
                  <Grid item xs={12} md={6}>
                    <TextField
                      fullWidth
                      label="Number of Pages"
                      name="pages"
                      type="number"
                      value={formData.pages}
                      onChange={handleChange}
                      error={Boolean(errors.pages)}
                      helperText={errors.pages}
                    />{" "}
                  </Grid>{" "}
                  <Grid item xs={12}>
                    <TextField
                      fullWidth
                      label="Description"
                      name="description"
                      multiline
                      rows={3}
                      value={formData.description}
                      onChange={handleChange}
                    />{" "}
                  </Grid>{" "}
                </Grid>{" "}
              </CardContent>{" "}
            </Card>{" "}
          </Grid>
          {}{" "}
          <Grid item xs={12}>
            <Card>
              <CardContent>
                <Box
                  display="flex"
                  justifyContent="space-between"
                  alignItems="center"
                  mb={2}
                >
                  <Typography variant="h6">
                    Book Copies({formData.copies.length}){" "}
                  </Typography>{" "}
                  <Button
                    startIcon={<Add />}
                    onClick={addCopy}
                    variant="outlined"
                    size="small"
                  >
                    Add Copy{" "}
                  </Button>{" "}
                </Box>
                {!isEditing && (
                  <Alert severity="info" sx={{ mb: 2 }}>
                    Reference IDs are generated automatically once the book is saved.
                  </Alert>
                )}
                {errors.copies && (
                  <Typography
                    variant="caption"
                    color="error"
                    sx={{ display: "block", mb: 2 }}
                  >
                    {errors.copies}
                  </Typography>
                )}
                {formData.copies.map((copy, index) => (
                  <Paper key={index} sx={{ p: 2, mb: 2 }}>
                    <Grid container spacing={2} alignItems="center">
                      <Grid item xs={12} md={4}>
                        {isEditing ? (
                          <TextField
                            fullWidth
                            label="Reference ID"
                            value={copy.copyId}
                            onChange={(e) =>
                              handleCopyChange(index, "copyId", e.target.value)
                            }
                            error={Boolean(errors[`copy_${index}_id`])}
                            helperText={errors[`copy_${index}_id`]}
                            required
                            size="small"
                          />
                        ) : (
                          <TextField
                            fullWidth
                            label="Reference ID"
                            value="Auto-generated"
                            disabled
                            helperText="Assigned automatically after save"
                            size="small"
                          />
                        )}
                      </Grid>{" "}
                      <Grid item xs={12} md={3}>
                        <FormControl fullWidth size="small">
                          <InputLabel> Status </InputLabel>{" "}
                          <Select
                            value={copy.status}
                            onChange={(e) =>
                              handleCopyChange(index, "status", e.target.value)
                            }
                            label="Status"
                          >
                            {copyStatuses.map((status) => (
                              <MenuItem key={status} value={status}>
                                <Chip
                                  label={status}
                                  size="small"
                                  color={
                                    status === "available"
                                      ? "success"
                                      : "default"
                                  }
                                />{" "}
                              </MenuItem>
                            ))}{" "}
                          </Select>{" "}
                        </FormControl>{" "}
                      </Grid>{" "}
                      <Grid item xs={12} md={4}>
                        <TextField
                          fullWidth
                          label="Location/Shelf"
                          value={copy.location}
                          onChange={(e) =>
                            handleCopyChange(index, "location", e.target.value)
                          }
                          size="small"
                        />
                      </Grid>{" "}
                      <Grid item xs={12} md={1}>
                        {" "}
                        {formData.copies.length > 1 && (
                          <IconButton
                            onClick={() => removeCopy(index)}
                            color="error"
                            size="small"
                          >
                            <Remove />
                          </IconButton>
                        )}{" "}
                      </Grid>{" "}
                    </Grid>{" "}
                  </Paper>
                ))}{" "}
              </CardContent>{" "}
            </Card>{" "}
          </Grid>
          {}{" "}
          <Grid item xs={12}>
            <Box display="flex" gap={2} justifyContent="flex-end">
              <Button
                onClick={() => navigate("/books")}
                disabled={loading}
                startIcon={<Cancel />}
              >
                Cancel{" "}
              </Button>{" "}
              <Button
                type="submit"
                variant="contained"
                disabled={loading}
                startIcon={<Save />}
              >
                {loading
                  ? "Saving..."
                  : isEditing
                    ? "Update Book"
                    : "Create Book"}{" "}
              </Button>{" "}
            </Box>{" "}
          </Grid>{" "}
        </Grid>{" "}
      </form>{" "}
    </Box>
  );
};

export default BookForm;
```

## BookImportDialog.js

| Field | Details |
| --- | --- |
| Program Name | BookImportDialog.js |
| Description | Frontend page view for routing and page-level UI. |
| Called by | BooksList.js |
| Table used | books |
|  |  |
| Programmer | Nazel Asca√±o |
| Date created | 12/14/2025 |
| Revision Date | TBD |
| Revision / description of change | None |

```javascript
import React, { useState } from "react";
import {
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  Button,
  Box,
  Typography,
  Paper,
  Alert,
  Table,
  TableHead,
  TableRow,
  TableCell,
  TableBody,
  Chip,
  LinearProgress,
} from "@mui/material";
import {
  CloudUpload,
  GetApp,
  CheckCircle,
  ErrorOutline,
  WarningAmber,
} from "@mui/icons-material";
import toast from "react-hot-toast";
import { booksAPI, downloadFile } from "../../utils/api";
import { formatAuthorsList } from "../../utils/authorDisplay";

const sanitizeFilename = (value, fallback) => {
  if (!value) {
    return fallback;
  }
  const cleaned = value.trim().replace(/[^a-zA-Z0-9._-]+/g, "_");
  return cleaned.length > 0 ? cleaned : fallback;
};

const extractFilename = (disposition, fallback) => {
  if (!disposition) {
    return fallback;
  }

  const utf8Match = disposition.match(/filename\*=UTF-8''([^;]+)/i);
  if (utf8Match && utf8Match[1]) {
    try {
      const decoded = decodeURIComponent(utf8Match[1]);
      return sanitizeFilename(decoded, fallback);
    } catch (error) {
      return fallback;
    }
  }

  const quotedMatch = disposition.match(/filename="?([^";]+)"?/i);
  if (quotedMatch && quotedMatch[1]) {
    return sanitizeFilename(quotedMatch[1], fallback);
  }

  return fallback;
};

const normalizeAuthorsInput = (value) => {
  if (value === undefined || value === null) {
    return [];
  }
  if (Array.isArray(value)) {
    return value
      .map((author) => (typeof author === "string" ? author.trim() : ""))
      .filter(Boolean);
  }
  if (typeof value === "string") {
    return value
      .split(/[,;|]/)
      .map((author) => author.trim())
      .filter(Boolean);
  }
  return [];
};

const mergeAuthors = (...sources) => {
  const seen = new Set();
  const list = [];
  sources.forEach((source) => {
    normalizeAuthorsInput(source).forEach((author) => {
      const key = author.toLowerCase();
      if (!seen.has(key)) {
        seen.add(key);
        list.push(author);
      }
    });
  });
  return list;
};

const normalizeHeader = (header) =>
  header.toLowerCase().replace(/[^a-z0-9]/g, "");

const csvToBooks = (text) => {
  const rows = text.split(/\r?\n/).filter((row) => row.trim().length > 0);
  if (rows.length < 2) {
    return [];
  }

  const headers = rows[0].split(",").map((h) => normalizeHeader(h.trim()));

  return rows.slice(1).map((row, index) => {
    const values = row
      .split(",")
      .map((value) => value.trim().replace(/^"|"$/g, ""));

    const book = {
      rowIndex: index + 2,
      title: "",
      author: "",
      authors: [],
      isbn: "",
      publisher: "",
      publishedYear: "",
      category: "",
      description: "",
      numberOfCopies: "",
      location: "",
    };

    headers.forEach((header, columnIndex) => {
      const value = values[columnIndex] || "";
      switch (header) {
        case "title":
          book.title = value;
          break;
        case "author":
          book.author = value;
          break;
        case "authors":
          book.authors = mergeAuthors(book.authors, value);
          break;
        case "isbn":
          book.isbn = value;
          break;
        case "publisher":
          book.publisher = value;
          break;
        case "publishedyear":
          book.publishedYear = value;
          break;
        case "category":
          book.category = value;
          break;
        case "description":
          book.description = value;
          break;
        case "numberofcopies":
          book.numberOfCopies = value;
          break;
        case "location":
          book.location = value;
          break;
        default:
          break;
      }
    });

    if (book.authors.length === 0 && book.author) {
      book.authors = mergeAuthors(book.author);
    }

    return book;
  });
};

const validateBook = (book, existingBooksByIsbn, isbnCounts) => {
  const errors = [];
  const warnings = [];
  const normalizedIsbn = (book.isbn || "").trim().toLowerCase();
  const existingBook = normalizedIsbn ? existingBooksByIsbn[normalizedIsbn] : null;
  const hasAuthorData = (Array.isArray(book.authors) && book.authors.length > 0) || Boolean(book.author);

  if (!book.isbn) {
    errors.push("ISBN required");
  }

  if (!existingBook) {
    if (!book.title) {
      errors.push("Title required");
    }
    if (!hasAuthorData) {
      errors.push("Author required");
    }
  } else {
    warnings.push("Existing ISBN ‚Äì copies will be added");
  }

  if (isbnCounts[normalizedIsbn] > 1) {
    errors.push("Duplicate ISBN in CSV file");
  }

  if (book.publishedYear) {
    const year = parseInt(book.publishedYear, 10);
    if (Number.isNaN(year) || `${year}`.length !== 4) {
      errors.push("Invalid published year");
    }
  }
  if (book.numberOfCopies) {
    const copies = parseInt(book.numberOfCopies, 10);
    if (Number.isNaN(copies) || copies < 1) {
      errors.push("Invalid number of copies");
    }
  }

  return { errors, warnings };
};

const buildIsbnCounts = (books) => {
  const counts = {};
  books.forEach((book) => {
    const normalizedIsbn = (book.isbn || "").trim().toLowerCase();
    if (!normalizedIsbn) {
      return;
    }
    counts[normalizedIsbn] = (counts[normalizedIsbn] || 0) + 1;
  });
  return counts;
};

const BookImportDialog = ({ open, onClose, onImportComplete }) => {
  const [file, setFile] = useState(null);
  const [csvBooks, setCsvBooks] = useState([]);
  const [existingBooks, setExistingBooks] = useState([]);
  const [step, setStep] = useState(1);
  const [importing, setImporting] = useState(false);
  const [importResults, setImportResults] = useState(null);
  const [importSuccessful, setImportSuccessful] = useState(false);
  const [downloadingBookId, setDownloadingBookId] = useState(null);
  const [isBatchDownloading, setIsBatchDownloading] = useState(false);

  const resetState = () => {
    setFile(null);
    setCsvBooks([]);
    setExistingBooks([]);
    setStep(1);
    setImporting(false);
    setImportResults(null);
    setImportSuccessful(false);
    setDownloadingBookId(null);
    setIsBatchDownloading(false);
  };

  const downloadTemplate = () => {
    const template = `title,author,authors,isbn,publisher,publishedYear,category,description,numberOfCopies,location\nThe Pragmatic Programmer,Andrew Hunt,"Andrew Hunt|David Thomas",978-0201616224,Addison-Wesley,1999,Software Development,"Classic developer book",3,main-library`;
    const blob = new Blob([template], { type: "text/csv" });
    const url = window.URL.createObjectURL(blob);
    const link = document.createElement("a");
    link.href = url;
    link.setAttribute("download", "book_import_template.csv");
    document.body.appendChild(link);
    link.click();
    link.remove();
    window.URL.revokeObjectURL(url);
  };

  const handleFileUpload = async (event) => {
    const uploadedFile = event.target.files[0];
    if (!uploadedFile) {
      return;
    }

    if (!uploadedFile.name.endsWith(".csv")) {
      toast.error("Please select a CSV file");
      return;
    }

    setFile(uploadedFile);

    try {
      const existingResponse = await booksAPI.getAll({ limit: 5000 });
      const existing = (existingResponse.data.books || []).map((record) => {
        if (Array.isArray(record?.authors) && record.authors.length > 0) {
          return record;
        }
        if (record?.author) {
          return {
            ...record,
            authors: mergeAuthors(record.authors, record.author),
          };
        }
        return {
          ...record,
          authors: Array.isArray(record?.authors) ? record.authors : [],
        };
      });
      setExistingBooks(existing);

      const reader = new FileReader();
      reader.onload = (loadEvent) => {
        const text = loadEvent.target.result;
        const parsed = csvToBooks(text);
        if (parsed.length === 0) {
          toast.error("No books found in CSV file");
          return;
        }
        setCsvBooks(parsed);
        setStep(2);
      };
      reader.readAsText(uploadedFile);
    } catch (error) {
      console.error("Failed to load books:", error);
      toast.error("Failed to read import file");
    }
  };

  const isbnCounts = buildIsbnCounts(csvBooks);
  const existingBooksByIsbn = existingBooks.reduce((acc, book) => {
    const key = (book.isbn || "").toLowerCase();
    if (key) {
      acc[key] = book;
    }
    return acc;
  }, {});

  const handleImport = async () => {
    setImporting(true);

    try {
      const validBooks = [];
      const invalidBooks = [];
      const warningBooks = [];

      csvBooks.forEach((book) => {
        const { errors, warnings } = validateBook(
          book,
          existingBooksByIsbn,
          isbnCounts,
        );
        if (errors.length > 0) {
          invalidBooks.push({ ...book, errors });
          return;
        }

        const copies = parseInt(book.numberOfCopies, 10);
        const normalizedIsbn = (book.isbn || "").trim().toLowerCase();
        const existingBook = normalizedIsbn
          ? existingBooksByIsbn[normalizedIsbn]
          : null;
        const requestedAuthors = mergeAuthors(book.authors, book.author);
        const fallbackAuthors = existingBook
          ? mergeAuthors(existingBook.authors, existingBook.author)
          : [];
        const authors = requestedAuthors.length > 0 ? requestedAuthors : fallbackAuthors;
        const authorDisplay = authors.join(", ");

        const payload = {
          title: book.title || existingBook?.title || "",
          author: authorDisplay || existingBook?.author || "",
          authors,
          isbn: book.isbn,
          publisher: book.publisher || existingBook?.publisher || "",
          publishedYear: book.publishedYear || existingBook?.publishedYear || null,
          category: book.category || existingBook?.category || "General",
          description: book.description || existingBook?.description || "",
          numberOfCopies: Number.isNaN(copies) ? 1 : Math.max(copies, 1),
          location: book.location || existingBook?.location || "main-library",
          rowIndex: book.rowIndex,
        };

        if (payload.publishedYear) {
          payload.publishedYear = parseInt(payload.publishedYear, 10);
        }

        validBooks.push(payload);

        if (warnings.length > 0) {
          warningBooks.push({
            isbn: payload.isbn,
            title: payload.title,
            warnings,
            rowIndex: book.rowIndex,
          });
        }
      });

      if (validBooks.length === 0) {
        toast.error("No valid books to import");
        setImporting(false);
        setImportResults({
          success: 0,
          errors: csvBooks.length,
          invalidBooks,
          warnings: warningBooks,
        });
        setStep(3);
        return;
      }

      const response = await booksAPI.bulkImport(validBooks);
      const importDetails = response.data.results?.details || [];

      setImportResults({
        success: response.data.results?.success || 0,
        errors: response.data.results?.errors || 0,
        details: importDetails,
        invalidBooks,
        warnings: warningBooks,
      });

      autoDownloadBarcodes(importDetails);

      if ((response.data.results?.success || 0) > 0) {
        toast.success(
          `Imported ${response.data.results.success} books successfully`,
        );
        setImportSuccessful(true);
      }

      if (invalidBooks.length > 0 || (response.data.results?.errors || 0) > 0) {
        toast.error("Some books failed to import");
      }

      setStep(3);
    } catch (error) {
      console.error("Failed to import books:", error);
      const apiMessage = error?.response?.data?.message;
      if (apiMessage) {
        toast.error(apiMessage);
      } else {
        toast.error("Failed to import books");
      }
    } finally {
      setImporting(false);
    }
  };

  const handleDialogClose = () => {
    const shouldRefresh = importSuccessful;
    resetState();
    onClose();
    if (shouldRefresh && onImportComplete) {
      onImportComplete();
    }
  };

  const handleDownloadBarcodes = async (detail, options = {}) => {
    const { silent = false, skipBusyCheck = false } = options;

    if (!detail?.bookId || !Array.isArray(detail?.copyIds) || detail.copyIds.length === 0) {
      if (!silent) {
        toast.error("No barcode data available");
      }
      return false;
    }

    if (!skipBusyCheck && (isBatchDownloading || downloadingBookId)) {
      if (!silent) {
        toast.error("Another barcode download is in progress");
      }
      return false;
    }

    try {
      setDownloadingBookId(detail.bookId);
      const response = await booksAPI.downloadBarcodes(detail.bookId, {
        copyIds: detail.copyIds,
      });

      const fallbackName = sanitizeFilename(
        `${detail.title || detail.bookId}_${detail.copyIds.length}_barcodes.pdf`,
        "book_barcodes.pdf",
      );
      const filename = extractFilename(
        response.headers?.["content-disposition"],
        fallbackName,
      );
      downloadFile(response.data, filename);
      if (!silent) {
        toast.success(`Barcodes downloaded for ${detail.title || detail.bookId}`);
      }
      return true;
    } catch (error) {
      console.error("Failed to download barcodes:", error);
      if (!silent) {
        toast.error("Failed to download barcode labels");
      }
      return false;
    } finally {
      setDownloadingBookId(null);
    }
  };

  const autoDownloadBarcodes = async (details) => {
    const printable = (details || []).filter(
      (detail) => detail.status === "success" && Array.isArray(detail.copyIds) && detail.copyIds.length > 0,
    );

    if (printable.length === 0) {
      return;
    }

    setIsBatchDownloading(true);
    let successCount = 0;
    let failureCount = 0;

    for (const detail of printable) {

      const ok = await handleDownloadBarcodes(detail, { silent: true, skipBusyCheck: true });
      if (ok) {
        successCount += 1;
      } else {
        failureCount += 1;
      }
    }

    setIsBatchDownloading(false);
    setDownloadingBookId(null);

    if (successCount > 0) {
      const message = successCount === 1
        ? "Barcode labels downloaded automatically"
        : `${successCount} barcode label sets downloaded automatically`;
      toast.success(message);
    }

    if (failureCount > 0) {
      toast.error("Some barcode downloads failed. You can retry from the table below.");
    }
  };

  const renderUploadStep = () => (
    <Box>
      <Alert severity="info" sx={{ mb: 3 }}>
        <Typography variant="body2">
          Upload a CSV file containing your book catalogue. Download the
          template to view the supported columns.
        </Typography>
      </Alert>
      <Box display="flex" gap={2} mb={3}>
        <Button variant="outlined" startIcon={<GetApp />} onClick={downloadTemplate}>
          Download Template
        </Button>
      </Box>
      <Paper
        sx={{
          border: "2px dashed #ccc",
          borderRadius: 2,
          p: 4,
          textAlign: "center",
          cursor: "pointer",
          "&:hover": { borderColor: "#2563EB" },
        }}
        role="button"
        tabIndex={0}
        onClick={() => document.getElementById("book-import-input").click()}
      >
        <CloudUpload aria-hidden="true" sx={{ fontSize: 48, color: "#666", mb: 2 }} />
        <Typography variant="h6" gutterBottom>
          Click or press Enter to upload CSV file
        </Typography>
        <Typography variant="body2" color="text.secondary">
          Only .csv files are supported for bulk import
        </Typography>
        <input
          id="book-import-input"
          type="file"
          accept=".csv"
          aria-label="Upload books CSV"
          style={{ display: "none" }}
          onChange={handleFileUpload}
        />
      </Paper>
      {file && (
        <Typography variant="body2" sx={{ mt: 2 }}>
          Selected file: <strong>{file.name}</strong>
        </Typography>
      )}
    </Box>
  );

  const renderPreviewStep = () => (
      <Box>
        <Alert severity="success" sx={{ mb: 3 }}>
          <Typography variant="body2">
            Found {csvBooks.length} books in the CSV file. Review the data
            before importing.
          </Typography>
        </Alert>
        <Table size="small">
          <TableHead>
            <TableRow>
              <TableCell>Title</TableCell>
              <TableCell>Authors</TableCell>
              <TableCell>ISBN</TableCell>
              <TableCell>Copies</TableCell>
              <TableCell>Status</TableCell>
            </TableRow>
          </TableHead>
          <TableBody>
            {csvBooks.map((book, index) => {
              const { errors, warnings } = validateBook(
                book,
                existingBooksByIsbn,
                isbnCounts,
              );
              const isValid = errors.length === 0;
              const hasWarnings = warnings.length > 0;
              const chipProps = isValid
                ? {
                    icon: hasWarnings ? <WarningAmber /> : <CheckCircle />,
                    label: hasWarnings
                      ? warnings.join(", ")
                      : "Ready",
                    color: hasWarnings ? "warning" : "success",
                  }
                : {
                    icon: <ErrorOutline />,
                    label: errors.join(", "),
                    color: "error",
                  };
              return (
                <TableRow key={`${book.isbn}-${index}`}>
                  <TableCell>{book.title}</TableCell>
                  <TableCell>{formatAuthorsList(book, "‚Äî")}</TableCell>
                  <TableCell>{book.isbn}</TableCell>
                  <TableCell>{book.numberOfCopies || 1}</TableCell>
                  <TableCell>
                    <Chip
                      icon={chipProps.icon}
                      label={chipProps.label}
                      color={chipProps.color}
                      size="small"
                    />
                  </TableCell>
                </TableRow>
              );
            })}
          </TableBody>
        </Table>
        <Box display="flex" justifyContent="space-between" mt={3}>
          <Button onClick={() => setStep(1)}>Choose Another File</Button>
          <Button
            variant="contained"
            onClick={handleImport}
            disabled={importing}
          >
            {importing ? "Importing..." : "Import Books"}
          </Button>
        </Box>
        {importing && <LinearProgress sx={{ mt: 2 }} />}
      </Box>
  );

  const renderResultsStep = () => (
    <Box>
      <Alert severity="info" sx={{ mb: 3 }}>
        <Typography variant="body2">
          Import finished. {importResults?.success || 0} success,
          {" "}
          {importResults?.errors || 0} failed.
        </Typography>
      </Alert>
      <Table size="small">
        <TableHead>
          <TableRow>
            <TableCell>Row</TableCell>
            <TableCell>ISBN</TableCell>
            <TableCell>Title</TableCell>
            <TableCell>Status</TableCell>
            <TableCell>Message</TableCell>
            <TableCell align="right">Barcodes</TableCell>
          </TableRow>
        </TableHead>
        <TableBody>
          {(importResults?.details || []).map((detail, index) => (
            <TableRow key={`${detail.isbn || index}-${index}`}>
              <TableCell>{detail.rowIndex ? `Row ${detail.rowIndex}` : '-'}</TableCell>
              <TableCell>{detail.isbn || "N/A"}</TableCell>
              <TableCell>{detail.title || ""}</TableCell>
              <TableCell>
                <Chip
                  label={detail.status === "success" ? "Imported" : "Failed"}
                  color={detail.status === "success" ? "success" : "error"}
                  size="small"
                />
              </TableCell>
              <TableCell>
                <Box display="flex" flexDirection="column" gap={0.5}>
                  <Typography variant="body2">
                    {detail.message
                      || (Array.isArray(detail.issues) && detail.issues.length > 0
                        ? detail.issues.join(", ")
                        : detail.status === "success"
                          ? "Imported successfully"
                          : "No details provided")}
                  </Typography>
                  {detail.status === "success" && detail.copyIds?.length > 0 && (
                    <Box display="flex" flexWrap="wrap" gap={0.5}>
                      {detail.copyIds.slice(0, 3).map((copyId) => (
                        <Chip key={copyId} label={copyId} size="small" variant="outlined" />
                      ))}
                      {detail.copyIds.length > 3 && (
                        <Chip
                          label={`+${detail.copyIds.length - 3} more`}
                          size="small"
                          variant="outlined"
                        />
                      )}
                    </Box>
                  )}
                </Box>
              </TableCell>
              <TableCell align="right">
                {detail.status === "success" && detail.copyIds?.length > 0 ? (
                  <Button
                    variant="outlined"
                    size="small"
                    startIcon={<GetApp fontSize="small" />}
                    onClick={() => handleDownloadBarcodes(detail)}
                    disabled={Boolean(downloadingBookId) || isBatchDownloading}
                  >
                    {downloadingBookId === detail.bookId
                      ? "Preparing..."
                      : isBatchDownloading
                        ? "Queued"
                        : "Barcodes"}
                  </Button>
                ) : (
                  <Typography variant="caption" color="text.secondary">
                    -
                  </Typography>
                )}
              </TableCell>
            </TableRow>
          ))}
          {(importResults?.invalidBooks || []).map((book, index) => (
            <TableRow key={`invalid-${book.isbn || index}`}>
              <TableCell>{book.rowIndex ? `Row ${book.rowIndex}` : '-'}</TableCell>
              <TableCell>{book.isbn || "N/A"}</TableCell>
              <TableCell>{book.title || ""}</TableCell>
              <TableCell>
                <Chip label="Invalid" color="error" size="small" />
              </TableCell>
              <TableCell>{book.errors?.join(", ")}</TableCell>
              <TableCell align="right">
                <Typography variant="caption" color="text.secondary">
                  -
                </Typography>
              </TableCell>
            </TableRow>
          ))}
          {(importResults?.warnings || []).map((book, index) => (
            <TableRow key={`warning-${book.isbn || index}`}>
              <TableCell>{book.rowIndex ? `Row ${book.rowIndex}` : '-'}</TableCell>
              <TableCell>{book.isbn || "N/A"}</TableCell>
              <TableCell>{book.title || ""}</TableCell>
              <TableCell>
                <Chip label="Updated" color="warning" size="small" />
              </TableCell>
              <TableCell>{book.warnings?.join(", ")}</TableCell>
              <TableCell align="right">
                <Typography variant="caption" color="text.secondary">
                  -
                </Typography>
              </TableCell>
            </TableRow>
          ))}
        </TableBody>
      </Table>
      <Box mt={3}>
        <Button
          variant="contained"
          onClick={handleDialogClose}
          disabled={isBatchDownloading || Boolean(downloadingBookId)}
        >
          Done
        </Button>
      </Box>
    </Box>
  );

  return (
    <Dialog
      open={open}
      onClose={handleDialogClose}
      fullWidth
      maxWidth="md"
    >
      <DialogTitle>Import Books</DialogTitle>
      <DialogContent dividers>
        {step === 1 && renderUploadStep()}
        {step === 2 && renderPreviewStep()}
        {step === 3 && renderResultsStep()}
      </DialogContent>
      <DialogActions>
        {step !== 3 && (
          <Button onClick={handleDialogClose} disabled={importing}>
            Cancel
          </Button>
        )}
      </DialogActions>
    </Dialog>
  );
};

export default BookImportDialog;
```

## BooksList.js

| Field | Details |
| --- | --- |
| Program Name | BooksList.js |
| Description | Frontend page view for routing and page-level UI. |
| Called by | App.js |
| Table used | books |
|  |  |
| Programmer | Nazel Asca√±o |
| Date created | 12/14/2025 |
| Revision Date | TBD |
| Revision / description of change | None |

```javascript
import React, { useState, useEffect, useCallback } from "react";
import {
  Box,
  Typography,
  Button,
  TextField,
  Card,
  CardContent,
  CardActions,
  Grid,
  Chip,
  IconButton,
  Menu,
  MenuItem,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  Fab,
  InputAdornment,
  FormControl,
  InputLabel,
  Select,
  TablePagination,
} from "@mui/material";
import {
  Add,
  Search,
  MoreVert,
  Edit,
  Delete,
  Visibility,
  FilterList,
  CloudUpload,
  QrCode2,
  Sort,
} from "@mui/icons-material";
import { useNavigate } from "react-router-dom";
import { useAuth } from "../../contexts/AuthContext";
import { api, booksAPI, downloadFile } from "../../utils/api";
import toast from "react-hot-toast";
import BookImportDialog from "./BookImportDialog";
import { PageLoading } from "../../components/Loading";
import MobileScanButton from "../../components/MobileScanButton";
import MobileScanDialog from "../../components/MobileScanDialog";
import { addActionButtonSx, importActionButtonSx, floatingAddFabSx } from "../../theme/actionButtons";
import { formatAuthorsList } from "../../utils/authorDisplay";

const sanitizeFilename = (value, fallback) => {
  if (!value) {
    return fallback;
  }
  const cleaned = value.trim().replace(/[^a-zA-Z0-9._-]+/g, "_");
  return cleaned.length > 0 ? cleaned : fallback;
};

const extractFilename = (disposition, fallback) => {
  if (!disposition) {
    return fallback;
  }

  const utf8Match = disposition.match(/filename\*=UTF-8''([^;]+)/i);
  if (utf8Match && utf8Match[1]) {
    try {
      const decoded = decodeURIComponent(utf8Match[1]);
      return sanitizeFilename(decoded, fallback);
    } catch (error) {
      return fallback;
    }
  }

  const quotedMatch = disposition.match(/filename="?([^";]+)"?/i);
  if (quotedMatch && quotedMatch[1]) {
    return sanitizeFilename(quotedMatch[1], fallback);
  }

  return fallback;
};

const BooksList = () => {
  const navigate = useNavigate();
  const { user, hasPermission } = useAuth();

  const [books, setBooks] = useState([]);
  const [loading, setLoading] = useState(true);
  const [searchTerm, setSearchTerm] = useState("");
  const [debouncedSearchTerm, setDebouncedSearchTerm] = useState("");
  const [page, setPage] = useState(0);
  const [rowsPerPage, setRowsPerPage] = useState(12);
  const [totalBooks, setTotalBooks] = useState(0);
  const [selectedBook, setSelectedBook] = useState(null);
  const [deleteDialogOpen, setDeleteDialogOpen] = useState(false);
  const [menuAnchor, setMenuAnchor] = useState(null);
  const [importDialogOpen, setImportDialogOpen] = useState(false);
  const [downloadingBookId, setDownloadingBookId] = useState(null);
  const [searchScannerOpen, setSearchScannerOpen] = useState(false);
  const searchInputId = "books-search-input";

  const [filterAnchorEl, setFilterAnchorEl] = useState(null);
  const filtersOpen = Boolean(filterAnchorEl);
  const handleOpenFilters = (e) => setFilterAnchorEl(e.currentTarget);
  const handleCloseFilters = () => setFilterAnchorEl(null);

  const [categories, setCategories] = useState([]);
  const [categoryFilter, setCategoryFilter] = useState("");
  const [sortByField, setSortByField] = useState("title");
  const [sortOrder, setSortOrder] = useState("asc");

  const sortOptions = [
    { value: "title", label: "Title" },
    { value: "availableCopiesCount", label: "Available Copies" },
  ];

  const toggleSortOrder = () => {
    setSortOrder((prev) => (prev === "asc" ? "desc" : "asc"));
  };

  const computeAvailableCopies = useCallback((book) => {
    if (Array.isArray(book?.copies) && book.copies.length > 0) {
      const availableCount = book.copies.filter((copy) => {
        if (!copy) return false;
        const status = typeof copy.status === "string" ? copy.status.trim().toLowerCase() : "";
        return status === "available";
      }).length;
      return availableCount;
    }

    if (typeof book?.availableCopies === "number") {
      return book.availableCopies;
    }

    return 0;
  }, []);

  const getAuthorsDisplay = useCallback((book) => formatAuthorsList(book), []);

  useEffect(() => {
    const timer = setTimeout(() => {
      setDebouncedSearchTerm(searchTerm);
    }, 400);
    return () => clearTimeout(timer);
  }, [searchTerm]);

  const fetchBooks = useCallback(
    async (override = {}) => {
      const pageToFetch = override.page ?? page;
      const limitToFetch = override.limit ?? rowsPerPage;
      const limitValue =
        typeof limitToFetch === "string" ? limitToFetch.toLowerCase() : limitToFetch;
      const isAllMode = limitValue === "all" || limitValue === -1;
      const categoryToFetch = override.category ?? categoryFilter;
      const searchToFetch = override.search ?? debouncedSearchTerm;
      const sortByToFetch = override.sortBy ?? sortByField;
      const sortOrderToFetch = override.sortOrder ?? sortOrder;

      try {
        setLoading(true);
        const params = {
          page: isAllMode ? 1 : pageToFetch + 1,
          limit: isAllMode ? "all" : limitToFetch,
        };
        if (categoryToFetch) params.category = categoryToFetch;
        if (searchToFetch) params.search = searchToFetch;
        if (sortByToFetch) params.sortBy = sortByToFetch;
        if (sortOrderToFetch) params.sortOrder = sortOrderToFetch;

        const response = await booksAPI.getAll(params);
        const payload = response.data || {};
        const bookList = payload.books || payload.data || [];
        const total = payload.total || payload.pagination?.total || bookList.length || 0;

        setBooks(bookList);
        setTotalBooks(total);
      } catch (error) {
        console.error("Failed to fetch books:", error);
        toast.error("Failed to load books");
      } finally {
        setLoading(false);
      }
    },
    [page, rowsPerPage, categoryFilter, debouncedSearchTerm, sortByField, sortOrder]
  );

  const fetchCategories = async () => {
    try {
      const res = await api.get("/books/meta/categories");
      if (Array.isArray(res.data)) setCategories(res.data);
    } catch (err) {
      console.error("Failed to fetch book categories:", err);
    }
  };

  useEffect(() => {
    fetchBooks();
  }, [fetchBooks]);

  useEffect(() => {
    fetchCategories();
  }, []);

  const handleDeleteBook = async () => {
    if (!selectedBook?.id) {
      toast.error("No book selected for deletion");
      return;
    }

    try {
      await api.delete(`/books/${selectedBook.id}`);
      fetchBooks();
      toast.success("Book deleted successfully");
      setDeleteDialogOpen(false);
      setSelectedBook(null);
    } catch (error) {
      console.error("Failed to delete book:", error);
      const message = error.response?.data?.message || "Failed to delete book";
      toast.error(message);
    }
  };

  const handleMenuClick = (event, book) => {
    setMenuAnchor(event.currentTarget);
    setSelectedBook(book);
  };

  const handleMenuClose = ({ clearSelection = true } = {}) => {
    setMenuAnchor(null);
    if (clearSelection) {
      setSelectedBook(null);
    }
  };

  const downloadBarcodesForBook = async (book) => {
    if (!book) {
      return;
    }

    try {
      setDownloadingBookId(book.id);
      const response = await booksAPI.downloadBarcodes(book.id);

      const fallbackName = sanitizeFilename(
        `${book.title || "book"}_${book.isbn || book.id}_barcodes.pdf`,
        "book_barcodes.pdf",
      );
      const filename = extractFilename(
        response.headers?.["content-disposition"],
        fallbackName,
      );

      downloadFile(response.data, filename);
      toast.success(`Barcode labels downloaded for ${book.title || book.isbn || "book"}`);
    } catch (error) {
      console.error("Failed to download barcodes:", error);
      const message = error.response?.data?.message || "Failed to download barcode labels";
      toast.error(message);
    } finally {
      setDownloadingBookId(null);
    }
  };

  const handleBarcodesMenuClick = async () => {
    const bookToDownload = selectedBook;
    handleMenuClose();
    if (!bookToDownload) {
      return;
    }
    await downloadBarcodesForBook(bookToDownload);
  };

  const handleStudentBorrowRequest = useCallback(
    (book) => {
      if (!book) return;
      const bookId = book.id || book._id;
      if (!bookId) {
        toast.error("Unable to identify the selected book");
        return;
      }

      navigate("/transactions/request", {
        state: {
          from: "/books",
          prefillBook: {
            bookId,
            title: book.title || "Untitled",
            author: getAuthorsDisplay(book),
            isbn: book.isbn || "",
            category: book.category || "",
            publisher: book.publisher || "",
            availableCopies: computeAvailableCopies(book),
          },
        },
      });
    },
    [navigate, computeAvailableCopies, getAuthorsDisplay],
  );

  useEffect(() => {
    setPage(0);
  }, [debouncedSearchTerm, categoryFilter, sortByField, sortOrder]);

  useEffect(() => {
    if (!loading && books.length === 0 && totalBooks > 0 && page > 0) {
      setPage((prev) => Math.max(prev - 1, 0));
    }
  }, [loading, books.length, totalBooks, page]);

  const getStatusColor = (status) => {
    switch (status) {
      case "available":
        return "success";
      case "borrowed":
        return "warning";
      case "lost":
      case "damaged":
        return "error";
      default:
        return "default";
    }
  };
  if (loading && books.length === 0) return <PageLoading message="Loading books..." />;

  const isStudent = user?.role === "student";
  const canManageBooks = hasPermission("books.update") || hasPermission("books.delete");
  const headerTitle = isStudent ? "Browse Books" : "Books Management";

  return (
    <Box>
      {}
      <Box display="flex" justifyContent="space-between" alignItems="center" mb={3}>
        <Typography variant="h4" component="h1" color={"white"}>
          {headerTitle}
        </Typography>

        {hasPermission("books.create") && (
          <Box display="flex" gap={2}>
            <Button
              variant="outlined"
              startIcon={<CloudUpload />}
              onClick={() => setImportDialogOpen(true)}
              sx={importActionButtonSx}
            >
              Import Books
            </Button>
            <Button
              variant="contained"
              startIcon={<Add />}
              onClick={() => navigate("/books/new")}
              sx={addActionButtonSx}
            >
              Add New Book
            </Button>
          </Box>
        )}
      </Box>

      {}
      <Box mb={3}>
        <Box display="flex" gap={2} flexWrap="wrap" alignItems="center">
          <TextField
            placeholder="Search books by title, author, or ISBN..."
            value={searchTerm}
            onChange={(e) => setSearchTerm(e.target.value)}
            sx={{ flex: 1, minWidth: 300 }}
            inputProps={{ id: searchInputId }}
            InputProps={{ startAdornment: (<InputAdornment position="start"><Search /></InputAdornment>) }}
          />

          <MobileScanButton
            label="Scan to Search"
            onClick={() => setSearchScannerOpen(true)}
          />

          <IconButton aria-label="Open filters" onClick={handleOpenFilters} size="small" sx={{ border: "1px solid #E2E8F0", backgroundColor: "#F8FAFC" }}>
            <FilterList />
          </IconButton>

          <Menu anchorEl={filterAnchorEl} open={filtersOpen} onClose={handleCloseFilters} anchorOrigin={{ vertical: "bottom", horizontal: "right" }} transformOrigin={{ vertical: "top", horizontal: "right" }} PaperProps={{ sx: { p: 2, minWidth: 220 } }}>
            <Box sx={{ display: "flex", flexDirection: "column", gap: 1 }}>
              <FormControl fullWidth size="small">
                <InputLabel>Category</InputLabel>
                <Select value={categoryFilter} label="Category" onChange={(e) => setCategoryFilter(e.target.value)}>
                  <MenuItem value="">All Categories</MenuItem>
                  {categories.map((cat) => (<MenuItem key={cat} value={cat}>{cat}</MenuItem>))}
                </Select>
              </FormControl>

              <FormControl fullWidth size="small">
                <InputLabel>Sort By</InputLabel>
                <Select
                  label="Sort By"
                  value={sortByField}
                  onChange={(event) => setSortByField(event.target.value)}
                >
                  {sortOptions.map((option) => (
                    <MenuItem key={option.value} value={option.value}>
                      {option.label}
                    </MenuItem>
                  ))}
                </Select>
              </FormControl>

              <Button
                size="small"
                variant="outlined"
                startIcon={<Sort />}
                onClick={toggleSortOrder}
                sx={{ textTransform: "none" }}
              >
                {sortOrder === "asc" ? "Ascending" : "Descending"}
              </Button>

              <Box display="flex" justifyContent="flex-end" gap={1} mt={1}>
                <Button
                  size="small"
                  onClick={() => {
                    setCategoryFilter("");
                    setSortByField("title");
                    setSortOrder("asc");
                    handleCloseFilters();
                  }}
                >
                  Clear
                </Button>
                <Button size="small" variant="contained" onClick={handleCloseFilters}>Apply</Button>
              </Box>
            </Box>
          </Menu>
        </Box>
      </Box>

      {}
      {!loading && totalBooks === 0 ? (
        <Box textAlign="center" py={8}>
          <Typography variant="h6" color="text.secondary" gutterBottom>
            {searchTerm ? "No books found matching your search" : "No books available"}
          </Typography>
          <Typography variant="body2" color="text.secondary" gutterBottom>
            {hasPermission("books.create") && "Start by adding your first book to the library"}
          </Typography>
          {hasPermission("books.create") && (
            <Button
              variant="contained"
              startIcon={<Add />}
              onClick={() => navigate("/books/new")}
              sx={{ ...addActionButtonSx, mt: 2 }}
            >
              Add First Book
            </Button>
          )}
        </Box>
      ) : (
        <Grid container spacing={3}>
          {books.map((book, index) => {
            const fallbackKey = `book-${index}`;
            const itemKey = book.id || book._id || book.isbn || fallbackKey;
            const availableCopies = computeAvailableCopies(book);
            return (
              <Grid
                item
                xs={12}
                sm={6}
                md={4}
                lg={3}
                key={`${itemKey}-${index}`}
              >
                <Card sx={{ height: "100%", display: "flex", flexDirection: "column" }}>
                  <CardContent sx={{ flexGrow: 1 }}>
                    <Box display="flex" justifyContent="space-between" alignItems="flex-start" mb={1}>
                      <Typography variant="h6" component="h2" noWrap>{book.title}</Typography>
                      {canManageBooks ? (
                        <IconButton
                          size="small"
                          onClick={(e) => handleMenuClick(e, book)}
                          aria-label={`Actions for ${book.title}`}
                        >
                          <MoreVert />
                        </IconButton>
                      ) : null}
                    </Box>
                    <Typography variant="body2" color="text.secondary" gutterBottom>by {getAuthorsDisplay(book)}</Typography>
                    <Typography variant="body2" gutterBottom>ISBN: {book.isbn}</Typography>
                    <Typography variant="body2" gutterBottom>Category: {book.category}</Typography>
                    <Box display="flex" justifyContent="space-between" alignItems="center" mt={2}>
                      <Chip label={book.status || "available"} size="small" color={getStatusColor(book.status)} />
                      <Typography variant="caption" color="text.secondary">
                        {availableCopies} available
                      </Typography>
                    </Box>
                  </CardContent>
                  <CardActions sx={{ justifyContent: "space-between", alignItems: "center", gap: 1 }}>
                    <Button size="small" startIcon={<Visibility />} onClick={() => navigate(`/books/${book.id}`)}>View Details</Button>
                    {isStudent && availableCopies > 0 && (
                      <Button
                        size="small"
                        variant="contained"
                        onClick={() => handleStudentBorrowRequest(book)}
                      >
                        Request Borrow
                      </Button>
                    )}
                  </CardActions>
                </Card>
              </Grid>
            );
          })}
        </Grid>
      )}

      {totalBooks > 0 && (
        <Box display="flex" justifyContent="flex-end" mt={3}>
          <TablePagination
            component="div"
            count={totalBooks}
            page={page}
            rowsPerPage={rowsPerPage}
            onPageChange={(event, newPage) => {
              setPage(newPage);
            }}
            onRowsPerPageChange={(event) => {
              const value = parseInt(event.target.value, 10);
              const nextLimit = Number.isNaN(value) ? rowsPerPage : value;
              setRowsPerPage(nextLimit);
              setPage(0);
            }}
            rowsPerPageOptions={[8, 12, 24, 48, { label: "All", value: -1 }]}
            labelRowsPerPage="Rows per page"
          />
        </Box>
      )}

      {}
      {canManageBooks ? (
        <>
          <Menu anchorEl={menuAnchor} open={Boolean(menuAnchor)} onClose={handleMenuClose}>
            {hasPermission("books.update") && (
              <MenuItem
                onClick={() => {
                  navigate(`/books/${selectedBook?.id}/edit`);
                  handleMenuClose();
                }}
              >
                <Edit sx={{ mr: 1 }} /> Edit Book
              </MenuItem>
            )}
            <MenuItem
              onClick={handleBarcodesMenuClick}
              disabled={Boolean(downloadingBookId)}
            >
              <QrCode2 sx={{ mr: 1 }} /> Print Tag
            </MenuItem>
            {hasPermission("books.delete") && (
              <MenuItem
                onClick={() => {
                  setDeleteDialogOpen(true);
                  handleMenuClose({ clearSelection: false });
                }}
              >
                <Delete sx={{ mr: 1 }} /> Delete Book
              </MenuItem>
            )}
          </Menu>

          {}
          <Dialog
            open={deleteDialogOpen}
            onClose={() => {
              setDeleteDialogOpen(false);
              setSelectedBook(null);
            }}
          >
            <DialogTitle>Delete Book</DialogTitle>
            <DialogContent>
              <Typography>
                Are you sure you want to delete "{selectedBook?.title}" ? This action cannot be undone.
              </Typography>
            </DialogContent>
            <DialogActions>
              <Button
                onClick={() => {
                  setDeleteDialogOpen(false);
                  setSelectedBook(null);
                }}
              >
                Cancel
              </Button>
              <Button onClick={handleDeleteBook} color="error" variant="contained">
                Delete
              </Button>
            </DialogActions>
          </Dialog>
        </>
      ) : null}

      {}
      {hasPermission("books.create") && (
        <Fab
          color="primary"
          aria-label="add book"
          sx={{ ...floatingAddFabSx, position: "fixed", bottom: 16, right: 16, display: { xs: "flex", sm: "none" } }}
          onClick={() => navigate("/books/new")}
        >
          <Add />
        </Fab>
      )}

      <MobileScanDialog
        open={searchScannerOpen}
        onClose={() => setSearchScannerOpen(false)}
        onDetected={(value) => setSearchTerm(value || "")}
        title="Scan to Search Books"
        elementId="books-search-qr"
        targetSelector={`#${searchInputId}`}
      />

      <BookImportDialog
        open={importDialogOpen}
        onClose={() => setImportDialogOpen(false)}
        onImportComplete={() => {
          setPage(0);
          fetchBooks({ page: 0 });
        }}
      />
    </Box>
  );
};

export default BooksList;
```

## BorrowForm.js

| Field | Details |
| --- | --- |
| Program Name | BorrowForm.js |
| Description | Frontend page view for routing and page-level UI. |
| Called by | App.js |
| Table used | transactions |
|  |  |
| Programmer | Nazel Asca√±o |
| Date created | 12/14/2025 |
| Revision Date | TBD |
| Revision / description of change | None |

```javascript
import React, { useCallback, useEffect, useMemo, useState } from "react";
import { useNavigate, useLocation } from "react-router-dom";
import {
  Alert,
  Autocomplete,
  Box,
  Button,
  Chip,
  CircularProgress,
  Dialog,
  DialogActions,
  DialogContent,
  DialogTitle,
  Divider,
  Grid,
  IconButton,
  InputAdornment,
  List,
  ListItem,
  ListItemText,
  Paper,
  TextField,
  Typography,
} from "@mui/material";
import QRScanner from "../../components/QRScanner";
import MobileScanButton from "../../components/MobileScanButton";
import { ArrowBack, Assignment, Book, Remove, Search, QrCodeScanner } from "@mui/icons-material";
import { api, settingsAPI } from "../../utils/api";
import { formatCurrency } from "../../utils/currency";
import { generateTransactionReceipt, downloadPDF } from "../../utils/pdfGenerator";
import toast from "react-hot-toast";
import { useAuth } from "../../contexts/AuthContext";
const normalizeNumber = (value, fallback) => {
  const parsed = Number(value);
  return Number.isFinite(parsed) ? parsed : fallback;
};

const normalizeBoolean = (value, fallback) => {
  if (value === undefined || value === null) return fallback;
  if (typeof value === "boolean") return value;
  if (typeof value === "string") {
    const normalized = value.trim().toLowerCase();
    if (["true", "1", "yes"].includes(normalized)) return true;
    if (["false", "0", "no"].includes(normalized)) return false;
  }
  return fallback;
};

const DEFAULT_LIBRARY_TIMEZONE = "Asia/Manila";

const DEFAULT_LIBRARY_PROFILE = {
  openingTime: "08:00",
  closingTime: "17:00",
  operatingDays: ["monday", "tuesday", "wednesday", "thursday", "friday"],
  timezone: DEFAULT_LIBRARY_TIMEZONE,
};

const capitalizeWord = (value = "") => {
  if (!value) return "";
  const normalized = String(value).trim();
  if (!normalized) return "";
  return `${normalized.charAt(0).toUpperCase()}${normalized.slice(1)}`;
};

const normalizeOperatingDays = (value) => {
  if (!Array.isArray(value) || value.length === 0) {
    return DEFAULT_LIBRARY_PROFILE.operatingDays.slice();
  }
  return value
    .map((day) => String(day || "").trim().toLowerCase())
    .filter(Boolean);
};

const getLibraryTimezone = (settings = {}) => {
  if (settings && typeof settings.timezone === "string" && settings.timezone.trim()) {
    return settings.timezone.trim();
  }
  return DEFAULT_LIBRARY_TIMEZONE;
};

const getZonedDayAndMinutes = (timeZone = DEFAULT_LIBRARY_TIMEZONE) => {
  try {
    const formatter = new Intl.DateTimeFormat("en-US", {
      timeZone,
      hour: "2-digit",
      minute: "2-digit",
      hour12: false,
      weekday: "long",
    });
    const parts = formatter.formatToParts(new Date());
    const weekday = parts.find((part) => part.type === "weekday")?.value?.toLowerCase();
    const hourValue = parts.find((part) => part.type === "hour")?.value;
    const minuteValue = parts.find((part) => part.type === "minute")?.value;
    const hours = hourValue !== undefined ? parseInt(hourValue, 10) : NaN;
    const minutes = minuteValue !== undefined ? parseInt(minuteValue, 10) : NaN;
    if (weekday && !Number.isNaN(hours) && !Number.isNaN(minutes)) {
      return { weekday, minutes: hours * 60 + minutes };
    }
  } catch (error) {
    console.error("Timezone evaluation error:", error);
  }

  const fallback = new Date();
  return {
    weekday: fallback.toLocaleString("en-US", { weekday: "long" }).toLowerCase(),
    minutes: fallback.getHours() * 60 + fallback.getMinutes(),
  };
};

const evaluateOperatingWindow = (settings = DEFAULT_LIBRARY_PROFILE) => {
  const profile = {
    openingTime: settings.openingTime || DEFAULT_LIBRARY_PROFILE.openingTime,
    closingTime: settings.closingTime || DEFAULT_LIBRARY_PROFILE.closingTime,
    operatingDays: normalizeOperatingDays(settings.operatingDays),
    timezone: getLibraryTimezone(settings),
  };

  const { weekday: currentDay, minutes } = getZonedDayAndMinutes(profile.timezone);
  const currentTime = `${String(Math.floor(minutes / 60)).padStart(2, "0")}:${String(minutes % 60).padStart(2, "0")}`;

  const isOperatingDay =
    profile.operatingDays.length === 0 || profile.operatingDays.includes(currentDay);
  const withinHours =
    currentTime >= profile.openingTime && currentTime <= profile.closingTime;

  let reason = "";
  if (!isOperatingDay) {
    reason = `Library is closed on ${capitalizeWord(currentDay)}.`;
  } else if (!withinHours) {
    reason = `Requests are accepted between ${profile.openingTime} and ${profile.closingTime}.`;
  }

  return {
    ...profile,
    isOpen: isOperatingDay && withinHours,
    currentDay,
    currentTime,
    reason,
  };
};

const formatOperatingDaysLabel = (days = DEFAULT_LIBRARY_PROFILE.operatingDays) => {
  if (!Array.isArray(days) || days.length === 0) {
    return "All days";
  }
  if (days.length === 7) {
    return "Daily";
  }
  return days.map(capitalizeWord).join(", ");
};

const getBorrowerLabel = (borrower) => {
  if (!borrower) return "";
  const name = [
    borrower.firstName,
    borrower.middleName,
    borrower.lastName,
  ]
    .filter(Boolean)
    .join(" ")
    .trim();
  return (
    name ||
    borrower.username ||
    borrower.email ||
    borrower.studentId ||
    borrower.libraryCardNumber ||
    "Unnamed borrower"
  );
};

const BorrowForm = () => {
  const navigate = useNavigate();
  const location = useLocation();
  const { user: authUser } = useAuth();
  const isStudentRequestRoute =
    location.pathname && location.pathname.includes("/transactions/request");
  const isStudentMode = Boolean(
    isStudentRequestRoute && authUser && authUser.role === "student",
  );

  const [borrowerQuery, setBorrowerQuery] = useState("");
  const [borrowerOptions, setBorrowerOptions] = useState([]);
  const [borrowerLoading, setBorrowerLoading] = useState(false);
  const [borrowerSearchError, setBorrowerSearchError] = useState("");
  const [selectedBorrower, setSelectedBorrower] = useState(null);
  const [borrowerStatus, setBorrowerStatus] = useState(null);
  const [statusLoading, setStatusLoading] = useState(false);

  const [bookQuery, setBookQuery] = useState("");
  const [bookOptions, setBookOptions] = useState([]);
  const [bookLoading, setBookLoading] = useState(false);
  const [bookSearchError, setBookSearchError] = useState("");
  const [scannerOpen, setScannerOpen] = useState(false);

  const [selectedBooks, setSelectedBooks] = useState([]);
  const [notes, setNotes] = useState("");

  const [rules, setRules] = useState({
    maxBooksPerTransaction: 10,
    maxBorrowDays: 14,
    finePerDay: 5,
    enableFines: true,
  });

  const [libraryProfile, setLibraryProfile] = useState(null);
  const [libraryProfileLoading, setLibraryProfileLoading] = useState(false);
  const [libraryProfileError, setLibraryProfileError] = useState("");
  const [libraryOpenState, setLibraryOpenState] = useState(() => evaluateOperatingWindow());

  const [errorMessage, setErrorMessage] = useState("");
  const [successMessage, setSuccessMessage] = useState("");
  const [confirmOpen, setConfirmOpen] = useState(false);
  const [submitting, setSubmitting] = useState(false);

  const borrowerId = useMemo(() => {
    if (isStudentMode) {
      return (
        authUser?.id ||
        authUser?._id ||
        authUser?.userId ||
        authUser?.studentId ||
        null
      );
    }
    return selectedBorrower?.id || selectedBorrower?._id || null;
  }, [authUser, isStudentMode, selectedBorrower]);

  const maxBooksPerTransaction = normalizeNumber(
    rules.maxBooksPerTransaction,
    0,
  );
  const borrowLimitReached =
    maxBooksPerTransaction > 0 &&
    selectedBooks.length >= maxBooksPerTransaction;
  const remainingSlots = useMemo(() => {
    if (!maxBooksPerTransaction) return null;
    return Math.max(maxBooksPerTransaction - selectedBooks.length, 0);
  }, [maxBooksPerTransaction, selectedBooks.length]);
  const borrowDays = normalizeNumber(rules.maxBorrowDays, 14);
  const finePerDay = normalizeNumber(rules.finePerDay, 5);
  const finesEnabled = normalizeBoolean(rules.enableFines, true);
  const operatingDaysLabel = useMemo(
    () =>
      formatOperatingDaysLabel(
        libraryProfile?.operatingDays || libraryOpenState.operatingDays,
      ),
    [libraryProfile, libraryOpenState.operatingDays],
  );
  const canSubmitStudentRequest =
    selectedBooks.length > 0 && (!libraryProfile || libraryOpenState.isOpen);
  const canSubmitStaffBorrow = Boolean(selectedBorrower) && selectedBooks.length > 0;
  const reviewButtonDisabled = isStudentMode
    ? !canSubmitStudentRequest
    : !canSubmitStaffBorrow;
  const reviewButtonLabel = isStudentMode
    ? libraryProfile && !libraryOpenState.isOpen
      ? "Library Closed"
      : "Review Request"
    : "Review Borrow Request";

  useEffect(() => {
    if (isStudentMode) {

      return;
    }

    let mounted = true;
    api
      .get("/settings/borrowing-rules")
      .then((response) => {
        if (!mounted) return;
        const data = response.data || {};
        setRules({
          maxBooksPerTransaction: normalizeNumber(
            data.maxBooksPerTransaction,
            10,
          ),
          maxBorrowDays: normalizeNumber(data.maxBorrowDays, 14),
          finePerDay: normalizeNumber(data.finePerDay, 5),
          enableFines: normalizeBoolean(data.enableFines, true),
        });
      })
      .catch((error) => {
        console.error("Error fetching borrowing rules:", error);
      });
    return () => {
      mounted = false;
    };
  }, [isStudentMode]);

  useEffect(() => {
    if (!isStudentMode) {
      setLibraryProfile(null);
      setLibraryProfileError("");
      setLibraryOpenState(evaluateOperatingWindow());
      return;
    }

    let active = true;
    setLibraryProfileLoading(true);
    setLibraryProfileError("");

    settingsAPI
      .getByCategory("library")
      .then((response) => {
        if (!active) return;
        const profile = response.data || {};
        setLibraryProfile(profile);
        setLibraryOpenState(evaluateOperatingWindow(profile));
      })
      .catch((error) => {
        if (!active) return;
        console.error("Error loading library profile:", error);
        setLibraryProfile(null);
        setLibraryProfileError(
          "Unable to load operating hours. Requests will be validated on submit.",
        );
        setLibraryOpenState(evaluateOperatingWindow());
      })
      .finally(() => {
        if (active) setLibraryProfileLoading(false);
      });

    return () => {
      active = false;
    };
  }, [isStudentMode]);

  useEffect(() => {
    if (!isStudentMode) {
      return;
    }

    const updateState = () => {
      setLibraryOpenState(evaluateOperatingWindow(libraryProfile || undefined));
    };

    updateState();
    const intervalId = window.setInterval(updateState, 60000);
    return () => {
      window.clearInterval(intervalId);
    };
  }, [isStudentMode, libraryProfile]);

  useEffect(() => {
    if (!isStudentMode) {
      return;
    }

    const state = location.state;
    const prefillBook = state?.prefillBook;
    if (!prefillBook) {
      return;
    }

    const bookId = prefillBook.bookId || prefillBook.id || prefillBook._id;
    if (!bookId) {
      return;
    }

    const normalizedBook = {
      bookId,
      title: prefillBook.title || "Untitled",
      author: prefillBook.author || "",
      isbn: prefillBook.isbn || "",
      category: prefillBook.category || "",
      publisher: prefillBook.publisher || "",
      availableCopies: prefillBook.availableCopies ?? null,
    };

    setSelectedBooks((prev) => {
      if (prev.some((book) => (book.bookId || book.id || book._id) === bookId)) {
        return prev;
      }

      if (maxBooksPerTransaction > 0 && prev.length >= maxBooksPerTransaction) {
        setBookSearchError(
          "Borrow limit reached for this transaction. Remove a book to add another.",
        );
        return prev;
      }

      return [...prev, normalizedBook];
    });

    if (state) {
      const nextState = { ...state };
      delete nextState.prefillBook;
      const cleanedState =
        Object.keys(nextState).length > 0 ? nextState : undefined;
      navigate(location.pathname, { replace: true, state: cleanedState });
    }
  }, [
    isStudentMode,
    location.state,
    location.pathname,
    navigate,
    maxBooksPerTransaction,
  ]);

  useEffect(() => {
    if (isStudentMode) {
      setBorrowerOptions([]);
      setBorrowerLoading(false);
      setBorrowerSearchError("");
      return;
    }

    if (!borrowerQuery.trim()) {
      setBorrowerOptions([]);
      setBorrowerLoading(false);
      setBorrowerSearchError("");
      return;
    }

    let active = true;
    setBorrowerLoading(true);
    setBorrowerSearchError("");

    const timer = setTimeout(() => {
      api
        .get("/users/search", {
          params: { q: borrowerQuery.trim(), limit: 12 },
        })
        .then((response) => {
          if (!active) return;
          setBorrowerOptions(response.data || []);
        })
        .catch((error) => {
          if (!active) return;
          console.error("Error searching borrowers:", error);
          setBorrowerSearchError("Unable to search borrowers right now.");
        })
        .finally(() => {
          if (active) setBorrowerLoading(false);
        });
    }, 350);

    return () => {
      active = false;
      clearTimeout(timer);
    };
  }, [borrowerQuery, isStudentMode]);

  useEffect(() => {
    if (!bookQuery.trim()) {
      setBookOptions([]);
      setBookLoading(false);
      setBookSearchError("");
      return;
    }

    let active = true;
    setBookLoading(true);
    setBookSearchError("");

    const timer = setTimeout(() => {
      api
        .get("/books/search", {
          params: {
            q: bookQuery.trim(),
            available: !isStudentMode,
            limit: 20,
          },
        })
        .then((response) => {
          if (!active) return;

          if (isStudentMode) {
            const uniqueBooks = new Map();
            (response.data || []).forEach((book) => {
              const bookId = book.id || book._id;
              if (!bookId || uniqueBooks.has(bookId)) return;
              uniqueBooks.set(bookId, {
                bookId,
                title: book.title || "Untitled",
                author: book.author || "",
                isbn: book.isbn || "",
                category: book.category || "",
                publisher: book.publisher || "",
                availableCopies: Array.isArray(book.copies)
                  ? book.copies.filter((copy) => copy.status === "available").length
                  : book.availableCopies ?? 0,
              });
            });
            setBookOptions(Array.from(uniqueBooks.values()));
            return;
          }

          const selectedCopyIds = new Set(
            selectedBooks.map((book) => book.copyId),
          );
          const options =
            response.data?.flatMap((book) =>
              (book.copies || [])
                .filter((copy) => copy.status === "available")
                .filter((copy) => !selectedCopyIds.has(copy.copyId))
                .map((copy) => ({
                  copyId: copy.copyId,
                  bookId: book.id || book._id,
                  title: book.title || "Untitled",
                  author: book.author || "",
                  isbn: book.isbn || "",
                  location: copy.location || "Main Library",
                  category: book.category || "",
                  publisher: book.publisher || "",
                })),
            ) || [];
          setBookOptions(options);
        })
        .catch((error) => {
          if (!active) return;
          console.error("Error searching books:", error);
          setBookSearchError("Unable to search available books right now.");
        })
        .finally(() => {
          if (active) setBookLoading(false);
        });
    }, 350);

    return () => {
      active = false;
      clearTimeout(timer);
    };
  }, [bookQuery, selectedBooks, isStudentMode]);

  useEffect(() => {
    if (isStudentMode) {
      setBorrowerStatus(null);
      setStatusLoading(false);
      return;
    }

    if (!borrowerId) {
      setBorrowerStatus(null);
      return;
    }

    let active = true;
    setStatusLoading(true);

    api
      .get(`/users/${borrowerId}/borrowing-status`)
      .then((response) => {
        if (!active) return;
        setBorrowerStatus(response.data);
      })
      .catch((error) => {
        if (!active) return;
        console.error("Error fetching borrower status:", error);
        setBorrowerStatus(null);
      })
      .finally(() => {
        if (active) setStatusLoading(false);
      });

    return () => {
      active = false;
    };
  }, [borrowerId, isStudentMode]);

  useEffect(() => {
    if (!successMessage) return;
    const timer = window.setTimeout(() => setSuccessMessage(""), 4000);
    return () => window.clearTimeout(timer);
  }, [successMessage]);

  const clearFeedback = useCallback(() => {
    setErrorMessage("");
    setSuccessMessage("");
  }, []);

  const resetForm = useCallback(() => {
    if (!isStudentMode) {
      setSelectedBorrower(null);
      setBorrowerQuery("");
      setBorrowerStatus(null);
    }
    setSelectedBooks([]);
    setBookQuery("");
    setBookOptions([]);
    setBookSearchError("");
    setNotes("");
    setBorrowerSearchError("");
  }, [isStudentMode]);

  const handleAddBook = (option) => {
    if (!option) return;
    clearFeedback();

    if (borrowLimitReached) {
      setBookSearchError(
        "Borrow limit reached for this transaction. Remove a book to add another.",
      );
      return;
    }

    if (isStudentMode) {
      const bookId = option.bookId || option.id || option._id;
      if (!bookId) {
        setBookSearchError("Unable to determine selected book.");
        return;
      }

      if (
        selectedBooks.some(
          (book) => (book.bookId || book.id || book._id) === bookId,
        )
      ) {
        setBookSearchError("You already added this book to your request.");
        return;
      }

      setSelectedBooks((prev) => [
        ...prev,
        {
          bookId,
          title: option.title || "Untitled",
          author: option.author || "",
          isbn: option.isbn || "",
          category: option.category || "",
          publisher: option.publisher || "",
          availableCopies: option.availableCopies ?? null,
        },
      ]);
      setBookQuery("");
      setBookOptions([]);
      return;
    }

    if (
      selectedBooks.some(
        (book) =>
          book.copyId &&
          option.copyId &&
          book.copyId.toLowerCase() === option.copyId.toLowerCase(),
      )
    ) {
      setBookSearchError("This copy is already selected.");
      return;
    }

    setSelectedBooks((prev) => [...prev, option]);
    setBookQuery("");
    setBookOptions([]);
  };

  const handleBorrowScan = async (raw) => {
    const scanned = String(raw || "").trim();
    if (!scanned) return;
    const inOptions = bookOptions.find(
      (o) => String(o.copyId).toLowerCase() === scanned.toLowerCase(),
    );
    if (inOptions) {
      handleAddBook(inOptions);
      setScannerOpen(false);
      toast.success(`Added copy ${scanned}`);
      return;
    }

    try {
      const resp = await api.get("/books/search", {
        params: { q: scanned, limit: 20 },
      });
      const options = (resp.data || [])
        .flatMap((book) =>
          (book.copies || [])
            .filter((c) => c.status === "available")
            .map((c) => ({
              copyId: c.copyId,
              bookId: book.id || book._id,
              title: book.title || "Untitled",
              author: book.author || "",
              isbn: book.isbn || "",
              location: c.location || "Main Library",
            })),
        );
      const match = options.find(
        (o) => String(o.copyId).toLowerCase() === scanned.toLowerCase(),
      );
      if (match) {
        handleAddBook(match);
        setScannerOpen(false);
        toast.success(`Added copy ${scanned}`);
        return;
      }
      toast.error("Scanned copy not available");
    } catch (err) {
      console.error("Error searching copy by scanned value", err);
      toast.error("Failed to search scanned copy");
    }
  };

  const handleRemoveBook = (identifier) => {
    clearFeedback();
    if (isStudentMode) {
      const targetId =
        identifier && typeof identifier === "object"
          ? identifier.bookId || identifier.id || identifier._id
          : identifier;
      setSelectedBooks((prev) =>
        prev.filter(
          (book) => (book.bookId || book.id || book._id) !== targetId,
        ),
      );
      return;
    }

    setSelectedBooks((prev) =>
      prev.filter((book) => book.copyId !== identifier),
    );
  };

  const openConfirmation = () => {
    clearFeedback();

    if (isStudentMode && libraryProfile && !libraryOpenState.isOpen) {
      setErrorMessage(
        `Borrow requests are accepted between ${libraryOpenState.openingTime} and ${libraryOpenState.closingTime} on ${operatingDaysLabel}.`,
      );
      return;
    }

    if (!isStudentMode && !borrowerId) {
      setErrorMessage("Select a borrower before submitting the transaction.");
      return;
    }

    if (selectedBooks.length === 0) {
      setErrorMessage(
        isStudentMode
          ? "Add at least one book to request."
          : "Add at least one available book copy to proceed.",
      );
      return;
    }

    if (borrowLimitReached) {
      setErrorMessage(
        "Borrow limit reached for this borrower. Remove a book to continue.",
      );
      return;
    }

    setConfirmOpen(true);
  };

  const handleConfirmBorrow = async () => {
    if (submitting) return;
    if (!isStudentMode && !borrowerId) return;

    setSubmitting(true);
    clearFeedback();

    try {
      const payload = {
        items: selectedBooks.map((book) =>
          isStudentMode
            ? { bookId: book.bookId || book.id || book._id }
            : { copyId: book.copyId },
        ),
        notes: notes.trim() || undefined,
      };

      const endpoint = isStudentMode
        ? "/transactions/request"
        : "/transactions/borrow";
      if (!isStudentMode) {
        payload.userId = borrowerId;
      }

      const response = await api.post(endpoint, payload);

      setSuccessMessage(
        response.data?.message ||
          (isStudentMode
            ? "Borrow request submitted successfully."
            : "Borrowing transaction submitted successfully."),
      );

      setConfirmOpen(false);

      if (!isStudentMode) {
        try {
          const transactionData = response.data.transaction || {
            id: response.data.transactionId,
            createdAt: new Date(),
            dueDate: new Date(
              Date.now() + borrowDays * 24 * 60 * 60 * 1000,
            ),
            fineAmount: 0,
          };

          const libraryResponse = await settingsAPI.getByCategory('library');
          const librarySettings = libraryResponse.data || {};

          const receiptPDF = await generateTransactionReceipt(
            transactionData,
            selectedBorrower,
            selectedBooks,
            librarySettings,
          );
          downloadPDF(
            receiptPDF,
            `receipt_${transactionData.id || Date.now()}.pdf`,
          );
        } catch (receiptError) {
          console.error("Error generating receipt:", receiptError);
        }
      }

      resetForm();

      window.setTimeout(() => {
        if (isStudentMode) {
          navigate(location.state?.from || "/student/dashboard");
        } else {
          navigate(location.state?.from || "/transactions");
        }
      }, 1500);
    } catch (error) {
      const message =
        error.response?.data?.message ||
        "Failed to submit borrowing transaction.";
      setErrorMessage(message);
      console.error("Error creating borrowing transaction:", error);
    } finally {
      setSubmitting(false);
    }
  };

  return (
    <Box>
      <Box display="flex" alignItems="center" mb={3}>
        <IconButton
          onClick={() => navigate(-1)}
          edge="start"
          sx={{ mr: 2, color: "text.primary" }}
          aria-label="Go back"
        >
          <ArrowBack />
        </IconButton>
        <Typography variant="h4" sx={{ flexGrow: 1, color:"white" }}>
          Borrow Books
        </Typography>
      </Box>

      {errorMessage && (
        <Alert severity="error" sx={{ mb: 2 }}>
          {errorMessage}
        </Alert>
      )}

      {successMessage && (
        <Alert severity="success" sx={{ mb: 2 }}>
          {successMessage}
        </Alert>
      )}

      {isStudentMode && (
        <Box mb={2}>
          {libraryProfileLoading ? (
            <Alert severity="info">Checking library operating hours‚Ä¶</Alert>
          ) : libraryProfileError ? (
            <Alert severity="warning">{libraryProfileError}</Alert>
          ) : (
            <Alert severity={libraryOpenState.isOpen ? "info" : "warning"}>
              {libraryOpenState.isOpen
                ? `Borrow requests are open now. Operating hours: ${libraryOpenState.openingTime} - ${libraryOpenState.closingTime} (${operatingDaysLabel}).`
                : `Library accepts borrow requests between ${libraryOpenState.openingTime} and ${libraryOpenState.closingTime} on ${operatingDaysLabel}.`}
            </Alert>
          )}
        </Box>
      )}

      <Grid container spacing={3}>
        <Grid item xs={12} md={5}>
          <Paper elevation={1} sx={{ p: 3 }}>
            <Typography variant="h6" gutterBottom>
              Borrower Details
            </Typography>

            {isStudentMode ? (
              <Box>
                <Typography variant="subtitle2" color="text.secondary">
                  You are requesting on your own behalf.
                </Typography>
                <Box mt={1}>
                  <Typography variant="body1" fontWeight={600}>
                    {getBorrowerLabel(authUser) || "You"}
                  </Typography>
                  <Typography variant="body2" color="text.secondary">
                    {[
                      authUser?.email,
                      authUser?.studentId,
                      authUser?.libraryCardNumber,
                    ]
                      .filter(Boolean)
                      .join(" ‚Ä¢ ")}
                  </Typography>
                  <Box mt={1} display="flex" flexWrap="wrap" gap={1}>
                    {authUser?.curriculum && (
                      <Chip
                        label={`Curriculum: ${authUser.curriculum}`}
                        size="small"
                      />
                    )}
                    {authUser?.grade && (
                      <Chip label={`Grade: ${authUser.grade}`} size="small" />
                    )}
                    {authUser?.section && (
                      <Chip
                        label={`Section: ${authUser.section}`}
                        size="small"
                      />
                    )}
                  </Box>
                </Box>

                {authUser?.borrowingStats && (
                  <Box mt={2}>
                    <Divider sx={{ my: 1 }} />
                    <Typography variant="subtitle2" gutterBottom>
                      Your Borrowing Summary
                    </Typography>
                    <Box display="flex" flexWrap="wrap" gap={1}>
                      <Chip
                        icon={<Assignment fontSize="small" />}
                        label={`Borrowed: ${
                          authUser.borrowingStats.currentlyBorrowed || 0
                        }`}
                        size="small"
                        color={
                          (authUser.borrowingStats.currentlyBorrowed || 0) > 0
                            ? "primary"
                            : "default"
                        }
                      />
                      <Chip
                        icon={<Book fontSize="small" />}
                        label={`Total: ${
                          authUser.borrowingStats.totalBorrowed || 0
                        }`}
                        size="small"
                      />
                      <Chip
                        label={`Returned: ${
                          authUser.borrowingStats.totalReturned || 0
                        }`}
                        size="small"
                      />
                    </Box>
                  </Box>
                )}
              </Box>
            ) : (
              <>
                <Autocomplete
                  value={selectedBorrower}
                  onChange={(_, value) => {
                    clearFeedback();
                    setSelectedBorrower(value);
                    setBorrowerQuery("");
                    setBorrowerSearchError("");
                  }}
                  inputValue={borrowerQuery}
                  onInputChange={(_, value) => setBorrowerQuery(value)}
                  options={borrowerOptions}
                  loading={borrowerLoading}
                  getOptionLabel={getBorrowerLabel}
                  isOptionEqualToValue={(option, value) =>
                    (option.id || option._id) === (value.id || value._id)
                  }
                  renderInput={(params) => (
                    <TextField
                      {...params}
                      label="Search borrower"
                      placeholder="Type name, email, or ID"
                      error={Boolean(borrowerSearchError)}
                      helperText={
                        borrowerSearchError ||
                        "Borrowers must have an active account to borrow."
                      }
                      InputProps={{
                        ...params.InputProps,
                        startAdornment: (
                          <>
                            <InputAdornment position="start">
                              <Search fontSize="small" />
                            </InputAdornment>
                            {params.InputProps.startAdornment}
                          </>
                        ),
                        endAdornment: (
                          <>
                            {borrowerLoading ? (
                              <CircularProgress color="inherit" size={20} />
                            ) : null}
                            {params.InputProps.endAdornment}
                          </>
                        ),
                      }}
                    />
                  )}
                />

                {selectedBorrower && (
                  <Box mt={2}>
                    <Typography variant="subtitle2" color="text.secondary">
                      Selected Borrower
                    </Typography>
                    <Box mt={1}>
                      <Typography variant="body1" fontWeight={600}>
                        {getBorrowerLabel(selectedBorrower)}
                      </Typography>
                      <Typography variant="body2" color="text.secondary">
                        {[
                          selectedBorrower.email,
                          selectedBorrower.studentId,
                          selectedBorrower.libraryCardNumber,
                        ]
                          .filter(Boolean)
                          .join(" ‚Ä¢ ")}
                      </Typography>
                      <Box mt={1} display="flex" flexWrap="wrap" gap={1}>
                        {selectedBorrower.role && (
                          <Chip
                            label={`Role: ${selectedBorrower.role}`}
                            size="small"
                          />
                        )}
                        {selectedBorrower.curriculum && (
                          <Chip
                            label={`Curriculum: ${selectedBorrower.curriculum}`}
                            size="small"
                          />
                        )}
                        {selectedBorrower.gradeLevel && (
                          <Chip
                            label={`Grade: ${selectedBorrower.gradeLevel}`}
                            size="small"
                          />
                        )}
                      </Box>
                    </Box>

                    <Divider sx={{ my: 2 }} />

                    {statusLoading ? (
                      <Box display="flex" alignItems="center" gap={1}>
                        <CircularProgress size={18} />
                        <Typography variant="body2" color="text.secondary">
                          Fetching borrowing status‚Ä¶
                        </Typography>
                      </Box>
                    ) : (
                      borrowerStatus && (
                        <Box>
                          <Typography variant="subtitle2" gutterBottom>
                            Borrowing Status
                          </Typography>
                          <Box display="flex" flexWrap="wrap" gap={1}>
                            <Chip
                              icon={<Assignment fontSize="small" />}
                              label={`Borrowed: ${
                                borrowerStatus.currentlyBorrowed || 0
                              }`}
                              size="small"
                              color={
                                borrowerStatus.currentlyBorrowed > 0
                                  ? "primary"
                                  : "default"
                              }
                            />
                            <Chip
                              icon={<Book fontSize="small" />}
                              label={`Total: ${
                                borrowerStatus.totalBorrowed || 0
                              }`}
                              size="small"
                            />
                            <Chip
                              label={`Limit: ${
                                borrowerStatus.borrowingLimit ??
                                  maxBooksPerTransaction ??
                                  "N/A"
                              }`}
                              size="small"
                            />
                            {remainingSlots !== null && (
                              <Chip
                                label={`Remaining this transaction: ${remainingSlots}`}
                                size="small"
                                color={remainingSlots > 0 ? "success" : "warning"}
                              />
                            )}
                            {borrowerStatus.overdueBooks > 0 && (
                              <Chip
                                label={`Overdue: ${borrowerStatus.overdueBooks}`}
                                size="small"
                                color="warning"
                              />
                            )}
                            {borrowerStatus.fineBalance > 0 && (
                              <Chip
                                label={`Fines: ${formatCurrency(
                                  borrowerStatus.fineBalance,
                                )}`}
                                size="small"
                                color="error"
                              />
                            )}
                          </Box>
                        </Box>
                      )
                    )}

                    {borrowerStatus?.overdueBooks > 0 && (
                      <Alert severity="warning" sx={{ mt: 2 }}>
                        Borrower currently has {borrowerStatus.overdueBooks} overdue
                        book
                        {borrowerStatus.overdueBooks > 1 ? "s" : ""}.
                      </Alert>
                    )}
                  </Box>
                )}
              </>
            )}
          </Paper>
        </Grid>

        <Grid item xs={12} md={7}>
          <Paper elevation={1} sx={{ p: 3, mb: 3 }}>
            <Typography variant="h6" gutterBottom>
              {isStudentMode
                ? "Select Books to Request"
                : "Add Available Book Copies"}
            </Typography>
            <Autocomplete
              value={null}
              onChange={(_, option) => handleAddBook(option)}
              inputValue={bookQuery}
              onInputChange={(_, value) => setBookQuery(value)}
              options={bookOptions}
              loading={bookLoading}
              getOptionLabel={(option) =>
                isStudentMode
                  ? option.title || "Untitled"
                  : `${option.title} (${option.copyId})`
              }
              isOptionEqualToValue={(option, value) =>
                isStudentMode
                  ? (option.bookId || option.id || option._id) ===
                    (value.bookId || value.id || value._id)
                  : option.copyId === value.copyId
              }
              filterOptions={(options) => options}
              renderOption={(props, option) => {
                if (isStudentMode) {
                  const key = option.bookId || option.id || option._id;
                  const available =
                    typeof option.availableCopies === "number"
                      ? option.availableCopies
                      : undefined;
                  return (
                    <li {...props} key={key || option.title}>
                      <Box>
                        <Typography variant="body2" fontWeight={600}>
                          {option.title}
                        </Typography>
                        <Typography variant="caption" color="text.secondary">
                          {[option.author, option.isbn]
                            .filter(Boolean)
                            .join(" ‚Ä¢ ")}
                        </Typography>
                        {available !== undefined && (
                          <Typography variant="caption" color="text.secondary">
                            {available} {available === 1 ? "copy" : "copies"} available
                          </Typography>
                        )}
                      </Box>
                    </li>
                  );
                }

                return (
                  <li {...props} key={option.copyId}>
                    <Box>
                      <Typography variant="body2" fontWeight={600}>
                        {option.title}
                      </Typography>
                      <Typography variant="caption" color="text.secondary">
                        Reference ID: {option.copyId}
                        {option.isbn ? ` ‚Ä¢ ISBN ${option.isbn}` : ""}
                        {option.author ? ` ‚Ä¢ ${option.author}` : ""}
                      </Typography>
                      <Typography variant="caption" color="text.secondary">
                        Location: {option.location}
                      </Typography>
                    </Box>
                  </li>
                );
              }}
              renderInput={(params) => (
                <TextField
                  {...params}
                  label={
                    isStudentMode
                      ? "Search library books"
                      : "Search available books"
                  }
                  placeholder="Search by title, author, or ISBN"
                  error={Boolean(bookSearchError)}
                  helperText={
                    bookSearchError ||
                    (borrowLimitReached
                      ? "Borrow limit reached. Remove a book to add another."
                      : isStudentMode
                        ? "Select books you want to request."
                        : "Select copies to include in this transaction.")
                  }
                  InputProps={{
                    ...params.InputProps,
                    startAdornment: (
                      <>
                        <InputAdornment position="start">
                          <Search fontSize="small" />
                        </InputAdornment>
                        {params.InputProps.startAdornment}
                      </>
                    ),
                    endAdornment: (
                      <>
                        {bookLoading ? (
                          <CircularProgress color="inherit" size={20} />
                        ) : null}
                        {params.InputProps.endAdornment}
                      </>
                    ),
                  }}
                />
              )}
            />

            {!isStudentMode && (
              <>
                <Box
                  mt={2}
                  display={{ xs: "none", sm: "flex" }}
                  justifyContent="flex-end"
                >
                  <Button
                    variant="outlined"
                    startIcon={<QrCodeScanner />}
                    onClick={() => setScannerOpen(true)}
                  >
                    Scan Reference QR
                  </Button>
                </Box>
                <MobileScanButton
                  label="Scan Reference QR"
                  onClick={() => setScannerOpen(true)}
                />
              </>
            )}

            {!isStudentMode && (
              <Dialog
                open={scannerOpen}
                onClose={() => setScannerOpen(false)}
                maxWidth="xs"
                fullWidth
              >
                <DialogTitle>Scan Reference QR</DialogTitle>
                <DialogContent>
                  <QRScanner
                    elementId="borrow-qr-scanner"
                    onDetected={(v) => handleBorrowScan(v)}
                    onClose={() => setScannerOpen(false)}
                  />
                </DialogContent>
                <DialogActions>
                  <Button variant="outlined" onClick={() => setScannerOpen(false)}>Cancel</Button>
                </DialogActions>
              </Dialog>
            )}

            <Box mt={3}>
              <Typography variant="subtitle2" gutterBottom>
                {isStudentMode
                  ? `Requested Books (${selectedBooks.length})`
                  : `Selected Copies (${selectedBooks.length})`}
              </Typography>
              {selectedBooks.length === 0 ? (
                <Typography variant="body2" color="text.secondary">
                  {isStudentMode
                    ? "No books requested yet."
                    : "No book copies selected yet."}
                </Typography>
              ) : (
                <List disablePadding>
                  {selectedBooks.map((book, index) => {
                    const key = isStudentMode
                      ? book.bookId || book.id || book._id || book.title || index
                      : book.copyId;
                    const details = [];
                    if (isStudentMode) {
                      if (book.author) details.push(`Author: ${book.author}`);
                      if (book.isbn) details.push(`ISBN: ${book.isbn}`);
                      if (typeof book.availableCopies === "number") {
                        details.push(
                          `${book.availableCopies} ${
                            book.availableCopies === 1 ? "copy" : "copies"
                          } available`,
                        );
                      }
                    }

                    return (
                      <React.Fragment key={key}>
                        <ListItem
                          disableGutters
                          secondaryAction={
                            <IconButton
                              edge="end"
                              aria-label={
                                isStudentMode
                                  ? `Remove book ${book.title}`
                                  : `Remove copy ${book.copyId}`
                              }
                              onClick={() =>
                                handleRemoveBook(
                                  isStudentMode
                                    ? book.bookId || book.id || book._id
                                    : book.copyId,
                                )
                              }
                            >
                              <Remove />
                            </IconButton>
                          }
                        >
                          <ListItemText
                            primary={
                              <Typography variant="body1" fontWeight={600}>
                                {book.title}
                              </Typography>
                            }
                            secondary={
                              isStudentMode ? (
                                <Typography
                                  variant="body2"
                                  color="text.secondary"
                                >
                                  {details.join(" ‚Ä¢ ")}
                                </Typography>
                              ) : (
                                <Typography
                                  variant="body2"
                                  color="text.secondary"
                                >
                                  Reference ID: {book.copyId}
                                  {book.isbn ? ` ‚Ä¢ ISBN ${book.isbn}` : ""}
                                  {book.author ? ` ‚Ä¢ ${book.author}` : ""}
                                  {book.location ? ` ‚Ä¢ ${book.location}` : ""}
                                </Typography>
                              )
                            }
                          />
                        </ListItem>
                        {index < selectedBooks.length - 1 && (
                          <Divider component="li" sx={{ my: 1 }} />
                        )}
                      </React.Fragment>
                    );
                  })}
                </List>
              )}
            </Box>
          </Paper>

          <Paper elevation={1} sx={{ p: 3 }}>
            <Grid container spacing={2}>
              <Grid item xs={12}>
                <Box
                  display="flex"
                  flexDirection="column"
                  justifyContent="center"
                  height="100%"
                >
                  <Typography variant="subtitle2">
                    Borrowing Window
                  </Typography>
                  <Typography variant="body2" color="text.secondary">
                    Due in {borrowDays} day{borrowDays !== 1 ? "s" : ""}.
                    {finesEnabled
                      ? ` ${formatCurrency(
                          finePerDay,
                        )} fine per day if overdue.`
                      : " Fines disabled."}
                  </Typography>
                </Box>
              </Grid>
              <Grid item xs={12}>
                <TextField
                  label="Notes (optional)"
                  multiline
                  minRows={3}
                  fullWidth
                  value={notes}
                  onChange={(event) => setNotes(event.target.value)}
                  placeholder="Add instructions or remarks for this borrowing transaction."
                />
              </Grid>
              <Grid item xs={12}>
                <Button
                  variant="contained"
                  color="primary"
                  startIcon={<Book />}
                  onClick={openConfirmation}
                  disabled={reviewButtonDisabled}
                >
                  {reviewButtonLabel}
                </Button>
                {isStudentMode && libraryProfile && !libraryOpenState.isOpen && (
                  <Typography
                    variant="caption"
                    color="warning.main"
                    display="block"
                    mt={1}
                  >
                    Borrow requests reopen between {libraryOpenState.openingTime} and {libraryOpenState.closingTime}. Operating days: {operatingDaysLabel}.
                  </Typography>
                )}
              </Grid>
            </Grid>
          </Paper>
        </Grid>
      </Grid>

      <Dialog
        open={confirmOpen}
        onClose={() => (!submitting ? setConfirmOpen(false) : null)}
        maxWidth="sm"
        fullWidth
      >
        <DialogTitle>
          {isStudentMode ? "Confirm Borrow Request" : "Confirm Borrow Request"}
        </DialogTitle>
        <DialogContent dividers>
          <Typography variant="body1" gutterBottom>
            Borrower:{" "}
            <strong>
              {getBorrowerLabel(isStudentMode ? authUser : selectedBorrower) ||
                "You"}
            </strong>
          </Typography>
          <Typography variant="body2" color="text.secondary" gutterBottom>
            {selectedBooks.length} book
            {selectedBooks.length !== 1 ? "s" : ""} will be borrowed for{" "}
            {borrowDays} day{borrowDays !== 1 ? "s" : ""}.
          </Typography>

          <List dense disablePadding sx={{ mt: 2 }}>
            {selectedBooks.map((book, index) => {
              const key = isStudentMode
                ? book.bookId || book.id || book._id || `${book.title}-${index}`
                : book.copyId;
              const details = [];

              if (isStudentMode) {
                if (book.author) details.push(`Author: ${book.author}`);
                if (book.isbn) details.push(`ISBN: ${book.isbn}`);
                if (typeof book.availableCopies === "number") {
                  details.push(
                    `${book.availableCopies} ${
                      book.availableCopies === 1 ? "copy" : "copies"
                    } available`,
                  );
                }
              } else {
                details.push(`Reference ID: ${book.copyId}`);
                if (book.isbn) details.push(`ISBN ${book.isbn}`);
                if (book.author) details.push(book.author);
                if (book.location) details.push(book.location);
              }

              return (
                <React.Fragment key={key}>
                  <ListItem disableGutters>
                    <ListItemText
                      primary={book.title}
                      secondary={details.join(" ‚Ä¢ ")}
                    />
                  </ListItem>
                  <Divider component="li" />
                </React.Fragment>
              );
            })}
          </List>

          {notes.trim() && (
            <>
              <Typography variant="subtitle2" sx={{ mt: 2 }}>
                Notes
              </Typography>
              <Typography variant="body2" color="text.secondary">
                {notes.trim()}
              </Typography>
            </>
          )}
        </DialogContent>
        <DialogActions>
          <Button
            onClick={() => setConfirmOpen(false)}
            disabled={submitting}
            color="inherit"
          >
            Cancel
          </Button>
          <Button
            variant="contained"
            onClick={handleConfirmBorrow}
            disabled={submitting}
          >
            {submitting
              ? "Submitting‚Ä¶"
              : isStudentMode
                ? "Confirm Request"
                : "Confirm Borrow"}
          </Button>
        </DialogActions>
      </Dialog>
    </Box>
  );
};

export default BorrowForm;
```

## LibrarianDashboard.js

| Field | Details |
| --- | --- |
| Program Name | LibrarianDashboard.js |
| Description | Frontend page view for routing and page-level UI. |
| Called by | App.js, StaffDashboard.js |
| Table used | None |
|  |  |
| Programmer | Nazel Asca√±o |
| Date created | 12/14/2025 |
| Revision Date | TBD |
| Revision / description of change | None |

```javascript
Ôªø
import React, { useState, useEffect } from "react";
import {
  Box,
  Grid,
  Card,
  CardActionArea,
  CardContent,
  Typography,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
} from "@mui/material";
import { useTheme } from "@mui/material/styles";
import { useNavigate } from "react-router-dom";
import { reportsAPI } from "../../utils/api";
import { useSettings } from "../../contexts/SettingsContext";
import {
  LineChart,
  Line,
  XAxis,
  YAxis,
  CartesianGrid,
  ResponsiveContainer,
} from "recharts";
import { PageLoading } from "../../components/Loading";

const getCurrentSchoolYearLabel = () => {
  const currentDate = new Date();
  const currentMonth = currentDate.getMonth();
  const baseYear = currentMonth >= 5 ? currentDate.getFullYear() : currentDate.getFullYear() - 1;
  const nextYear = baseYear + 1;
  return `${baseYear}-${nextYear}`;
};

const normalizeAuthorList = (value) => {
  if (!value) {
    return [];
  }

  if (Array.isArray(value)) {
    return value
      .map((entry) => {
        if (typeof entry === "string") {
          return entry.trim();
        }
        if (entry && typeof entry === "object" && typeof entry.name === "string") {
          return entry.name.trim();
        }
        return "";
      })
      .filter(Boolean);
  }

  if (typeof value === "string") {
    return value
      .split(/[,;|]/)
      .map((entry) => entry.trim())
      .filter(Boolean);
  }

  if (typeof value === "object" && typeof value.name === "string") {
    const trimmed = value.name.trim();
    return trimmed ? [trimmed] : [];
  }

  return [];
};

const formatBookAuthor = (record) => {
  if (!record) {
    return "Unknown Author";
  }

  const references = [];

  if (Array.isArray(record.items) && record.items.length > 0) {
    references.push(...record.items);
  }

  if (Array.isArray(record.books) && record.books.length > 0) {
    references.push(...record.books);
  }

  const sources = [
    record.authors,
    record.author,
    record.bookAuthors,
    record.bookAuthor,
    record.book?.authors,
    record.book?.author,
    record.bookDetails?.authors,
    record.bookDetails?.author,
    record.primaryBook?.authors,
    record.primaryBook?.author,
  ];

  references.forEach((reference) => {
    sources.push(reference?.authors, reference?.author);
  });

  const seen = new Set();
  const names = [];

  sources.forEach((source) => {
    normalizeAuthorList(source).forEach((name) => {
      const key = name.toLowerCase();
      if (!seen.has(key)) {
        seen.add(key);
        names.push(name);
      }
    });
  });

  return names.length > 0 ? names.join(", ") : "Unknown Author";
};

const LibrarianDashboard = ({ dashboardTitle = "Librarian Dashboard" }) => {
  const theme = useTheme();
  const navigate = useNavigate();
  const { finesEnabled } = useSettings();
  const [stats, setStats] = useState(null);
  const [chartData, setChartData] = useState([]);
  const [overdueBooks, setOverdueBooks] = useState([]);
  const [recentCheckouts, setRecentCheckouts] = useState([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    const loadDashboardData = async () => {
      const fetchWithFallback = async (loader, fallback) => {
        try {
          const response = await loader();
          return response?.data ?? fallback;
        } catch (error) {
          console.error("Dashboard data fetch failed:", error);
          return fallback;
        }
      };

      try {
        setLoading(true);

        const overduePromise = finesEnabled
          ? fetchWithFallback(() => reportsAPI.getRecentOverdue(), [])
          : Promise.resolve([]);

        const [statsData, trendsData, overdueData, checkoutData] = await Promise.all([
          fetchWithFallback(() => reportsAPI.getStats(), null),
          fetchWithFallback(() => reportsAPI.getDailyTrends(), []),
          overduePromise,
          fetchWithFallback(() => reportsAPI.getRecentCheckouts(), []),
        ]);

        setStats(statsData);

        const transformedData = Array.isArray(trendsData)
          ? trendsData.map((item) => ({
              name: new Date(item.date).toLocaleDateString("en-US", {
                month: "short",
                day: "numeric",
              }),
              borrowed: item.borrows,
              returned: item.returns,
            }))
          : [];
        setChartData(transformedData);

        setOverdueBooks(Array.isArray(overdueData) && finesEnabled ? overdueData : []);
        setRecentCheckouts(Array.isArray(checkoutData) ? checkoutData : []);
      } catch (error) {
        console.error("Error loading dashboard data:", error);
      } finally {
        setLoading(false);
      }
    };

    loadDashboardData();
  }, [finesEnabled]);

  const StatCard = ({ title, value, onClick }) => {
    const isInteractive = typeof onClick === "function";
    const content = (
      <CardContent
        sx={{
          p: 1.5,
          height: "100%",
          display: "flex",
          flexDirection: { xs: "column", sm: "row" },
          justifyContent: { xs: "flex-start", sm: "space-between" },
          alignItems: { xs: "flex-start", sm: "center" },
          gap: 0.75,
        }}
      >
        <Typography
          variant="body2"
          sx={{
            color: "#6B7280",
            fontSize: "0.75rem",
            mb: 0.25,
            fontWeight: 500,
          }}
        >
          {title}
        </Typography>
        <Typography
          variant="h2"
          sx={{
            fontWeight: 700,
            color: "#111827",
            fontSize: { xs: "1.5rem", sm: "1.8rem" },
            lineHeight: 1,
          }}
        >
          {value ?? 0}
        </Typography>
      </CardContent>
    );

    return (
      <Card
        sx={{
          backgroundColor: "#FFFFFF",
          border: "none",
          borderRadius: "6px",
          boxShadow: "0 1px 4px rgba(0, 0, 0, 0.08)",
          height: { xs: "auto", sm: "70px" },
          cursor: isInteractive ? "pointer" : "default",
          "&:hover": {
            boxShadow: "0 2px 8px rgba(0, 0, 0, 0.12)",
            transition: "all 0.2s ease",
          },
        }}
      >
        {isInteractive ? (
          <CardActionArea onClick={onClick} sx={{ height: "100%" }} aria-label={`View ${title}`}>
            {content}
          </CardActionArea>
        ) : (
          content
        )}
      </Card>
    );
  };

  const handleCardNavigate = (path, filters = {}) => {
    if (!path) {
      return;
    }

    const params = new URLSearchParams();
    Object.entries(filters).forEach(([key, value]) => {
      if (value !== undefined && value !== null && value !== "" && value !== "all") {
        params.set(key, value);
      }
    });

    const query = params.toString();
    navigate(query ? `${path}?${query}` : path);
  };

  const newStudentsCount = stats?.newStudents ?? stats?.studentsThisYear ?? 0;
  const schoolYearLabel = stats?.currentSchoolYear ?? getCurrentSchoolYearLabel();

  if (loading) {
    return <PageLoading message="Loading dashboard data..." />;
  }

  return (
    <Box sx={{ p: { xs: 1.5, md: 2 } }}>
      <Typography variant="h1" sx={{ mb: 3, fontSize: "1.5rem", fontWeight: 600, color: "white" }}>
        {dashboardTitle}
      </Typography>

      {}
      <Grid container spacing={2} mb={3}>
        {}
        <Grid item xs={6} sm={6} md={3}>
          <StatCard
            title="Borrowed Books"
            value={stats?.borrowedBooks}
            onClick={() => handleCardNavigate("/transactions", { status: "active" })}
          />
        </Grid>
        <Grid item xs={6} sm={6} md={3}>
          <StatCard
            title="Returned Books"
            value={stats?.returnedBooks}
            onClick={() => handleCardNavigate("/transactions", { status: "returned" })}
          />
        </Grid>
        {finesEnabled ? (
          <Grid item xs={6} sm={6} md={3}>
            <StatCard
              title="Overdue Books"
              value={stats?.overdueBooks}
              onClick={() => handleCardNavigate("/transactions", { status: "overdue" })}
            />
          </Grid>
        ) : null}
        <Grid item xs={6} sm={6} md={3}>
          <StatCard
            title="Missing Books"
            value={stats?.missingBooks}
            onClick={() => handleCardNavigate("/transactions", { status: "missing" })}
          />
        </Grid>

        {}
        <Grid item xs={6} sm={6} md={4}>
          <StatCard
            title="Total Books"
            value={stats?.totalBooks}
            onClick={() => handleCardNavigate("/books")}
          />
        </Grid>
        <Grid item xs={6} sm={6} md={4}>
          <StatCard
            title={`New Students (S.Y. ${schoolYearLabel})`}
            value={newStudentsCount}
            onClick={() => handleCardNavigate("/students")}
          />
        </Grid>
      </Grid>
      {}
      <Grid container spacing={2}>
        {}
        <Grid item xs={12} lg={6}>
          <Card
            sx={{
              backgroundColor: "#FFFFFF",
              borderRadius: "6px",
              boxShadow: "0 1px 4px rgba(0, 0, 0, 0.08)",
            }}
          >
            <CardActionArea
              onClick={() => handleCardNavigate("/transactions")}
              sx={{ height: "100%" }}
              aria-label="View all transactions"
            >
              <CardContent sx={{ p: 2 }}>
                <Typography
                  variant="h2"
                  sx={{
                    mb: 1.5,
                    fontWeight: 600,
                    color: "#111827",
                    fontSize: "0.875rem",
                  }}
                >
                  Check - out statistics
                </Typography>
                <Box sx={{ display: "flex", gap: 2, mb: 1.5 }}>
                  <Box sx={{ display: "flex", alignItems: "center", gap: 1 }}>
                    <Box
                      sx={{
                        width: 6,
                        height: 6,
                        borderRadius: "50%",
                        backgroundColor: (theme) => theme.palette.success.main,
                      }}
                    />
                    <Typography
                      variant="body2"
                      sx={{ color: "#6B7280", fontSize: "0.75rem" }}
                    >
                      Borrowed
                    </Typography>
                  </Box>
                  <Box sx={{ display: "flex", alignItems: "center", gap: 1 }}>
                    <Box
                      sx={{
                        width: 6,
                        height: 6,
                        borderRadius: "50%",
                        backgroundColor: "#EF4444",
                      }}
                    />
                    <Typography
                      variant="body2"
                      sx={{ color: "#6B7280", fontSize: "0.75rem" }}
                    >
                      Returned
                    </Typography>
                  </Box>
                </Box>
                <Box sx={{ height: { xs: 220, md: 180 } }}>
                  <ResponsiveContainer width="100%" height="100%">
                    <LineChart data={chartData}>
                      <CartesianGrid strokeDasharray="3 3" stroke="#E5E7EB" />
                      <XAxis
                        dataKey="name"
                        axisLine={false}
                        tickLine={false}
                        tick={{ fontSize: 10, fill: "#6B7280" }}
                      />
                      <YAxis
                        axisLine={false}
                        tickLine={false}
                        tick={{ fontSize: 10, fill: "#6B7280" }}
                      />
                      <Line
                        type="monotone"
                        dataKey="borrowed"
                        stroke={theme.palette.success.main}
                        strokeWidth={2}
                        dot={false}
                      />
                      <Line
                        type="monotone"
                        dataKey="returned"
                        stroke="#EF4444"
                        strokeWidth={2}
                        dot={false}
                      />
                    </LineChart>
                  </ResponsiveContainer>
                </Box>
              </CardContent>
            </CardActionArea>
          </Card>
        </Grid>
        {finesEnabled ? (
          <Grid item xs={12} lg={6}>
            <Card
              sx={{
                backgroundColor: "#FFFFFF",
                borderRadius: "6px",
                boxShadow: "0 1px 4px rgba(0, 0, 0, 0.08)",
              }}
            >
              <CardActionArea
                onClick={() => handleCardNavigate("/transactions", { status: "overdue" })}
                sx={{ height: "100%" }}
                aria-label="View overdue transactions"
              >
                <CardContent sx={{ p: 2 }}>
                  <Typography
                    variant="h2"
                    sx={{
                      mb: 1.5,
                      fontWeight: 600,
                      color: "#111827",
                      fontSize: "0.875rem",
                    }}
                  >
                    Overdue's History
                  </Typography>
                  <TableContainer sx={{ maxHeight: 220, overflowX: "auto" }}>
                    <Table size="small" aria-label="Overdue books table">
                      <TableHead>
                        <TableRow>
                          <TableCell
                            scope="col"
                            id="overdue-student-id-header"
                            sx={{
                              fontWeight: 600,
                              color: "#6B7280",
                              fontSize: "0.75rem",
                              py: 0.75,
                              border: "none",
                            }}
                          >
                            Student Id
                          </TableCell>
                          <TableCell
                            scope="col"
                            id="overdue-title-header"
                            sx={{
                              fontWeight: 600,
                              color: "#6B7280",
                              fontSize: "0.75rem",
                              py: 0.75,
                              border: "none",
                            }}
                          >
                            Title
                          </TableCell>
                          <TableCell
                            scope="col"
                            id="overdue-due-date-header"
                            sx={{
                              fontWeight: 600,
                              color: "#6B7280",
                              fontSize: "0.75rem",
                              py: 0.75,
                              border: "none",
                            }}
                          >
                            Due Date
                          </TableCell>
                        </TableRow>
                      </TableHead>
                      <TableBody>
                        {overdueBooks.length > 0 ? (
                          overdueBooks.map((book, index) => (
                            <TableRow key={index}>
                              <TableCell
                                scope="row"
                                headers="overdue-student-id-header"
                                sx={{
                                  py: 1,
                                  border: "none",
                                  color: "#6B7280",
                                  fontSize: "0.75rem",
                                }}
                              >
                                #{book.studentId}
                              </TableCell>
                              <TableCell
                                headers="overdue-title-header"
                                sx={{
                                  py: 1,
                                  border: "none",
                                  color: "#111827",
                                  fontSize: "0.75rem",
                                  fontWeight: 500,
                                }}
                              >
                                {book.title}
                              </TableCell>
                              <TableCell
                                headers="overdue-due-date-header"
                                sx={{
                                  py: 1,
                                  border: "none",
                                  color: "#6B7280",
                                  fontSize: "0.75rem",
                                }}
                              >
                                {book.dueDate ? new Date(book.dueDate).toLocaleDateString() : "N/A"}
                              </TableCell>
                            </TableRow>
                          ))
                        ) : (
                          <TableRow>
                            <TableCell
                              colSpan={3}
                              sx={{
                                py: 3,
                                border: "none",
                                textAlign: "center",
                                color: "#9CA3AF",
                                fontSize: "0.875rem",
                              }}
                            >
                              No overdue books at this time
                            </TableCell>
                          </TableRow>
                        )}
                      </TableBody>
                    </Table>
                  </TableContainer>
                </CardContent>
              </CardActionArea>
            </Card>
          </Grid>
        ) : null}

        {}
        <Grid item xs={12}>
          <Card
            sx={{
              backgroundColor: "#FFFFFF",
              borderRadius: "6px",
              boxShadow: "0 1px 4px rgba(0, 0, 0, 0.08)",
            }}
          >
            <CardActionArea
              onClick={() => handleCardNavigate("/transactions")}
              sx={{ height: "100%" }}
              aria-label="View recent transactions"
            >
              <CardContent sx={{ p: 2 }}>
                <Typography
                  variant="h2"
                  sx={{
                    mb: 1.5,
                    fontWeight: 600,
                    color: "#111827",
                    fontSize: "0.875rem",
                  }}
                >
                  Recent Check - outs
                </Typography>
                <TableContainer sx={{ overflowX: "auto" }}>
                  <Table size="small" aria-label="Recent check-outs table">
                    <TableHead>
                      <TableRow>
                        <TableCell
                          scope="col"
                          id="checkout-student-id-header"
                          sx={{
                            fontWeight: 600,
                            color: "#6B7280",
                            fontSize: "0.75rem",
                            py: 0.75,
                            border: "none",
                          }}
                        >
                          Student Id
                        </TableCell>
                        <TableCell
                          scope="col"
                          id="checkout-title-header"
                          sx={{
                            fontWeight: 600,
                            color: "#6B7280",
                            fontSize: "0.75rem",
                            py: 0.75,
                            border: "none",
                          }}
                        >
                          Title
                        </TableCell>
                        <TableCell
                          scope="col"
                          id="checkout-author-header"
                          sx={{
                            fontWeight: 600,
                            color: "#6B7280",
                            fontSize: "0.75rem",
                            py: 0.75,
                            border: "none",
                          }}
                        >
                          Author
                        </TableCell>
                        <TableCell
                          scope="col"
                          id="checkout-student-header"
                          sx={{
                            fontWeight: 600,
                            color: "#6B7280",
                            fontSize: "0.75rem",
                            py: 0.75,
                            border: "none",
                          }}
                        >
                          Student
                        </TableCell>
                        <TableCell
                          scope="col"
                          id="checkout-issued-header"
                          sx={{
                            fontWeight: 600,
                            color: "#6B7280",
                            fontSize: "0.75rem",
                            py: 0.75,
                            border: "none",
                          }}
                        >
                          Issued Date
                        </TableCell>
                        <TableCell
                          scope="col"
                          id="checkout-returned-header"
                          sx={{
                            fontWeight: 600,
                            color: "#6B7280",
                            fontSize: "0.75rem",
                            py: 0.75,
                            border: "none",
                          }}
                        >
                          Returned Date
                        </TableCell>
                      </TableRow>
                    </TableHead>
                    <TableBody>
                    {recentCheckouts.length > 0 ? (
                      recentCheckouts.map((checkout, index) => (
                        <TableRow key={index}>
                          <TableCell
                            headers="checkout-student-id-header"
                            sx={{
                              py: 1,
                              border: "none",
                              color: "#6B7280",
                              fontSize: "0.75rem",
                            }}
                          >
                            {checkout.studentId ? `#${checkout.studentId}` : 'N/A'}
                          </TableCell>
                          <TableCell
                            headers="checkout-title-header"
                            sx={{
                              py: 1,
                              border: "none",
                              color: "#111827",
                              fontSize: "0.75rem",
                              fontWeight: 500,
                            }}
                          >
                            {checkout.title}
                          </TableCell>
                          <TableCell
                            headers="checkout-author-header"
                            sx={{
                              py: 1,
                              border: "none",
                              color: "#6B7280",
                              fontSize: "0.75rem",
                            }}
                          >
                            {formatBookAuthor(checkout)}
                          </TableCell>
                          <TableCell
                            headers="checkout-student-header"
                            sx={{
                              py: 1,
                              border: "none",
                              color: "#6B7280",
                              fontSize: "0.75rem",
                            }}
                          >
                            {checkout.student}
                          </TableCell>
                          <TableCell
                            headers="checkout-issued-header"
                            sx={{
                              py: 1,
                              border: "none",
                              color: "#6B7280",
                              fontSize: "0.75rem",
                            }}
                          >
                            {checkout.recordDate ? new Date(checkout.recordDate).toLocaleDateString() : 'N/A'}
                          </TableCell>
                          <TableCell
                            headers="checkout-returned-header"
                            sx={{
                              py: 1,
                              border: "none",
                              color: "#6B7280",
                              fontSize: "0.75rem",
                            }}
                          >
                            {checkout.returnedDate ? new Date(checkout.returnedDate).toLocaleDateString() : "Not returned"}
                          </TableCell>
                        </TableRow>
                      ))
                    ) : (
                      <TableRow>
                        <TableCell
                          colSpan={6}
                          sx={{
                            py: 3,
                            border: "none",
                            textAlign: "center",
                            color: "#9CA3AF",
                            fontSize: "0.875rem",
                          }}
                        >
                          No recent transactions found
                        </TableCell>
                      </TableRow>
                    )}
                  </TableBody>
                </Table>
              </TableContainer>
              </CardContent>
            </CardActionArea>
          </Card>
        </Grid>
      </Grid>
    </Box>
  );
};

export default LibrarianDashboard;
```

## LoginPage.js

| Field | Details |
| --- | --- |
| Program Name | LoginPage.js |
| Description | Frontend page view for routing and page-level UI. |
| Called by | App.js |
| Table used | None |
|  |  |
| Programmer | Nazel Asca√±o |
| Date created | 12/14/2025 |
| Revision Date | TBD |
| Revision / description of change | None |

```javascript
import React, { useState, useEffect } from "react";
import { useNavigate } from "react-router-dom";
import {
  Box,
  TextField,
  Button,
  Typography,
  InputAdornment,
  IconButton,
  CircularProgress,
  Grid,
} from "@mui/material";
import { Visibility, VisibilityOff, Person, Lock } from "@mui/icons-material";
import { useAuth } from "../../contexts/AuthContext";
import { api } from "../../utils/api";
import { resolveAssetUrl } from "../../utils/media";
import logo from "../../assets/images/logo.png";
import loginBg from "../../assets/images/login_bg.jpg";

const LoginPage = () => {
  const navigate = useNavigate();
  const { login, loginLoading } = useAuth();

  const [isOpen, setIsOpen] = useState(false);
  const [libraryInfo, setLibraryInfo] = useState({
    libraryName: '',
    libraryAddress: '',
    libraryPhone: '',
    libraryEmail: '',
    website: '',
    description: '',
    loginLogoUrl: '',
    loginMotto: '',
    loginBackgroundUrl: ''
  });

  useEffect(() => {
    const timer = setTimeout(() => setIsOpen(true), 100);
    return () => clearTimeout(timer);
  }, []);

  useEffect(() => {
    const fetchLibraryInfo = async () => {
      try {
        const response = await api.get("/settings/library");
        setLibraryInfo(response.data);
      } catch (error) {
        console.error("Failed to fetch library info:", error);

      }
    };

    fetchLibraryInfo();
  }, []);

  const [formData, setFormData] = useState({
    username: "",
    password: "",
  });
  const [showPassword, setShowPassword] = useState(false);
  const [error, setError] = useState("");

  const configuredLogo = resolveAssetUrl(libraryInfo.loginLogoUrl);
  const configuredBackground = resolveAssetUrl(libraryInfo.loginBackgroundUrl);
  const displayLogo = configuredLogo || logo;
  const displayBackground = configuredBackground || loginBg;
  const displayMotto = (libraryInfo.loginMotto || '').trim() || "The School of Choice";

  const handleChange = (e) => {
    const { name, value } = e.target;
    setFormData((prev) => ({
      ...prev,
      [name]: value,
    }));
    if (error) setError("");
  };

  const handleSubmit = async (e) => {
    e.preventDefault();

    if (!formData.username || !formData.password) {
      setError("Please fill in all fields");
      return;
    }

    setError("");

    try {
      const result = await login(formData.username, formData.password);

      if (result.success) {

        switch (result.user.role) {
          case "admin":
            navigate("/admin/dashboard");
            break;
          case "librarian":
            navigate("/librarian/dashboard");
            break;
          case "staff":
            navigate("/staff/dashboard");
            break;
          case "student":
            navigate("/student/dashboard");
            break;
          default:
            navigate("/");
        }
      } else {
        setError(result.error || "Login failed. Please try again.");
      }
    } catch (error) {
      console.error("Login error:", error);
      setError("Login failed. Please try again.");
    }
  };

  const handleTogglePasswordVisibility = () => {
    setShowPassword(!showPassword);
  };

  return (
    <Box
      sx={{
        minHeight: "100vh",
        minWidth: "100vw",
        width: "100vw",
        height: "100vh",
        display: "flex",
        alignItems: "stretch",
        justifyContent: "stretch",
        backgroundColor: { xs: "#305FB7", md: "#f5f5f5" },
        position: "relative",
        overflow: "hidden",
        perspective: '2000px',
      }}
    >
      <Grid
        container
        sx={{
          minHeight: "100vh",
          minWidth: "100vw",
          width: "100vw",
          height: "100vh",
          position: "relative",
          flexDirection: { xs: "column", md: "row" },
          zIndex: 1,
          transformStyle: 'preserve-3d',
        }}
      >
        {" "}
        {}{" "}
        <Grid
          item
          xs={12}
          md={6}
          sx={{
            background: "linear-gradient(90deg, #305FB7 0%, #305FB7 80%, #022a75ff 100%)",
            display: { xs: "none", md: "flex" },
            flexDirection: "column",
            alignItems: "center",
            justifyContent: "center",
            padding: 4,
            color: "white",
            position: "relative",
            zIndex: 1,
            borderRadius: '10px 0 0 10px',
            boxShadow: '0 0 20px rgba(0,0,0,0.5)',
            transformOrigin: 'right center',
            transform: { xs: 'none', md: isOpen ? 'rotateY(0deg)' : 'rotateY(90deg)' },
            transition: { xs: 'none', md: 'transform 3.2s cubic-bezier(0.77,0,0.175,1)' },
            transformStyle: 'preserve-3d',
          }}
        >
          {}{" "}
          <Box
            component="img"
            src={displayLogo}
            alt="ONHS School Library Management System Logo"
            sx={{
              width: { md: 280, lg: 320 },
              height: "auto",
              mb: 3,
              display: "block",
            }}
          />
          <Typography
            variant="h5"
            sx={{
              fontFamily: "Inknut Antiqua, serif",
              fontWeight: 400,
              textAlign: "center",
              color: "white",
              textShadow: "0 2px 4px rgba(0,0,0,0.1)",
              fontSize: { md: "1.5rem", lg: "1.8rem" },
            }}
          >
            {displayMotto}
          </Typography>{" "}
          {}
          <Box sx={{ mt: 4, textAlign: 'center', maxWidth: 320 }}>
            {libraryInfo.libraryName && (
              <Typography variant="h6" sx={{ color: 'white', mb: 1, fontWeight: 600 }}>
                {libraryInfo.libraryName}
              </Typography>
            )}
            {libraryInfo.libraryAddress && (
              <Typography variant="body2" sx={{ color: 'white', mb: 1, opacity: 0.9 }}>
                {libraryInfo.libraryAddress}
              </Typography>
            )}
            {libraryInfo.libraryPhone && (
              <Typography variant="body2" sx={{ color: 'white', mb: 1, opacity: 0.9 }}>
                Phone: {libraryInfo.libraryPhone}
              </Typography>
            )}
            {libraryInfo.libraryEmail && (
              <Typography variant="body2" sx={{ color: 'white', mb: 1, opacity: 0.9 }}>
                Email: {libraryInfo.libraryEmail}
              </Typography>
            )}
            {libraryInfo.website && (
              <Typography variant="body2" sx={{ color: 'white', mb: 1, opacity: 0.9 }}>
                Website: {libraryInfo.website}
              </Typography>
            )}
            {libraryInfo.description && (
              <Typography variant="body2" sx={{ color: 'white', mt: 2, opacity: 0.8, fontStyle: 'italic' }}>
                {libraryInfo.description}
              </Typography>
            )}
          </Box>
        </Grid>
        {}{" "}
        <Grid
          item
          xs={12}
          md={6}
          sx={{
            backgroundColor: { xs: "transparent", md: "#FFFFFF00" },
            backgroundImage: {
              xs: 'none',
              md: `linear-gradient(90deg, rgba(53, 53, 53, 1) 0%, rgba(236, 236, 236, 0) 20%, rgba(255, 255, 255, 0) 100%), url(${displayBackground})`
            },
            backgroundSize: { xs: 'auto', md: 'cover' },
            backgroundPosition: { xs: 'center', md: 'center' },
            backgroundRepeat: 'no-repeat',
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            padding: { xs: 3, sm: 4, md: 6 },
            position: "relative",
            flexDirection: "column",
            gap: { xs: 2.5, md: 0 },
            borderRadius: '0 10px 10px 0',
            transformOrigin: 'left center',
            transform: { xs: 'none', md: isOpen ? 'rotateY(0deg)' : 'rotateY(-90deg)' },
            transition: { xs: 'none', md: 'transform 3.2s cubic-bezier(0.77,0,0.175,1)' },
            transformStyle: 'preserve-3d',
            overflow: 'hidden',
            "&::before": {
              content: '""',
              position: "absolute",
              top: 0,
              left: 0,
              width: '100%',
              height: '100%',

              background: 'rgba(255,255,255,0.25)',
              zIndex: 1,
              pointerEvents: 'none',
              display: { xs: "none", md: "block" },
            },
          }}
        >
          <Box
            sx={{
              display: { xs: "flex", md: "none" },
              flexDirection: "column",
              alignItems: "center",
              textAlign: "center",
              color: "#FFFFFF",
              zIndex: 3,
              gap: 1.25,
            }}
          >
            <Box
              component="img"
              src={displayLogo}
              alt="ONHS Library Management System Logo"
              sx={{
                width: 115,
                height: "auto",
              }}
            />
            <Typography
              variant="subtitle1"
              sx={{
                fontFamily: "Inknut Antiqua, serif",
                letterSpacing: "0.02em",
              }}
            >
              {displayMotto}
            </Typography>
          </Box>
          <Box
            sx={{
              width: { xs: '100%', md: '370px' },
              maxWidth: { xs: '100%', md: '370px' },
              padding: { xs: 3, sm: 3, md: 4 },
              background: `white`,
              boxShadow: '0 8px 32px 0 rgba(31,38,135,0.18), 0 0 24px 0 rgba(180,180,180,0.10) inset',
              borderRadius: '16px',
              border: '1.5px solid rgba(48,95,183,0.18)',
              mx: { xs: 0, md: 0 },
              position: "relative",
              zIndex: 2,

              mt: { xs: 0, md: 20 },
            }}
          >
            {}{" "}
            <Typography
              variant="h4"
              sx={{
                mb: 4,
                fontFamily: "Inria Serif, serif",
                fontWeight: 700,
                color: "#333333",
                textAlign: "center",
                fontSize: { xs: "1.4rem", sm: "1.6rem", md: "2rem" },
              }}
            >
              Online Library Management{" "}
            </Typography>
            {}{" "}
            <Box component="form" onSubmit={handleSubmit} noValidate>
              {" "}
              {error && (
                <Box sx={{ mb: 3 }}>
                  <div role="alert" aria-live="assertive">{error}</div>
                </Box>
              )}
              {}{" "}
              <Box sx={{ mb: 2.5 }}>
                <TextField
                  fullWidth
                  id="username"
                  name="username"
                  label="Username"
                  value={formData.username}
                  onChange={handleChange}
                  required
                  autoComplete="username"
                  disabled={loginLoading}
                  error={Boolean(error && !formData.username)}
                  aria-describedby={error && !formData.username ? "username-error" : undefined}
                  aria-invalid={Boolean(error && !formData.username)}
                  sx={{
                    "& .MuiOutlinedInput-root": {
                      backgroundColor: "transparent !important",
                      borderRadius: "8px",
                      height: "42px",
                      "& fieldset": {
                        borderColor: "#CCCCCC",
                        borderWidth: "1px",
                      },
                      "&:hover fieldset": {
                        borderColor: "#305FB7",
                      },
                      "&.Mui-focused fieldset": {
                        borderColor: "#305FB7",
                        borderWidth: "2px",
                      },
                    },
                    "& .MuiInputLabel-root": {
                      color: "#333333",
                      fontSize: "0.9rem",
                      fontWeight: 500,
                    },
                    "& input": {
                      backgroundColor: "transparent !important",
                    },
                  }}
                  InputProps={{
                    startAdornment: (
                      <InputAdornment position="start">
                        <Person
                          sx={{ color: "#000000", fontSize: "18px" }}
                        />{" "}
                      </InputAdornment>
                    ),
                  }}
                />
                {error && !formData.username && (
                  <Typography
                    id="username-error"
                    variant="caption"
                    color="error"
                    sx={{ mt: 0.5, display: "block" }}
                  >
                    Username is required
                  </Typography>
                )}
              </Box>
              {}{" "}
              <Box sx={{ mb: 3 }}>
                <TextField
                  fullWidth
                  id="password"
                  name="password"
                  label="Password"
                  type={showPassword ? "text" : "password"}
                  value={formData.password}
                  onChange={handleChange}
                  required
                  autoComplete="current-password"
                  disabled={loginLoading}
                  error={Boolean(error && !formData.password)}
                  aria-describedby={error && !formData.password ? "password-error" : undefined}
                  aria-invalid={Boolean(error && !formData.password)}
                  sx={{
                    "& .MuiOutlinedInput-root": {
                      backgroundColor: "transparent !important",
                      borderRadius: "8px",
                      height: "42px",
                      "& fieldset": {
                        borderColor: "#CCCCCC",
                        borderWidth: "1px",
                      },
                      "&:hover fieldset": {
                        borderColor: "#305FB7",
                      },
                      "&.Mui-focused fieldset": {
                        borderColor: "#305FB7",
                        borderWidth: "2px",
                      },
                    },
                    "& .MuiInputLabel-root": {
                      color: "#333333",
                      fontSize: "0.9rem",
                      fontWeight: 500,
                    },
                    "& input": {
                      backgroundColor: "transparent !important",
                    },
                  }}
                  InputProps={{
                    startAdornment: (
                      <InputAdornment position="start">
                        <Lock
                          sx={{ color: "#000000", fontSize: "18px" }}
                        />{" "}
                      </InputAdornment>
                    ),
                    endAdornment: (
                      <InputAdornment position="end">
                        <IconButton
                          aria-label="toggle password visibility"
                          onClick={handleTogglePasswordVisibility}
                          edge="end"
                          disabled={loginLoading}
                        >
                          {showPassword ? (
                            <VisibilityOff />
                          ) : (
                            <Visibility />
                          )}{" "}
                        </IconButton>{" "}
                      </InputAdornment>
                    ),
                  }}
                />
                {error && !formData.password && (
                  <Typography
                    id="password-error"
                    variant="caption"
                    color="error"
                    sx={{ mt: 0.5, display: "block" }}
                  >
                    Password is required
                  </Typography>
                )}
              </Box>
              {}{" "}
              <Box
                sx={{
                  display: "flex",
                  justifyContent: "center",
                  mt: { xs: 2, sm: 3 },
                }}
              >
                <Button
                  type="submit"
                  variant="outlined"
                  sx={{
                    px: 5,
                    py: 1.2,
                    borderRadius: "25px",
                    fontSize: "0.9rem",
                    fontWeight: 600,
                    textTransform: "uppercase",
                    color: "#22C55E",
                    borderColor: "#22C55E",
                    borderWidth: "2px",
                    backgroundColor: "white",
                    minWidth: "100px",
                    "&:hover": {
                      backgroundColor: "rgba(34, 197, 94, 0.04)",
                      borderColor: "#22C55E",
                      borderWidth: "2px",
                    },
                    "&:disabled": {
                      color: "#9CA3AF",
                      borderColor: "#9CA3AF",
                    },
                  }}
                  disabled={loginLoading}
                  startIcon={
                    loginLoading && <CircularProgress size={20} color="inherit" />
                  }
                >
                  {loginLoading ? "Signing In..." : "LOGIN"}{" "}
                </Button>{" "}
              </Box>{" "}
            </Box>{" "}
          </Box>{" "}
        </Grid>{" "}
      </Grid>{" "}
    </Box>
  );
};

export default LoginPage;
```

## NotFoundPage.js

| Field | Details |
| --- | --- |
| Program Name | NotFoundPage.js |
| Description | Frontend page view for routing and page-level UI. |
| Called by | App.js |
| Table used | None |
|  |  |
| Programmer | Nazel Asca√±o |
| Date created | 12/14/2025 |
| Revision Date | TBD |
| Revision / description of change | None |

```javascript
import React from "react";
import { Box, Typography, Paper, Button } from "@mui/material";
import { useNavigate } from "react-router-dom";

const NotFoundPage = () => {
  const navigate = useNavigate();

  return (
    <Box
      display="flex"
      justifyContent="center"
      alignItems="center"
      minHeight="60vh"
    >
      <Paper sx={{ p: 4, textAlign: "center" }}>
        <Typography variant="h1" color="error" gutterBottom>
          404{" "}
        </Typography>{" "}
        <Typography variant="h5" gutterBottom>
          Page Not Found{" "}
        </Typography>{" "}
        <Typography variant="body1" color="text.secondary" gutterBottom>
          The page you 're looking for doesn' t exist.{" "}
        </Typography>{" "}
        <Button
          variant="contained"
          onClick={() => navigate("/")}
          sx={{ mt: 2 }}
        >
          Go Home{" "}
        </Button>{" "}
      </Paper>{" "}
    </Box>
  );
};

export default NotFoundPage;
```

## NotificationsPage.js

| Field | Details |
| --- | --- |
| Program Name | NotificationsPage.js |
| Description | Frontend page view for routing and page-level UI. |
| Called by | App.js |
| Table used | notifications |
|  |  |
| Programmer | Nazel Asca√±o |
| Date created | 12/14/2025 |
| Revision Date | TBD |
| Revision / description of change | None |

```javascript
import React, { useCallback, useEffect, useMemo, useState } from 'react';
import { Box, Paper, List, ListItem, ListItemText, IconButton, Typography } from '@mui/material';
import { api, notificationsAPI } from '../../utils/api';
import toast from 'react-hot-toast';
import MarkEmailReadIcon from '@mui/icons-material/MarkEmailRead';
import MarkEmailUnreadIcon from '@mui/icons-material/MarkEmailUnread';
import DeleteIcon from '@mui/icons-material/Delete';
import { useAuth } from '../../contexts/AuthContext';

const NotificationsPage = () => {
  const [items, setItems] = useState([]);
  const { user } = useAuth();
  const userId = useMemo(() => {
    return user?.id || user?._id || user?.userId || null;
  }, [user]);

  const fetchNotifications = useCallback(async (autoMarkRead = true) => {
    try {
      const resp = await api.get('/notifications/persistent');
      const notifications = Array.isArray(resp.data.notifications)
        ? resp.data.notifications.map((entry) => {
            const readBy = Array.isArray(entry.readBy)
              ? entry.readBy.map((value) => String(value))
              : [];
            const normalizedUserId = userId ? String(userId) : null;
            return {
              ...entry,
              read: normalizedUserId ? readBy.includes(normalizedUserId) : false,
            };
          })
        : [];
      if (!autoMarkRead) {
        setItems(notifications);
      } else {
        const unreadIds = [];
        const normalized = notifications.map((entry) => {
          if (!entry.read) {
            const identifier = entry.id || entry._id;
            if (identifier) {
              unreadIds.push(identifier);
              return { ...entry, read: true };
            }
          }
          return entry;
        });
        setItems(normalized);
        if (unreadIds.length > 0) {
          unreadIds.forEach((identifier) => {
            notificationsAPI
              .markRead(identifier, true)
              .catch((error) => console.error('Auto mark notification failed:', error));
          });
        }
      }
    } catch (err) {
      console.error('Failed to load notifications', err);
      toast.error('Failed to load notifications');
    }
  }, [userId]);

  useEffect(() => { fetchNotifications(); }, [fetchNotifications]);

  const toggleRead = async (n, read) => {
    try {
      const identifier = n.id || n._id;
      if (!identifier) {
        return;
      }
      await notificationsAPI.markRead(identifier, read);
      fetchNotifications(false);
    } catch (err) {
      console.error('Mark read failed', err);
      toast.error('Failed to update notification');
    }
  };

  const handleDelete = async (n) => {
    try {
      await api.delete(`/notifications/${n.id || n._id}`);
      fetchNotifications();
      toast.success('Deleted');
    } catch (err) {
      console.error('Delete failed', err);
      toast.error('Failed to delete');
    }
  };

  return (
    <Box>
      <Box mb={2}><Typography variant="h4">Notifications</Typography></Box>
      <Paper>
        <List>
          {items.length === 0 ? (
            <ListItem><ListItemText primary="No notifications" /></ListItem>
          ) : items.map(n => (
            <ListItem key={n.id || n._id} secondaryAction={(
              <>
                <IconButton onClick={() => toggleRead(n, !n.read)} title="Toggle read">
                  {n.read ? <MarkEmailReadIcon /> : <MarkEmailUnreadIcon />}
                </IconButton>
                <IconButton onClick={() => handleDelete(n)} title="Delete"><DeleteIcon /></IconButton>
              </>
            )}>
              <ListItemText primary={n.title} secondary={n.message} />
            </ListItem>
          ))}
        </List>
      </Paper>
    </Box>
  );
};

export default NotificationsPage;
```

## ReportsPage.js

| Field | Details |
| --- | --- |
| Program Name | ReportsPage.js |
| Description | Frontend page view for routing and page-level UI. |
| Called by | App.js |
| Table used | None |
|  |  |
| Programmer | Nazel Asca√±o |
| Date created | 12/14/2025 |
| Revision Date | TBD |
| Revision / description of change | None |

```javascript
import React, { useState, useEffect, useCallback, useRef, useMemo } from "react";
import {
  Box,
  Typography,
  Paper,
  Grid,
  Card,
  CardContent,
  Button,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  Alert,
  Tabs,
  Tab,
  List,
  ListItem,
  ListItemText,
  ListItemIcon,
  CircularProgress,
  Chip,
  Select,
  MenuItem,
  FormControl,
  InputLabel,
} from "@mui/material";
import {
  TrendingUp,
  LibraryBooks,
  People,
  Assignment,
  Warning,
  Download,
  Refresh,
  Assessment,
  Book,
  Schedule,
  CurrencyExchange,
  FilterList,
} from "@mui/icons-material";
import { DatePicker } from "@mui/x-date-pickers/DatePicker";
import { LocalizationProvider } from "@mui/x-date-pickers/LocalizationProvider";
import { AdapterDateFns } from "@mui/x-date-pickers/AdapterDateFns";
import { reportsAPI, studentsAPI } from "../../utils/api";
import { useAuth } from "../../contexts/AuthContext";
import { useSettings } from "../../contexts/SettingsContext";
import { formatCurrency } from "../../utils/currency";
import { generateReportPDF, downloadPDF } from "../../utils/pdfGenerator";

const DEFAULT_STUDENT_FILTERS = {
  grade: "",
  section: "",
  schoolYear: "",
};

const normalizeFilterValue = (value) => {
  if (value === null || value === undefined) return "";
  const trimmed = String(value).trim();
  if (!trimmed) return "";
  const lowered = trimmed.toLowerCase();
  if (["n/a", "not assigned", "none", "unknown"].includes(lowered)) {
    return "";
  }
  return trimmed;
};

const deriveFilterOptionsFromStudents = (students) => {
  const grades = new Set();
  const sections = new Set();
  const schoolYears = new Set();

  (students || []).forEach((student) => {
    const grade = normalizeFilterValue(student.grade || student.gradeLevel);
    if (grade) grades.add(grade);

    const section = normalizeFilterValue(student.section);
    if (section) sections.add(section);

    const schoolYear = normalizeFilterValue(student.schoolYear || student.academicYear);
    if (schoolYear) schoolYears.add(schoolYear);
  });

  const toSortedArray = (set) => Array.from(set).sort((a, b) => a.localeCompare(b));

  return {
    grades: toSortedArray(grades),
    sections: toSortedArray(sections),
    schoolYears: toSortedArray(schoolYears),
  };
};

const filterStudentsByCriteria = (students, filters) => {
  const gradeFilter = normalizeFilterValue(filters.grade);
  const sectionFilter = normalizeFilterValue(filters.section);
  const yearFilter = normalizeFilterValue(filters.schoolYear);

  return (students || []).filter((student) => {
    const grade = normalizeFilterValue(student.grade || student.gradeLevel);
    if (gradeFilter && grade !== gradeFilter) return false;

    const section = normalizeFilterValue(student.section);
    if (sectionFilter && section !== sectionFilter) return false;

    const schoolYear = normalizeFilterValue(student.schoolYear || student.academicYear);
    if (yearFilter && schoolYear !== yearFilter) return false;

    return true;
  });
};

const createInitialDashboardStats = () => ({
  totalBooks: 0,
  totalUsers: 0,
  activeTransactions: 0,
  overdueBooks: 0,
  monthlyBorrowings: 0,
  popularBooks: [],
  recentActivity: [],
});

const createInitialReportData = () => ({
  circulationReport: [],
  popularBooksReport: [],
  userActivityReport: [],
  overdueReport: [],
  fineReport: [],
  inventoryReport: [],
  studentListReport: [],
});

const ReportsPage = () => {
  const [currentTab, setCurrentTab] = useState(0);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState("");
  const [dateRange, setDateRange] = useState({
    startDate: new Date(new Date().getFullYear(), new Date().getMonth(), 1),
    endDate: new Date(),
  });

  const [studentFilters, setStudentFilters] = useState(DEFAULT_STUDENT_FILTERS);
  const [draftStudentFilters, setDraftStudentFilters] = useState(DEFAULT_STUDENT_FILTERS);

  const [filterOptions, setFilterOptions] = useState({
    grades: [],
    sections: [],
    schoolYears: [],
  });

  const [allStudents, setAllStudents] = useState([]);
  const studentFiltersRef = useRef(studentFilters);

  const [dashboardStats, setDashboardStats] = useState(() => createInitialDashboardStats());
  const [reportData, setReportData] = useState(() => createInitialReportData());
  const { isAuthenticated, loading: authLoading, user, authToken } = useAuth();
  const { finesEnabled } = useSettings();

  const sessionReady = useMemo(() => {
    if (authLoading) {
      return false;
    }
    if (typeof isAuthenticated === "function") {
      return isAuthenticated();
    }
    return Boolean(authToken && user);
  }, [authLoading, isAuthenticated, authToken, user]);

  const overviewMetrics = useMemo(
    () => [
      {
        key: "totalBooks",
        title: "Total Books",
        icon: LibraryBooks,
        color: "primary",
      },
      {
        key: "totalUsers",
        title: "Total Users",
        icon: People,
        color: "success",
      },
      {
        key: "activeTransactions",
        title: "Borrowed Books",
        icon: Assignment,
        color: "info",
      },
      {
        key: "overdueBooks",
        title: "Overdue Books",
        icon: Warning,
        color: "error",
      },
    ],
    [],
  );

  const resolvedOverviewMetrics = useMemo(() => {
    if (finesEnabled) {
      return overviewMetrics;
    }
    return overviewMetrics.filter((metric) => metric.key !== "overdueBooks");
  }, [finesEnabled, overviewMetrics]);

  const toValidDate = (value) => {
    if (!value) return null;
    const date = value instanceof Date ? value : new Date(value);
    return Number.isNaN(date.getTime()) ? null : date;
  };

  const formatNumber = (value) => {
    const number = Number(value);
    if (Number.isNaN(number)) return "0";
    return number.toLocaleString();
  };

  const formatDate = (value) => {
    const date = toValidDate(value);
    return date ? date.toLocaleDateString() : "N/A";
  };

  const formatDateTime = (value) => {
    const date = toValidDate(value);
    return date ? date.toLocaleString() : "N/A";
  };

  const convertToCSV = (data) => {
    if (!data || data.length === 0) return '';

    const headers = Object.keys(data[0]);
    const csvRows = [];

    csvRows.push(headers.join(','));

    data.forEach(row => {
      const values = headers.map(header => {
        const value = row[header];

        if (typeof value === 'string' && (value.includes(',') || value.includes('"'))) {
          return `"${value.replace(/"/g, '""')}"`;
        }
        return value || '';
      });
      csvRows.push(values.join(','));
    });

    return csvRows.join('\n');
  };

  const buildRowKey = (prefix, row, index) => {
    const candidate =
      row?.id ??
      row?._id ??
      row?.transactionId ??
      row?.userId ??
      row?.bookId ??
      row?.libraryId ??
      row?.libraryCardNumber ??
      row?.studentId ??
      row?.bookTitle ??
      row?.title ??
      row?.name ??
      row?.email;
    const normalized =
      candidate !== undefined && candidate !== null ? candidate : "row";
    return `${prefix}-${String(normalized)}-${index}`;
  };

  const renderTableRows = (rows, renderRow, emptyMessage, colSpan) => {
    if (!rows || rows.length === 0) {
      return (
        <TableRow>
          <TableCell
            colSpan={colSpan}
            align="center"
            sx={{ py: 4, color: "text.secondary" }}
          >
            {emptyMessage}
          </TableCell>
        </TableRow>
      );
    }
    return rows.map(renderRow);
  };

  const tableContainerSx = {
    borderRadius: 2,
    border: (theme) => `1px solid ${theme.palette.divider}`,
    overflow: "hidden",
  };

  const tableHeadSx = {
    bgcolor: "grey.50",
    "& .MuiTableCell-root": {
      fontWeight: 600,
      fontSize: 12,
      letterSpacing: 0.4,
      color: "text.secondary",
      textTransform: "uppercase",
    },
  };

  const stripedRowSx = {
    "&:nth-of-type(odd)": {
      bgcolor: "grey.50",
    },
    "&:hover": {
      bgcolor: "action.hover",
    },
  };

  const getRangeParams = useCallback(() => {
    const params = {};
    const start = toValidDate(dateRange.startDate);
    const end = toValidDate(dateRange.endDate);
    if (start) params.startDate = start.toISOString();
    if (end) params.endDate = end.toISOString();
    return params;
  }, [dateRange.startDate, dateRange.endDate]);

  const loadAllReports = useCallback(async () => {
    if (!sessionReady) {
      return;
    }
    try {
      setLoading(true);
      setError("");
      const params = getRangeParams();

      const overdueLoader = finesEnabled
        ? reportsAPI.getOverdue(params)
        : Promise.resolve({ data: [] });
      const fineLoader = finesEnabled
        ? reportsAPI.getFines(params)
        : Promise.resolve({ data: [] });

      const [
        dashboardResponse,
        statsResponse,
        circulation,
        popular,
        userActivity,
        overdue,
        fine,
        inventory,
        studentsResponse,
      ] = await Promise.all([
        reportsAPI.getDashboard(params),
        reportsAPI.getStats(),
        reportsAPI.getCirculation(params),
        reportsAPI.getPopularBooks(params),
        reportsAPI.getUserActivity(params),
        overdueLoader,
        fineLoader,
        reportsAPI.getInventory(),
        studentsAPI.getAll(),
      ]);

  const studentsRaw = studentsResponse?.data?.students || studentsResponse?.data || [];
      setAllStudents(studentsRaw);
      setFilterOptions(deriveFilterOptionsFromStudents(studentsRaw));
  const activeStudentFilters = studentFiltersRef.current;
  const filteredStudents = filterStudentsByCriteria(studentsRaw, activeStudentFilters);

      setDashboardStats({
        ...createInitialDashboardStats(),
        ...(dashboardResponse?.data || {}),
        ...(statsResponse?.data || {}),
      });

      setReportData({
        circulationReport: circulation?.data || [],
        popularBooksReport: popular?.data || [],
        userActivityReport: userActivity?.data || [],
        overdueReport: overdue?.data || [],
        fineReport: fine?.data || [],
        inventoryReport: inventory?.data || [],
        studentListReport: filteredStudents,
      });
    } catch (loadError) {
      setError("Failed to load reports data");
      console.error("Error loading reports data:", loadError);
    } finally {
      setLoading(false);
    }
  }, [finesEnabled, getRangeParams, sessionReady]);

  useEffect(() => {
    if (!finesEnabled && (currentTab === 4 || currentTab === 5)) {
      setCurrentTab(0);
    }
  }, [currentTab, finesEnabled]);

  useEffect(() => {
    if (!sessionReady) {
      if (!authLoading) {
        setDashboardStats(createInitialDashboardStats());
        setReportData(createInitialReportData());
        setAllStudents([]);
        setFilterOptions({ grades: [], sections: [], schoolYears: [] });
        setLoading(false);
        setError("");
      }
      return;
    }
    loadAllReports();
  }, [sessionReady, authLoading, loadAllReports]);

  useEffect(() => {
    studentFiltersRef.current = studentFilters;
  }, [studentFilters]);

  useEffect(() => {
    setReportData((prev) => ({
      ...prev,
      studentListReport: filterStudentsByCriteria(allStudents, studentFilters),
    }));
  }, [allStudents, studentFilters]);

  const handleExportReport = async (type) => {
    if (!finesEnabled && (type === "overdue" || type === "fines")) {
      return;
    }
    try {
      if (type === "student-list") {
        const studentRows = (reportData.studentListReport || []).map((student) => ({
          LibraryID: student.libraryId || student.libraryCardNumber || student.studentId || "",
          Name:
            student.firstName && student.lastName
              ? `${student.firstName} ${student.middleName || ""} ${student.lastName}`.replace(/\s+/g, " ").trim()
              : student.name || "",
          GradeSection:
            student.grade && student.section
              ? `${student.grade} - ${student.section}`
              : student.grade || student.section || "",
          Email: student.email || "",
          Phone: student.phoneNumber || student.parentPhone || "",
          LibraryCard: student.libraryCardNumber || "",
          Status: student.isActive !== false ? "Active" : "Inactive",
        }));

        const csvData = convertToCSV(studentRows);
        const blob = new Blob([csvData], { type: "text/csv;charset=utf-8;" });
        const url = window.URL.createObjectURL(blob);
        const link = document.createElement("a");
        link.href = url;
        link.setAttribute(
          "download",
          `${type}_report_${new Date().toISOString().split("T")[0]}.csv`,
        );
        document.body.appendChild(link);
        link.click();
        link.remove();
        window.URL.revokeObjectURL(url);
        return;
      }

      const params = { ...getRangeParams(), format: "csv" };
      const response = await reportsAPI.export(type, params);

      const url = window.URL.createObjectURL(new Blob([response.data]));
      const link = document.createElement("a");
      link.href = url;
      link.setAttribute(
        "download",
        `${type}_report_${new Date().toISOString().split("T")[0]}.csv`,
      );
      document.body.appendChild(link);
      link.click();
      link.remove();
      window.URL.revokeObjectURL(url);
    } catch (exportError) {
      setError(`Failed to export ${type} report`);
      console.error("Error exporting report:", exportError);
    }
  };

  const handlePrintReport = async (type, reportData) => {
    if (!finesEnabled && (type === "overdue" || type === "fines")) {
      return;
    }
    try {
      const options = {
        startDate: dateRange.startDate,
        endDate: dateRange.endDate
      };

      if (type === 'student-list') {
        options.studentFilters = studentFilters;
      }

      const pdf = await generateReportPDF(type, reportData, options);
      downloadPDF(pdf, `${type}_report_${new Date().toISOString().split("T")[0]}.pdf`);
    } catch (printError) {
      setError(`Failed to generate PDF for ${type} report`);
      console.error("Error generating PDF:", printError);
    }
  };

  const TabPanel = ({ children, value, index }) => {
    if (value !== index) {
      return null;
    }
    return <Box sx={{ px: { xs: 1.5, md: 3 }, py: 3 }}>{children}</Box>;
  };

  if (loading && currentTab === 0) {
    return (
      <Box
        display="flex"
        justifyContent="center"
        alignItems="center"
        minHeight="400px"
      >
        <CircularProgress />
      </Box>
    );
  }

  return (
    <LocalizationProvider dateAdapter={AdapterDateFns}>
      <Box sx={{ display: "flex", flexDirection: "column", gap: 3 }}>
        <Box
          sx={{
            display: "flex",
            flexDirection: { xs: "column", md: "row" },
            alignItems: { xs: "flex-start", md: "center" },
            justifyContent: "space-between",
            gap: 2,
          }}
        >
          <Box>
            <Typography variant="h4" sx={{ fontWeight: 600 }} color={"white"}>
              Reports & Analytics
            </Typography>
            <Typography variant="body2" color="text.secondary">
              Track circulation, popular titles, user activity, and more in one
              place.
            </Typography>
          </Box>
          <Button
            variant="outlined"
            startIcon={<Refresh />}
            onClick={loadAllReports}
            sx={{ alignSelf: { xs: "stretch", md: "center" } }}
          >
            Refresh Data
          </Button>
        </Box>
        {error && (
          <Alert severity="error" sx={{ mb: 1 }}>
            {error}
          </Alert>
        )}
        <Paper
          elevation={0}
          sx={{
            p: 2,
            borderRadius: 2,
            border: (theme) => `1px solid ${theme.palette.divider}`,
          }}
        >
          {currentTab === 7 ? (
              <>
                <Typography variant="subtitle2" color="text.secondary" gutterBottom>
                  Student Filters
                </Typography>
                <Grid container spacing={2} alignItems="center">
                  <Grid item xs={12} sm={4} md={3}>
                    <FormControl fullWidth size="small">
                      <InputLabel>Grade</InputLabel>
                      <Select
                        value={draftStudentFilters.grade}
                        label="Grade"
                        onChange={(e) => setDraftStudentFilters({ ...draftStudentFilters, grade: e.target.value })}
                      >
                        <MenuItem value="">
                          <em>All Grades</em>
                        </MenuItem>
                        {filterOptions.grades.map((grade) => (
                          <MenuItem key={grade} value={grade}>
                            {grade}
                          </MenuItem>
                        ))}
                      </Select>
                    </FormControl>
                  </Grid>
                  <Grid item xs={12} sm={4} md={3}>
                    <FormControl fullWidth size="small">
                      <InputLabel>Section</InputLabel>
                      <Select
                        value={draftStudentFilters.section}
                        label="Section"
                        onChange={(e) => setDraftStudentFilters({ ...draftStudentFilters, section: e.target.value })}
                      >
                        <MenuItem value="">
                          <em>All Sections</em>
                        </MenuItem>
                        {filterOptions.sections.map((section) => (
                          <MenuItem key={section} value={section}>
                            Section {section}
                          </MenuItem>
                        ))}
                      </Select>
                    </FormControl>
                  </Grid>
                  <Grid item xs={12} sm={4} md={3}>
                    <FormControl fullWidth size="small">
                      <InputLabel>School Year</InputLabel>
                      <Select
                        value={draftStudentFilters.schoolYear}
                        label="School Year"
                        onChange={(e) => setDraftStudentFilters({ ...draftStudentFilters, schoolYear: e.target.value })}
                      >
                        <MenuItem value="">
                          <em>All Years</em>
                        </MenuItem>
                        {filterOptions.schoolYears.map((year) => (
                          <MenuItem key={year} value={year}>
                            {year}
                          </MenuItem>
                        ))}
                      </Select>
                    </FormControl>
                  </Grid>
                  <Grid
                    item
                    xs={12}
                    sm={12}
                    md={3}
                    sx={{ display: "flex", justifyContent: { xs: "flex-start", md: "flex-end" }, gap: 1 }}
                  >
                    <Button
                      size="small"
                      onClick={() => {
                        setDraftStudentFilters(DEFAULT_STUDENT_FILTERS);
                        setStudentFilters(DEFAULT_STUDENT_FILTERS);
                      }}
                    >
                      Clear
                    </Button>
                    <Button
                      size="small"
                      variant="contained"
                      startIcon={<FilterList />}
                      onClick={() => {
                        setStudentFilters(draftStudentFilters);
                      }}
                    >
                      Apply
                    </Button>
                  </Grid>
                </Grid>
              </>
          ) : (

            <Grid container spacing={2} alignItems="center">
              <Grid item xs={12} sm={3} md={2.5}>
                <Typography variant="subtitle2" color="text.secondary">
                  Date Range
                </Typography>
              </Grid>
              <Grid item xs={12} sm={4} md={3}>
                <DatePicker
                  label="Start Date"
                  value={dateRange.startDate}
                  onChange={(newValue) =>
                    setDateRange({ ...dateRange, startDate: newValue })
                  }
                  slotProps={{ textField: { size: "small", fullWidth: true } }}
                />
              </Grid>
              <Grid item xs={12} sm={4} md={3}>
                <DatePicker
                  label="End Date"
                  value={dateRange.endDate}
                  onChange={(newValue) =>
                    setDateRange({ ...dateRange, endDate: newValue })
                  }
                  slotProps={{ textField: { size: "small", fullWidth: true } }}
                />
              </Grid>
              <Grid
                item
                xs={12}
                sm={4}
                md={3}
                sx={{ display: "flex", justifyContent: { sm: "flex-end" } }}
              >
                <Button variant="contained" onClick={loadAllReports} fullWidth>
                  Apply Filter
                </Button>
              </Grid>
            </Grid>
          )}
        </Paper>
        <Paper
          elevation={0}
          sx={{
            borderRadius: 2,
            border: (theme) => `1px solid ${theme.palette.divider}`,
          }}
        >
          <Tabs
            value={currentTab}
            onChange={(event, newValue) => setCurrentTab(newValue)}
            variant="scrollable"
            scrollButtons="auto"
            sx={{ px: 2, borderBottom: (theme) => `1px solid ${theme.palette.divider}` }}
          >
            <Tab label="Overview" icon={<Assessment />} disableRipple />
            <Tab label="Circulation" icon={<TrendingUp />} disableRipple />
            <Tab label="Popular Books" icon={<LibraryBooks />} disableRipple />
            <Tab label="User Activity" icon={<People />} disableRipple />
            <Tab
              label="Overdue Books"
              icon={<Warning />}
              disableRipple
              sx={{ display: finesEnabled ? "inline-flex" : "none" }}
            />
            <Tab
              label="Fines"
              icon={<CurrencyExchange />}
              disableRipple
              sx={{ display: finesEnabled ? "inline-flex" : "none" }}
            />
            <Tab label="Inventory" icon={<Book />} disableRipple />
            <Tab label="Student List" icon={<People />} disableRipple />
          </Tabs>
          {}{" "}
          <TabPanel value={currentTab} index={0}>
            <Grid container spacing={3}>
              {resolvedOverviewMetrics.map((metric) => {
                const Icon = metric.icon;
                return (
                  <Grid key={metric.key} item xs={12} sm={6} md={3}>
                    <Card
                      elevation={0}
                      sx={{
                        borderRadius: 2,
                        border: (theme) => `1px solid ${theme.palette.divider}`,
                        height: "100%",
                      }}
                    >
                      <CardContent>
                        <Box display="flex" alignItems="center" gap={2}>
                          <Icon color={metric.color} sx={{ fontSize: 38 }} />
                          <Box>
                            <Typography variant="h4" sx={{ fontWeight: 600 }}>
                              {formatNumber(dashboardStats[metric.key])}
                            </Typography>
                            <Typography variant="body2" color="text.secondary">
                              {metric.title}
                            </Typography>
                          </Box>
                        </Box>
                      </CardContent>
                    </Card>
                  </Grid>
                );
              })}
              {}{" "}
              <Grid item xs={12} md={6}>
                <Card>
                  <CardContent>
                    <Typography variant="h6" gutterBottom>
                      Most Popular Books
                    </Typography>
                    <List>
                      {dashboardStats.popularBooks.slice(0, 5).map((book, index) => (
                        <ListItem key={buildRowKey("overview-popular", book, index)}>
                          <ListItemIcon>
                            <Typography variant="h6" color="primary">
                              #{index + 1}
                            </Typography>
                          </ListItemIcon>
                          <ListItemText
                            primary={book.title || "Unknown Title"}
                            secondary={`${formatNumber(book.borrowCount)} borrowings`}
                          />
                        </ListItem>
                      ))}
                    </List>
                  </CardContent>{" "}
                </Card>{" "}
              </Grid>
              {}{" "}
              <Grid item xs={12} md={6}>
                <Card>
                  <CardContent>
                    <Typography variant="h6" gutterBottom>
                      Recent Activity
                    </Typography>
                    <List>
                      {dashboardStats.recentActivity.slice(0, 5).map((activity, index) => (
                        <ListItem key={index}>
                          <ListItemIcon>
                            <Schedule color="primary" />
                          </ListItemIcon>
                          <ListItemText
                            primary={
                              activity.description ||
                              (activity.type
                                ? `Transaction ${activity.type}`
                                : "Activity update")
                            }
                            secondary={
                              [
                                formatDateTime(activity.timestamp || activity.date),
                                activity.bookCount
                                  ? `${formatNumber(activity.bookCount)} book${activity.bookCount === 1 ? "" : "s"}`
                                  : null,
                              ]
                                .filter(Boolean)
                                .join(" ‚Ä¢ ")
                            }
                          />
                        </ListItem>
                      ))}
                    </List>
                  </CardContent>{" "}
                </Card>{" "}
              </Grid>{" "}
            </Grid>{" "}
          </TabPanel>
          {}{" "}
          <TabPanel value={currentTab} index={1}>
            <Box
              display="flex"
              justifyContent="space-between"
              alignItems="center"
              mb={2}
            >
              <Typography variant="h6"> Circulation Report </Typography>{" "}
              <Box display="flex" gap={1}>
                <Button
                  variant="outlined"
                  startIcon={<Download />}
                  onClick={() => handleExportReport("circulation")}
                >
                  Export CSV{" "}
                </Button>{" "}
                <Button
                  variant="contained"
                  startIcon={<Download />}
                  onClick={() => handlePrintReport("circulation", reportData.circulationReport)}
                >
                  Export PDF{" "}
                </Button>{" "}
              </Box>
            </Box>{" "}
            <TableContainer sx={tableContainerSx}>
              <Table size="small">
                <TableHead sx={tableHeadSx}>
                  <TableRow>
                    <TableCell>Date</TableCell>
                    <TableCell>Books Borrowed</TableCell>
                    <TableCell>Books Returned</TableCell>
                    <TableCell>New Registrations</TableCell>
                    <TableCell>Fines Collected</TableCell>
                  </TableRow>
                </TableHead>
                <TableBody>
                  {renderTableRows(
                    reportData.circulationReport,
                    (row, index) => (
                      <TableRow key={index} sx={stripedRowSx}>
                        <TableCell>{formatDate(row.date)}</TableCell>
                        <TableCell>{formatNumber(row.borrowed)}</TableCell>
                        <TableCell>{formatNumber(row.returned)}</TableCell>
                        <TableCell>{formatNumber(row.newUsers)}</TableCell>
                        <TableCell>{formatCurrency(row.finesCollected)}</TableCell>
                      </TableRow>
                    ),
                    "No circulation activity for this range.",
                    5,
                  )}
                </TableBody>
              </Table>
            </TableContainer>
          </TabPanel>
          {}{" "}
          <TabPanel value={currentTab} index={2}>
            <Box
              display="flex"
              justifyContent="space-between"
              alignItems="center"
              mb={2}
            >
              <Typography variant="h6"> Popular Books Report </Typography>{" "}
              <Box display="flex" gap={1}>
                <Button
                  variant="outlined"
                  startIcon={<Download />}
                  onClick={() => handleExportReport("popular-books")}
                >
                  Export CSV{" "}
                </Button>{" "}
                <Button
                  variant="contained"
                  startIcon={<Download />}
                  onClick={() => handlePrintReport("popular-books", reportData.popularBooksReport)}
                >
                  Export PDF{" "}
                </Button>{" "}
              </Box>
            </Box>{" "}
            <TableContainer sx={tableContainerSx}>
              <Table size="small">
                <TableHead sx={tableHeadSx}>
                  <TableRow>
                    <TableCell>Rank</TableCell>
                    <TableCell>Book Title</TableCell>
                    <TableCell>Author</TableCell>
                    <TableCell>Category</TableCell>
                    <TableCell>Times Borrowed</TableCell>
                    <TableCell>Average Rating</TableCell>
                  </TableRow>
                </TableHead>
                <TableBody>
                  {renderTableRows(
                    reportData.popularBooksReport,
                    (book, index) => (
                      <TableRow key={buildRowKey("popular-book", book, index)} sx={stripedRowSx}>
                        <TableCell>{`#${index + 1}`}</TableCell>
                        <TableCell>{book.title || "Unknown Title"}</TableCell>
                        <TableCell>
                          {book.author || "Unknown Author"}
                        </TableCell>
                        <TableCell>
                          <Chip
                            label={book.category || "Uncategorized"}
                            size="small"
                            color={book.category ? "default" : "warning"}
                          />
                        </TableCell>
                        <TableCell>{formatNumber(book.borrowCount)}</TableCell>
                        <TableCell>{book.averageRating ?? "N/A"}</TableCell>
                      </TableRow>
                    ),
                    "No popular books data available.",
                    6,
                  )}
                </TableBody>
              </Table>
            </TableContainer>
          </TabPanel>
          {}{" "}
          <TabPanel value={currentTab} index={3}>
            <Box
              display="flex"
              justifyContent="space-between"
              alignItems="center"
              mb={2}
            >
              <Typography variant="h6"> User Activity Report </Typography>{" "}
              <Box display="flex" gap={1}>
                <Button
                  variant="outlined"
                  startIcon={<Download />}
                  onClick={() => handleExportReport("user-activity")}
                >
                  Export CSV{" "}
                </Button>{" "}
                <Button
                  variant="contained"
                  startIcon={<Download />}
                  onClick={() => handlePrintReport("user-activity", reportData.userActivityReport)}
                >
                  Export PDF{" "}
                </Button>{" "}
              </Box>
            </Box>{" "}
            <TableContainer sx={tableContainerSx}>
              <Table size="small">
                <TableHead sx={tableHeadSx}>
                  <TableRow>
                    <TableCell>User</TableCell>
                    <TableCell>Role</TableCell>
                    <TableCell>Books Borrowed</TableCell>
                    <TableCell>Books Returned</TableCell>
                    <TableCell>Total Fines</TableCell>
                    <TableCell>Last Activity</TableCell>
                  </TableRow>
                </TableHead>
                <TableBody>
                  {renderTableRows(
                    reportData.userActivityReport,
                    (user, index) => (
                      <TableRow key={buildRowKey("user-activity", user, index)} sx={stripedRowSx}>
                        <TableCell>
                          {user.name || `${user.firstName || ""} ${user.lastName || ""}`.trim() || "Unknown User"}
                        </TableCell>
                        <TableCell>
                          <Chip
                            label={user.role || "Unknown"}
                            size="small"
                            color={user.role ? "default" : "warning"}
                          />
                        </TableCell>
                        <TableCell>{formatNumber(user.borrowed)}</TableCell>
                        <TableCell>{formatNumber(user.returned)}</TableCell>
                        <TableCell>{formatCurrency(user.totalFines)}</TableCell>
                        <TableCell>{formatDate(user.lastActivity)}</TableCell>
                      </TableRow>
                    ),
                    "No user activity recorded for this range.",
                    6,
                  )}
                </TableBody>
              </Table>
            </TableContainer>
          </TabPanel>
          {}{" "}
          {finesEnabled ? (
          <TabPanel value={currentTab} index={4}>
            <Box
              display="flex"
              justifyContent="space-between"
              alignItems="center"
              mb={2}
            >
              <Typography variant="h6"> Overdue Books Report </Typography>{" "}
              <Box display="flex" gap={1}>
                <Button
                  variant="outlined"
                  startIcon={<Download />}
                  onClick={() => handleExportReport("overdue")}
                >
                  Export CSV{" "}
                </Button>{" "}
                <Button
                  variant="contained"
                  startIcon={<Download />}
                  onClick={() => handlePrintReport("overdue", reportData.overdueReport)}
                >
                  Export PDF{" "}
                </Button>{" "}
              </Box>
            </Box>{" "}
            <TableContainer sx={tableContainerSx}>
              <Table size="small">
                <TableHead sx={tableHeadSx}>
                  <TableRow>
                    <TableCell>Book Title</TableCell>
                    <TableCell>Borrower</TableCell>
                    <TableCell>Due Date</TableCell>
                    <TableCell>Days Overdue</TableCell>
                    <TableCell>Accumulated Fine</TableCell>
                    <TableCell>Status</TableCell>
                  </TableRow>
                </TableHead>
                <TableBody>
                  {renderTableRows(
                    reportData.overdueReport,
                    (item, index) => (
                      <TableRow key={buildRowKey("overdue", item, index)} sx={stripedRowSx}>
                        <TableCell>{item.bookTitle || "Unknown Book"}</TableCell>
                        <TableCell>
                          {item.borrowerName || "Unknown Borrower"}
                        </TableCell>
                        <TableCell>{formatDate(item.dueDate)}</TableCell>
                        <TableCell>{formatNumber(item.daysOverdue)}</TableCell>
                        <TableCell>{formatCurrency(item.fine)}</TableCell>
                        <TableCell>
                          <Chip
                            label={item.status || "Overdue"}
                            color={
                              Number(item.daysOverdue) > 30 ? "error" : "warning"
                            }
                            size="small"
                          />
                        </TableCell>
                      </TableRow>
                    ),
                    "No overdue items at the moment.",
                    6,
                  )}
                </TableBody>
              </Table>
            </TableContainer>
              </TabPanel>
              ) : null}
              {}{" "}
              {finesEnabled ? (
              <TabPanel value={currentTab} index={5}>
            <Box
              display="flex"
              justifyContent="space-between"
              alignItems="center"
              mb={2}
            >
              <Typography variant="h6"> Fines Report </Typography>{" "}
              <Box display="flex" gap={1}>
                <Button
                  variant="outlined"
                  startIcon={<Download />}
                  onClick={() => handleExportReport("fines")}
                >
                  Export CSV{" "}
                </Button>{" "}
                <Button
                  variant="contained"
                  startIcon={<Download />}
                  onClick={() => handlePrintReport("fines", reportData.fineReport)}
                >
                  Export PDF{" "}
                </Button>{" "}
              </Box>
            </Box>{" "}
            <TableContainer sx={tableContainerSx}>
              <Table size="small">
                <TableHead sx={tableHeadSx}>
                  <TableRow>
                    <TableCell>Date</TableCell>
                    <TableCell>User</TableCell>
                    <TableCell>Book</TableCell>
                    <TableCell>Fine Amount</TableCell>
                    <TableCell>Reason</TableCell>
                    <TableCell>Status</TableCell>
                  </TableRow>
                </TableHead>
                <TableBody>
                  {renderTableRows(
                    reportData.fineReport,
                    (fine, index) => (
                      <TableRow key={buildRowKey("fine", fine, index)} sx={stripedRowSx}>
                        <TableCell>{formatDate(fine.date)}</TableCell>
                        <TableCell>
                          {fine.userName || "Unknown User"}
                        </TableCell>
                        <TableCell>
                          {fine.bookTitle || "Unknown Book"}
                        </TableCell>
                        <TableCell>{formatCurrency(fine.amount)}</TableCell>
                        <TableCell>{fine.reason || "N/A"}</TableCell>
                        <TableCell>
                          <Chip
                            label={fine.status || "unpaid"}
                            color={
                              (fine.status || "").toLowerCase() === "paid"
                                ? "success"
                                : "warning"
                            }
                            size="small"
                          />
                        </TableCell>
                      </TableRow>
                    ),
                    "No fines recorded for this range.",
                    6,
                  )}
                </TableBody>
              </Table>
            </TableContainer>
          </TabPanel>
          ) : null}
          {}{" "}
          <TabPanel value={currentTab} index={6}>
            <Box
              display="flex"
              justifyContent="space-between"
              alignItems="center"
              mb={2}
            >
              <Typography variant="h6"> Inventory Report </Typography>{" "}
              <Box display="flex" gap={1}>
                <Button
                  variant="outlined"
                  startIcon={<Download />}
                  onClick={() => handleExportReport("inventory")}
                >
                  Export CSV{" "}
                </Button>{" "}
                <Button
                  variant="contained"
                  startIcon={<Download />}
                  onClick={() => handlePrintReport("inventory", reportData.inventoryReport)}
                >
                  Export PDF{" "}
                </Button>{" "}
              </Box>
            </Box>{" "}
            <TableContainer sx={tableContainerSx}>
              <Table size="small">
                <TableHead sx={tableHeadSx}>
                  <TableRow>
                    <TableCell>Book Title</TableCell>
                    <TableCell>Author</TableCell>
                    <TableCell>Category</TableCell>
                    <TableCell>Total Copies</TableCell>
                    <TableCell>Available</TableCell>
                    <TableCell>Borrowed</TableCell>
                    <TableCell>Lost / Damaged</TableCell>
                  </TableRow>
                </TableHead>
                <TableBody>
                  {renderTableRows(
                    reportData.inventoryReport,
                    (book, index) => (
                      <TableRow key={buildRowKey("inventory", book, index)} sx={stripedRowSx}>
                        <TableCell>{book.title || "Unknown Title"}</TableCell>
                        <TableCell>{book.author || "Unknown Author"}</TableCell>
                        <TableCell>
                          <Chip
                            label={book.category || "Uncategorized"}
                            size="small"
                            color={book.category ? "default" : "warning"}
                          />
                        </TableCell>
                        <TableCell>{formatNumber(book.totalCopies)}</TableCell>
                        <TableCell>{formatNumber(book.available)}</TableCell>
                        <TableCell>{formatNumber(book.borrowed)}</TableCell>
                        <TableCell>{formatNumber(book.lostDamaged)}</TableCell>
                      </TableRow>
                    ),
                    "Inventory looks good - no records found for this range.",
                    7,
                  )}
                </TableBody>
              </Table>
            </TableContainer>
          </TabPanel>{" "}
          {}{" "}
          <TabPanel value={currentTab} index={7}>
            <Box
              display="flex"
              justifyContent="space-between"
              alignItems="center"
              mb={2}
            >
              <Typography variant="h6"> Student List Report </Typography>{" "}
              <Box display="flex" gap={1}>
                <Button
                  variant="outlined"
                  startIcon={<Download />}
                  onClick={() => handleExportReport("student-list")}
                >
                  Export CSV{" "}
                </Button>{" "}
                <Button
                  variant="contained"
                  startIcon={<Download />}
                  onClick={() => handlePrintReport("student-list", reportData.studentListReport)}
                >
                  Export PDF{" "}
                </Button>{" "}
              </Box>
            </Box>{" "}
            <TableContainer sx={tableContainerSx}>
              <Table size="small">
                <TableHead sx={tableHeadSx}>
                  <TableRow>
                    <TableCell>Library ID</TableCell>
                    <TableCell>Name</TableCell>
                    <TableCell>Grade & Section</TableCell>
                    <TableCell>Email</TableCell>
                    <TableCell>Phone</TableCell>
                    <TableCell>Library Card</TableCell>
                    <TableCell>Status</TableCell>
                  </TableRow>
                </TableHead>
                <TableBody>
                  {renderTableRows(
                    reportData.studentListReport,
                    (student, index) => (
                      <TableRow key={buildRowKey("student", student, index)} sx={stripedRowSx}>
                        <TableCell>{student.libraryId || student.libraryCardNumber || student.studentId || "N/A"}</TableCell>
                        <TableCell>
                          {student.firstName && student.lastName
                            ? `${student.firstName} ${student.middleName || ""} ${student.lastName}`.trim()
                            : student.name || "Unknown"}
                        </TableCell>
                        <TableCell>
                          {student.grade && student.section
                            ? `${student.grade} - ${student.section}`
                            : student.grade || student.section || "N/A"}
                        </TableCell>
                        <TableCell>{student.email || "N/A"}</TableCell>
                        <TableCell>{student.phoneNumber || "N/A"}</TableCell>
                        <TableCell>{student.libraryCardNumber || "Not assigned"}</TableCell>
                        <TableCell>
                          <Chip
                            label={student.isActive !== false ? "Active" : "Inactive"}
                            color={student.isActive !== false ? "success" : "error"}
                            size="small"
                          />
                        </TableCell>
                      </TableRow>
                    ),
                    "No students found.",
                    7,
                  )}
                </TableBody>
              </Table>
            </TableContainer>
          </TabPanel>{" "}
        </Paper>{" "}
      </Box>{" "}
    </LocalizationProvider>
  );
};

export default ReportsPage;
```

## RequestsPage.js

| Field | Details |
| --- | --- |
| Program Name | RequestsPage.js |
| Description | Frontend page view for routing and page-level UI. |
| Called by | App.js |
| Table used | transactions |
|  |  |
| Programmer | Nazel Asca√±o |
| Date created | 12/14/2025 |
| Revision Date | TBD |
| Revision / description of change | None |

```javascript
import React, { useCallback, useEffect, useMemo, useState } from 'react';
import { useNavigate } from 'react-router-dom';
import {
  Alert,
  Autocomplete,
  Box,
  Button,
  Checkbox,
  CircularProgress,
  Dialog,
  DialogActions,
  DialogContent,
  DialogTitle,
  Divider,
  IconButton,
  InputAdornment,
  List,
  ListItem,
  ListItemText,
  Paper,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TablePagination,
  TableRow,
  TextField,
  Tooltip,
  Typography,
} from '@mui/material';
import ArrowBackIcon from '@mui/icons-material/ArrowBack';
import QrCodeScannerIcon from '@mui/icons-material/QrCodeScanner';
import { api } from '../../utils/api';
import toast from 'react-hot-toast';
import { useAuth } from '../../contexts/AuthContext';
import QRScanner from '../../components/QRScanner';

const RequestsPage = () => {
  useAuth();
  const navigate = useNavigate();
  const [requests, setRequests] = useState([]);
  const [loading, setLoading] = useState(true);
  const [selected, setSelected] = useState([]);
  const [rejectDialogOpen, setRejectDialogOpen] = useState(false);
  const [rejectReason, setRejectReason] = useState('');
  const [page, setPage] = useState(0);
  const [rowsPerPage, setRowsPerPage] = useState(50);

  const [approveDialogOpen, setApproveDialogOpen] = useState(false);
  const [approveTarget, setApproveTarget] = useState(null);
  const [approveAssignments, setApproveAssignments] = useState({});
  const [approveBooks, setApproveBooks] = useState({});
  const [approveLoading, setApproveLoading] = useState(false);
  const [approveSubmitting, setApproveSubmitting] = useState(false);
  const [approveError, setApproveError] = useState('');
  const [scannerConfig, setScannerConfig] = useState({ open: false, targetKey: null, label: '' });

  const approveTransaction = (txId, payload) => api.post(`/transactions/approve/${txId}`, payload);

  const resolveTransactionId = (entry) =>
    entry?.id || entry?.transactionId || entry?._id || entry?.resolvedId || null;

  const getTransactionItems = (entry) => {
    if (!entry) return [];
    if (Array.isArray(entry.items)) return entry.items;
    if (entry.transaction && Array.isArray(entry.transaction.items)) return entry.transaction.items;
    return [];
  };

  const buildItemKey = (item, index) => {
    if (!item) return `item-${index}`;
    if (item.requestItemId) return String(item.requestItemId);
    const bookId = item.bookId ? String(item.bookId) : 'book';
    return `${bookId}-${index}`;
  };

    const normalizeRequests = useCallback((entries = []) => {
      if (!Array.isArray(entries)) return [];
      const seen = new Set();
      return entries.reduce((acc, entry, index) => {
        const id = resolveTransactionId(entry);
        if (id) {
          if (seen.has(id)) {
            return acc;
          }
          seen.add(id);
          acc.push(entry);
          return acc;
        }
        acc.push({ ...entry, __fallbackKey: `request-${index}` });
        return acc;
      }, []);
    }, []);

  const fetchRequests = useCallback(async () => {
    try {
      setLoading(true);
      const resp = await api.get('/transactions', { params: { status: 'requested', limit: 200 } });
      const data = Array.isArray(resp.data) ? resp.data : resp.data?.transactions || [];
      setRequests(normalizeRequests(data));
    } catch (err) {
      console.error('Failed to load requests', err);
      toast.error('Failed to load requests');
    } finally {
      setLoading(false);
    }
  }, [normalizeRequests]);

  useEffect(() => { fetchRequests(); }, [fetchRequests]);

  const shouldFallbackToAssignments = (errorResponse) => {
    if (!errorResponse) return false;
    const message = String(errorResponse.message || '').toLowerCase();
    const hasMessageMatch = message && (
      message.includes('copy assignments') ||
      message.includes('missing copy') ||
      message.includes('missing-copy') ||
      message.includes('copy-not-found') ||
      message.includes('copy-unavailable') ||
      message.includes('requested copies are missing')
    );

    const detailReasons = Array.isArray(errorResponse.details)
      ? errorResponse.details
      : Array.isArray(errorResponse.details?.validationFailures)
        ? errorResponse.details.validationFailures
        : [];

    const hasDetailMatch = detailReasons.some((entry) => {
      const reason = String(entry?.reason || '').toLowerCase();
      return reason && (
        reason.includes('copy') ||
        reason.includes('missing')
      );
    });

    return hasMessageMatch || hasDetailMatch;
  };

  const approveWithoutAssignments = async (tx) => {
    const id = resolveTransactionId(tx);
    if (!id) return;
    try {
      await approveTransaction(id);
      toast.success('Request approved');
      setSelected((prev) => prev.filter((value) => value !== id));
      fetchRequests();
    } catch (err) {
      console.error('Approve failed', err);
      const status = err.response?.status;
      const message = err.response?.data?.message || 'Approve failed';
      if (status === 400 && shouldFallbackToAssignments(err.response?.data)) {
        toast.error(`${message}. Please assign copies manually.`);
        openApproveDialog(tx);
        return;
      }
      toast.error(message);
    }
  };

  const startApproveWorkflow = (tx) => {
    const items = getTransactionItems(tx);
    if (items.some((item) => !item?.copyId)) {
      openApproveDialog(tx);
      return;
    }
    approveWithoutAssignments(tx);
  };

  const openApproveDialog = async (tx) => {
    const id = resolveTransactionId(tx);
    const items = getTransactionItems(tx).map((item) => ({ ...item }));
    if (!id) return;

    setApproveDialogOpen(true);
    setApproveTarget({ id, transaction: tx, items });
    setApproveAssignments({});
    setApproveBooks({});
    setApproveError('');
    setApproveSubmitting(false);
    setApproveLoading(true);

    try {
      const missingBookRefs = items.some((item) => !item.copyId && !item.bookId);
      if (missingBookRefs) {
        setApproveError('Some requested items do not reference a specific book. Please review the request.');
      }

      const uniqueBookIds = Array.from(
        new Set(
          items
            .map((item) => (item.bookId ? String(item.bookId) : ''))
            .filter((value) => Boolean(value))
        )
      );

      let booksMap = {};
      if (uniqueBookIds.length > 0) {
        const responses = await Promise.all(
          uniqueBookIds.map(async (bookId) => {
            try {
              const resp = await api.get(`/books/${bookId}`);
              return { bookId, data: resp.data };
            } catch (err) {
              console.error('Failed to load book details', bookId, err);
              return { bookId, error: err };
            }
          })
        );

        const failedBooks = [];
        responses.forEach(({ bookId, data, error }) => {
          if (data) {
            const normalizedId = String(data.id || data._id || bookId);
            booksMap[normalizedId] = data;
            booksMap[String(bookId)] = data;
          } else {
            failedBooks.push(bookId);
          }
        });

        if (failedBooks.length > 0) {
          setApproveError((prev) =>
            prev || 'Some book details could not be loaded. Please verify availability before approving.'
          );
        }
      }

      setApproveBooks(booksMap);

      setApproveAssignments(() => {
        const initial = {};
        items.forEach((item, index) => {
          const key = buildItemKey(item, index);
          if (item.copyId) {
            initial[key] = item.copyId;
            return;
          }

          const bookId = item.bookId ? String(item.bookId) : '';
          const book = booksMap[bookId];
          const availableCopies = Array.isArray(book?.copies)
            ? book.copies.filter((copy) => copy.status === 'available')
            : [];

          if (availableCopies.length === 1) {
            initial[key] = availableCopies[0].copyId;
          } else {
            initial[key] = '';
          }
        });
        return initial;
      });
    } catch (err) {
      console.error('Failed to prepare approval dialog', err);
      setApproveError(err.response?.data?.message || 'Failed to load book details');
    } finally {
      setApproveLoading(false);
    }
  };

  const handleAssignmentChange = (itemKey, copyId) => {
    const normalized = (copyId || '').toString().trim();
    setApproveAssignments((prev) => ({ ...prev, [itemKey]: normalized }));
    setApproveError('');
  };

  const openScannerForItem = (itemKey, label) => {
    if (!itemKey) return;
    setScannerConfig({ open: true, targetKey: itemKey, label: label || 'Reference ID' });
  };

  const closeScannerDialog = () => {
    setScannerConfig({ open: false, targetKey: null, label: '' });
  };

  const handleScannerDetected = (value) => {
    const trimmed = String(value || '').trim();
    if (!trimmed) {
      toast.error('QR code did not contain a reference ID');
      return;
    }
    if (!scannerConfig.targetKey) {
      toast.error('No target field selected for scanning');
      return;
    }
    setApproveAssignments((prev) => ({ ...prev, [scannerConfig.targetKey]: trimmed }));
    toast.success('Reference ID captured');
    closeScannerDialog();
  };

  const closeApproveDialog = () => {
    if (approveSubmitting) return;
    setApproveDialogOpen(false);
    setApproveTarget(null);
    setApproveAssignments({});
    setApproveBooks({});
    setApproveError('');
  };

  const handleSubmitAssignments = async () => {
    if (!approveTarget) return;
    const { id, items } = approveTarget;
    setApproveSubmitting(true);
    setApproveError('');

    try {
      const payloadItems = items.map((item, index) => {
        const key = buildItemKey(item, index);
        const selectedCopyId = (approveAssignments[key] || item.copyId || '').toString().trim();
        const normalizedBookId = item.bookId ? String(item.bookId) : undefined;
        return {
          requestItemId: item.requestItemId,
          bookId: normalizedBookId,
          copyId: selectedCopyId,
        };
      });

      const missingAssignments = payloadItems.filter((entry) => !entry.copyId);
      if (missingAssignments.length > 0) {
        setApproveError('Please assign a copy for each requested book.');
        setApproveSubmitting(false);
        return;
      }

      await approveTransaction(id, { items: payloadItems });
      toast.success('Request approved');
      closeApproveDialog();
      fetchRequests();
      setSelected((prev) => prev.filter((value) => value !== id));
    } catch (err) {
      console.error('Approve failed', err);
      setApproveError(err.response?.data?.message || 'Approve failed');
    } finally {
      setApproveSubmitting(false);
    }
  };

  const takenCopyMap = useMemo(() => {
    const mapping = {};
    Object.entries(approveAssignments).forEach(([key, value]) => {
      if (!value) return;
      mapping[String(value).toLowerCase()] = key;
    });
    return mapping;
  }, [approveAssignments]);

  const dialogItems = useMemo(() => approveTarget?.items || [], [approveTarget]);

  const assignmentsReady = useMemo(() => {
    if (!approveDialogOpen || approveLoading) return false;
    return dialogItems.every((item, index) => {
      const key = buildItemKey(item, index);
      const assigned = approveAssignments[key] || item.copyId;
      return Boolean((assigned || '').toString().trim());
    });
  }, [approveAssignments, approveDialogOpen, approveLoading, dialogItems]);

  const actionableRequestCount = useMemo(
    () => requests.filter((entry) => Boolean(resolveTransactionId(entry))).length,
    [requests]
  );

  const handleBulkApprove = async () => {
    if (!selected || selected.length === 0) return;
    const autoApprove = [];
    const needsManual = [];

    selected.forEach((txId) => {
      const tx = requests.find((entry) => resolveTransactionId(entry) === txId);
      const items = getTransactionItems(tx);
      if (items.some((item) => !item?.copyId)) {
        needsManual.push(txId);
      } else {
        autoApprove.push(txId);
      }
    });

    if (needsManual.length > 0) {
      toast.error(`Cannot bulk approve ${needsManual.length} request${needsManual.length > 1 ? 's' : ''} without assigning copies first.`);
    }

    if (autoApprove.length === 0) {
      return;
    }

    const results = { success: 0, failed: 0, details: [] };
    for (const txId of autoApprove) {
      try {
        await approveTransaction(txId);
        results.success += 1;
      } catch (err) {
        results.failed += 1;
        results.details.push({ id: txId, message: err.response?.data?.message || err.message });
      }
    }

    fetchRequests();
    setSelected([]);

    if (results.success > 0) {
      toast.success(`Approved ${results.success} request${results.success > 1 ? 's' : ''}${results.failed ? `, ${results.failed} failed` : ''}`);
    } else if (results.failed > 0) {
      toast.error(`Failed to approve ${results.failed} request${results.failed > 1 ? 's' : ''}`);
    }

    if (results.failed) console.error('Bulk approve failures', results.details);
  };

  const handleReject = async () => {
    if (!selected || (Array.isArray(selected) && selected.length === 0)) return;

    const ids = Array.isArray(selected) ? selected : [selected.id || selected.transactionId || selected._id];
    const results = { success: 0, failed: 0, details: [] };
    for (const id of ids) {
      try {
        await api.post(`/transactions/reject/${id}`, { reason: rejectReason });
        results.success++;
      } catch (err) {
        results.failed++;
        results.details.push({ id, message: err.response?.data?.message || err.message });
      }
    }
    setRejectDialogOpen(false);
    setSelected([]);
    fetchRequests();
    toast.success(`Rejected ${results.success} requests${results.failed ? `, ${results.failed} failed` : ''}`);
    if (results.failed) console.error('Bulk reject failures', results.details);
  };

  const isSelected = (id) => selected.includes(id);

  const toggleSelect = (id) => {
    if (!id) return;
    setSelected(prev => prev.includes(id) ? prev.filter(x => x !== id) : [...prev, id]);
  };

  const handleSelectAll = (checked) => {
    if (checked) {
      const allIds = requests.map(resolveTransactionId).filter(Boolean);
      setSelected(allIds);
    } else {
      setSelected([]);
    }
  };

  const handleChangePage = (event, newPage) => setPage(newPage);
  const handleChangeRowsPerPage = (event) => { setRowsPerPage(parseInt(event.target.value, 10)); setPage(0); };
  const handleBack = () => navigate('/transactions');

  return (
    <Box>
      <Box display="flex" alignItems="center" mb={2}>
        <IconButton onClick={handleBack} aria-label="Go back" sx={{ color: 'text.primary', mr: 2 }}>
          <ArrowBackIcon />
        </IconButton>
        <Typography variant="h4" color={"white"}>Borrow Requests</Typography>
      </Box>
      <Paper>
        <TableContainer>
          <Table size="small">
            <TableHead>
              <TableRow>
                <TableCell padding="checkbox">
                  <Checkbox
                    indeterminate={selected.length > 0 && selected.length < actionableRequestCount}
                    checked={actionableRequestCount > 0 && selected.length === actionableRequestCount}
                    onChange={(e) => handleSelectAll(e.target.checked)}
                    inputProps={{ 'aria-label': 'select all requests' }}
                    disabled={actionableRequestCount === 0}
                  />
                </TableCell>
                <TableCell>Transaction ID</TableCell>
                <TableCell>Borrower</TableCell>
                <TableCell>Items</TableCell>
                <TableCell>Created</TableCell>
                <TableCell>Actions</TableCell>
              </TableRow>
            </TableHead>
            <TableBody>
              {requests.length === 0 ? (
                <TableRow><TableCell colSpan={6} align="center">{loading ? 'Loading...' : 'No requests'}</TableCell></TableRow>
              ) : (
                (requests.slice(page * rowsPerPage, page * rowsPerPage + rowsPerPage)).map((tx, idx) => {
                  const txId = resolveTransactionId(tx);
                  const rowIndex = page * rowsPerPage + idx;
                  const rowKey = txId || tx.__fallbackKey || `request-row-${rowIndex}`;
                  const isActionable = Boolean(txId);
                  return (
                    <TableRow key={rowKey} hover>
                      <TableCell padding="checkbox">
                        <Checkbox
                          checked={Boolean(txId) && isSelected(txId)}
                          onChange={() => toggleSelect(txId)}
                          disabled={!isActionable}
                        />
                      </TableCell>
                      <TableCell>{txId}</TableCell>
                      <TableCell>{tx.borrowerName || tx.user || tx.userId || 'Unknown'}</TableCell>
                      <TableCell>{(tx.items || []).length}</TableCell>
                      <TableCell>{new Date(tx.createdAt || tx.borrowDate || Date.now()).toLocaleString()}</TableCell>
                      <TableCell>
                        <Button size="small" onClick={() => startApproveWorkflow(tx)} sx={{ mr: 1 }} disabled={!isActionable}>Approve</Button>
                        <Button
                          size="small"
                          color="error"
                          onClick={() => {
                            if (!txId) return;
                            setSelected([txId]);
                            setRejectDialogOpen(true);
                            setRejectReason('');
                          }}
                          disabled={!isActionable}
                        >
                          Reject
                        </Button>
                      </TableCell>
                    </TableRow>
                  );
                })
              )}
            </TableBody>
          </Table>
        </TableContainer>
        <Box display="flex" alignItems="center" justifyContent="space-between" p={1}>
          <Box>
            <Button variant="contained" onClick={handleBulkApprove} disabled={selected.length === 0} sx={{ mr: 1 }}>Approve Selected</Button>
            <Button variant="outlined" color="error" onClick={() => setRejectDialogOpen(true)} disabled={selected.length === 0}>Reject Selected</Button>
          </Box>
          <TablePagination component="div" count={requests.length} page={page} onPageChange={handleChangePage} rowsPerPage={rowsPerPage} onRowsPerPageChange={handleChangeRowsPerPage} rowsPerPageOptions={[10,25,50,100]} />
        </Box>
      </Paper>

      <Dialog
        open={approveDialogOpen}
        onClose={closeApproveDialog}
        maxWidth="md"
        fullWidth
      >
        <DialogTitle>Assign Copies</DialogTitle>
        <DialogContent dividers>
          {approveError && (
            <Alert severity="warning" sx={{ mb: 2 }}>
              {approveError}
            </Alert>
          )}

          {approveLoading ? (
            <Box display="flex" alignItems="center" justifyContent="center" minHeight={160}>
              <CircularProgress />
            </Box>
          ) : dialogItems.length === 0 ? (
            <Typography variant="body2" color="text.secondary">
              No items to assign for this request.
            </Typography>
          ) : (
            <List disablePadding>
              {dialogItems.map((item, index) => {
                const key = buildItemKey(item, index);
                const assignedCopyId = approveAssignments[key] || item.copyId || '';
                const bookId = item.bookId ? String(item.bookId) : '';
                const bookDetails = approveBooks[bookId];
                const availableCopies = Array.isArray(bookDetails?.copies)
                  ? bookDetails.copies.filter((copy) => copy.status === 'available')
                  : [];
                const hasBookDetails = Boolean(bookDetails);
                const title = bookDetails?.title || item.title || 'Unknown title';
                const author = bookDetails?.author || item.author || '';
                const isbn = bookDetails?.isbn || item.isbn || '';
                const secondary = [
                  author ? `Author: ${author}` : null,
                  isbn ? `ISBN: ${isbn}` : null,
                  bookDetails?.category ? `Category: ${bookDetails.category}` : null,
                ]
                  .filter(Boolean)
                  .join(' ‚Ä¢ ');

                return (
                  <React.Fragment key={key}>
                    <ListItem disableGutters sx={{ flexDirection: 'column', alignItems: 'stretch', py: 1 }}>
                      <ListItemText primary={title} secondary={secondary || undefined} />

                      {item.copyId ? (
                        <Typography variant="body2" color="text.secondary" sx={{ mt: 1 }}>
                          Copy already assigned: {item.copyId}
                        </Typography>
                      ) : hasBookDetails && availableCopies.length > 0 ? (
                        <Box sx={{ width: '100%', mt: 1 }}>
                          <Autocomplete
                            freeSolo
                            disableClearable
                            autoHighlight
                            options={availableCopies
                              .filter((copy) => {
                                const owner = takenCopyMap[String(copy.copyId).toLowerCase()];
                                return !owner || owner === key;
                              })
                              .map((copy) => copy.copyId)
                              .filter(Boolean)}
                            value={assignedCopyId || ''}
                            onChange={(event, newValue) => handleAssignmentChange(key, newValue || '')}
                            onInputChange={(event, newInputValue, reason) => {
                              if (reason === 'input') {
                                handleAssignmentChange(key, newInputValue || '');
                              }
                            }}
                            disabled={approveSubmitting}
                            renderOption={(props, option) => {
                              const copyMeta = availableCopies.find((copy) => copy.copyId === option);
                              return (
                                <li {...props} key={option}>
                                  <Box display="flex" flexDirection="column">
                                    <Typography variant="body2">{option}</Typography>
                                    {copyMeta?.location && (
                                      <Typography variant="caption" color="text.secondary">
                                        Location: {copyMeta.location}
                                      </Typography>
                                    )}
                                    {copyMeta?.condition && (
                                      <Typography variant="caption" color="text.secondary">
                                        Condition: {copyMeta.condition}
                                      </Typography>
                                    )}
                                  </Box>
                                </li>
                              );
                            }}
                            renderInput={(params) => (
                              <TextField
                                {...params}
                                label="Reference ID"
                                placeholder="Search or scan reference ID"
                                InputProps={{
                                  ...params.InputProps,
                                  endAdornment: (
                                    <>
                                      <InputAdornment position="end">
                                        <Tooltip title="Scan QR code">
                                          <span>
                                            <IconButton
                                              size="small"
                                              onClick={() => openScannerForItem(key, title)}
                                              disabled={approveSubmitting}
                                            >
                                              <QrCodeScannerIcon fontSize="small" />
                                            </IconButton>
                                          </span>
                                        </Tooltip>
                                      </InputAdornment>
                                      {params.InputProps.endAdornment}
                                    </>
                                  ),
                                }}
                                helperText="Type to search available copies or scan a QR label"
                                size="small"
                              />
                            )}
                          />
                        </Box>
                      ) : (
                        <Alert severity={hasBookDetails ? 'warning' : 'error'} sx={{ mt: 1 }}>
                          {hasBookDetails
                            ? 'No available copies for this book.'
                            : 'Unable to load available copies for this book.'}
                        </Alert>
                      )}
                    </ListItem>
                    {index < dialogItems.length - 1 && <Divider component="li" />}
                  </React.Fragment>
                );
              })}
            </List>
          )}
        </DialogContent>
        <DialogActions>
          <Button onClick={closeApproveDialog} disabled={approveSubmitting}>
            Cancel
          </Button>
          <Button
            variant="contained"
            onClick={handleSubmitAssignments}
            disabled={!assignmentsReady || approveSubmitting}
          >
            {approveSubmitting ? 'Assigning‚Ä¶' : 'Assign Copies'}
          </Button>
        </DialogActions>
      </Dialog>

      <Dialog
        open={scannerConfig.open}
        onClose={closeScannerDialog}
        maxWidth="xs"
        fullWidth
      >
        <DialogTitle>Scan Reference ID</DialogTitle>
        <DialogContent>
          {scannerConfig.open && (
            <QRScanner
              elementId="requests-approval-qr"
              onDetected={handleScannerDetected}
            />
          )}
          <Typography variant="body2" color="text.secondary" sx={{ mt: 1 }}>
            Position the QR label for {scannerConfig.label || 'this item'} inside the frame.
          </Typography>
        </DialogContent>
        <DialogActions>
          <Button onClick={closeScannerDialog}>Close</Button>
        </DialogActions>
      </Dialog>

      <Dialog open={rejectDialogOpen} onClose={() => setRejectDialogOpen(false)}>
        <DialogTitle>Reject Request</DialogTitle>
        <DialogContent>
          <TextField fullWidth label="Reason" multiline minRows={3} value={rejectReason} onChange={(e) => setRejectReason(e.target.value)} />
        </DialogContent>
        <DialogActions>
          <Button variant="outlined" onClick={() => setRejectDialogOpen(false)}>Cancel</Button>
          <Button variant="contained" color="error" onClick={handleReject}>Reject</Button>
        </DialogActions>
      </Dialog>
    </Box>
  );
};

export default RequestsPage;
```

## ReturnForm.js

| Field | Details |
| --- | --- |
| Program Name | ReturnForm.js |
| Description | Frontend page view for routing and page-level UI. |
| Called by | App.js |
| Table used | transactions |
|  |  |
| Programmer | Nazel Asca√±o |
| Date created | 12/14/2025 |
| Revision Date | TBD |
| Revision / description of change | None |

```javascript
import React, { useCallback, useEffect, useRef, useState } from "react";
import { useNavigate, useLocation } from "react-router-dom";
import {
  Alert,
  Avatar,
  Box,
  Button,
  Card,
  CardContent,
  Checkbox,
  Chip,
  Dialog,
  DialogActions,
  DialogContent,
  DialogTitle,
  Grid,
  IconButton,
  List,
  ListItem,
  ListItemIcon,
  ListItemText,
  Paper,
  InputAdornment,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  TextField,
  Typography,
} from "@mui/material";
import {
  ArrowBack,
  AssignmentReturn,
  CurrencyExchange,
  Book,
  Search,
  Warning,
  QrCodeScanner,
} from "@mui/icons-material";
import MobileScanButton from "../../components/MobileScanButton";
import { DateTimePicker } from "@mui/x-date-pickers/DateTimePicker";
import { LocalizationProvider } from "@mui/x-date-pickers/LocalizationProvider";
import { AdapterDateFns } from "@mui/x-date-pickers/AdapterDateFns";
import { api, settingsAPI } from "../../utils/api";
import { formatCurrency } from "../../utils/currency";
import { generateTransactionReceipt, downloadPDF } from "../../utils/pdfGenerator";
import QRScanner from "../../components/QRScanner";
import { useSettings } from "../../contexts/SettingsContext";

const toNumber = (value, fallback) => {
  const parsed = Number(value);
  return Number.isFinite(parsed) ? parsed : fallback;
};

const ReturnForm = () => {
  const navigate = useNavigate();
  const location = useLocation();
  const [searchInput, setSearchInput] = useState("");
  const [borrowedBooks, setBorrowedBooks] = useState([]);
  const [selectedReturns, setSelectedReturns] = useState([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState("");
  const [success, setSuccess] = useState("");
  const [returnDate, setReturnDate] = useState(new Date());
  const [notes, setNotes] = useState("");
  const [borrowingRules, setBorrowingRules] = useState({
    finePerDay: 0.5,
    gracePeriodDays: 0,
    enableFines: true,
  });
  const [confirmDialog, setConfirmDialog] = useState(false);
  const [totalFine, setTotalFine] = useState(0);
  const [scannerOpen, setScannerOpen] = useState(false);
  const { finesEnabled } = useSettings();

  const scannerBufferRef = useRef("");
  const lastKeyTimeRef = useRef(0);

  const getRowId = (transaction) =>
    transaction?.rowId ||
    transaction?._id ||
    `${transaction?.transactionId || transaction?.id}_${transaction?.copyId}`;

  const resolveDueDate = (transaction) =>
    transaction?.dueDate || transaction?.metadata?.providedDueDate || null;

  const calculateFine = useCallback((dueDate, candidateReturnDate) => {
    if (!finesEnabled) {
      return 0;
    }
    if (!dueDate) return 0;

    const due = new Date(dueDate);
    const returned = new Date(candidateReturnDate);

    if (Number.isNaN(due.getTime()) || Number.isNaN(returned.getTime())) {
      return 0;
    }

    if (returned <= due) return 0;

    const overdueDays = Math.ceil((returned - due) / (1000 * 60 * 60 * 24));
    const graceDays = borrowingRules.gracePeriodDays || 0;
    const fineDays = Math.max(0, overdueDays - graceDays);

    return fineDays * borrowingRules.finePerDay;
  }, [borrowingRules.gracePeriodDays, borrowingRules.finePerDay, finesEnabled]);

  const handleBarcodeScan = useCallback(
    async (rawValue) => {
      const trimmedCopyId = String(rawValue || "").trim();
      if (!trimmedCopyId) {
        return;
      }

      try {
        const response = await api.get("/transactions/by-copy", {
          params: { copyId: trimmedCopyId },
        });

        if (response.data) {
          setBorrowedBooks([response.data]);
          setSelectedReturns([]);
          setSearchInput(trimmedCopyId);
          setError("");
          setSuccess("");
        } else {
          setError("No borrowed record found for this copy");
        }
      } catch (requestError) {
        setError("Failed to find borrowing record");
        console.error("Error processing scan:", requestError);
      }
    },
    []
  );

  const fetchBorrowingRules = async () => {
    try {
      const response = await api.get("/settings/borrowing-rules");
      const data = response.data || {};
      setBorrowingRules({
        finePerDay: toNumber(data.finePerDay, 0.5),
        gracePeriodDays: toNumber(data.gracePeriodDays, 0),
        enableFines: data.enableFines !== false,
      });
    } catch (fetchError) {
      console.error("Error fetching borrowing rules:", fetchError);
    }
  };

  useEffect(() => {
    fetchBorrowingRules();
  }, []);

  useEffect(() => {
    const SCAN_RESET_THRESHOLD = 80;
    const MIN_BARCODE_LENGTH = 4;

    const handleKeyDown = (event) => {
      const currentTime = Date.now();
      if (currentTime - lastKeyTimeRef.current > SCAN_RESET_THRESHOLD) {
        scannerBufferRef.current = "";
      }

      if (event.key === "Enter") {
        const barcode = scannerBufferRef.current;
        scannerBufferRef.current = "";
        lastKeyTimeRef.current = currentTime;
        if (barcode.length >= MIN_BARCODE_LENGTH) {
          event.preventDefault();
          handleBarcodeScan(barcode);
        }
        return;
      }

      if (event.key.length === 1 && !event.ctrlKey && !event.metaKey) {
        scannerBufferRef.current += event.key;
        lastKeyTimeRef.current = currentTime;
      }
    };

    window.addEventListener("keydown", handleKeyDown);
    return () => window.removeEventListener("keydown", handleKeyDown);
  }, [handleBarcodeScan]);

  useEffect(() => {
    const total = selectedReturns.reduce((sum, transaction) => {
      return sum + calculateFine(transaction.dueDate, returnDate);
    }, 0);
    setTotalFine(total);
  }, [selectedReturns, returnDate, calculateFine]);

  const searchBorrowedBooks = async () => {
    const trimmedQuery = searchInput.trim();
    if (!trimmedQuery) {
      setError("Please enter a search term");
      return;
    }

    setLoading(true);
    try {
      const response = await api.get("/transactions/borrowed", {
        params: { search: trimmedQuery },
      });
      const results = response.data || [];
      setBorrowedBooks(results);
      setError(results.length === 0 ? "No borrowed books found for this search" : "");
    } catch (requestError) {
      setError("Failed to search borrowed books");
      console.error("Error searching borrowed books:", requestError);
    } finally {
      setLoading(false);
    }
  };

  const handleSelectReturn = (transaction, isSelected) => {
    const rowId = getRowId(transaction);
    const dueDateValue = resolveDueDate(transaction);

    if (isSelected) {
      setSelectedReturns((previous) => {
        if (previous.some((entry) => entry.rowId === rowId)) {
          return previous;
        }
        const fine = calculateFine(dueDateValue, returnDate);
        return [...previous, { ...transaction, rowId, fine, dueDate: dueDateValue }];
      });
    } else {
      setSelectedReturns((previous) => previous.filter((entry) => entry.rowId !== rowId));
    }
  };

  const handleToggleSelectAll = (event) => {
    const { checked } = event.target;
    const visibleRowIds = new Set(borrowedBooks.map((transaction) => getRowId(transaction)));

    if (checked) {
      const updatedSelections = borrowedBooks.map((transaction) => {
        const rowId = getRowId(transaction);
        const dueDateValue = resolveDueDate(transaction);
        const fine = calculateFine(dueDateValue, returnDate);
        return { ...transaction, rowId, fine, dueDate: dueDateValue };
      });

      setSelectedReturns((previous) => {
        const merged = new Map(previous.map((entry) => [entry.rowId, entry]));
        updatedSelections.forEach((entry) => {
          merged.set(entry.rowId, entry);
        });
        return Array.from(merged.values());
      });
    } else {
      setSelectedReturns((previous) => previous.filter((entry) => !visibleRowIds.has(entry.rowId)));
    }
  };

  const handleReturnBooks = () => {
    if (selectedReturns.length === 0) {
      setError("Please select at least one book to return");
      return;
    }
    setConfirmDialog(true);
  };

  const confirmReturn = async () => {
    setLoading(true);
    try {
      const groupedTransactions = selectedReturns.reduce((acc, entry) => {
        const id = entry.transactionId || entry._id;
        if (!id) {
          return acc;
        }
        if (!acc[id]) {
          acc[id] = { transactionId: id, items: [] };
        }
        acc[id].items.push({ copyId: entry.copyId });
        return acc;
      }, {});

      const groupedValues = Object.values(groupedTransactions);
      if (groupedValues.length === 0) {
        setError("Unable to process the selected items. Please try again.");
        setLoading(false);
        return;
      }

      const payload = {
        transactions: groupedValues,
        returnDate: returnDate ? new Date(returnDate).toISOString() : undefined,
        notes,
      };

      const response = await api.post("/transactions/return", payload);
      setSuccess(response.data?.message || `Successfully returned ${selectedReturns.length} book(s)`);
      setError("");

      try {
        const returnDateTime = returnDate || new Date();
        for (const returnItem of selectedReturns) {
          const transactionData = {
            id: returnItem.transactionId,
            type: 'Return',
            createdAt: returnDateTime,
            fineAmount: calculateFine(returnItem.dueDate, returnDateTime)
          };

          const studentData = {
            firstName: returnItem.borrowerName?.split(' ')[0] || '',
            lastName: returnItem.borrowerName?.split(' ').slice(1).join(' ') || '',
            studentId: returnItem.studentId || '',
            libraryCardNumber: returnItem.libraryCardNumber || ''
          };

          const booksData = [{
            title: returnItem.bookTitle,
            copyId: returnItem.copyId
          }];

          const libraryResponse = await settingsAPI.getByCategory('library');
          const librarySettings = libraryResponse.data || {};

          const receiptPDF = await generateTransactionReceipt(
            transactionData,
            studentData,
            booksData,
            librarySettings
          );
          downloadPDF(receiptPDF, `return_receipt_${returnItem.transactionId}_${Date.now()}.pdf`);
        }
      } catch (receiptError) {
        console.error("Error generating receipts:", receiptError);

      }

      setBorrowedBooks([]);
      setSelectedReturns([]);
      setSearchInput("");
      setNotes("");
      setConfirmDialog(false);

      setTimeout(() => {
        navigate(location.state?.from || "/transactions");
      }, 2000);
    } catch (requestError) {
      setError(requestError.response?.data?.message || "Failed to process returns");
      console.error("Error processing returns:", requestError);
    } finally {
      setLoading(false);
    }
  };

  const getStatusColor = (dueDate) => {
    if (!dueDate) return "default";

    const due = new Date(dueDate);
    if (Number.isNaN(due.getTime())) {
      return "default";
    }

    const now = new Date();

    if (due < now) return "error";
    if (due - now < 3 * 24 * 60 * 60 * 1000) return "warning";
    return "success";
  };

  const getOverdueDays = (dueDate) => {
    if (!dueDate) return 0;

    const due = new Date(dueDate);
    if (Number.isNaN(due.getTime())) {
      return 0;
    }

    const now = new Date();
    return Math.max(0, Math.ceil((now - due) / (1000 * 60 * 60 * 24)));
  };

  const visibleRowIds = borrowedBooks.map((transaction) => getRowId(transaction));
  const selectedRowIds = new Set(selectedReturns.map((entry) => entry.rowId));
  const allVisibleSelected =
    borrowedBooks.length > 0 && visibleRowIds.every((rowId) => selectedRowIds.has(rowId));
  const someVisibleSelected =
    borrowedBooks.length > 0 &&
    visibleRowIds.some((rowId) => selectedRowIds.has(rowId)) &&
    !allVisibleSelected;

  return (
    <LocalizationProvider dateAdapter={AdapterDateFns}>
      <Box>
        <Box display="flex" alignItems="center" mb={3}>
          <IconButton
            onClick={() => {
              if (location.state?.from) navigate(location.state.from);
              else navigate(-1);
            }}
            sx={{ mr: 2 }}
          >
            <ArrowBack />
          </IconButton>
          <Typography variant="h4" gutterBottom sx={{ flexGrow: 1, mb: 0 }}>
            Return Books
          </Typography>
        </Box>
        {error && (
          <Alert severity="error" sx={{ mb: 2 }}>
            {error}
          </Alert>
        )}
        {success && (
          <Alert severity="success" sx={{ mb: 2 }}>
            {success}
          </Alert>
        )}
        {}
        <Paper sx={{ p: 3, mb: 3 }}>
          <Typography variant="h6" gutterBottom>
            Find Borrowed Books
          </Typography>
          <Grid container spacing={2} alignItems="center">
            <Grid item xs={12} md={8}>
              <TextField
                fullWidth
                label="Search by borrower name, reference ID, or book title"
                value={searchInput}
                onChange={(event) => setSearchInput(event.target.value)}
                onKeyPress={(event) => event.key === "Enter" && searchBorrowedBooks()}
                InputProps={{
                  startAdornment: (
                    <InputAdornment position="start">
                      <Search sx={{ color: "text.secondary" }} />
                    </InputAdornment>
                  ),
                  endAdornment: (
                    <InputAdornment position="end">
                      <IconButton
                        aria-label="scan barcode or QR code"
                        onClick={() => setScannerOpen(true)}
                        edge="end"
                      >
                        <QrCodeScanner />
                      </IconButton>
                    </InputAdornment>
                  ),
                }}
              />
            </Grid>
            <Grid item xs={12} md={4}>
              <Button
                fullWidth
                variant="contained"
                onClick={searchBorrowedBooks}
                disabled={loading}
                startIcon={<Search />}
              >
                {loading ? "Searching..." : "Search"}
              </Button>
            </Grid>
            <Grid item xs={12}>
              <MobileScanButton
                label="Open QR Scanner"
                onClick={() => setScannerOpen(true)}
              />
            </Grid>
          </Grid>
        </Paper>
        <Dialog open={scannerOpen} onClose={() => setScannerOpen(false)} maxWidth="xs" fullWidth>
          <DialogTitle>Scan Reference Code</DialogTitle>
          <DialogContent>
            <QRScanner
              elementId="return-qr-scanner"
              onDetected={(value) => {
                setScannerOpen(false);
                handleBarcodeScan(value);
              }}
              onClose={() => setScannerOpen(false)}
            />
          </DialogContent>
          <DialogActions>
            <Button variant="outlined" onClick={() => setScannerOpen(false)}>Cancel</Button>
          </DialogActions>
        </Dialog>
        {}
        {borrowedBooks.length > 0 && (
          <Paper sx={{ mb: 3 }}>
            <Box p={2}>
              <Typography variant="h6" gutterBottom>
                Borrowed Books Found
              </Typography>
            </Box>
            <TableContainer>
              <Table>
                <TableHead>
                  <TableRow>
                    <TableCell padding="checkbox">
                      <Checkbox
                        indeterminate={someVisibleSelected}
                        checked={allVisibleSelected}
                        onChange={handleToggleSelectAll}
                      />
                    </TableCell>
                    <TableCell>Book Details</TableCell>
                    <TableCell>Borrower</TableCell>
                    <TableCell>Reference ID</TableCell>
                    <TableCell>Borrow Date</TableCell>
                    <TableCell>Due Date</TableCell>
                    <TableCell>Status</TableCell>
                    {finesEnabled ? <TableCell>Fine</TableCell> : null}
                  </TableRow>
                </TableHead>
                <TableBody>
                  {borrowedBooks.map((transaction) => {
                    const rowId = getRowId(transaction);
                    const dueDateValue = resolveDueDate(transaction);
                    const isSelected = selectedReturns.some((entry) => entry.rowId === rowId);
                    const fine = calculateFine(dueDateValue, returnDate);
                    const overdueDays = getOverdueDays(dueDateValue);

                    return (
                      <TableRow key={rowId}>
                        <TableCell padding="checkbox">
                          <Checkbox
                            checked={isSelected}
                            onChange={(event) =>
                              handleSelectReturn(transaction, event.target.checked)
                            }
                          />
                        </TableCell>
                        <TableCell>
                          <Box>
                            <Typography variant="body2" fontWeight="medium">
                              {transaction.bookTitle}
                            </Typography>
                            <Typography variant="caption" color="textSecondary">
                              by {transaction.author}
                            </Typography>
                          </Box>
                        </TableCell>
                        <TableCell>
                          <Box display="flex" alignItems="center">
                            <Avatar sx={{ mr: 1, width: 32, height: 32 }}>
                              {transaction.borrowerName?.charAt(0)}
                            </Avatar>
                            <Box>
                              <Typography variant="body2">
                                {transaction.borrowerName}
                              </Typography>
                              <Typography variant="caption" color="textSecondary">
                                {transaction.borrowerEmail}
                              </Typography>
                            </Box>
                          </Box>
                        </TableCell>
                        <TableCell>{transaction.copyId}</TableCell>
                        <TableCell>
                          {transaction.borrowDate
                            ? new Date(transaction.borrowDate).toLocaleDateString()
                            : "-"}
                        </TableCell>
                        <TableCell>
                          <Box display="flex" alignItems="center">
                            {overdueDays > 0 && <Warning color="error" sx={{ mr: 1, fontSize: 16 }} />}
                            {dueDateValue
                              ? new Date(dueDateValue).toLocaleDateString()
                              : "-"}
                            {overdueDays > 0 && (
                              <Typography variant="caption" color="error" sx={{ ml: 1 }}>
                                ({overdueDays} days overdue)
                              </Typography>
                            )}
                          </Box>
                        </TableCell>
                        <TableCell>
                          <Chip
                            label={overdueDays > 0 ? "Overdue" : "Active"}
                            color={getStatusColor(dueDateValue)}
                            size="small"
                          />
                        </TableCell>
                        {finesEnabled ? (
                          <TableCell>
                            <Box display="flex" alignItems="center">
                              {fine > 0 && (
                                <CurrencyExchange
                                  color="error"
                                  sx={{ mr: 1, fontSize: 16 }}
                                />
                              )}
                              <Typography
                                variant="body2"
                                color={fine > 0 ? "error" : "textSecondary"}
                                fontWeight={fine > 0 ? "medium" : "normal"}
                              >
                                  {formatCurrency(fine)}
                              </Typography>
                            </Box>
                          </TableCell>
                        ) : null}
                      </TableRow>
                    );
                  })}
                </TableBody>
              </Table>
            </TableContainer>
          </Paper>
        )}
        {}
        {selectedReturns.length > 0 && (
          <Paper sx={{ p: 3, mb: 3 }}>
            <Typography variant="h6" gutterBottom>
              Return Details
            </Typography>
            <Grid container spacing={3}>
              <Grid item xs={12} md={6}>
                <DateTimePicker
                  label="Return Date & Time"
                  value={returnDate}
                  onChange={(newValue) => setReturnDate(newValue || new Date())}
                  slotProps={{ textField: { fullWidth: true } }}
                  maxDate={new Date()}
                />
              </Grid>
              {finesEnabled ? (
                <Grid item xs={12} md={6}>
                  <Card variant="outlined">
                    <CardContent>
                      <Typography variant="h6" color="error">
                        Total Fine: {formatCurrency(totalFine)}
                      </Typography>
                      <Typography variant="body2" color="textSecondary">
                        Fine rate: {formatCurrency(borrowingRules.finePerDay)}/day
                      </Typography>
                    </CardContent>
                  </Card>
                </Grid>
              ) : null}
              <Grid item xs={12}>
                <TextField
                  fullWidth
                  label="Return Notes (Optional)"
                  multiline
                  rows={3}
                  value={notes}
                  onChange={(event) => setNotes(event.target.value)}
                  placeholder="Add any notes about the book condition or return..."
                />
              </Grid>
            </Grid>
            <Box display="flex" justifyContent="space-between" alignItems="center" mt={3}>
              <Typography variant="body1">
                Returning {selectedReturns.length} book(s)
              </Typography>
              <Box>
                <Button variant="outlined" onClick={() => setSelectedReturns([])} sx={{ mr: 2 }}>
                  Clear Selection
                </Button>
                <Button
                  variant="contained"
                  startIcon={<AssignmentReturn />}
                  onClick={handleReturnBooks}
                  disabled={loading}
                >
                  Return Books
                </Button>
              </Box>
            </Box>
          </Paper>
        )}
        {}
        <Dialog
          open={confirmDialog}
          onClose={() => setConfirmDialog(false)}
          maxWidth="md"
          fullWidth
        >
          <DialogTitle>Confirm Book Return</DialogTitle>
          <DialogContent>
            <Alert severity="info" sx={{ mb: 2 }}>
              You are about to return {selectedReturns.length} book(s)
              {finesEnabled ? ` with a total fine of ${formatCurrency(totalFine)}` : ""}
            </Alert>
            <List>
              {selectedReturns.map((transaction) => {
                const fine = calculateFine(transaction.dueDate, returnDate);
                return (
                  <ListItem key={transaction.rowId} divider>
                    <ListItemIcon>
                      <Book />
                    </ListItemIcon>
                    <ListItemText
                      primary={`${transaction.bookTitle} (Reference ID: ${transaction.copyId})`}
                      secondary={
                        finesEnabled
                          ? `Borrower: ${transaction.borrowerName} | Fine: ${formatCurrency(fine)}`
                          : `Borrower: ${transaction.borrowerName}`
                      }
                    />
                  </ListItem>
                );
              })}
            </List>
          </DialogContent>
          <DialogActions>
            <Button variant="outlined" onClick={() => setConfirmDialog(false)}>Cancel</Button>
            <Button onClick={confirmReturn} variant="contained" disabled={loading}>
              {loading ? "Processing..." : "Confirm Return"}
            </Button>
          </DialogActions>
        </Dialog>
      </Box>
    </LocalizationProvider>
  );
};

export default ReturnForm;
```

## SearchResults.js

| Field | Details |
| --- | --- |
| Program Name | SearchResults.js |
| Description | Frontend page view for routing and page-level UI. |
| Called by | None |
| Table used | None |
|  |  |
| Programmer | Nazel Asca√±o |
| Date created | 12/14/2025 |
| Revision Date | TBD |
| Revision / description of change | None |

## SettingsPage.js

| Field | Details |
| --- | --- |
| Program Name | SettingsPage.js |
| Description | Frontend page view for routing and page-level UI. |
| Called by | App.js |
| Table used | settings |
|  |  |
| Programmer | Nazel Asca√±o |
| Date created | 12/14/2025 |
| Revision Date | TBD |
| Revision / description of change | None |

```javascript
import React, { useState, useEffect, useRef } from "react";
import {
  Box,
  Typography,
  Paper,
  Grid,
  TextField,
  Button,
  Switch,
  FormControlLabel,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  Alert,
  Card,
  CardContent,
  CardHeader,
  Chip,
  List,
  ListItem,
  ListItemText,
  IconButton,
  Tab,
  Tabs,
  InputAdornment,
  Stack,
} from "@mui/material";
import {
  Restore,
  LibraryBooks,
  Notifications,
  Backup,
  Computer,
  Edit,
  Delete,
  Add,
  Schedule,
  Group,
  CloudUpload,
} from "@mui/icons-material";
import { useAuth } from "../../contexts/AuthContext";
import { api, settingsAPI } from "../../utils/api";
import { SETTINGS_UPDATED_EVENT } from "../../contexts/SettingsContext";
import {
  ensureUserAttributes,
  normalizeStringList,
  normalizeGradeStructure,
  getDefaultGradeColor,
  sanitizeHexColor,
} from "../../utils/userAttributes";

const TabPanel = ({ children, value, index }) => {
  if (value !== index) {
    return null;
  }
  return (
    <Box
      sx={{
        px: { xs: 2, md: 3 },
        pt: 3,
        pb: 6,
      }}
    >
      {children}
    </Box>
  );
};

const normalizeNumber = (value, fallback) => {
  const parsed = Number(value);
  return Number.isFinite(parsed) ? parsed : fallback;
};

const normalizeBoolean = (value, fallback) => {
  if (typeof value === "boolean") return value;
  if (typeof value === "string") {
    const normalized = value.trim().toLowerCase();
    if (["true", "1", "yes"].includes(normalized)) return true;
    if (["false", "0", "no"].includes(normalized)) return false;
  }
  if (typeof value === "number") return value !== 0;
  return fallback;
};

const sanitizePhoneInput = (value = "") =>
  String(value ?? "").replace(/\D/g, "").slice(0, 11);

const resolveGradeColorValue = (entry, index = 0) =>
  sanitizeHexColor(entry?.color, getDefaultGradeColor(index));

const AUTO_SAVE_DEBOUNCE_MS = 1000;

const getAutoSaveMessage = (status, error) => {
  switch (status) {
    case "pending":
      return "Preparing to save changes...";
    case "saving":
      return "Saving changes...";
    case "saved":
      return "All changes saved automatically.";
    case "error":
      return (
        error || "Auto-save failed. Please review your connection or try again."
      );
    default:
      return "Changes are saved automatically.";
  }
};

const getAutoSaveColor = (status) => {
  if (status === "error") {
    return "error.main";
  }
  if (status === "saved") {
    return "success.main";
  }
  return "text.secondary";
};

const BRANDING_FIELD_BY_SLOT = {
  logo: "loginLogoUrl",
  background: "loginBackgroundUrl",
};

const sanitizeBrandingSlotName = (value) =>
  value === "background" ? "background" : "logo";

const useAutoSaveSetting = ({
  data,
  mergeFn,
  endpoint,
  eventCategory,
  debounceMs = AUTO_SAVE_DEBOUNCE_MS,
  resetKey = 0,
}) => {
  const [status, setStatus] = useState("idle");
  const [error, setError] = useState("");
  const readyRef = useRef(false);
  const lastSerializedRef = useRef("");

  useEffect(() => {
    readyRef.current = false;
  }, [resetKey]);

  useEffect(() => {
    const normalized = mergeFn(data);
    const serialized = JSON.stringify(normalized);

    if (!readyRef.current) {
      readyRef.current = true;
      lastSerializedRef.current = serialized;
      setStatus("saved");
      setError("");
      return;
    }

    if (lastSerializedRef.current === serialized) {
      setStatus("saved");
      setError("");
      return;
    }

    setStatus("pending");
    setError("");
    let cancelled = false;

    const handler = setTimeout(async () => {
      if (cancelled) {
        return;
      }

      setStatus("saving");
      setError("");

      try {
        await api.put(`/settings/${endpoint}`, normalized);
        if (cancelled) {
          return;
        }

        lastSerializedRef.current = serialized;
        setStatus("saved");
        setError("");

        if (
          typeof window !== "undefined" &&
          typeof window.dispatchEvent === "function"
        ) {
          window.dispatchEvent(
            new CustomEvent(SETTINGS_UPDATED_EVENT, {
              detail: { category: eventCategory || endpoint },
            }),
          );
        }
      } catch (err) {
        if (cancelled) {
          return;
        }

        console.error(`Error auto-saving ${endpoint} settings:`, err);
        setStatus("error");
        setError(
          err?.response?.data?.message ||
            "Failed to auto-save changes. Please check your connection.",
        );
      }
    }, debounceMs);

    return () => {
      cancelled = true;
      clearTimeout(handler);
    };
  }, [data, debounceMs, endpoint, eventCategory, mergeFn]);

  return { status, error };
};

const createDefaultLibrarySettings = () => ({
  libraryName: "",
  libraryAddress: "",
  libraryPhone: "",
  libraryEmail: "",
  website: "",
  description: "",
  loginLogoUrl: "",
  loginMotto: "",
  loginBackgroundUrl: "",
  openingTime: "08:00",
  closingTime: "17:00",
  operatingDays: ["monday", "tuesday", "wednesday", "thursday", "friday"],
  timezone: "Asia/Manila",
});

const mergeLibrarySettings = (data = {}) => ({
  libraryName: data.libraryName || "",
  libraryAddress: data.libraryAddress || "",
  libraryPhone: sanitizePhoneInput(data.libraryPhone),
  libraryEmail: data.libraryEmail || "",
  website: data.website || "",
  description: data.description || "",
  loginLogoUrl: data.loginLogoUrl || "",
  loginMotto: data.loginMotto || "",
  loginBackgroundUrl: data.loginBackgroundUrl || "",
  openingTime: data.openingTime || "08:00",
  closingTime: data.closingTime || "17:00",
  operatingDays: Array.isArray(data.operatingDays) ? data.operatingDays : ["monday", "tuesday", "wednesday", "thursday", "friday"],
  timezone: data.timezone || "Asia/Manila",
});

const createDefaultBorrowingRules = () => ({
  maxBooksPerTransaction: 10,
  maxBorrowDays: 14,
  finePerDay: 5,
  gracePeriodDays: 0,
  maxFineAmount: 0,
  enableFines: true,
  annualBorrowingEnabled: true,
});

const mergeBorrowingRules = (data = {}) => {
  const base = createDefaultBorrowingRules();
  return {
    ...base,
    maxBooksPerTransaction: normalizeNumber(
      data.maxBooksPerTransaction,
      base.maxBooksPerTransaction,
    ),
    maxBorrowDays: normalizeNumber(data.maxBorrowDays, base.maxBorrowDays),
    finePerDay: normalizeNumber(data.finePerDay, base.finePerDay),
    gracePeriodDays: normalizeNumber(
      data.gracePeriodDays,
      base.gracePeriodDays,
    ),
    maxFineAmount: normalizeNumber(data.maxFineAmount, base.maxFineAmount),
    enableFines: normalizeBoolean(data.enableFines, base.enableFines),
    annualBorrowingEnabled: normalizeBoolean(
      data.annualBorrowingEnabled,
      base.annualBorrowingEnabled,
    ),
  };
};

const createDefaultNotificationSettings = () => ({
  dueDateReminders: true,
  overdueNotifications: true,
  reminderDaysBefore: 3,
  maxReminders: 3,
});

const mergeNotificationSettings = (data = {}) => {
  const base = createDefaultNotificationSettings();
  return {
    dueDateReminders: normalizeBoolean(
      data.dueDateReminders,
      base.dueDateReminders,
    ),
    overdueNotifications: normalizeBoolean(
      data.overdueNotifications,
      base.overdueNotifications,
    ),
    reminderDaysBefore: normalizeNumber(
      data.reminderDaysBefore,
      base.reminderDaysBefore,
    ),
    maxReminders: normalizeNumber(data.maxReminders, base.maxReminders),
  };
};

const createDefaultSystemSettings = () => ({
  maintenanceMode: false,
  sessionTimeoutMinutes: 60,
  maxLoginAttempts: 5,
  passwordPolicy: {
    minLength: 8,
  },
  backupFrequency: "daily",
  logRetentionDays: 90,
  auditLogging: true,
  schoolYearStart: "2024-08-01",
  schoolYearEnd: "2025-05-31",
});

const mergeSystemSettings = (data = {}) => {
  const base = createDefaultSystemSettings();
  return {
    ...base,
    passwordPolicy: {
      minLength: data.passwordPolicy?.minLength ?? base.passwordPolicy.minLength,
    },
    maintenanceMode: normalizeBoolean(data.maintenanceMode, base.maintenanceMode),
    sessionTimeoutMinutes: normalizeNumber(
      data.sessionTimeoutMinutes,
      base.sessionTimeoutMinutes,
    ),
    maxLoginAttempts: normalizeNumber(
      data.maxLoginAttempts,
      base.maxLoginAttempts,
    ),
    backupFrequency: data.backupFrequency || base.backupFrequency,
    logRetentionDays: normalizeNumber(data.logRetentionDays, base.logRetentionDays),
    auditLogging: normalizeBoolean(data.auditLogging, base.auditLogging),
    schoolYearStart: data.schoolYearStart || base.schoolYearStart,
    schoolYearEnd: data.schoolYearEnd || base.schoolYearEnd,
  };
};

const resolveCategoryName = (category) => {
  if (typeof category === "string") {
    return category.trim();
  }
  if (category && typeof category === "object") {
    return category.name || category.label || category.title || "";
  }
  return "";
};

const resolveCategoryKey = (category, fallback) => {
  if (category && typeof category === "object") {
    return category._id || category.id || category.slug || category.name || fallback;
  }
  if (typeof category === "string") {
    const trimmed = category.trim();
    return trimmed || fallback;
  }
  return fallback;
};

const normalizeUserAttributesPayload = (attributes = {}) => {
  const normalizedStructure = normalizeGradeStructure(
    attributes.gradeStructure || [],
    [],
    { useFallbackWhenEmpty: false },
  );

  return {
    curriculum: normalizeStringList(attributes.curriculum || []),
    gradeLevels: normalizedStructure.map((entry) => entry.grade),
    gradeStructure: normalizedStructure,
  };
};

const resolveCategoryDeleteTarget = (category) => {
  if (!category || typeof category !== "object") {
    return null;
  }
  return category._id || category.id || category.slug || null;
};

const SettingsPage = () => {
  const { user } = useAuth();
  const [currentTab, setCurrentTab] = useState(0);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState("");
  const [success, setSuccess] = useState("");
  const [librarySettingsVersion, setLibrarySettingsVersion] = useState(0);
  const [borrowingRulesVersion, setBorrowingRulesVersion] = useState(0);
  const [notificationSettingsVersion, setNotificationSettingsVersion] = useState(0);
  const [systemSettingsVersion, setSystemSettingsVersion] = useState(0);
  const [userAttributesVersion, setUserAttributesVersion] = useState(0);

  const [librarySettings, setLibrarySettings] = useState(() =>
    createDefaultLibrarySettings(),
  );

  const [borrowingRules, setBorrowingRules] = useState(() =>
    createDefaultBorrowingRules(),
  );

  const [notificationSettings, setNotificationSettings] = useState(() =>
    mergeNotificationSettings(),
  );

  const [systemSettings, setSystemSettings] = useState(() =>
    mergeSystemSettings(),
  );

  const [categories, setCategories] = useState([]);
  const [newCategory, setNewCategory] = useState("");
  const [userAttributes, setUserAttributes] = useState(() =>
    ensureUserAttributes(),
  );
  const [newCurriculum, setNewCurriculum] = useState("");
  const [newGradeLevel, setNewGradeLevel] = useState("");
  const [sectionDrafts, setSectionDrafts] = useState({});
  const [brandingUploads, setBrandingUploads] = useState({
    logo: { loading: false, message: "", error: false },
    background: { loading: false, message: "", error: false },
  });

  useEffect(() => {
    fetchAllSettings();
    fetchCategories();
    fetchUserAttributes();
  }, []);

  const fetchAllSettings = async () => {
    try {
      setLoading(true);
      const [library, borrowing, notifications, system] = await Promise.all([
        api.get("/settings/library"),
        api.get("/settings/borrowing-rules"),
        api.get("/settings/notifications"),
        api.get("/settings/system"),
      ]);
      const mergedLibrarySettings = mergeLibrarySettings(library.data);
      setLibrarySettings(mergedLibrarySettings);
      setLibrarySettingsVersion((prev) => prev + 1);

      setBorrowingRules(mergeBorrowingRules(borrowing.data));
      setBorrowingRulesVersion((prev) => prev + 1);

      setNotificationSettings(mergeNotificationSettings(notifications.data));
      setNotificationSettingsVersion((prev) => prev + 1);

      setSystemSettings(mergeSystemSettings(system.data));
      setSystemSettingsVersion((prev) => prev + 1);
    } catch (error) {
      setError("Failed to fetch settings");
      console.error("Error fetching settings:", error);
    } finally {
      setLoading(false);
    }
  };

  const fetchCategories = async () => {
    try {
      const response = await api.get("/books/categories");
      setCategories(response.data);
    } catch (error) {
      console.error("Error fetching categories:", error);
    }
  };

  const fetchUserAttributes = async () => {
    try {
      const response = await settingsAPI.getUserAttributes();
      setUserAttributes(ensureUserAttributes(response.data));
      setUserAttributesVersion((prev) => prev + 1);
    } catch (error) {
      console.error("Error fetching user attributes:", error);
      setUserAttributes(ensureUserAttributes());
      setUserAttributesVersion((prev) => prev + 1);
    }
  };

  const handleAddCategory = async () => {
    if (!newCategory.trim()) return;

    try {
      await api.post("/books/categories", { name: newCategory });
      setNewCategory("");
      fetchCategories();
      setSuccess("Category added successfully");
    } catch (error) {
      setError("Failed to add category");
      console.error("Error adding category:", error);
    }
  };

  const handleAddCurriculum = () => {
    const value = newCurriculum.trim();
    if (!value) return;

    setUserAttributes((prev) => {
      if (prev.curriculum.some((item) => item.toLowerCase() === value.toLowerCase())) {
        return prev;
      }
      return {
        ...prev,
        curriculum: [...prev.curriculum, value],
      };
    });
    setNewCurriculum("");
  };

  const handleRemoveCurriculum = (value) => {
    setUserAttributes((prev) => ({
      ...prev,
      curriculum: prev.curriculum.filter((item) => item !== value),
    }));
  };

  const handleGradeColorChange = (grade, colorValue) => {
    if (!grade) {
      return;
    }

    setUserAttributes((prev) => {
      const structure = Array.isArray(prev.gradeStructure) ? prev.gradeStructure : [];
      const nextStructure = structure.map((entry, index) => {
        if (entry.grade !== grade) {
          return entry;
        }
        return {
          ...entry,
          color: sanitizeHexColor(colorValue, resolveGradeColorValue(entry, index)),
        };
      });
      return {
        ...prev,
        gradeStructure: nextStructure,
      };
    });
  };

  const handleAddGradeLevel = () => {
    const value = newGradeLevel.trim();
    if (!value) return;

    setUserAttributes((prev) => {
      const structure = Array.isArray(prev.gradeStructure) ? prev.gradeStructure : [];
      if (structure.some((entry) => entry.grade?.toLowerCase() === value.toLowerCase())) {
        return prev;
      }
      const defaultColor = getDefaultGradeColor(structure.length);
      const nextStructure = normalizeGradeStructure(
        [
          ...structure,
          { grade: value, sections: [], color: defaultColor },
        ],
        [],
        { useFallbackWhenEmpty: false }
      );
      return {
        ...prev,
        gradeStructure: nextStructure,
        gradeLevels: nextStructure.map((entry) => entry.grade),
      };
    });
    setNewGradeLevel("");
  };

  const handleRemoveGradeLevel = (value) => {
    setUserAttributes((prev) => {
      const structure = Array.isArray(prev.gradeStructure) ? prev.gradeStructure : [];
      const nextStructure = normalizeGradeStructure(
        structure.filter((entry) => entry.grade !== value),
        [],
        { useFallbackWhenEmpty: false }
      );
      return {
        ...prev,
        gradeStructure: nextStructure,
        gradeLevels: nextStructure.map((entry) => entry.grade),
      };
    });
    setSectionDrafts((prev) => {
      if (!prev[value]) {
        return prev;
      }
      const nextDrafts = { ...prev };
      delete nextDrafts[value];
      return nextDrafts;
    });
  };

  const handleSectionDraftChange = (grade, value) => {
    setSectionDrafts((prev) => ({
      ...prev,
      [grade]: value,
    }));
  };

  const handleAddSection = (grade) => {
    if (!grade) {
      return;
    }
    const value = (sectionDrafts[grade] || "").trim();
    if (!value) {
      return;
    }

    setUserAttributes((prev) => {
      const structure = Array.isArray(prev.gradeStructure) ? prev.gradeStructure : [];
      const nextStructure = structure.map((entry) => {
        if (entry.grade !== grade) {
          return entry;
        }
        if (entry.sections.some((section) => section.toLowerCase() === value.toLowerCase())) {
          return entry;
        }
        return {
          ...entry,
          sections: [...entry.sections, value],
        };
      });
      return {
        ...prev,
        gradeStructure: nextStructure,
      };
    });

    setSectionDrafts((prev) => ({
      ...prev,
      [grade]: "",
    }));
  };

  const handleRemoveSection = (grade, section) => {
    if (!grade) {
      return;
    }
    setUserAttributes((prev) => {
      const structure = Array.isArray(prev.gradeStructure) ? prev.gradeStructure : [];
      const nextStructure = structure.map((entry) => {
        if (entry.grade !== grade) {
          return entry;
        }
        return {
          ...entry,
          sections: entry.sections.filter((item) => item !== section),
        };
      });
      return {
        ...prev,
        gradeStructure: nextStructure,
      };
    });
  };

  const handleDeleteCategory = async (categoryId) => {
    if (!categoryId) {
      setError("This category is synced from book data and can't be deleted here.");
      return;
    }

    if (!window.confirm("Are you sure you want to delete this category?")) {
      return;
    }

    try {
      await api.delete(`/books/categories/${categoryId}`);
      fetchCategories();
      setSuccess("Category deleted successfully");
    } catch (error) {
      setError("Failed to delete category");
      console.error("Error deleting category:", error);
    }
  };

  const handleBackup = async () => {
    try {
      await api.post("/settings/backup");
      setSuccess("Backup created successfully");
    } catch (error) {
      setError("Failed to create backup");
      console.error("Error creating backup:", error);
    }
  };

  const handleRestore = async () => {
    if (
      !window.confirm(
        "Are you sure you want to restore from backup? This will overwrite current data.",
      )
    ) {
      return;
    }

    try {
      await api.post("/settings/restore");
      setSuccess("System restored successfully");
      fetchAllSettings();
    } catch (error) {
      setError("Failed to restore from backup");
      console.error("Error restoring backup:", error);
    }
  };

  const updateBrandingUploadState = (slot, nextState) => {
    const normalizedSlot = sanitizeBrandingSlotName(slot);
    setBrandingUploads((prev) => ({
      ...prev,
      [normalizedSlot]: {
        ...prev[normalizedSlot],
        ...nextState,
      },
    }));
  };

  const handleBrandingUpload = async (file, slot) => {
    if (!file) {
      return;
    }

    const normalizedSlot = sanitizeBrandingSlotName(slot);
    updateBrandingUploadState(normalizedSlot, {
      loading: true,
      message: "Uploading...",
      error: false,
    });

    try {
      const response = await settingsAPI.uploadBrandingAsset(normalizedSlot, file);
      const uploadedUrl = response?.data?.url || "";
      const returnedSlot = sanitizeBrandingSlotName(response?.data?.slot || normalizedSlot);
      const targetField = BRANDING_FIELD_BY_SLOT[returnedSlot];

      if (uploadedUrl && targetField) {
        setLibrarySettings((prev) => ({
          ...prev,
          [targetField]: uploadedUrl,
        }));
      }

      updateBrandingUploadState(normalizedSlot, {
        loading: false,
        message: "Upload complete. URL saved automatically.",
        error: false,
      });
    } catch (error) {
      console.error("Branding upload failed:", error);
      const message =
        error?.response?.data?.message ||
        error?.message ||
        "Upload failed. Please try again.";
      updateBrandingUploadState(normalizedSlot, {
        loading: false,
        message,
        error: true,
      });
    }
  };

  const handleBrandingFileInputChange = (event, slot) => {
    const file = event?.target?.files?.[0];
    if (file) {
      handleBrandingUpload(file, slot);
    }
    if (event?.target) {
      event.target.value = "";
    }
  };

  const { status: libraryAutoSaveStatus, error: libraryAutoSaveError } =
    useAutoSaveSetting({
      data: librarySettings,
      mergeFn: mergeLibrarySettings,
      endpoint: "library",
      eventCategory: "library",
      resetKey: librarySettingsVersion,
    });

  const { status: borrowingAutoSaveStatus, error: borrowingAutoSaveError } =
    useAutoSaveSetting({
      data: borrowingRules,
      mergeFn: mergeBorrowingRules,
      endpoint: "borrowing-rules",
      eventCategory: "borrowing-rules",
      resetKey: borrowingRulesVersion,
    });

  const { status: notificationAutoSaveStatus, error: notificationAutoSaveError } =
    useAutoSaveSetting({
      data: notificationSettings,
      mergeFn: mergeNotificationSettings,
      endpoint: "notifications",
      eventCategory: "notifications",
      resetKey: notificationSettingsVersion,
    });

  const { status: systemAutoSaveStatus, error: systemAutoSaveError } =
    useAutoSaveSetting({
      data: systemSettings,
      mergeFn: mergeSystemSettings,
      endpoint: "system",
      eventCategory: "system",
      resetKey: systemSettingsVersion,
    });

  const { status: userAttributesAutoSaveStatus, error: userAttributesAutoSaveError } =
    useAutoSaveSetting({
      data: userAttributes,
      mergeFn: normalizeUserAttributesPayload,
      endpoint: "user-attributes",
      eventCategory: "user-attributes",
      resetKey: userAttributesVersion,
    });

  const role = user?.role || "";
  const isAdmin = role === "admin";
  const isLibrarian = role === "librarian";
  const canAccessSettings = isAdmin || isLibrarian;
  const libraryAutoSaveMessage = getAutoSaveMessage(
    libraryAutoSaveStatus,
    libraryAutoSaveError,
  );
  const libraryAutoSaveColor = getAutoSaveColor(libraryAutoSaveStatus);
  const borrowingAutoSaveMessage = getAutoSaveMessage(
    borrowingAutoSaveStatus,
    borrowingAutoSaveError,
  );
  const borrowingAutoSaveColor = getAutoSaveColor(borrowingAutoSaveStatus);
  const notificationAutoSaveMessage = getAutoSaveMessage(
    notificationAutoSaveStatus,
    notificationAutoSaveError,
  );
  const notificationAutoSaveColor = getAutoSaveColor(
    notificationAutoSaveStatus,
  );
  const systemAutoSaveMessage = getAutoSaveMessage(
    systemAutoSaveStatus,
    systemAutoSaveError,
  );
  const systemAutoSaveColor = getAutoSaveColor(systemAutoSaveStatus);
  const userAttributesAutoSaveMessage = getAutoSaveMessage(
    userAttributesAutoSaveStatus,
    userAttributesAutoSaveError,
  );
  const userAttributesAutoSaveColor = getAutoSaveColor(
    userAttributesAutoSaveStatus,
  );

  useEffect(() => {
    if (!isAdmin && currentTab === 3) {
      setCurrentTab(0);
      return;
    }
    if (isAdmin && (currentTab === 1 || currentTab === 5)) {
      setCurrentTab(0);
    }
  }, [isAdmin, currentTab]);

  if (!canAccessSettings) {
    return (
      <Box>
        <Alert severity="error">
          Access denied. Only administrators and librarians can access settings.
        </Alert>
      </Box>
    );
  }

  return (
    <Box>
      <Box
        display="flex"
        justifyContent="space-between"
        alignItems="center"
        mb={3}
      >
        <Typography variant="h4" color={"white"}>System Settings</Typography>
        {isAdmin && (
          <Box>
            <Button
              variant="outlined"
              startIcon={<Backup />}
              onClick={handleBackup}
              sx={{ mr: 2 }}
              disabled={loading}
            >
              Create Backup
            </Button>
            <Button
              variant="outlined"
              startIcon={<Restore />}
              onClick={handleRestore}
              color="warning"
              disabled={loading}
            >
              Restore Backup
            </Button>
          </Box>
        )}
      </Box>
      {error && (
        <Alert severity="error" sx={{ mb: 2 }}>
          {error}
        </Alert>
      )}
      {success && (
        <Alert severity="success" sx={{ mb: 2 }}>
          {success}
        </Alert>
      )}
      <Paper sx={{ borderRadius: 2 }}>
        <Tabs
          value={currentTab}
          onChange={(event, newValue) => setCurrentTab(newValue)}
          variant="scrollable"
          scrollButtons="auto"
        >
          <Tab label="Library Info" icon={<LibraryBooks />} />
          <Tab
            label="Borrowing Rules"
            icon={<Schedule />}
            disabled={isAdmin}
            sx={{ display: isAdmin ? "none" : "inline-flex" }}
          />
          <Tab label="Notifications" icon={<Notifications />} />
          <Tab
            label="System"
            icon={<Computer />}
            disabled={!isAdmin}
            sx={{ display: isAdmin ? "inline-flex" : "none" }}
          />
          <Tab label="User Fields" icon={<Group />} />
          <Tab
            label="Categories"
            icon={<Edit />}
            disabled={isAdmin}
            sx={{ display: isAdmin ? "none" : "inline-flex" }}
          />
        </Tabs>

        <TabPanel value={currentTab} index={0}>
          <Grid container spacing={3}>
            <Grid item xs={12} md={6}>
              <Card elevation={1}>
                <CardHeader
                  title="Library Profile"
                  subheader="Information shown to patrons and on notices"
                />
                <CardContent>
                  <Stack spacing={2}>
                    <TextField
                      fullWidth
                      size="small"
                      label="Library Name"
                      value={librarySettings.libraryName}
                      onChange={(e) =>
                        setLibrarySettings({
                          ...librarySettings,
                          libraryName: e.target.value,
                        })
                      }
                    />
                    <TextField
                      fullWidth
                      size="small"
                      label="Website"
                      placeholder="https://"
                      value={librarySettings.website}
                      onChange={(e) =>
                        setLibrarySettings({
                          ...librarySettings,
                          website: e.target.value,
                        })
                      }
                    />
                    <TextField
                      fullWidth
                      size="small"
                      label="Description"
                      multiline
                      minRows={4}
                      value={librarySettings.description}
                      onChange={(e) =>
                        setLibrarySettings({
                          ...librarySettings,
                          description: e.target.value,
                        })
                      }
                    />
                  </Stack>
                </CardContent>
              </Card>
            </Grid>
            <Grid item xs={12} md={6}>
              <Card elevation={1}>
                <CardHeader
                  title="Contact Details"
                  subheader="Helps patrons reach the library quickly"
                />
                <CardContent>
                  <Stack spacing={2}>
                    <TextField
                      fullWidth
                      size="small"
                      label="Phone Number"
                      value={librarySettings.libraryPhone}
                      onChange={(e) =>
                        setLibrarySettings({
                          ...librarySettings,
                          libraryPhone: sanitizePhoneInput(e.target.value),
                        })
                      }
                      inputProps={{ inputMode: "numeric", pattern: "[0-9]*", maxLength: 11 }}
                    />
                    <TextField
                      fullWidth
                      size="small"
                      label="Email Address"
                      type="email"
                      value={librarySettings.libraryEmail}
                      onChange={(e) =>
                        setLibrarySettings({
                          ...librarySettings,
                          libraryEmail: e.target.value,
                        })
                      }
                    />
                    <TextField
                      fullWidth
                      size="small"
                      label="Address"
                      multiline
                      minRows={3}
                      value={librarySettings.libraryAddress}
                      onChange={(e) =>
                        setLibrarySettings({
                          ...librarySettings,
                          libraryAddress: e.target.value,
                        })
                      }
                    />
                  </Stack>
                </CardContent>
              </Card>
            </Grid>
            <Grid item xs={12}>
              <Card elevation={1}>
                <CardHeader
                  title="Login Branding"
                  subheader="Control what appears on the public login page"
                />
                <CardContent>
                  <Stack spacing={3}>
                    <Stack spacing={1}>
                      <Stack
                        direction={{ xs: "column", sm: "row" }}
                        spacing={1}
                        alignItems={{ sm: "flex-end" }}
                      >
                        <TextField
                          fullWidth
                          size="small"
                          label="Login Logo URL"
                          placeholder="https://example.com/logo.png"
                          value={librarySettings.loginLogoUrl}
                          onChange={(e) =>
                            setLibrarySettings({
                              ...librarySettings,
                              loginLogoUrl: e.target.value,
                            })
                          }
                          helperText="PNG, JPG, or SVG links. Leave blank to use the built-in logo."
                          sx={{ flexGrow: 1 }}
                        />
                        <Button
                          variant="outlined"
                          component="label"
                          startIcon={<CloudUpload />}
                          disabled={brandingUploads.logo.loading}
                          sx={{ alignSelf: { xs: "stretch", sm: "flex-end" } }}
                        >
                          {brandingUploads.logo.loading ? "Uploading..." : "Upload Logo"}
                          <input
                            type="file"
                            accept="image/*"
                            hidden
                            onChange={(event) =>
                              handleBrandingFileInputChange(event, "logo")
                            }
                          />
                        </Button>
                      </Stack>
                      {brandingUploads.logo.message && (
                        <Typography
                          variant="caption"
                          color={
                            brandingUploads.logo.error
                              ? "error.main"
                              : brandingUploads.logo.loading
                                ? "text.secondary"
                                : "success.main"
                          }
                        >
                          {brandingUploads.logo.message}
                        </Typography>
                      )}
                    </Stack>
                    <TextField
                      fullWidth
                      size="small"
                      label="School Motto / Tagline"
                      value={librarySettings.loginMotto}
                      onChange={(e) =>
                        setLibrarySettings({
                          ...librarySettings,
                          loginMotto: e.target.value,
                        })
                      }
                      helperText="Shown on both desktop and mobile login screens."
                    />
                    <Stack spacing={1}>
                      <Stack
                        direction={{ xs: "column", sm: "row" }}
                        spacing={1}
                        alignItems={{ sm: "flex-end" }}
                      >
                        <TextField
                          fullWidth
                          size="small"
                          label="Login Background Image URL"
                          placeholder="https://example.com/background.jpg"
                          value={librarySettings.loginBackgroundUrl}
                          onChange={(e) =>
                            setLibrarySettings({
                              ...librarySettings,
                              loginBackgroundUrl: e.target.value,
                            })
                          }
                          helperText="Wide landscape images work best. Uses the default artwork when empty."
                          sx={{ flexGrow: 1 }}
                        />
                        <Button
                          variant="outlined"
                          component="label"
                          startIcon={<CloudUpload />}
                          disabled={brandingUploads.background.loading}
                          sx={{ alignSelf: { xs: "stretch", sm: "flex-end" } }}
                        >
                          {brandingUploads.background.loading
                            ? "Uploading..."
                            : "Upload Background"}
                          <input
                            type="file"
                            accept="image/*"
                            hidden
                            onChange={(event) =>
                              handleBrandingFileInputChange(event, "background")
                            }
                          />
                        </Button>
                      </Stack>
                      {brandingUploads.background.message && (
                        <Typography
                          variant="caption"
                          color={
                            brandingUploads.background.error
                              ? "error.main"
                              : brandingUploads.background.loading
                                ? "text.secondary"
                                : "success.main"
                          }
                        >
                          {brandingUploads.background.message}
                        </Typography>
                      )}
                    </Stack>
                  </Stack>
                </CardContent>
              </Card>
            </Grid>
            <Grid item xs={12} md={6}>
              <Card elevation={1}>
                <CardHeader
                  title="Operating Hours"
                  subheader="When the library is open for business"
                />
                <CardContent>
                  <Stack spacing={2}>
                    <Stack direction={{ xs: "column", sm: "row" }} spacing={2}>
                      <TextField
                        fullWidth
                        size="small"
                        label="Opening Time"
                        type="time"
                        value={librarySettings.openingTime}
                        onChange={(e) =>
                          setLibrarySettings({
                            ...librarySettings,
                            openingTime: e.target.value,
                          })
                        }
                        InputLabelProps={{ shrink: true }}
                      />
                      <TextField
                        fullWidth
                        size="small"
                        label="Closing Time"
                        type="time"
                        value={librarySettings.closingTime}
                        onChange={(e) =>
                          setLibrarySettings({
                            ...librarySettings,
                            closingTime: e.target.value,
                          })
                        }
                        InputLabelProps={{ shrink: true }}
                      />
                    </Stack>
                    <TextField
                      fullWidth
                      size="small"
                      label="Timezone"
                      value={librarySettings.timezone}
                      onChange={(e) =>
                        setLibrarySettings({
                          ...librarySettings,
                          timezone: e.target.value,
                        })
                      }
                      helperText="Use an IANA timezone (e.g., Asia/Manila)."
                    />
                    <FormControl fullWidth size="small">
                      <InputLabel>Operating Days</InputLabel>
                      <Select
                        multiple
                        value={librarySettings.operatingDays}
                        onChange={(e) =>
                          setLibrarySettings({
                            ...librarySettings,
                            operatingDays: e.target.value,
                          })
                        }
                        renderValue={(selected) => (
                          <Box sx={{ display: "flex", flexWrap: "wrap", gap: 0.5 }}>
                            {selected.map((value) => (
                              <Chip
                                key={value}
                                label={value.charAt(0).toUpperCase() + value.slice(1)}
                                size="small"
                              />
                            ))}
                          </Box>
                        )}
                      >
                        {["monday", "tuesday", "wednesday", "thursday", "friday", "saturday", "sunday"].map((day) => (
                          <MenuItem key={day} value={day}>
                            {day.charAt(0).toUpperCase() + day.slice(1)}
                          </MenuItem>
                        ))}
                      </Select>
                    </FormControl>
                  </Stack>
                </CardContent>
              </Card>
            </Grid>
            <Grid item xs={12}>
              <Box display="flex" justifyContent="flex-end">
                <Typography
                  variant="body2"
                  sx={{ color: libraryAutoSaveColor, textAlign: "right" }}
                >
                  {libraryAutoSaveMessage}
                </Typography>
              </Box>
            </Grid>
          </Grid>
        </TabPanel>

        <TabPanel value={currentTab} index={1}>
          <Grid container spacing={3}>
            <Grid item xs={12} md={6}>
              <Card elevation={1}>
                <CardHeader
                  title="Borrowing Limits"
                  subheader="Control how many books each patron gets"
                />
                <CardContent>
                  <Stack spacing={2}>
                    <TextField
                      fullWidth
                      size="small"
                      label="Max Books Per Transaction"
                      type="number"
                      value={borrowingRules.maxBooksPerTransaction}
                      onChange={(e) =>
                        setBorrowingRules({
                          ...borrowingRules,
                          maxBooksPerTransaction:
                            parseInt(e.target.value, 10) || 0,
                        })
                      }
                    />
                    <TextField
                      fullWidth
                      size="small"
                      label="Borrowing Period (Days)"
                      type="number"
                      value={borrowingRules.maxBorrowDays}
                      onChange={(e) =>
                        setBorrowingRules({
                          ...borrowingRules,
                          maxBorrowDays: parseInt(e.target.value, 10) || 0,
                        })
                      }
                    />
                  </Stack>
                </CardContent>
              </Card>
            </Grid>
            <Grid item xs={12} md={6}>
              <Card elevation={1}>
                <CardHeader
                  title="Fines & Grace Period"
                  subheader="Adjust how the system calculates penalties"
                />
                <CardContent>
                  <Stack spacing={2}>
                    <FormControlLabel
                      control={
                        <Switch
                          checked={borrowingRules.enableFines}
                          onChange={(e) =>
                            setBorrowingRules({
                              ...borrowingRules,
                              enableFines: e.target.checked,
                            })
                          }
                        />
                      }
                      label="Enable Fines"
                    />
                    <TextField
                      fullWidth
                      size="small"
                      label="Fine Per Day"
                      type="number"
                      inputProps={{ step: 0.01, min: 0 }}
                      value={borrowingRules.finePerDay}
                      onChange={(e) =>
                        setBorrowingRules({
                          ...borrowingRules,
                          finePerDay: parseFloat(e.target.value) || 0,
                        })
                      }
                      InputProps={{
                        startAdornment: (
                          <InputAdornment position="start">‚Ç±</InputAdornment>
                        ),
                      }}
                      disabled={!borrowingRules.enableFines}
                    />
                    <TextField
                      fullWidth
                      size="small"
                      label="Grace Period (Days)"
                      type="number"
                      value={borrowingRules.gracePeriodDays}
                      onChange={(e) =>
                        setBorrowingRules({
                          ...borrowingRules,
                          gracePeriodDays: parseInt(e.target.value, 10) || 0,
                        })
                      }
                    />
                    <TextField
                      fullWidth
                      size="small"
                      label="Maximum Fine Amount"
                      type="number"
                      inputProps={{ step: 0.01, min: 0 }}
                      value={borrowingRules.maxFineAmount}
                      onChange={(e) =>
                        setBorrowingRules({
                          ...borrowingRules,
                          maxFineAmount: parseFloat(e.target.value) || 0,
                        })
                      }
                      InputProps={{
                        startAdornment: (
                          <InputAdornment position="start">‚Ç±</InputAdornment>
                        ),
                      }}
                      disabled={!borrowingRules.enableFines}
                    />
                  </Stack>
                </CardContent>
              </Card>
            </Grid>
            <Grid item xs={12}>
              <Card elevation={1}>
                <CardHeader
                  title="Borrowing Options"
                  subheader="Toggle advanced borrowing flows"
                />
                <CardContent>
                  <Stack spacing={1.5}>
                    <FormControlLabel
                      control={
                        <Switch
                          checked={borrowingRules.annualBorrowingEnabled}
                          onChange={(e) =>
                            setBorrowingRules({
                              ...borrowingRules,
                              annualBorrowingEnabled: e.target.checked,
                            })
                          }
                        />
                      }
                      label="Enable Annual Borrowing"
                    />
                  </Stack>
                </CardContent>
              </Card>
            </Grid>
            <Grid item xs={12}>
              <Box display="flex" justifyContent="flex-end">
                <Typography
                  variant="body2"
                  sx={{ color: borrowingAutoSaveColor, textAlign: "right" }}
                >
                  {borrowingAutoSaveMessage}
                </Typography>
              </Box>
            </Grid>
          </Grid>
        </TabPanel>

        <TabPanel value={currentTab} index={2}>
          <Grid container spacing={3}>
            <Grid item xs={12} md={6}>
              <Card elevation={1}>
                <CardHeader
                  title="Notification Types"
                  subheader="Enable reminders that matter to your team"
                />
                <CardContent>
                  <Stack spacing={1.5}>
                    <FormControlLabel
                      control={
                        <Switch
                          checked={notificationSettings.dueDateReminders}
                          onChange={(e) =>
                            setNotificationSettings({
                              ...notificationSettings,
                              dueDateReminders: e.target.checked,
                            })
                          }
                        />
                      }
                      label="Due Date Reminders"
                    />
                    <FormControlLabel
                      control={
                        <Switch
                          checked={notificationSettings.overdueNotifications}
                          onChange={(e) =>
                            setNotificationSettings({
                              ...notificationSettings,
                              overdueNotifications: e.target.checked,
                            })
                          }
                        />
                      }
                      label="Overdue Notices"
                    />
                  </Stack>
                </CardContent>
              </Card>
            </Grid>
            <Grid item xs={12} md={6}>
              <Card elevation={1}>
                <CardHeader
                  title="Reminder Schedule"
                  subheader="Fine-tune when reminders are sent"
                />
                <CardContent>
                  <Stack spacing={2}>
                    <TextField
                      fullWidth
                      size="small"
                      label="Reminder Days Before Due"
                      type="number"
                      value={notificationSettings.reminderDaysBefore}
                      onChange={(e) =>
                        setNotificationSettings({
                          ...notificationSettings,
                          reminderDaysBefore: parseInt(e.target.value, 10) || 0,
                        })
                      }
                    />
                    <TextField
                      fullWidth
                      size="small"
                      label="Maximum Reminders"
                      type="number"
                      value={notificationSettings.maxReminders}
                      onChange={(e) =>
                        setNotificationSettings({
                          ...notificationSettings,
                          maxReminders: parseInt(e.target.value, 10) || 0,
                        })
                      }
                    />
                  </Stack>
                </CardContent>
              </Card>
            </Grid>
            <Grid item xs={12}>
              <Box display="flex" justifyContent="flex-end">
                <Typography
                  variant="body2"
                  sx={{ color: notificationAutoSaveColor, textAlign: "right" }}
                >
                  {notificationAutoSaveMessage}
                </Typography>
              </Box>
            </Grid>
          </Grid>
        </TabPanel>

        <TabPanel value={currentTab} index={3}>
          {isAdmin ? (
            <Grid container spacing={3}>
              <Grid item xs={12} md={6}>
              <Card elevation={1}>
                <CardHeader
                  title="Access & Availability"
                  subheader="Control who can access the portal"
                />
                <CardContent>
                  <Stack spacing={1.5}>
                    <FormControlLabel
                      control={
                        <Switch
                          checked={systemSettings.maintenanceMode}
                          onChange={(e) =>
                            setSystemSettings({
                              ...systemSettings,
                              maintenanceMode: e.target.checked,
                            })
                          }
                        />
                      }
                      label="Maintenance Mode"
                    />
                    <FormControlLabel
                      control={
                        <Switch
                          checked={systemSettings.auditLogging}
                          onChange={(e) =>
                            setSystemSettings({
                              ...systemSettings,
                              auditLogging: e.target.checked,
                            })
                          }
                        />
                      }
                      label="Enable Audit Logging"
                    />
                  </Stack>
                </CardContent>
              </Card>
            </Grid>
            <Grid item xs={12} md={6}>
              <Card elevation={1}>
                <CardHeader
                  title="Security Limits"
                  subheader="Keep accounts secure with sensible defaults"
                />
                <CardContent>
                  <Stack spacing={2}>
                    <TextField
                      fullWidth
                      size="small"
                      label="Session Timeout (Minutes)"
                      type="number"
                      value={systemSettings.sessionTimeoutMinutes}
                      onChange={(e) =>
                        setSystemSettings({
                          ...systemSettings,
                          sessionTimeoutMinutes:
                            parseInt(e.target.value, 10) || 0,
                        })
                      }
                    />
                    <TextField
                      fullWidth
                      size="small"
                      label="Max Login Attempts"
                      type="number"
                      value={systemSettings.maxLoginAttempts}
                      onChange={(e) =>
                        setSystemSettings({
                          ...systemSettings,
                          maxLoginAttempts: parseInt(e.target.value, 10) || 0,
                        })
                      }
                    />
                    <TextField
                      fullWidth
                      size="small"
                      label="Password Minimum Length"
                      type="number"
                      value={systemSettings.passwordPolicy.minLength}
                      onChange={(e) =>
                        setSystemSettings({
                          ...systemSettings,
                          passwordPolicy: {
                            ...systemSettings.passwordPolicy,
                            minLength: parseInt(e.target.value, 10) || 0,
                          },
                        })
                      }
                    />
                  </Stack>
                </CardContent>
              </Card>
            </Grid>
            <Grid item xs={12} md={6}>
              <Card elevation={1}>
                <CardHeader
                  title="Backup & Retention"
                  subheader="Keep data safe and manageable"
                />
                <CardContent>
                  <Stack spacing={2}>
                    <FormControl fullWidth size="small">
                      <InputLabel>Backup Frequency</InputLabel>
                      <Select
                        value={systemSettings.backupFrequency}
                        label="Backup Frequency"
                        onChange={(e) =>
                          setSystemSettings({
                            ...systemSettings,
                            backupFrequency: e.target.value,
                          })
                        }
                      >
                        <MenuItem value="daily">Daily</MenuItem>
                        <MenuItem value="weekly">Weekly</MenuItem>
                        <MenuItem value="monthly">Monthly</MenuItem>
                      </Select>
                    </FormControl>
                    <TextField
                      fullWidth
                      size="small"
                      label="Log Retention (Days)"
                      type="number"
                      value={systemSettings.logRetentionDays}
                      onChange={(e) =>
                        setSystemSettings({
                          ...systemSettings,
                          logRetentionDays: parseInt(e.target.value, 10) || 0,
                        })
                      }
                    />
                  </Stack>
                </CardContent>
              </Card>
            </Grid>
            <Grid item xs={12}>
              <Box display="flex" justifyContent="flex-end">
                <Typography
                  variant="body2"
                  sx={{ color: systemAutoSaveColor, textAlign: "right" }}
                >
                  {systemAutoSaveMessage}
                </Typography>
              </Box>
            </Grid>
            </Grid>
          ) : (
            <Alert severity="warning">
              System configuration is restricted to administrators.
            </Alert>
          )}
        </TabPanel>

        <TabPanel value={currentTab} index={4}>
          <Grid container spacing={3}>
            <Grid item xs={12} md={6}>
              <Card elevation={1}>
                <CardHeader
                  title="Curriculum"
                  subheader="Update the selectable curricula for users and students"
                />
                <CardContent>
                  <Stack spacing={2}>
                    <Stack direction={{ xs: "column", sm: "row" }} spacing={2}>
                      <TextField
                        fullWidth
                        size="small"
                        label="Add Curriculum"
                        value={newCurriculum}
                        onChange={(event) => setNewCurriculum(event.target.value)}
                        onKeyDown={(event) => {
                          if (event.key === "Enter") {
                            event.preventDefault();
                            handleAddCurriculum();
                          }
                        }}
                      />
                      <Button
                        variant="contained"
                        startIcon={<Add />}
                        onClick={handleAddCurriculum}
                        disabled={!newCurriculum.trim()}
                      >
                        Add
                      </Button>
                    </Stack>
                    {userAttributes.curriculum.length === 0 ? (
                      <Typography color="text.secondary">
                        No curriculum options configured. Add at least one option.
                      </Typography>
                    ) : (
                      <Stack direction="row" flexWrap="wrap" spacing={1}>
                        {userAttributes.curriculum.map((item) => (
                          <Chip
                            key={item}
                            label={item}
                            onDelete={() => handleRemoveCurriculum(item)}
                            sx={{ mb: 1 }}
                            color="primary"
                            variant="outlined"
                          />
                        ))}
                      </Stack>
                    )}
                  </Stack>
                </CardContent>
              </Card>
            </Grid>
            <Grid item xs={12} md={6}>
              <Card elevation={1}>
                <CardHeader
                  title="Grade Levels"
                  subheader="Manage grade and year level choices"
                />
                <CardContent>
                  <Stack spacing={2}>
                    <Stack direction={{ xs: "column", sm: "row" }} spacing={2}>
                      <TextField
                        fullWidth
                        size="small"
                        label="Add Grade Level"
                        value={newGradeLevel}
                        onChange={(event) => setNewGradeLevel(event.target.value)}
                        onKeyDown={(event) => {
                          if (event.key === "Enter") {
                            event.preventDefault();
                            handleAddGradeLevel();
                          }
                        }}
                      />
                      <Button
                        variant="contained"
                        startIcon={<Add />}
                        onClick={handleAddGradeLevel}
                        disabled={!newGradeLevel.trim()}
                      >
                        Add
                      </Button>
                    </Stack>
                    {(!userAttributes.gradeStructure || userAttributes.gradeStructure.length === 0) ? (
                      <Typography color="text.secondary">
                        No grade levels configured. Add a grade, then list sections for each grade.
                      </Typography>
                    ) : (
                      <Stack spacing={2}>
                        {userAttributes.gradeStructure.map((entry, entryIndex) => {
                          const entryColor = resolveGradeColorValue(entry, entryIndex);
                          return (
                            <Paper
                              key={entry.grade}
                              variant="outlined"
                              sx={{ p: 2, borderRadius: 2, borderColor: entryColor }}
                            >
                              <Stack direction="row" alignItems="center" justifyContent="space-between" spacing={1}>
                                <Box display="flex" alignItems="center" flexWrap="wrap" gap={1}>
                                  <Typography variant="subtitle1">{entry.grade}</Typography>
                                  <Box display="flex" alignItems="center" gap={1}>
                                    <Box
                                      component="input"
                                      type="color"
                                      aria-label={`Select color for ${entry.grade}`}
                                      value={entryColor}
                                      onChange={(event) => handleGradeColorChange(entry.grade, event.target.value)}
                                      sx={{
                                        width: 40,
                                        height: 32,
                                        border: "none",
                                        background: "transparent",
                                        cursor: "pointer",
                                        p: 0,
                                      }}
                                    />
                                    <Typography variant="caption" color="text.secondary">
                                      {entryColor}
                                    </Typography>
                                  </Box>
                                </Box>
                                <IconButton
                                  size="small"
                                  color="error"
                                  onClick={() => handleRemoveGradeLevel(entry.grade)}
                                  aria-label={`Remove ${entry.grade}`}
                                >
                                  <Delete fontSize="small" />
                                </IconButton>
                              </Stack>
                            {entry.sections.length === 0 ? (
                              <Typography variant="body2" color="text.secondary" sx={{ mt: 1 }}>
                                No sections yet. Add at least one section for this grade.
                              </Typography>
                            ) : (
                              <Stack direction="row" flexWrap="wrap" spacing={1} sx={{ mt: 1 }}>
                                {entry.sections.map((section) => (
                                  <Chip
                                    key={`${entry.grade}-${section}`}
                                    label={`Section ${section}`}
                                    onDelete={() => handleRemoveSection(entry.grade, section)}
                                    variant="outlined"
                                    size="small"
                                    sx={{ mb: 1 }}
                                  />
                                ))}
                              </Stack>
                            )}
                            <Stack direction={{ xs: "column", sm: "row" }} spacing={1} mt={1}>
                              <TextField
                                fullWidth
                                size="small"
                                label={`Add section for ${entry.grade}`}
                                value={sectionDrafts[entry.grade] || ""}
                                onChange={(event) => handleSectionDraftChange(entry.grade, event.target.value)}
                                onKeyDown={(event) => {
                                  if (event.key === "Enter") {
                                    event.preventDefault();
                                    handleAddSection(entry.grade);
                                  }
                                }}
                              />
                              <Button
                                variant="outlined"
                                startIcon={<Add />}
                                onClick={() => handleAddSection(entry.grade)}
                                disabled={!((sectionDrafts[entry.grade] || "").trim())}
                              >
                                Add Section
                              </Button>
                            </Stack>
                            </Paper>
                          );
                        })}
                      </Stack>
                    )}
                  </Stack>
                </CardContent>
              </Card>
            </Grid>
            <Grid item xs={12}>
              <Box display="flex" justifyContent="flex-end">
                <Typography
                  variant="body2"
                  sx={{ color: userAttributesAutoSaveColor, textAlign: "right" }}
                >
                  {userAttributesAutoSaveMessage}
                </Typography>
              </Box>
            </Grid>
          </Grid>
        </TabPanel>

        <TabPanel value={currentTab} index={5}>
          <Card elevation={1}>
            <CardHeader
              title="Book Categories"
              subheader="Organize titles by keeping categories up to date"
            />
            <CardContent>
              <Grid container spacing={2}>
                <Grid item xs={12} md={6}>
                  <TextField
                    fullWidth
                    size="small"
                    label="New Category"
                    value={newCategory}
                    onChange={(e) => setNewCategory(e.target.value)}
                    onKeyDown={(e) => {
                      if (e.key === "Enter") {
                        handleAddCategory();
                      }
                    }}
                  />
                </Grid>
                <Grid item xs={12} md={6} display="flex" alignItems="center">
                  <Button
                    variant="contained"
                    startIcon={<Add />}
                    onClick={handleAddCategory}
                    disabled={!newCategory.trim() || loading}
                  >
                    Add Category
                  </Button>
                </Grid>
                <Grid item xs={12}>
                  {categories.length === 0 ? (
                    <Typography color="text.secondary">
                      No categories yet. Add your first category to improve search.
                    </Typography>
                  ) : (
                    <List>
                      {categories.map((category, index) => {
                        const displayName = resolveCategoryName(category);
                        const fallbackKey = `${displayName || "category"}-${index}`;
                        const categoryKey = resolveCategoryKey(category, fallbackKey);
                        const deleteTarget = resolveCategoryDeleteTarget(category);

                        return (
                          <ListItem
                            key={categoryKey}
                            divider
                            secondaryAction={
                              deleteTarget ? (
                                <IconButton
                                  edge="end"
                                  color="error"
                                  onClick={() => handleDeleteCategory(deleteTarget)}
                                >
                                  <Delete />
                                </IconButton>
                              ) : undefined
                            }
                          >
                            <ListItemText
                              primary={displayName || "Unnamed Category"}
                              secondary={
                                deleteTarget
                                  ? undefined
                                  : "Synced from existing book records"
                              }
                            />
                          </ListItem>
                        );
                      })}
                    </List>
                  )}
                </Grid>
              </Grid>
            </CardContent>
          </Card>
        </TabPanel>
      </Paper>
    </Box>
  );
};

export default SettingsPage;
```

## StaffDashboard.js

| Field | Details |
| --- | --- |
| Program Name | StaffDashboard.js |
| Description | Frontend page view for routing and page-level UI. |
| Called by | App.js |
| Table used | None |
|  |  |
| Programmer | Nazel Asca√±o |
| Date created | 12/14/2025 |
| Revision Date | TBD |
| Revision / description of change | None |

```javascript
import React from "react";
import LibrarianDashboard from "./LibrarianDashboard";

const StaffDashboard = () => {
  return <LibrarianDashboard showVisitorCard={false} dashboardTitle="Staff Dashboard" />;
};

export default StaffDashboard;
```

## StudentDashboard.js

| Field | Details |
| --- | --- |
| Program Name | StudentDashboard.js |
| Description | Frontend page view for routing and page-level UI. |
| Called by | App.js |
| Table used | None |
|  |  |
| Programmer | Nazel Asca√±o |
| Date created | 12/14/2025 |
| Revision Date | TBD |
| Revision / description of change | None |

```javascript
import React, { useCallback, useEffect, useMemo, useState } from "react";
import { Box, Typography, Paper, Table, TableBody, TableCell, TableContainer, TableHead, TableRow, Chip, Grid, Card, CardContent, Button, Avatar, Stack, Divider, IconButton } from "@mui/material";
import { School, Email, Phone, Badge, Close, MenuBook, History, PendingActions } from "@mui/icons-material";
import toast from "react-hot-toast";
import { api, authAPI, transactionsAPI } from "../../utils/api";
import { useAuth } from "../../contexts/AuthContext";
import { useSettings } from "../../contexts/SettingsContext";
import { useNavigate } from "react-router-dom";
import { resolveEntityAvatar } from "../../utils/media";

const ACTIVE_TRANSACTION_STATUSES = new Set([
  "borrowed",
  "active",
  "missing",
  "lost",
  "damaged",
  "overdue",
  "released",
]);

const REQUEST_TRANSACTION_STATUSES = new Set([
  "requested",
  "pending",
  "reservation-expired",
  "queued",
  "processing",
  "awaiting-approval",
]);

const normalizeStatusValue = (status) => {
  if (!status) return "pending";
  return String(status).trim().toLowerCase();
};

const formatStatValue = (value) => {
  if (value === null || value === undefined) {
    return "0";
  }

  if (typeof value === "number") {
    return new Intl.NumberFormat("en-US").format(value);
  }

  const numericValue = Number(value);
  if (!Number.isNaN(numericValue)) {
    return new Intl.NumberFormat("en-US").format(numericValue);
  }

  return String(value);
};

const StatCard = ({ title, value, caption, icon: Icon, iconColor = "#2563EB", iconBg = "rgba(37, 99, 235, 0.12)" }) => {
  const displayValue = formatStatValue(value);

  return (
    <Card
      sx={{
        borderRadius: 3,
        border: "1px solid",
        borderColor: "divider",
        boxShadow: "0 14px 30px rgba(15, 23, 42, 0.12)",
        height: "100%",
        backgroundColor: "#fff",
      }}
    >
      <CardContent sx={{ p: 2.5, display: "flex", flexDirection: "column", gap: 1.5 }}>
        <Box display="flex" alignItems="flex-start" justifyContent="space-between" gap={1.5}>
          <Box>
            <Typography
              variant="caption"
              sx={{
                color: "text.secondary",
                letterSpacing: "0.08em",
                fontWeight: 600,
                textTransform: "uppercase",
              }}
            >
              {title}
            </Typography>
            <Typography variant="h4" sx={{ fontWeight: 700, color: "#0F172A", mt: 0.75 }}>
              {displayValue}
            </Typography>
          </Box>
          {Icon ? (
            <Box
              sx={{
                width: 48,
                height: 48,
                borderRadius: 2,
                backgroundColor: iconBg,
                color: iconColor,
                display: "flex",
                alignItems: "center",
                justifyContent: "center",
              }}
            >
              <Icon fontSize="small" />
            </Box>
          ) : null}
        </Box>
        {caption ? (
          <Typography variant="body2" sx={{ color: "text.secondary", fontSize: "0.8rem" }}>
            {caption}
          </Typography>
        ) : null}
      </CardContent>
    </Card>
  );
};

const SectionCard = ({ title, subtitle, children }) => (
  <Paper
    sx={{
      p: { xs: 2, md: 3 },
      borderRadius: 3,
      border: "1px solid",
      borderColor: "divider",
      backgroundColor: "#fff",
      boxShadow: "0 18px 45px rgba(15, 23, 42, 0.12)",
    }}
  >
    <Box mb={2}>
      {subtitle ? (
        <Typography
          variant="caption"
          sx={{
            color: "text.secondary",
            letterSpacing: "0.08em",
            fontWeight: 600,
            textTransform: "uppercase",
          }}
        >
          {subtitle}
        </Typography>
      ) : null}
      <Typography variant="h6" sx={{ color: "#0F172A", fontWeight: 700 }}>
        {title}
      </Typography>
    </Box>
    <Divider sx={{ mb: 2 }} />
    {children}
  </Paper>
);

const StudentDashboard = () => {
  const { user, updateUserData } = useAuth();
  const { finesEnabled } = useSettings();
  const [transactions, setTransactions] = useState([]);
  const [loading, setLoading] = useState(false);
  const [cancelingId, setCancelingId] = useState(null);
  const [showWelcomeCard, setShowWelcomeCard] = useState(() => {
    const dismissed = Boolean(user?.preferences?.studentDashboard?.welcomeDismissed);
    return !dismissed;
  });
  const navigate = useNavigate();
  const studentAvatarSrc = useMemo(() => resolveEntityAvatar(user), [user]);
  const studentDisplayName = useMemo(() => {
    if (!user) return "Student";
    const fallback = user.username || "Student";
    const fullName = `${user.firstName || ""} ${user.lastName || ""}`.trim();
    return fullName || fallback;
  }, [user]);
  const studentInitial = (studentDisplayName.charAt(0) || "U").toUpperCase();
  const userIdentifier = useMemo(() => {
    return (
      user?.id ||
      user?._id ||
      user?.userId ||
      user?.libraryCardNumber ||
      ""
    );
  }, [user]);

  const resolveTransactionId = useCallback((tx) => {
    if (!tx) return "";
    return tx.id || tx._id || tx.transactionId || tx.documentId || "";
  }, []);

  const normalizeStatus = useCallback((status) => normalizeStatusValue(status), []);

  const isBorrowedStatus = useCallback(
    (status) => ACTIVE_TRANSACTION_STATUSES.has(normalizeStatus(status)),
    [normalizeStatus],
  );

  const isPendingRequestStatus = useCallback(
    (status) => REQUEST_TRANSACTION_STATUSES.has(normalizeStatus(status)),
    [normalizeStatus],
  );

  useEffect(() => {
    const dismissed = Boolean(user?.preferences?.studentDashboard?.welcomeDismissed);
    setShowWelcomeCard(!dismissed);

    const fetchUserTransactions = async () => {
      if (!userIdentifier) return;
      try {
        setLoading(true);
        const encodedId = encodeURIComponent(userIdentifier);
        const resp = await api.get(`/transactions/user/${encodedId}`);
        const txs = Array.isArray(resp.data) ? resp.data : resp.data?.transactions || [];
        setTransactions(txs);
      } catch (err) {
        console.error("Failed to load user transactions", err);
        setTransactions([]);
      } finally {
        setLoading(false);
      }
    };

    fetchUserTransactions();
  }, [user, userIdentifier]);

  const handleDismissWelcomeCard = async () => {
    setShowWelcomeCard(false);
    try {
      await authAPI.updatePreferences({
        studentDashboard: { welcomeDismissed: true },
      });
      updateUserData((previous) => {
        const base = previous && typeof previous === "object" ? previous : {};
        const existingPreferences =
          base.preferences && typeof base.preferences === "object"
            ? base.preferences
            : {};
        const updatedPreferences = {
          ...existingPreferences,
          studentDashboard: {
            ...(existingPreferences.studentDashboard || {}),
            welcomeDismissed: true,
          },
        };

        return {
          ...base,
          preferences: updatedPreferences,
        };
      });
    } catch (error) {
      console.error("Failed to persist welcome preference", error);
    }
  };

  const currentBorrows = useMemo(
    () => transactions.filter((t) => isBorrowedStatus(t.status)),
    [transactions, isBorrowedStatus],
  );

  const requests = useMemo(
    () => transactions.filter((t) => isPendingRequestStatus(t.status)),
    [transactions, isPendingRequestStatus],
  );

  const overdue = useMemo(() => {
    return transactions.filter((t) => {
      try {
        if (!t.dueDate) return false;
        const due = new Date(t.dueDate);
        return isBorrowedStatus(t.status) && due < new Date();
      } catch (error) {
        return false;
      }
    });
  }, [transactions, isBorrowedStatus]);

  const totalBorrowed = useMemo(() => transactions.length, [transactions]);

  const currentlyBorrowed = useMemo(() => currentBorrows.length, [currentBorrows]);

  const pendingRequestsCount = requests.length;
  const pendingCardLabel = finesEnabled ? "Pending / Overdue" : "Pending Requests";
  const pendingDisplayValue = finesEnabled
    ? pendingRequestsCount + overdue.length
    : pendingRequestsCount;

  const statCards = useMemo(
    () => [
      {
        title: "Total Borrowed",
        value: totalBorrowed,
        caption: "Lifetime checkouts",
        icon: MenuBook,
        iconColor: "#A855F7",
        iconBg: "rgba(168, 85, 247, 0.16)",
      },
      {
        title: "Currently Borrowed",
        value: currentlyBorrowed,
        caption: "Books in hand",
        icon: History,
        iconColor: "#2563EB",
        iconBg: "rgba(37, 99, 235, 0.12)",
      },
      {
        title: pendingCardLabel,
        value: pendingDisplayValue,
        caption: finesEnabled ? "Requests + overdue" : "Awaiting approval",
        icon: PendingActions,
        iconColor: "#F97316",
        iconBg: "rgba(249, 115, 22, 0.16)",
      },
    ],
    [totalBorrowed, currentlyBorrowed, pendingDisplayValue, pendingCardLabel, finesEnabled],
  );

  const handleCancelRequest = async (transactionId) => {
    if (!transactionId) return;
    const confirmed = window.confirm("Are you sure you want to cancel this request?");
    if (!confirmed) return;

    try {
      setCancelingId(transactionId);
      const response = await transactionsAPI.cancelRequest(transactionId);
      toast.success(response?.data?.message || "Request cancelled");
      setTransactions((prev) =>
        prev.map((entry) => {
          const entryId = resolveTransactionId(entry);
          if (entryId !== transactionId) {
            return entry;
          }
          const updated = response?.data?.transaction;
          if (updated) {
            return updated;
          }
          return {
            ...entry,
            status: "cancelled",
            cancelledAt: new Date().toISOString(),
          };
        }),
      );
    } catch (error) {
      console.error("Failed to cancel request", error);
      toast.error(error?.response?.data?.message || "Failed to cancel request");
    } finally {
      setCancelingId(null);
    }
  };

  return (
    <Box sx={{ display: "flex", flexDirection: "column", gap: 3 }}>
      <Typography variant="h1" sx={{ fontSize: "1.5rem", fontWeight: 600, color: "white" }}>
        Student Dashboard
      </Typography>
      {showWelcomeCard ? (
        <Paper sx={{ p: 3, position: "relative", borderRadius: 3, boxShadow: 4 }}>
          <IconButton
            size="small"
            aria-label="Dismiss welcome message"
            onClick={handleDismissWelcomeCard}
            sx={{ position: "absolute", top: 12, right: 12 }}
          >
            <Close fontSize="small" />
          </IconButton>
          <Typography variant="h6">Welcome to your library portal!</Typography>
          <Typography variant="body1" color="text.secondary" sx={{ mt: 1 }}>
            View your borrowed books, due dates, and borrowing history.
            <br />Request borrowing of books easily.
          </Typography>
        </Paper>
      ) : null}

      <Paper
        sx={{
          p: { xs: 2.5, sm: 3 },
          borderRadius: 3,
          border: '1px solid',
          borderColor: 'divider',
          boxShadow: 6,
          backgroundColor: '#fff',
        }}
      >
        <Grid container spacing={3} alignItems="center">
          <Grid item xs={12} md={4} lg={3}>
            <Box display="flex" alignItems="center" gap={2}>
              <Avatar
                src={studentAvatarSrc || undefined}
                alt={studentDisplayName}
                sx={{ width: 80, height: 80, bgcolor: 'primary.main', color: 'primary.contrastText', fontSize: 34 }}
              >
                {studentInitial}
              </Avatar>
              <Box>
                <Typography variant="overline" color="text.secondary" sx={{ letterSpacing: 1 }}>
                  Student
                </Typography>
                <Typography variant="h5" sx={{ fontWeight: 600 }}>
                  {studentDisplayName}
                </Typography>
                <Stack direction="row" spacing={1} mt={1} flexWrap="wrap" useFlexGap>
                  {user?.curriculum && <Chip size="small" color="primary" variant="outlined" label={`Curriculum: ${user.curriculum}`} />}
                  {(user?.grade || user?.section) && (
                    <Chip
                      size="small"
                      color="primary"
                      variant="outlined"
                      label={`Grade ${user?.grade || '‚Äî'}${user?.section ? ` ‚Ä¢ ${user.section}` : ''}`}
                    />
                  )}
                  {user?.libraryCardNumber && (
                    <Chip size="small" variant="outlined" color="secondary" label={`Library ID ${user.libraryCardNumber}`} />
                  )}
                </Stack>
              </Box>
            </Box>
          </Grid>

          <Grid item xs={12} md={4} lg={4}>
            <Stack spacing={1.25}>
              <Box>
                <Typography variant="caption" color="text.secondary" sx={{ display: 'block', mb: 0.5 }}>
                  Student ID
                </Typography>
                <Box display="flex" alignItems="center" gap={1.25}>
                  <Badge fontSize="small" color="action" />
                  <Typography variant="body1" fontWeight={600}>
                    {user ? (user.studentId || '‚Äî') : '‚Äî'}
                  </Typography>
                </Box>
              </Box>

              <Divider flexItem sx={{ borderStyle: 'dashed', borderColor: 'divider' }} />

              <Box>
                <Typography variant="caption" color="text.secondary" sx={{ display: 'block', mb: 0.5 }}>
                  Contact Information
                </Typography>
                <Stack spacing={0.5}>
                  <Box display="flex" alignItems="center" gap={1.25}>
                    <Email fontSize="small" color="action" />
                    <Typography variant="body2" color="text.secondary" sx={{ wordBreak: 'break-word' }}>
                      {user?.email || '‚Äî'}
                    </Typography>
                  </Box>
                  <Box display="flex" alignItems="center" gap={1.25}>
                    <Phone fontSize="small" color="action" />
                    <Typography variant="body2" color="text.secondary">
                      {user?.phoneNumber || user?.profile?.phone || '‚Äî'}
                    </Typography>
                  </Box>
                </Stack>
              </Box>
            </Stack>
          </Grid>

          <Grid item xs={12} md={4} lg={5}>
            <Box
              sx={{
                px: { xs: 2, sm: 3 },
                py: { xs: 2, sm: 2.5 },
                borderRadius: 2,
                backgroundColor: (theme) =>
                  theme.palette.mode === 'dark'
                    ? 'rgba(25, 118, 210, 0.15)'
                    : 'rgba(25, 118, 210, 0.08)',
              }}
            >
              <Stack direction={{ xs: 'column', sm: 'row' }} spacing={{ xs: 1.5, sm: 3 }} divider={<Divider orientation="vertical" flexItem sx={{ display: { xs: 'none', sm: 'block' }, borderStyle: 'dashed', borderColor: 'primary.light' }} />}>
                <Box>
                  <Typography variant="caption" color="primary.main" sx={{ display: 'flex', alignItems: 'center', gap: 0.5 }}>
                    <School fontSize="inherit" /> Borrowed Items
                  </Typography>
                  <Typography variant="h6" sx={{ mt: 0.5, fontWeight: 700 }}>
                    {currentlyBorrowed || 0}
                  </Typography>
                </Box>
                <Box>
                  <Typography variant="caption" color="primary.main" sx={{ display: 'flex', alignItems: 'center', gap: 0.5 }}>
                    Pending Requests
                  </Typography>
                  <Typography variant="h6" sx={{ mt: 0.5, fontWeight: 700 }}>
                    {pendingRequestsCount}
                  </Typography>
                </Box>
                {finesEnabled ? (
                  <Box>
                    <Typography variant="caption" color="primary.main" sx={{ display: 'flex', alignItems: 'center', gap: 0.5 }}>
                      Overdue Items
                    </Typography>
                    <Typography variant="h6" sx={{ mt: 0.5, fontWeight: 700 }} color={overdue.length > 0 ? 'error.main' : 'text.primary'}>
                      {overdue.length}
                    </Typography>
                  </Box>
                ) : null}
              </Stack>
            </Box>
          </Grid>
        </Grid>
      </Paper>

      <Grid container spacing={2}>
        <Grid item xs={12} lg={8}>
          <Grid container spacing={2}>
            {statCards.map((card) => (
              <Grid item xs={12} sm={6} md={4} key={card.title}>
                <StatCard {...card} />
              </Grid>
            ))}
          </Grid>
        </Grid>
        <Grid item xs={12} lg={4}>
          <Card
            sx={{
              height: '100%',
              borderRadius: 3,
              border: '1px solid',
              borderColor: 'divider',
              boxShadow: '0 14px 30px rgba(15, 23, 42, 0.12)',
            }}
          >
            <CardContent sx={{ p: 2.5 }}>
              <Typography
                variant="caption"
                sx={{
                  color: 'text.secondary',
                  letterSpacing: '0.08em',
                  fontWeight: 600,
                  textTransform: 'uppercase',
                }}
              >
                Quick Actions
              </Typography>
              <Typography variant="h6" sx={{ color: '#0F172A', fontWeight: 700, mt: 0.5 }}>
                Stay productive
              </Typography>
              <Box mt={2} display="flex" flexDirection={{ xs: 'column', sm: 'row' }} gap={1}>
                <Button variant="contained" color="primary" onClick={() => navigate('/transactions/request')} sx={{ flex: 1, width: '100%' }}>
                  Request Borrow
                </Button>
                <Button variant="outlined" onClick={() => navigate('/books')} sx={{ flex: 1, width: '100%' }}>
                  Browse Books
                </Button>
              </Box>
            </CardContent>
          </Card>
        </Grid>
      </Grid>

      <SectionCard title="Current Borrows" subtitle="Items you currently have checked out">
        <TableContainer sx={{ width: '100%', overflowX: 'auto' }}>
          <Table size="small">
            <TableHead>
              <TableRow>
                <TableCell>Transaction ID</TableCell>
                <TableCell>Book</TableCell>
                <TableCell>Borrow Date</TableCell>
                <TableCell>Due Date</TableCell>
                <TableCell>Status</TableCell>
              </TableRow>
            </TableHead>
            <TableBody>
              {currentBorrows.length === 0 ? (
                <TableRow>
                  <TableCell colSpan={5} align="center">
                    {loading ? 'Loading...' : 'No current borrows'}
                  </TableCell>
                </TableRow>
              ) : (
                currentBorrows.map((tx) => (
                  <TableRow key={tx.id || tx._id || tx.transactionId}>
                    <TableCell>{tx.id || tx.transactionId || tx._id}</TableCell>
                    <TableCell>
                      {(tx.items && tx.items[0])
                        ? (tx.items[0].title || tx.items[0].bookTitle || tx.items[0].bookId)
                        : (tx.bookTitle || '')}
                    </TableCell>
                    <TableCell>{tx.borrowDate ? new Date(tx.borrowDate).toLocaleDateString() : ''}</TableCell>
                    <TableCell>{tx.dueDate ? new Date(tx.dueDate).toLocaleDateString() : ''}</TableCell>
                    <TableCell>
                      <Chip label={String(tx.status).toUpperCase()} size="small" />
                    </TableCell>
                  </TableRow>
                ))
              )}
            </TableBody>
          </Table>
        </TableContainer>
      </SectionCard>

      <SectionCard title="Pending Requests" subtitle="Awaiting librarian review">
        <TableContainer sx={{ width: '100%', overflowX: 'auto' }}>
          <Table size="small">
            <TableHead>
              <TableRow>
                <TableCell>Request ID</TableCell>
                <TableCell>Items</TableCell>
                <TableCell>Created</TableCell>
                <TableCell>Status</TableCell>
                <TableCell align="right">Action</TableCell>
              </TableRow>
            </TableHead>
            <TableBody>
              {requests.length === 0 ? (
                <TableRow>
                  <TableCell colSpan={5} align="center">
                    No pending requests
                  </TableCell>
                </TableRow>
              ) : (
                requests.map((tx) => {
                  const transactionId = resolveTransactionId(tx);
                  return (
                    <TableRow key={transactionId}>
                      <TableCell>{transactionId}</TableCell>
                      <TableCell>{(tx.items || []).length}</TableCell>
                      <TableCell>{tx.createdAt ? new Date(tx.createdAt).toLocaleString() : ''}</TableCell>
                      <TableCell>
                        <Chip label={String(tx.status).toUpperCase()} size="small" />
                      </TableCell>
                      <TableCell align="right">
                        <Button
                          variant="outlined"
                          color="error"
                          size="small"
                          onClick={() => handleCancelRequest(transactionId)}
                          disabled={cancelingId === transactionId}
                        >
                          {cancelingId === transactionId ? 'Cancelling...' : 'Cancel Request'}
                        </Button>
                      </TableCell>
                    </TableRow>
                  );
                })
              )}
            </TableBody>
          </Table>
        </TableContainer>
      </SectionCard>
    </Box>
  );
};

export default StudentDashboard;
```

## StudentForm.js

| Field | Details |
| --- | --- |
| Program Name | StudentForm.js |
| Description | Frontend page view for routing and page-level UI. |
| Called by | App.js |
| Table used | None |
|  |  |
| Programmer | Nazel Asca√±o |
| Date created | 12/14/2025 |
| Revision Date | TBD |
| Revision / description of change | None |

```javascript
import React, { useEffect, useMemo, useState } from "react";
import { useNavigate, useParams, useLocation } from "react-router-dom";
import {
  Box,
  Typography,
  Grid,
  TextField,
  Button,
  MenuItem,
  Card,
  CardContent,
  Alert,
  IconButton,
  InputAdornment,
  Divider,
  Autocomplete,
} from "@mui/material";
import {
  Save,
  Cancel,
  Person,
  Email,
  Phone,
  School,
  ArrowBack,
} from "@mui/icons-material";
import { useAuth } from "../../contexts/AuthContext";
import { api, studentsAPI, settingsAPI } from "../../utils/api";
import {
  ensureUserAttributes,
  getSectionsForGrade,
  collectAllSections,
  buildGradeColorMap,
} from "../../utils/userAttributes";
import { generateLibraryCard, downloadPDF } from "../../utils/pdfGenerator";
import toast from "react-hot-toast";
import {
  getProvinces,
  getMunicipalities,
  getBarangays,
} from "../../utils/addressService";

const PHONE_FIELD_NAMES = new Set(["phoneNumber", "parentPhone"]);
const LRN_MAX_LENGTH = 12;

const sanitizePhoneInput = (value = "") =>
  String(value ?? "").replace(/\D/g, "").slice(0, 11);

const sanitizeLrnInput = (value = "") =>
  String(value ?? "")
    .replace(/\D/g, "")
    .slice(0, LRN_MAX_LENGTH);

const StudentForm = () => {
  const navigate = useNavigate();
  const { id } = useParams();
  const location = useLocation();
  const { hasPermission } = useAuth();
  const isEditing = Boolean(id);
  const canCreateStudents = hasPermission("students.create");
  const canEditStudents = hasPermission("students.update");
  const canAccessForm = isEditing ? canEditStudents : canCreateStudents;

  const [formData, setFormData] = useState({

    libraryCardNumber: "",

    firstName: "",
    lastName: "",
    middleName: "",
    email: "",
    phoneNumber: "",

    lrn: "", // Learner Reference Number
  grade: "",
  section: "",
  curriculum: "",

    streetAddress: "",
    barangay: "",
    barangayCode: "",
    municipality: "",
    municipalityCode: "",
    province: "",
    provinceCode: "",
    fullAddress: "",

    parentGuardianName: "",
    parentOccupation: "",
    parentAddress: "",
    parentPhone: "",
    parentEmail: "",

    isActive: true,
  });

  const [loading, setLoading] = useState(false);
  const [error, setError] = useState("");
  const [success, setSuccess] = useState("");
  const [validationErrors, setValidationErrors] = useState({});
  const [nextLibraryCard, setNextLibraryCard] = useState("");
  const [userAttributes, setUserAttributes] = useState(() =>
    ensureUserAttributes(),
  );
  const [attributeError, setAttributeError] = useState("");

  const gradeOptions = userAttributes.gradeLevels;
  const gradeStructure = useMemo(
    () => userAttributes.gradeStructure || [],
    [userAttributes.gradeStructure],
  );
  const gradeColorMap = useMemo(
    () => buildGradeColorMap(gradeStructure),
    [gradeStructure],
  );
  const curriculumOptions = userAttributes.curriculum;
  const hasGradeOptions = gradeOptions.length > 0;
  const hasCurriculumOptions = curriculumOptions.length > 0;
  const allSectionOptions = useMemo(
    () => collectAllSections(gradeStructure),
    [gradeStructure],
  );
  const sectionOptions = useMemo(() => {
    const gradeSpecific = getSectionsForGrade(gradeStructure, formData.grade);
    if (gradeSpecific.length > 0) {
      return gradeSpecific;
    }
    return allSectionOptions;
  }, [gradeStructure, formData.grade, allSectionOptions]);
  const hasSectionOptions = sectionOptions.length > 0;
  const [provinceOptions, setProvinceOptions] = useState([]);
  const [municipalityOptions, setMunicipalityOptions] = useState([]);
  const [barangayOptions, setBarangayOptions] = useState([]);
  const [addressLoading, setAddressLoading] = useState({
    provinces: false,
    municipalities: false,
    barangays: false,
  });
  const [addressError, setAddressError] = useState("");

  const selectedProvinceOption = useMemo(
    () =>
      provinceOptions.find((option) => option.code === formData.provinceCode) ||
      null,
    [provinceOptions, formData.provinceCode],
  );

  const selectedMunicipalityOption = useMemo(
    () =>
      municipalityOptions.find(
        (option) => option.code === formData.municipalityCode,
      ) || null,
    [municipalityOptions, formData.municipalityCode],
  );

  const selectedBarangayOption = useMemo(
    () =>
      barangayOptions.find((option) => option.code === formData.barangayCode) ||
      null,
    [barangayOptions, formData.barangayCode],
  );

  const composeFullAddress = ({ street, barangay, municipality, province }) =>
    [street, barangay, municipality, province].filter(Boolean).join(", ");

  useEffect(() => {
    if (isEditing) {
      fetchStudent();
    } else {
      fetchNextLibraryCard();

      setFormData((prev) => ({
        ...prev,
        libraryCardNumber: nextLibraryCard,
      }));
    }

  }, [id, isEditing, nextLibraryCard]);

  useEffect(() => {
    let isMounted = true;

    const loadAttributes = async () => {
      try {
        const response = await settingsAPI.getUserAttributes();
        if (isMounted) {
          setUserAttributes(ensureUserAttributes(response.data));
          setAttributeError("");
        }
      } catch (attributesError) {
        console.error("Failed to load user attribute options:", attributesError);
        if (isMounted) {
          setUserAttributes(ensureUserAttributes());
          setAttributeError(
            "Failed to load curriculum and grade options. Using defaults.",
          );
        }
      }
    };

    loadAttributes();

    return () => {
      isMounted = false;
    };
  }, []);

  useEffect(() => {
    setFormData((prev) => {
      const updates = {};

      if (
        prev.grade &&
        gradeOptions.length > 0 &&
        !gradeOptions.includes(prev.grade)
      ) {
        updates.grade = "";
      }

      if (
        prev.curriculum &&
        curriculumOptions.length > 0 &&
        !curriculumOptions.includes(prev.curriculum)
      ) {
        updates.curriculum = "";
      }

      const activeGrade =
        updates.grade !== undefined ? updates.grade : prev.grade;
      const gradeSpecificSections = getSectionsForGrade(
        gradeStructure,
        activeGrade,
      );
      const allowedSections =
        gradeSpecificSections.length > 0
          ? gradeSpecificSections
          : allSectionOptions;
      if (
        prev.section &&
        allowedSections.length > 0 &&
        !allowedSections.includes(prev.section)
      ) {
        updates.section = "";
      }

      return Object.keys(updates).length > 0 ? { ...prev, ...updates } : prev;
    });
  }, [gradeOptions, curriculumOptions, gradeStructure, allSectionOptions]);

  useEffect(() => {
    let isMounted = true;
    const loadProvinces = async () => {
      setAddressLoading((prev) => ({ ...prev, provinces: true }));
      setAddressError("");
      try {
        const provinces = await getProvinces();
        if (isMounted) {
          setProvinceOptions(provinces);
        }
      } catch (error) {
        console.error("Failed to load provinces:", error);
        if (isMounted) {
          setAddressError("Unable to load provinces from PSGC.");
        }
      } finally {
        if (isMounted) {
          setAddressLoading((prev) => ({ ...prev, provinces: false }));
        }
      }
    };

    loadProvinces();
    return () => {
      isMounted = false;
    };
  }, []);

  useEffect(() => {
    if (!formData.provinceCode) {
      setMunicipalityOptions([]);
      return;
    }

    let isMounted = true;
    setAddressLoading((prev) => ({ ...prev, municipalities: true }));
    const loadMunicipalities = async () => {
      try {
        const municipalities = await getMunicipalities(formData.provinceCode);
        if (isMounted) {
          setMunicipalityOptions(municipalities);
        }
      } catch (error) {
        console.error("Failed to load municipalities:", error);
        if (isMounted) {
          setAddressError("Unable to load municipalities for the province.");
        }
      } finally {
        if (isMounted) {
          setAddressLoading((prev) => ({ ...prev, municipalities: false }));
        }
      }
    };

    loadMunicipalities();
    return () => {
      isMounted = false;
    };
  }, [formData.provinceCode]);

  useEffect(() => {
    if (!formData.municipalityCode) {
      setBarangayOptions([]);
      return;
    }

    let isMounted = true;
    setAddressLoading((prev) => ({ ...prev, barangays: true }));
    const loadBarangays = async () => {
      try {
        const barangays = await getBarangays(formData.municipalityCode);
        if (isMounted) {
          setBarangayOptions(barangays);
        }
      } catch (error) {
        console.error("Failed to load barangays:", error);
        if (isMounted) {
          setAddressError("Unable to load barangays for the municipality.");
        }
      } finally {
        if (isMounted) {
          setAddressLoading((prev) => ({ ...prev, barangays: false }));
        }
      }
    };

    loadBarangays();
    return () => {
      isMounted = false;
    };
  }, [formData.municipalityCode]);

  const fetchNextLibraryCard = async () => {
    try {
      const response = await api.get("/students/next-library-card");
      setNextLibraryCard(response.data.nextCardNumber);
    } catch (error) {
      console.error("Failed to fetch next library card number:", error);

      setNextLibraryCard("LIB-25-XXXX");
    }
  };

  const fetchStudent = async () => {
    try {
      const response = await studentsAPI.getById(id);
      const studentData = response.data.student || response.data;

      setFormData({
        libraryCardNumber: studentData.libraryCardNumber || "",
        firstName: studentData.firstName || "",
        lastName: studentData.lastName || "",
        middleName: studentData.middleName || "",
        email: studentData.email || "",
  phoneNumber: sanitizePhoneInput(studentData.phoneNumber),
        lrn: sanitizeLrnInput(studentData.lrn),
  grade: studentData.grade || "",
  section: studentData.section || "",
  curriculum: studentData.curriculum || "",
        streetAddress:
          studentData.streetAddress ||
          studentData.street ||
          studentData.address ||
          "",
        barangay: studentData.barangay || "",
        barangayCode: studentData.barangayCode || "",
        municipality: studentData.municipality || "",
        municipalityCode: studentData.municipalityCode || "",
        province: studentData.province || "",
        provinceCode: studentData.provinceCode || "",
        fullAddress: studentData.fullAddress || "",
        parentGuardianName: studentData.parentGuardianName || "",
        parentOccupation: studentData.parentOccupation || "",
        parentAddress: studentData.parentAddress || "",
  parentPhone: sanitizePhoneInput(studentData.parentPhone),
        parentEmail: studentData.parentEmail || "",
        isActive:
          studentData.isActive !== undefined ? studentData.isActive : true,
      });
    } catch (error) {
      console.error("Failed to fetch student:", error);
      toast.error("Failed to load student data");

      navigate(location.state?.from || "/students");
    }
  };

  const handleChange = (e) => {
    const { name, value, type, checked } = e.target;
    const isCheckbox = type === "checkbox";
    let sanitizedValue = value;

    if (!isCheckbox) {
      if (PHONE_FIELD_NAMES.has(name)) {
        sanitizedValue = sanitizePhoneInput(value);
      } else if (name === "lrn") {
        sanitizedValue = sanitizeLrnInput(value);
      }
    }

    const nextValue = isCheckbox ? checked : sanitizedValue;

    setFormData((prev) => {
      if (name === "grade" && prev.grade !== nextValue) {
        return {
          ...prev,
          grade: nextValue,
          section: "",
        };
      }
      return {
        ...prev,
        [name]: nextValue,
      };
    });

    if (validationErrors[name]) {
      setValidationErrors((prev) => ({
        ...prev,
        [name]: "",
      }));
    }
  };

  const resetMunicipalityFields = () => ({
    municipality: "",
    municipalityCode: "",
    barangay: "",
    barangayCode: "",
  });

  const resetBarangayFields = () => ({
    barangay: "",
    barangayCode: "",
  });

  const handleProvinceSelect = (_, option) => {
    if (!option) {
      setFormData((prev) => ({
        ...prev,
        province: "",
        provinceCode: "",
        ...resetMunicipalityFields(),
      }));
      return;
    }

    setFormData((prev) => ({
      ...prev,
      province: option.name,
      provinceCode: option.code,
      ...resetMunicipalityFields(),
    }));
  };

  const handleProvinceInput = (_, value, reason) => {
    if (reason === "input") {
      setFormData((prev) => ({
        ...prev,
        province: value,
        provinceCode: "",
        ...resetMunicipalityFields(),
      }));
    }
    if (reason === "clear") {
      setFormData((prev) => ({
        ...prev,
        province: "",
        provinceCode: "",
        ...resetMunicipalityFields(),
      }));
    }
  };

  const handleMunicipalitySelect = (_, option) => {
    if (!option) {
      setFormData((prev) => ({
        ...prev,
        municipality: "",
        municipalityCode: "",
        ...resetBarangayFields(),
      }));
      return;
    }

    setFormData((prev) => ({
      ...prev,
      municipality: option.name,
      municipalityCode: option.code,
      ...resetBarangayFields(),
    }));
  };

  const handleMunicipalityInput = (_, value, reason) => {
    if (reason === "input") {
      setFormData((prev) => ({
        ...prev,
        municipality: value,
        municipalityCode: "",
        ...resetBarangayFields(),
      }));
    }
    if (reason === "clear") {
      setFormData((prev) => ({
        ...prev,
        municipality: "",
        municipalityCode: "",
        ...resetBarangayFields(),
      }));
    }
  };

  const handleBarangaySelect = (_, option) => {
    if (!option) {
      setFormData((prev) => ({
        ...prev,
        barangay: "",
        barangayCode: "",
      }));
      return;
    }

    setFormData((prev) => ({
      ...prev,
      barangay: option.name,
      barangayCode: option.code,
    }));
  };

  const handleBarangayInput = (_, value, reason) => {
    if (reason === "input") {
      setFormData((prev) => ({
        ...prev,
        barangay: value,
        barangayCode: "",
      }));
    }
    if (reason === "clear") {
      setFormData((prev) => ({
        ...prev,
        barangay: "",
        barangayCode: "",
      }));
    }
  };

  useEffect(() => {
    if (
      !formData.province ||
      formData.provinceCode ||
      provinceOptions.length === 0
    ) {
      return;
    }
    const match = provinceOptions.find(
      (option) => option.name.toLowerCase() === formData.province.toLowerCase(),
    );
    if (match) {
      setFormData((prev) => ({
        ...prev,
        provinceCode: match.code,
      }));
    }
  }, [formData.province, formData.provinceCode, provinceOptions]);

  useEffect(() => {
    if (
      !formData.municipality ||
      formData.municipalityCode ||
      municipalityOptions.length === 0
    ) {
      return;
    }
    const match = municipalityOptions.find(
      (option) => option.name.toLowerCase() === formData.municipality.toLowerCase(),
    );
    if (match) {
      setFormData((prev) => ({
        ...prev,
        municipalityCode: match.code,
      }));
    }
  }, [
    formData.municipality,
    formData.municipalityCode,
    municipalityOptions,
  ]);

  useEffect(() => {
    if (!formData.barangay || formData.barangayCode || barangayOptions.length === 0) {
      return;
    }
    const match = barangayOptions.find(
      (option) => option.name.toLowerCase() === formData.barangay.toLowerCase(),
    );
    if (match) {
      setFormData((prev) => ({
        ...prev,
        barangayCode: match.code,
      }));
    }
  }, [formData.barangay, formData.barangayCode, barangayOptions]);

  const validateForm = () => {
    const errors = {};

    if (!formData.firstName.trim()) errors.firstName = "First name is required";
    if (!formData.lastName.trim()) errors.lastName = "Last name is required";
    const normalizedLrn = formData.lrn.trim();
    if (!normalizedLrn)
      errors.lrn = "LRN (Learner Reference Number) is required";
    else if (!/^\d{12}$/.test(normalizedLrn)) {
      errors.lrn = "LRN must be exactly 12 digits";
    }
    if (!formData.grade) errors.grade = "Grade is required";
    if (!formData.section) errors.section = "Section is required";
    const validationSections = (() => {
      const gradeSpecific = getSectionsForGrade(gradeStructure, formData.grade);
      return gradeSpecific.length > 0 ? gradeSpecific : allSectionOptions;
    })();
    if (
      formData.section &&
      validationSections.length > 0 &&
      !validationSections.includes(formData.section)
    ) {
      errors.section = "Section must match the configured list";
    }

    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (formData.email && !emailRegex.test(formData.email)) {
      errors.email = "Please enter a valid email address";
    }

    if (formData.parentEmail && !emailRegex.test(formData.parentEmail)) {
      errors.parentEmail = "Please enter a valid parent email address";
    }

    setValidationErrors(errors);
    return Object.keys(errors).length === 0;
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    setError("");
    setSuccess("");

    if (!validateForm()) {
      setError("Please fix the validation errors below");
      return;
    }

    try {
      setLoading(true);

      const studentData = {
        ...formData,
        role: "student",
        username: (formData.lrn || "").toString().trim(),
      };

      studentData.phoneNumber = sanitizePhoneInput(studentData.phoneNumber);
      studentData.parentPhone = sanitizePhoneInput(studentData.parentPhone);

      if (isEditing) {
        await studentsAPI.update(id, studentData);
        toast.success("Student updated successfully");
        setTimeout(() => {

          navigate(location.state?.from || "/students", { state: { refresh: true } });
        }, 1000);
      } else {
        const response = await studentsAPI.create(studentData);
        toast.success("Student created successfully");

        try {

          const libraryResponse = await settingsAPI.getByCategory('library');
          const librarySettings = libraryResponse.data || {};

          const libraryCardPDF = await generateLibraryCard(
            response.data.student || studentData,
            librarySettings,
            { gradeColorMap },
          );
          downloadPDF(libraryCardPDF, `library_card_${studentData.libraryCardNumber}.pdf`);
          toast.success("Library card generated and downloaded");
        } catch (cardError) {
          console.error("Error generating library card:", cardError);
          toast.error("Student created but failed to generate library card");
        }

        setTimeout(() => {

          navigate(location.state?.from || "/students", { state: { refresh: true } });
        }, 1000);
      }
    } catch (error) {
      setError(error.response?.data?.message || "Failed to save student");
      console.error("Error saving student:", error);
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    setFormData((prev) => {
      const combinedAddress = composeFullAddress({
        street: prev.streetAddress,
        barangay: prev.barangay,
        municipality: prev.municipality,
        province: prev.province,
      });
      if (combinedAddress === (prev.fullAddress || "")) {
        return prev;
      }
      return {
        ...prev,
        fullAddress: combinedAddress,
      };
    });
  }, [formData.streetAddress, formData.barangay, formData.municipality, formData.province]);

  if (!canAccessForm) {
    return (
      <Box>
        <Alert severity="error">
          {isEditing
            ? "Access denied. You don't have permission to edit student records."
            : "Access denied. You don't have permission to create student records."}
        </Alert>
      </Box>
    );
  }

  return (
    <Box>
      <Box display="flex" alignItems="center" mb={3}>
        <IconButton onClick={() => {

          if (location.state?.from) navigate(location.state.from);
          else navigate(-1);
        }} sx={{ mr: 2 }}>
          <ArrowBack />
        </IconButton>{" "}
        <Typography
          variant="h4"
          component="h1"
          sx={{ fontWeight: 600, color: "white" }}
        >
          {" "}
          {isEditing ? "Edit Student" : "Add New Student"}{" "}
        </Typography>{" "}
      </Box>
      {error && (
        <Box sx={{ mb: 3 }}>
          <div role="alert" aria-live="assertive">{error}</div>
        </Box>
      )}
      {success && (
        <Alert severity="success" sx={{ mb: 3 }}>
          {" "}
          {success}{" "}
        </Alert>
      )}
      {attributeError && (
        <Alert severity="warning" sx={{ mb: 3 }}>
          {attributeError}
        </Alert>
      )}
      {addressError && (
        <Alert severity="warning" sx={{ mb: 3 }}>
          {addressError}
        </Alert>
      )}
      <form onSubmit={handleSubmit}>
        <Grid container spacing={3}>
          {" "}
          {}{" "}
          <Grid item xs={12}>
            <Card>
              <CardContent>
                <Box display="flex" alignItems="center" mb={3}>
                  <School sx={{ mr: 1, color: "primary.main" }} />{" "}
                  <Typography variant="h6" fontWeight="medium">
                    Academic Information{" "}
                  </Typography>{" "}
                </Box>
                <Grid container spacing={2}>
                  {" "}
                  {}{" "}
                  <Grid item xs={12}>
                    {" "}
                    {isEditing ? (
                      <Alert severity="info" sx={{ mb: 1 }}>
                        <Typography variant="body2" sx={{ mb: 0.5 }}>
                          Library Card Number:
                        </Typography>{" "}
                        <Typography
                          variant="h6"
                          sx={{
                            fontFamily: "monospace",
                            fontWeight: "bold",
                            color: "#0288d1",
                            letterSpacing: "1px",
                          }}
                        >
                          {formData.libraryCardNumber || "Not assigned"}{" "}
                        </Typography>{" "}
                      </Alert>
                    ) : (
                      <Alert severity="success" sx={{ mb: 1 }}>
                        <Typography variant="body2" sx={{ mb: 0.5 }}>
                          The following Library Card Number will be assigned:
                        </Typography>{" "}
                        <Typography
                          variant="h6"
                          sx={{
                            fontFamily: "monospace",
                            fontWeight: "bold",
                            color: "#2e7d32",
                            letterSpacing: "1px",
                          }}
                        >
                          {nextLibraryCard || "Loading..."}{" "}
                        </Typography>{" "}
                      </Alert>
                    )}{" "}
                  </Grid>
                  {}{" " }
                  <Grid item xs={12} sm={6}>
                    <TextField
                      fullWidth
                      label="LRN (Learner Reference Number)"
                      name="lrn"
                      value={formData.lrn}
                      onChange={handleChange}
                      error={!!validationErrors.lrn}
                      helperText={
                        validationErrors.lrn ||""
                      }
                      required
                    />
                  </Grid>{" "}
                  <Grid item xs={12} sm={6}>
                    {hasCurriculumOptions ? (
                      <TextField
                        select
                        fullWidth
                        label="Curriculum"
                        name="curriculum"
                        value={formData.curriculum}
                        onChange={handleChange}
                        error={!!validationErrors.curriculum}
                        helperText={validationErrors.curriculum}
                      >
                        {curriculumOptions.map((curriculum) => (
                          <MenuItem key={curriculum} value={curriculum}>
                            {curriculum}
                          </MenuItem>
                        ))}
                      </TextField>
                    ) : (
                      <TextField
                        fullWidth
                        label="Curriculum"
                        name="curriculum"
                        value={formData.curriculum}
                        onChange={handleChange}
                        error={!!validationErrors.curriculum}
                        helperText={validationErrors.curriculum}
                        placeholder="Enter curriculum"
                      />
                    )}
                  </Grid>
                  {}{" " }
                  <Grid item xs={12} sm={6}>
                      {hasGradeOptions ? (
                        <TextField
                          fullWidth
                          label="Grade"
                          name="grade"
                          select
                          value={formData.grade}
                          onChange={handleChange}
                          error={!!validationErrors.grade}
                          helperText={validationErrors.grade}
                          required
                        >
                          {gradeOptions.map((grade) => (
                            <MenuItem key={grade} value={grade}>
                              {grade}
                            </MenuItem>
                          ))}
                        </TextField>
                      ) : (
                        <TextField
                          fullWidth
                          label="Grade"
                          name="grade"
                          value={formData.grade}
                          onChange={handleChange}
                          error={!!validationErrors.grade}
                          helperText={validationErrors.grade}
                          placeholder="Enter grade"
                          required
                        />
                      )}
                  </Grid>
                  <Grid item xs={12} sm={6}>
                    <TextField
                      fullWidth
                      select
                      label="Section"
                      name="section"
                      value={formData.section}
                      onChange={handleChange}
                      error={!!validationErrors.section}
                      helperText={
                        validationErrors.section ||
                        (hasSectionOptions
                          ? ""
                          : "No sections configured in settings")
                      }
                      required
                      disabled={!hasSectionOptions}
                    >
                      {hasSectionOptions ? (
                        sectionOptions.map((section) => (
                          <MenuItem key={section} value={section}>
                            {section}
                          </MenuItem>
                        ))
                      ) : (
                        <MenuItem value="" disabled>
                          No sections available
                        </MenuItem>
                      )}
                    </TextField>{" " }
                  </Grid>{" " }
                </Grid>{" "}
              </CardContent>{" "}
            </Card>{" "}
          </Grid>
          {}{" "}
          <Grid item xs={12}>
            <Card>
              <CardContent>
                <Box display="flex" alignItems="center" mb={3}>
                  <Person sx={{ mr: 1, color: "primary.main" }} />{" "}
                  <Typography variant="h6" fontWeight="medium">
                    Student Information{" "}
                  </Typography>{" "}
                </Box>
                <Grid container spacing={2}>
                  {" "}
                  {}{" "}
                  <Grid item xs={12}>
                    <Divider sx={{ my: 1 }}>
                      <Typography variant="subtitle2" color="textSecondary">
                        Name{" "}
                      </Typography>{" "}
                    </Divider>{" "}
                  </Grid>
                  <Grid item xs={12} sm={4}>
                    <TextField
                      fullWidth
                      label="Family Name"
                      name="lastName"
                      value={formData.lastName}
                      onChange={handleChange}
                      error={!!validationErrors.lastName}
                      helperText={validationErrors.lastName}
                      required
                    />
                  </Grid>{" "}
                  <Grid item xs={12} sm={4}>
                    <TextField
                      fullWidth
                      label="First Name"
                      name="firstName"
                      value={formData.firstName}
                      onChange={handleChange}
                      error={!!validationErrors.firstName}
                      helperText={validationErrors.firstName}
                      required
                    />
                  </Grid>{" "}
                  <Grid item xs={12} sm={4}>
                    <TextField
                      fullWidth
                      label="Middle Name"
                      name="middleName"
                      value={formData.middleName}
                      onChange={handleChange}
                    />{" "}
                  </Grid>
                  {}{" "}
                  <Grid item xs={12} sm={6}>
                    <TextField
                      fullWidth
                      label="Email"
                      name="email"
                      type="email"
                      value={formData.email}
                      onChange={handleChange}
                      error={!!validationErrors.email}
                      helperText={validationErrors.email}
                      InputProps={{
                        startAdornment: (
                          <InputAdornment position="start">
                            <Email />
                          </InputAdornment>
                        ),
                      }}
                    />{" "}
                  </Grid>{" "}
                  <Grid item xs={12} sm={6}>
                    <TextField
                      fullWidth
                      label="Phone"
                      name="phoneNumber"
                      value={formData.phoneNumber}
                      onChange={handleChange}
                      inputProps={{ inputMode: "numeric", pattern: "[0-9]*", maxLength: 11 }}
                      InputProps={{
                        startAdornment: (
                          <InputAdornment position="start">
                            <Phone />
                          </InputAdornment>
                        ),
                      }}
                    />{" "}
                  </Grid>
                  {}{" "}
                  <Grid item xs={12}>
                    <Divider sx={{ my: 2 }}>
                      <Typography variant="subtitle2" color="textSecondary">
                        Address{" "}
                      </Typography>{" "}
                    </Divider>{" "}
                  </Grid>
                  <Grid item xs={12} sm={4}>
                    <Autocomplete
                      freeSolo
                      loading={addressLoading.provinces}
                      options={provinceOptions}
                      getOptionLabel={(option) =>
                        typeof option === "string" ? option : option.name
                      }
                      value={selectedProvinceOption}
                      inputValue={formData.province}
                      onChange={handleProvinceSelect}
                      onInputChange={handleProvinceInput}
                      loadingText="Loading provinces..."
                      renderInput={(params) => (
                        <TextField
                          {...params}
                          label="Province"
                          placeholder="Select or type province"
                        />
                      )}
                    />{" "}
                  </Grid>{" "}
                  <Grid item xs={12} sm={4}>
                    <Autocomplete
                      freeSolo
                      loading={addressLoading.municipalities}
                      options={municipalityOptions}
                      getOptionLabel={(option) =>
                        typeof option === "string" ? option : option.name
                      }
                      value={selectedMunicipalityOption}
                      inputValue={formData.municipality}
                      onChange={handleMunicipalitySelect}
                      onInputChange={handleMunicipalityInput}
                      loadingText="Loading municipalities..."
                      renderInput={(params) => (
                        <TextField
                          {...params}
                          label="Municipality"
                          placeholder="Select or type municipality"
                        />
                      )}
                    />{" "}
                  </Grid>{" "}
                  <Grid item xs={12} sm={4}>
                    <Autocomplete
                      freeSolo
                      loading={addressLoading.barangays}
                      options={barangayOptions}
                      getOptionLabel={(option) =>
                        typeof option === "string" ? option : option.name
                      }
                      value={selectedBarangayOption}
                      inputValue={formData.barangay}
                      onChange={handleBarangaySelect}
                      onInputChange={handleBarangayInput}
                      loadingText="Loading barangays..."
                      renderInput={(params) => (
                        <TextField
                          {...params}
                          label="Barangay"
                          placeholder="Select or type barangay"
                        />
                      )}
                    />{" "}
                  </Grid>
                  <Grid item xs={12}>
                    <TextField
                      fullWidth
                      label="House No. / Street"
                      name="streetAddress"
                      value={formData.streetAddress}
                      onChange={handleChange}
                      placeholder="e.g., 123 Library Street"
                    />{" "}
                  </Grid>
                  {}{" "}
                  <Grid item xs={12}>
                    <Divider sx={{ my: 2 }}>
                      <Typography variant="subtitle2" color="textSecondary">
                        Parent / Guardian Information{" "}
                      </Typography>{" "}
                    </Divider>{" "}
                  </Grid>
                  <Grid item xs={12} sm={6}>
                    <TextField
                      fullWidth
                      label="Parent/Guardian Name"
                      name="parentGuardianName"
                      value={formData.parentGuardianName}
                      onChange={handleChange}
                    />{" "}
                  </Grid>{" "}
                  <Grid item xs={12} sm={6}>
                    <TextField
                      fullWidth
                      label="Phone Number"
                      name="parentPhone"
                      value={formData.parentPhone}
                      onChange={handleChange}
                      inputProps={{ inputMode: "numeric", pattern: "[0-9]*", maxLength: 11 }}
                      InputProps={{
                        startAdornment: (
                          <InputAdornment position="start">
                            <Phone />
                          </InputAdornment>
                        ),
                      }}
                    />{" "}
                  </Grid>{" "}
                </Grid>{" "}
              </CardContent>{" "}
            </Card>{" "}
          </Grid>
          {}{" "}
          <Grid item xs={12}>
            <Box display="flex" gap={2} justifyContent="flex-end">
              <Button
                variant="outlined"
                onClick={() => {
                  if (location.state?.from) navigate(location.state.from);
                  else navigate(-1);
                }}
                startIcon={<Cancel />}
                disabled={loading}
              >
                Cancel{" "}
              </Button>{" "}
              <Button
                type="submit"
                variant="contained"
                startIcon={<Save />}
                disabled={loading}
                sx={{
                  backgroundColor:'#0f5132',
                  color:'#fff',
                  '&:hover':{backgroundColor:'#0c3f28'},
                }}
              >
                {loading
                  ? "Saving..."
                  : isEditing
                    ? "Update Student"
                    : "Create Student"}{" "}
              </Button>{" "}
            </Box>{" "}
          </Grid>{" "}
        </Grid>{" "}
      </form>{" "}
    </Box>
  );
};

export default StudentForm;
```

## StudentImportDialog.js

| Field | Details |
| --- | --- |
| Program Name | StudentImportDialog.js |
| Description | Frontend page view for routing and page-level UI. |
| Called by | StudentsList.js |
| Table used | None |
|  |  |
| Programmer | Nazel Asca√±o |
| Date created | 12/14/2025 |
| Revision Date | TBD |
| Revision / description of change | None |

```javascript
import React, { useState, useEffect, useMemo, useCallback } from "react";
import {
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  Button,
  Box,
  Typography,
  Paper,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  Alert,
  LinearProgress,
  Chip,
  IconButton,
  FormControlLabel,
  Checkbox,
} from "@mui/material";
import { CloudUpload, GetApp, Check, Error, Close } from "@mui/icons-material";
import toast from "react-hot-toast";
import { studentsAPI, settingsAPI } from "../../utils/api";
import {
  ensureUserAttributes,
  getSectionsForGrade,
  collectAllSections,
  buildGradeColorMap,
} from "../../utils/userAttributes";
import { downloadPDF } from "../../utils/pdfGenerator";

const sanitizeLibraryCardNumber = (value = "") =>
  value.toString().trim().toUpperCase();

const normalizeLibraryCardNumber = (value = "") =>
  sanitizeLibraryCardNumber(value).replace(/[^A-Z0-9]/g, "");

const isValidLibraryCardNumber = (value = "") => {
  if (!value) {
    return true;
  }
  return /^[A-Z0-9-]{4,30}$/.test(sanitizeLibraryCardNumber(value));
};

const StudentImportDialog = ({ open, onClose, onImportComplete }) => {
  const [file, setFile] = useState(null);
  const [csvData, setCsvData] = useState([]);
  const [importing, setImporting] = useState(false);
  const [importResults, setImportResults] = useState(null);
  const [step, setStep] = useState(1); // 1: Upload, 2: Preview, 3: Results
  const [existingStudents, setExistingStudents] = useState([]);
  const [importSuccessful, setImportSuccessful] = useState(false);
  const [userAttributes, setUserAttributes] = useState(() => ensureUserAttributes());
  const [attributeError, setAttributeError] = useState("");
  const [autoPrintCards, setAutoPrintCards] = useState(true);

  const gradeOptions = useMemo(
    () => (Array.isArray(userAttributes.gradeLevels) ? userAttributes.gradeLevels : []),
    [userAttributes.gradeLevels],
  );
  const gradeStructure = useMemo(
    () => (Array.isArray(userAttributes.gradeStructure) ? userAttributes.gradeStructure : []),
    [userAttributes.gradeStructure],
  );
  const gradeColorMap = useMemo(
    () => buildGradeColorMap(gradeStructure),
    [gradeStructure],
  );
  const allSectionOptions = useMemo(
    () => collectAllSections(gradeStructure),
    [gradeStructure],
  );
  const resolveSectionOptions = useCallback(
    (gradeName) => {
      const options = getSectionsForGrade(gradeStructure, gradeName);
      return options.length > 0 ? options : allSectionOptions;
    },
    [gradeStructure, allSectionOptions],
  );

  useEffect(() => {
    if (!open) {
      return;
    }

    let isMounted = true;

    const loadAttributes = async () => {
      try {
        const response = await settingsAPI.getUserAttributes();
        if (isMounted) {
          setUserAttributes(ensureUserAttributes(response.data));
          setAttributeError("");
        }
      } catch (error) {
        console.error("Failed to load user attribute options:", error);
        if (isMounted) {
          setUserAttributes(ensureUserAttributes());
          setAttributeError("Failed to load curriculum and grade options. Using defaults.");
        }
      }
    };

    loadAttributes();

    return () => {
      isMounted = false;
    };
  }, [open]);

  const handleFileUpload = async (event) => {
    const uploadedFile = event.target.files?.[0];
    if (!uploadedFile) {
      return;
    }

    const isCSV =
      uploadedFile.type === "text/csv" || uploadedFile.name.toLowerCase().endsWith(".csv");

    if (!isCSV) {
      toast.error("Please upload a valid CSV file");
      return;
    }

    setFile(uploadedFile);

    try {
      const existingStudentsResponse = await studentsAPI.getAll();
      setExistingStudents(existingStudentsResponse.data.students || []);

      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          const text = e.target.result;
          const rows = text.split(/\r?\n/).filter((row) => row.trim());

          if (rows.length <= 1) {
            toast.error("CSV file does not contain student rows");
            return;
          }

          const headers = rows[0]
            .split(",")
            .map((header) => header.trim().replace(/^"|"$/g, ""));

          const data = rows.slice(1).map((row, index) => {
            const values = row
              .split(",")
              .map((value) => value.trim().replace(/^"|"$/g, ""));
            const student = {};
            headers.forEach((header, i) => {
              const key = header.toLowerCase().replace(/\s+/g, "");
              student[key] = values[i] || "";
            });
            student.rowIndex = index + 2; // account for header row
            return student;
          });

          setCsvData(data);
          setStep(2);
        } catch (parseError) {
          console.error("Failed to parse CSV:", parseError);
          toast.error("Failed to parse CSV file");
        }
      };
      reader.onerror = () => toast.error("Failed to read CSV file");
      reader.readAsText(uploadedFile);
    } catch (error) {
      console.error("Error loading data:", error);
      toast.error("Failed to load student data");
    }
  };

  const downloadTemplate = () => {
    const sampleGradePrimary = gradeOptions[0] || "Grade 9";
    const sampleGradeSecondary = gradeOptions[1] || gradeOptions[0] || "Grade 10";
    const primarySections = resolveSectionOptions(sampleGradePrimary);
    const secondarySections = resolveSectionOptions(sampleGradeSecondary);
    const sampleSectionPrimary = primarySections[0] || "A";
    const sampleSectionSecondary =
      secondarySections[0] || primarySections[1] || sampleSectionPrimary || "B";

    const template = `firstName,lastName,middleName,email,phoneNumber,libraryCardNumber,lrn,grade,section,barangay,municipality,province,fullAddress,parentGuardianName,parentPhone
John,Doe,Santos,john.doe@student.example.edu,09123456789,LIB-25-0101,123456789012,${sampleGradePrimary},${sampleSectionPrimary},Barangay 1,Quezon City,Metro Manila,"123 Main St Barangay 1 Quezon City",Jane Doe,09987654321
Mary,Smith,Cruz,mary.smith@student.example.edu,09111222333,,123456789013,${sampleGradeSecondary},${sampleSectionSecondary},Barangay 2,Manila,Metro Manila,"789 Pine St Barangay 2 Manila",Bob Smith,09444555666`;

    const blob = new Blob([template], { type: "text/csv" });
    const url = window.URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.style.display = "none";
    a.href = url;
    a.download = "student_import_template.csv";
    document.body.appendChild(a);
    a.click();
    window.URL.revokeObjectURL(url);
    document.body.removeChild(a);
  };

  const validateStudentData = (student, existingList = []) => {
    const errors = [];

    const firstName = (student.firstname || student.firstName || "").trim();
    const lastName = (student.lastname || student.lastName || "").trim();
    const normalizedLRN = (student.lrn || "").trim();
    const rawLibraryCard = (student.librarycardnumber || student.libraryCardNumber || "").trim();
    const cleanedLibraryCard = sanitizeLibraryCardNumber(rawLibraryCard);
    const normalizedLibraryCard = normalizeLibraryCardNumber(cleanedLibraryCard);
    const normalizedGrade = (student.grade || "").trim();
    const normalizedSection = (student.section || "").trim();

    if (!firstName) errors.push("First name required");
    if (!lastName) errors.push("Last name required");
    if (!normalizedLRN) errors.push("LRN required");
    if (!normalizedGrade) errors.push("Grade required");
    if (!normalizedSection) errors.push("Section required");

    if (student.email) {
      const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
      if (!emailRegex.test(student.email.trim())) {
        errors.push("Invalid email format");
      }
    }

    if (normalizedLRN && !/^\d{12}$/.test(normalizedLRN)) {
      errors.push("Invalid LRN (must be 12 digits)");
    }

    if (
      normalizedLRN &&
      existingList.some((s) => ((s.lrn || s.username || "").trim()) === normalizedLRN)
    ) {
      errors.push("LRN already exists in system");
    }

    if (rawLibraryCard && !isValidLibraryCardNumber(rawLibraryCard)) {
      errors.push("Invalid library card number");
    }

    if (
      normalizedLibraryCard &&
      existingList.some(
        (s) =>
          normalizeLibraryCardNumber(s.libraryCardNumber || s.library?.cardNumber || "") ===
          normalizedLibraryCard,
      )
    ) {
      errors.push("Library card number already exists in system");
    }

    if (
      normalizedGrade &&
      gradeOptions.length > 0 &&
      !gradeOptions.some((grade) => grade.toLowerCase() === normalizedGrade.toLowerCase())
    ) {
      errors.push("Invalid grade (must match the configured list)");
    }

    const allowedSections = resolveSectionOptions(normalizedGrade);
    if (
      normalizedSection &&
      allowedSections.length > 0 &&
      !allowedSections.some((section) => section.toLowerCase() === normalizedSection.toLowerCase())
    ) {
      errors.push("Invalid section for the selected grade");
    }

    return errors;
  };

  const handleImport = async () => {
    setImporting(true);

    const csvLRNs = new Set();
    const csvLibraryCards = new Set();
    const validStudents = [];
    const invalidStudents = [];

    try {
      csvData.forEach((student) => {
        const errors = validateStudentData(student, existingStudents);
        const normalizedLRN = (student.lrn || "").trim();
        const cleanedLibraryCard = sanitizeLibraryCardNumber(
          student.librarycardnumber || student.libraryCardNumber || "",
        );
        const normalizedCard = normalizeLibraryCardNumber(cleanedLibraryCard);

        if (normalizedLRN && csvLRNs.has(normalizedLRN)) {
          errors.push("Duplicate LRN in CSV file");
        }
        if (normalizedCard && csvLibraryCards.has(normalizedCard)) {
          errors.push("Duplicate library card number in CSV file");
        }

        if (errors.length === 0) {
          if (normalizedLRN) csvLRNs.add(normalizedLRN);
          if (normalizedCard) csvLibraryCards.add(normalizedCard);

          validStudents.push({
            firstName: student.firstname || student.firstName,
            lastName: student.lastname || student.lastName,
            middleName: student.middlename || student.middleName || "",
            email: student.email,
            phoneNumber: student.phonenumber || student.phoneNumber || "",
            lrn: normalizedLRN,
            grade: student.grade,
            section: student.section,
            libraryCardNumber: cleanedLibraryCard || undefined,
            barangay: student.barangay || "",
            municipality: student.municipality || "",
            province: student.province || "",
            fullAddress: student.fulladdress || student.fullAddress || "",
            parentGuardianName:
              student.parentguardianname ||
              student.parentGuardianName ||
              student.parentname ||
              student.parentName ||
              "",
            parentPhone: student.parentphone || student.parentPhone || "",
            username: normalizedLRN,
            rowIndex: student.rowIndex,
          });
        } else {
          invalidStudents.push({
            ...student,
            errors,
          });
        }
      });

      if (validStudents.length === 0) {
        toast.error("No valid students found in the import file");
        setImporting(false);
        return;
      }

      const response = await studentsAPI.bulkImport(validStudents);

      setImportResults({
        success: response.data.results.success,
        errors: response.data.results.errors,
        details: response.data.results.details,
        invalidStudents,
      });

      setStep(3);

      if (response.data.results?.success > 0) {
        toast.success(`Successfully imported ${response.data.results.success} students`);
        setImportSuccessful(true);
      }

      if (response.data.results?.errors > 0) {
        toast.error(`${response.data.results.errors} students failed to import`);
      }
    } catch (error) {
      console.error("Import error:", error);
      const responseMessage = error?.response?.data?.message;
      const responseErrors = error?.response?.data?.errors;
      const missingRows = error?.response?.data?.missing;
      const responseDetails = error?.response?.data?.results?.details;

      if (Array.isArray(responseDetails) && responseDetails.length > 0) {
        setImportResults({
          success: responseDetails.filter((detail) => detail.status === "success").length,
          errors: responseDetails.filter((detail) => detail.status !== "success").length,
          details: responseDetails,
          invalidStudents,
        });
        setStep(3);
        toast.error(
          responseMessage || "Bulk import failed. Review the details for row-specific errors.",
          { duration: 6000 },
        );
        return;
      }

      if (Array.isArray(responseErrors) && responseErrors.length > 0) {
        console.warn("Import validation errors:", responseErrors);
        const summarized = responseErrors
          .slice(0, 5)
          .map((entry) => {
            const rowNumber = entry.rowIndex
              ? entry.rowIndex
              : typeof entry.idx === "number"
              ? entry.idx + 2
              : "?";
            const issues = Array.isArray(entry.issues)
              ? entry.issues
              : Array.isArray(entry.errors)
              ? entry.errors
              : [entry.error || "Unknown validation issue"];
            return `Row ${rowNumber}: ${issues.join(", ")}`;
          })
          .join("\n");

        toast.error(
          responseMessage ? `${responseMessage}\n${summarized}` : `Bulk import failed:\n${summarized}`,
          { duration: 8000 },
        );
        return;
      }

      if (Array.isArray(missingRows) && missingRows.length > 0) {
        const summarized = missingRows
          .slice(0, 5)
          .map((entry) => {
            const rowNumber = entry.rowIndex
              ? entry.rowIndex
              : typeof entry.idx === "number"
              ? entry.idx + 2
              : "?";
            const cardRef = entry.libraryCardNumber ? ` (Library Card ${entry.libraryCardNumber})` : "";
            return `Row ${rowNumber}${cardRef}: Missing LRN`;
          })
          .join("\n");

        toast.error(
          responseMessage ? `${responseMessage}\n${summarized}` : `Bulk import failed:\n${summarized}`,
          { duration: 8000 },
        );
        return;
      }

      toast.error(responseMessage || "Failed to import students");
    } finally {
      setImporting(false);
    }
  };

  const handleClose = async () => {
    const wasSuccessful = importSuccessful;
    const shouldAutoPrint = autoPrintCards;
    const successfulStudents = importResults?.details?.filter((detail) => detail.status === "success") || [];

    setFile(null);
    setCsvData([]);
    setImportResults(null);
    setStep(1);
    setExistingStudents([]);
    setImportSuccessful(false);
    setAttributeError("");
    setAutoPrintCards(true);

    if (wasSuccessful && successfulStudents.length > 0 && shouldAutoPrint) {
      const loadingId = toast.loading("Generating library cards for imported students...");
      try {
        const allStudentsResponse = await studentsAPI.getAll();
        const allStudents = allStudentsResponse.data.students || [];

        const importedStudents = allStudents.filter((student) => {
          const studentCard = normalizeLibraryCardNumber(
            student.libraryCardNumber || student.library?.cardNumber || "",
          );
          const studentLRN = (student.lrn || "").trim();

          const matched = successfulStudents.some((success) => {
            const successCard = normalizeLibraryCardNumber(
              success.libraryCardNumber || success.librarycardnumber || "",
            );
            const successLRN = (success.lrn || "").trim();
            return (
              (successCard && studentCard && successCard === studentCard) ||
              (successLRN && studentLRN && successLRN === studentLRN)
            );
          });

          return matched && !!student.libraryCardNumber;
        });

        if (importedStudents.length > 0) {
          try {
            const pdfModule = await import(
               "../../utils/pdfGenerator"
            );
            const libraryResponse = await settingsAPI.getByCategory('library');
            const librarySettings = libraryResponse.data || {};
            const multiPDF = await pdfModule.generateLibraryCardsPDF(
              importedStudents,
              librarySettings,
              { gradeColorMap },
            );
            const filename = `library_cards_import_${Date.now()}.pdf`;
            downloadPDF(multiPDF, filename);
            toast.dismiss(loadingId);
            toast.success(`Generated ${importedStudents.length} library cards successfully!`);
          } catch (pdfError) {
            console.error("Failed to generate combined library cards PDF:", pdfError);
            toast.dismiss(loadingId);
            toast.error("Failed to generate library cards");
          }
        } else {
          toast.dismiss(loadingId);
          toast.error("No imported students with assigned library card numbers found");
        }
      } catch (error) {
        console.error("Error generating library cards after import:", error);
        toast.dismiss(loadingId);
        toast.error("Failed to generate library cards");
      }
    }

    onClose();

    if (wasSuccessful && onImportComplete) {
      onImportComplete();
    }
  };

  const renderUploadStep = () => (
    <Box>
      <Alert severity="info" sx={{ mb: 3 }}>
        <Typography variant="body2">
          Upload a CSV file with student data. Download the template below to see the required format.
        </Typography>
      </Alert>
      {gradeOptions.length > 0 && (
        <Typography variant="body2" color="text.secondary" sx={{ mb: 2 }}>
          Available grade levels: {gradeOptions.join(", ")}
        </Typography>
      )}
      <Box display="flex" gap={2} mb={3}>
        <Button variant="outlined" startIcon={<GetApp />} onClick={downloadTemplate}>
          Download Template
        </Button>
      </Box>
      <label htmlFor="csv-file-input" style={{ display: "block", cursor: "pointer" }}>
        <Paper
          role="button"
          tabIndex={0}
          sx={{
            border: "2px dashed #ccc",
            borderRadius: 2,
            p: 4,
            textAlign: "center",
            cursor: "pointer",
            "&:hover": { borderColor: "#22C55E" },
          }}
        >
          <CloudUpload aria-hidden="true" sx={{ fontSize: 48, color: "#666", mb: 2 }} />
          <Typography variant="h6" gutterBottom>
            Click or press Enter to upload CSV file
          </Typography>
          <Typography variant="body2" color="text.secondary">
            Supported format: CSV files only
          </Typography>
        </Paper>
      </label>
      <input
        id="csv-file-input"
        type="file"
        accept=".csv"
        aria-label="Upload students CSV"
        style={{ display: "none" }}
        onChange={handleFileUpload}
      />
      {file && (
        <Box mt={2}>
          <Typography variant="body2">
            Selected file: <strong>{file.name}</strong>
          </Typography>
        </Box>
      )}
    </Box>
  );

  const renderPreviewStep = () => {
    const csvLRNs = new Set();
    const csvLibraryCards = new Set();
    const duplicateLRNs = new Set();
    const duplicateCards = new Set();

    csvData.forEach((student) => {
      const normalizedLRN = (student.lrn || "").trim();
      const normalizedCard = normalizeLibraryCardNumber(
        student.librarycardnumber || student.libraryCardNumber || "",
      );

      if (normalizedLRN) {
        if (csvLRNs.has(normalizedLRN)) {
          duplicateLRNs.add(normalizedLRN);
        } else {
          csvLRNs.add(normalizedLRN);
        }
      }

      if (normalizedCard) {
        if (csvLibraryCards.has(normalizedCard)) {
          duplicateCards.add(normalizedCard);
        } else {
          csvLibraryCards.add(normalizedCard);
        }
      }
    });

    return (
      <Box>
        <Alert severity="success" sx={{ mb: 3 }}>
          <Typography variant="body2">
            Found {csvData.length} students in the CSV file. Review the data below and click Import to proceed.
          </Typography>
        </Alert>

        <Box sx={{ mb: 3, p: 2, bgcolor: "background.paper", borderRadius: 1 }}>
          <FormControlLabel
            control={
              <Checkbox
                checked={autoPrintCards}
                onChange={(e) => setAutoPrintCards(e.target.checked)}
                color="primary"
              />
            }
            label="Automatically generate and download library cards for imported students"
          />
          <Typography variant="caption" color="text.secondary" sx={{ ml: 4, display: "block" }}>
            PDFs will download automatically after a successful import
          </Typography>
        </Box>

        <TableContainer component={Paper} sx={{ maxHeight: 400 }}>
          <Table stickyHeader>
            <TableHead>
              <TableRow>
                <TableCell>Name</TableCell>
                <TableCell>Email</TableCell>
                <TableCell>Library Card</TableCell>
                <TableCell>LRN</TableCell>
                <TableCell>Grade</TableCell>
                <TableCell>Section</TableCell>
                <TableCell>Status</TableCell>
                <TableCell>Issues</TableCell>
              </TableRow>
            </TableHead>
            <TableBody>
              {csvData.map((student, index) => {
                const errors = validateStudentData(student, existingStudents);
                const normalizedLRN = (student.lrn || "").trim();
                const normalizedCard = normalizeLibraryCardNumber(
                  student.librarycardnumber || student.libraryCardNumber || "",
                );

                if (normalizedLRN && duplicateLRNs.has(normalizedLRN)) {
                  errors.push("Duplicate LRN in CSV file");
                }
                if (normalizedCard && duplicateCards.has(normalizedCard)) {
                  errors.push("Duplicate library card number in CSV file");
                }

                const isValid = errors.length === 0;

                return (
                  <TableRow key={index}>
                    <TableCell>
                      {(student.firstname || student.firstName || "").trim()} {(
                        student.lastname || student.lastName || ""
                      ).trim()}
                    </TableCell>
                    <TableCell>{student.email}</TableCell>
                    <TableCell>
                      {student.librarycardnumber || student.libraryCardNumber || "(auto)"}
                    </TableCell>
                    <TableCell>{student.lrn}</TableCell>
                    <TableCell>{student.grade}</TableCell>
                    <TableCell>{student.section}</TableCell>
                    <TableCell>
                      <Chip
                        label={isValid ? "Valid" : "Invalid"}
                        color={isValid ? "success" : "error"}
                        size="small"
                        icon={isValid ? <Check /> : <Error />}
                      />
                    </TableCell>
                    <TableCell>
                      {errors.length === 0 ? (
                        <Typography variant="body2" color="text.secondary">
                          No issues detected
                        </Typography>
                      ) : (
                        <Box component="ul" sx={{ pl: 2, mb: 0 }}>
                          {errors.map((err, errIdx) => (
                            <Typography component="li" variant="body2" key={`err-${errIdx}`}>
                              {err}
                            </Typography>
                          ))}
                        </Box>
                      )}
                    </TableCell>
                  </TableRow>
                );
              })}
            </TableBody>
          </Table>
        </TableContainer>
      </Box>
    );
  };

  const renderResultsStep = () => (
    <Box>
      <Alert severity="info" sx={{ mb: 3 }}>
        <Typography variant="body2">
          Import completed! {importResults.success} students imported successfully, {importResults.errors} failed.
        </Typography>
      </Alert>
      {(importResults.details?.length > 0 || (importResults.invalidStudents?.length || 0) > 0) && (
        <TableContainer component={Paper} sx={{ maxHeight: 300 }}>
          <Table>
            <TableHead>
              <TableRow>
                <TableCell>Row</TableCell>
                <TableCell>Library Card</TableCell>
                <TableCell>LRN</TableCell>
                <TableCell>Status</TableCell>
                <TableCell>Message</TableCell>
              </TableRow>
            </TableHead>
            <TableBody>
              {(importResults.details || []).map((detail, index) => (
                <TableRow key={`result-${index}`}>
                  <TableCell>{detail.rowIndex ? `Row ${detail.rowIndex}` : "-"}</TableCell>
                  <TableCell>{detail.libraryCardNumber || "-"}</TableCell>
                  <TableCell>{detail.lrn || "-"}</TableCell>
                  <TableCell>
                    <Chip
                      label={detail.status === "success" ? "Success" : "Error"}
                      color={detail.status === "success" ? "success" : "error"}
                      size="small"
                    />
                  </TableCell>
                  <TableCell>
                    {(() => {
                      const issues = Array.isArray(detail.issues) && detail.issues.length > 0
                        ? detail.issues.join(", ")
                        : null;
                      return detail.message || issues || (detail.status === "success" ? "Imported successfully" : "No details provided");
                    })()}
                  </TableCell>
                </TableRow>
              ))}
              {(importResults.invalidStudents || []).map((student, index) => (
                <TableRow key={`invalid-${student.librarycardnumber || student.libraryCardNumber || index}`}>
                  <TableCell>{student.rowIndex ? `Row ${student.rowIndex}` : "-"}</TableCell>
                  <TableCell>{student.librarycardnumber || student.libraryCardNumber || "(auto)"}</TableCell>
                  <TableCell>{student.lrn || "-"}</TableCell>
                  <TableCell>
                    <Chip label="Invalid" color="error" size="small" />
                  </TableCell>
                  <TableCell>{Array.isArray(student.errors) ? student.errors.join(", ") : "Invalid data"}</TableCell>
                </TableRow>
              ))}
            </TableBody>
          </Table>
        </TableContainer>
      )}
    </Box>
  );

  return (
    <Dialog open={open} onClose={handleClose} maxWidth="md" fullWidth>
      <DialogTitle>
        <Box display="flex" justifyContent="space-between" alignItems="center">
          <Typography variant="h6">Import Students</Typography>
          <IconButton onClick={handleClose}>
            <Close />
          </IconButton>
        </Box>
      </DialogTitle>
      <DialogContent>
        {importing && <LinearProgress sx={{ mb: 2 }} />}
        {attributeError && (
          <Alert severity="warning" sx={{ mb: 2 }}>
            {attributeError}
          </Alert>
        )}
        {step === 1 && renderUploadStep()}
        {step === 2 && renderPreviewStep()}
        {step === 3 && importResults && renderResultsStep()}
      </DialogContent>
      <DialogActions>
        {step === 2 && (
          <>
            <Button onClick={() => setStep(1)}>Back</Button>
            <Button variant="contained" onClick={handleImport} disabled={importing || csvData.length === 0}>
              {importing ? "Importing..." : `Import ${csvData.length} Students`}
            </Button>
          </>
        )}
        {step === 3 && (
          <Button variant="contained" onClick={handleClose}>
            Done
          </Button>
        )}
      </DialogActions>
    </Dialog>
  );
};

export default StudentImportDialog;
```

## StudentsList.js

| Field | Details |
| --- | --- |
| Program Name | StudentsList.js |
| Description | Frontend page view for routing and page-level UI. |
| Called by | App.js |
| Table used | None |
|  |  |
| Programmer | Nazel Asca√±o |
| Date created | 12/14/2025 |
| Revision Date | TBD |
| Revision / description of change | None |

```javascript
import React, { useState, useEffect, useCallback, useMemo } from "react";
import {
  Box,
  Typography,
  Button,
  TextField,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  Paper,
  Chip,
  TablePagination,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  InputAdornment,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  Avatar,
  Alert,
  IconButton,
  Menu,
  ListItemIcon,
  CircularProgress,
  Popover,
} from "@mui/material";
import Autocomplete from "@mui/material/Autocomplete";
import {
  Search,
  PersonAdd,
  GetApp,
  Person,
  MoreVert,
  FilterList,
  Edit,
  Print,
  Delete as DeleteIcon,
  Payments,
} from "@mui/icons-material";
import { useNavigate, useLocation } from "react-router-dom";
import { studentsAPI, settingsAPI } from "../../utils/api";
import { resolveEntityAvatar } from "../../utils/media";
import toast from "react-hot-toast";
import StudentImportDialog from "./StudentImportDialog";
import {
  ensureUserAttributes,
  collectAllSections,
  getSectionsForGrade,
  buildGradeColorMap,
} from "../../utils/userAttributes";
import { PageLoading } from "../../components/Loading";
import { generateLibraryCard, generateLibraryCardsPDF, downloadPDF } from "../../utils/pdfGenerator";
import MobileScanButton from "../../components/MobileScanButton";
import MobileScanDialog from "../../components/MobileScanDialog";
import {
  addActionButtonSx,
  importActionButtonSx,
  printActionButtonSx,
} from "../../theme/actionButtons";
import { useSettings } from "../../contexts/SettingsContext";
import { useAuth } from "../../contexts/AuthContext";

const deriveDefaultSchoolYearLabel = () => {
  const now = new Date();
  const baseYear = now.getMonth() >= 5 ? now.getFullYear() : now.getFullYear() - 1;
  const endYear = baseYear + 1;
  return `${baseYear}-${endYear}`;
};

const StudentsList = () => {
  const navigate = useNavigate();
  const location = useLocation();
  const [students, setStudents] = useState([]);
  const [loading, setLoading] = useState(true);
  const [searchTerm, setSearchTerm] = useState("");
  const [gradeFilter, setGradeFilter] = useState("");
  const [sectionFilter, setSectionFilter] = useState("");
  const [totalStudents, setTotalStudents] = useState(0);
  const [debouncedSearchTerm, setDebouncedSearchTerm] = useState("");
  const [selectedStudent, setSelectedStudent] = useState(null);
  const [deleteDialogOpen, setDeleteDialogOpen] = useState(false);
  const [paymentDialogOpen, setPaymentDialogOpen] = useState(false);
  const [importDialogOpen, setImportDialogOpen] = useState(false);
  const [userAttributes, setUserAttributes] = useState(() =>
    ensureUserAttributes(),
  );
  const [attributeError, setAttributeError] = useState("");
  const [page, setPage] = useState(0);
  const [rowsPerPage, setRowsPerPage] = useState(10);
  const [searchScannerOpen, setSearchScannerOpen] = useState(false);
  const [batchPrintDialogOpen, setBatchPrintDialogOpen] = useState(false);
  const [batchFilters, setBatchFilters] = useState(() => ({
    grade: "",
    section: "",
    schoolYear: deriveDefaultSchoolYearLabel(),
  }));
  const [batchPrintError, setBatchPrintError] = useState("");
  const [batchPrintLoading, setBatchPrintLoading] = useState(false);
  const [schoolYearOptions, setSchoolYearOptions] = useState([]);
  const [schoolYearLoading, setSchoolYearLoading] = useState(false);
  const searchInputId = "students-search-input";
  const { finesEnabled } = useSettings();
  const { hasPermission, user } = useAuth();
  const canCreateStudents = hasPermission("students.create");
  const canEditStudents = hasPermission("students.update");
  const canDeleteStudents = hasPermission("students.delete");
  const userRole = (user?.role || "").toString().toLowerCase();
  const canBatchPrintCards =
    hasPermission("students.view") && ["admin", "librarian", "staff"].includes(userRole);

  const [menuAnchorEl, setMenuAnchorEl] = useState(null);
  const [menuStudent, setMenuStudent] = useState(null);

  const handleOpenMenu = (event, student) => {
    setMenuAnchorEl(event.currentTarget);
    setMenuStudent(student);
  };

  const handleCloseMenu = () => {
    setMenuAnchorEl(null);
    setMenuStudent(null);
  };

  const gradeOptions = useMemo(
    () => (Array.isArray(userAttributes.gradeLevels) ? userAttributes.gradeLevels : []),
    [userAttributes.gradeLevels],
  );
  const gradeStructure = useMemo(
    () => (Array.isArray(userAttributes.gradeStructure) ? userAttributes.gradeStructure : []),
    [userAttributes.gradeStructure],
  );
  const gradeColorMap = useMemo(
    () => buildGradeColorMap(gradeStructure),
    [gradeStructure],
  );
  const allSections = useMemo(
    () => collectAllSections(gradeStructure),
    [gradeStructure],
  );
  const availableSections = useMemo(() => {
    if (!gradeFilter) {
      return allSections;
    }
    const gradeSpecific = getSectionsForGrade(gradeStructure, gradeFilter);
    return gradeSpecific.length > 0 ? gradeSpecific : allSections;
  }, [gradeFilter, gradeStructure, allSections]);
  const batchAvailableSections = useMemo(() => {
    if (!batchFilters.grade) {
      return allSections;
    }
    const gradeSpecific = getSectionsForGrade(gradeStructure, batchFilters.grade);
    return gradeSpecific.length > 0 ? gradeSpecific : allSections;
  }, [batchFilters.grade, gradeStructure, allSections]);
  const hasGradeOptions = gradeOptions.length > 0;

  const [filterAnchorEl, setFilterAnchorEl] = useState(null);
  const filterOpen = Boolean(filterAnchorEl);

  const handleOpenFilters = (e) => setFilterAnchorEl(e.currentTarget);
  const handleCloseFilters = () => setFilterAnchorEl(null);

  useEffect(() => {
    setGradeFilter((previous) => {
      if (!previous) {
        return previous;
      }

      return gradeOptions.includes(previous) ? previous : "";
    });
  }, [gradeOptions]);

  useEffect(() => {
    setSectionFilter((previous) => {
      if (!previous) {
        return previous;
      }
      return availableSections.includes(previous) ? previous : "";
    });
  }, [availableSections]);

  useEffect(() => {
    if (!finesEnabled) {
      setPaymentDialogOpen(false);
    }
  }, [finesEnabled]);

  useEffect(() => {
    if (!batchPrintDialogOpen) {
      return undefined;
    }

    let isMounted = true;

    const loadSchoolYears = async () => {
      try {
        setSchoolYearLoading(true);
        setBatchPrintError("");
        const response = await studentsAPI.getSchoolYears();
        if (!isMounted) {
          return;
        }
        const yearList = response?.data?.schoolYears || [];
        setSchoolYearOptions(yearList);
        setBatchFilters((previous) => {
          if (previous.schoolYear || yearList.length === 0) {
            return previous;
          }
          return { ...previous, schoolYear: yearList[yearList.length - 1] };
        });
      } catch (error) {
        console.error("Failed to load school year options:", error);
        if (isMounted) {
          setBatchPrintError("Failed to load school years. Enter one manually to continue.");
        }
      } finally {
        if (isMounted) {
          setSchoolYearLoading(false);
        }
      }
    };

    loadSchoolYears();

    return () => {
      isMounted = false;
    };
  }, [batchPrintDialogOpen]);

  useEffect(() => {
    let isMounted = true;

    const loadAttributes = async () => {
      try {
        const response = await settingsAPI.getUserAttributes();
        if (isMounted) {
          setUserAttributes(ensureUserAttributes(response.data));
          setAttributeError("");
        }
      } catch (error) {
        console.error("Failed to load user attribute options:", error);
        if (isMounted) {
          setUserAttributes(ensureUserAttributes());
          setAttributeError(
            "Failed to load curriculum and grade options. Using defaults.",
          );
        }
      }
    };

    loadAttributes();

    return () => {
      isMounted = false;
    };
  }, []);

  useEffect(() => {
    const timer = setTimeout(() => {
      setDebouncedSearchTerm(searchTerm);
    }, 400);
    return () => clearTimeout(timer);
  }, [searchTerm]);

  const fetchStudents = useCallback(
    async (override = {}) => {
      const pageToFetch = override.page ?? page;
  const limitToFetch = override.limit ?? rowsPerPage;
  const limitValue = typeof limitToFetch === "string" ? limitToFetch.toLowerCase() : limitToFetch;
  const isAllMode = limitValue === "all" || limitValue === -1;
      const gradeToFetch = override.grade ?? gradeFilter;
      const sectionToFetch = override.section ?? sectionFilter;
      const searchToFetch = override.search ?? debouncedSearchTerm;

      try {
        setLoading(true);
        const params = {
          page: isAllMode ? 1 : pageToFetch + 1,
          limit: isAllMode ? "all" : limitToFetch,
        };
        if (gradeToFetch) params.grade = gradeToFetch;
        if (sectionToFetch) params.section = sectionToFetch;
        if (searchToFetch) params.search = searchToFetch;

        const response = await studentsAPI.getAll(params);
        const payload = response.data || {};
        const studentList = payload.students || payload.data || [];
        const total = payload.total || payload.pagination?.total || studentList.length || 0;

        setStudents(studentList);
        setTotalStudents(total);
      } catch (error) {
        console.error("Failed to fetch students:", error);
        toast.error("Failed to load students");
      } finally {
        setLoading(false);
      }
    },
    [page, rowsPerPage, gradeFilter, sectionFilter, debouncedSearchTerm]
  );

  useEffect(() => {
    fetchStudents();
  }, [fetchStudents]);

  useEffect(() => {
    if (location.state?.refresh) {
      fetchStudents({ page: 0 });
      window.history.replaceState({}, document.title);
    }
  }, [location.state?.refresh, fetchStudents]);

  const handleDeleteStudent = async () => {
    try {
      const studentId =
        selectedStudent._id || selectedStudent.id || selectedStudent.uid;
      await studentsAPI.delete(studentId);
      fetchStudents();
      toast.success("Student deleted successfully");
      setDeleteDialogOpen(false);
      setSelectedStudent(null);
    } catch (error) {
      console.error("Failed to delete student:", error);
      toast.error("Failed to delete student");
    }
  };

  const handlePayDues = async () => {
    try {
      const studentId =
        selectedStudent._id || selectedStudent.id || selectedStudent.uid;
      await studentsAPI.payDues(studentId, { amount: selectedStudent.dues });
      fetchStudents();
      toast.success("Dues paid successfully");
      setPaymentDialogOpen(false);
      setSelectedStudent(null);
    } catch (error) {
      console.error("Failed to pay dues:", error);
      toast.error("Failed to process payment");
    }
  };

  const getStudentEntityId = (studentRecord = {}) =>
    studentRecord._id ||
    studentRecord.id ||
    studentRecord.uid ||
    studentRecord.userId;

  const handleNavigateToProfile = (student) => {
    if (!student) {
      return;
    }

    const studentId = getStudentEntityId(student);
    if (!studentId) {
      console.warn("Missing student identifier for profile navigation", student);
      toast.error("Cannot open profile for this student");
      return;
    }

    navigate(`/students/${studentId}`);
  };

  const handlePrintCard = async (student) => {
    try {
      toast.loading("Generating library card...");
      const libraryResponse = await settingsAPI.getByCategory('library');
      const librarySettings = libraryResponse.data || {};
      const libraryCardPDF = await generateLibraryCard(student, librarySettings, { gradeColorMap });
      downloadPDF(libraryCardPDF, `library_card_${student.libraryCardNumber}.pdf`);
      toast.dismiss();
      toast.success("Library card generated successfully!");
    } catch (error) {
      toast.dismiss();
      toast.error("Failed to generate library card");
      console.error("Error generating library card:", error);
    }
  };

  const handleOpenBatchDialog = () => {
    setBatchPrintError("");
    setBatchFilters((previous) => ({
      grade: gradeFilter || previous.grade || "",
      section: sectionFilter || previous.section || "",
      schoolYear: previous.schoolYear || deriveDefaultSchoolYearLabel(),
    }));
    setBatchPrintDialogOpen(true);
  };

  const handleBatchFilterChange = (field, value) => {
    setBatchFilters((previous) => ({
      ...previous,
      [field]: value,
    }));
  };

  const handleBatchPrintCards = async () => {
    const normalizedYear = (batchFilters.schoolYear || "").trim();
    if (!normalizedYear) {
      setBatchPrintError("School year is required to print new cards.");
      return;
    }

    setBatchPrintError("");
    const toastId = toast.loading("Preparing library cards...");
    try {
      setBatchPrintLoading(true);
      const params = {
        limit: "all",
        schoolYear: normalizedYear,
      };
      if (batchFilters.grade) params.grade = batchFilters.grade;
      if (batchFilters.section) params.section = batchFilters.section;

      const response = await studentsAPI.getAll(params);
      const payload = response.data || {};
      const dataset = payload.students || payload.data || [];
      const printableStudents = dataset
        .filter((studentRecord) => studentRecord?.libraryCardNumber)
        .sort((studentA, studentB) => {
          const gradeCompare = (studentA.grade || "").localeCompare(studentB.grade || "");
          if (gradeCompare !== 0) {
            return gradeCompare;
          }
          const sectionCompare = (studentA.section || "").localeCompare(studentB.section || "");
          if (sectionCompare !== 0) {
            return sectionCompare;
          }
          const nameA = `${studentA.lastName || ""} ${studentA.firstName || ""}`.trim();
          const nameB = `${studentB.lastName || ""} ${studentB.firstName || ""}`.trim();
          return nameA.localeCompare(nameB);
        });

      if (printableStudents.length === 0) {
        toast.error("No students matched the selected filters.");
        return;
      }

      const libraryResponse = await settingsAPI.getByCategory('library');
      const librarySettings = libraryResponse.data || {};
      const pdf = await generateLibraryCardsPDF(printableStudents, librarySettings, { gradeColorMap });
      const safeYear = normalizedYear.replace(/[^0-9A-Za-z-]/g, "_");
      downloadPDF(pdf, `library_cards_${safeYear || 'students'}.pdf`);
      toast.success(`Generated ${printableStudents.length} library card${printableStudents.length === 1 ? '' : 's'}.`);
      setBatchPrintDialogOpen(false);
    } catch (error) {
      console.error("Failed to generate batch library cards:", error);
      setBatchPrintError(error?.response?.data?.message || "Failed to generate library cards.");
      toast.error("Failed to generate library cards.");
    } finally {
      if (toastId) {
        toast.dismiss(toastId);
      }
      setBatchPrintLoading(false);
    }
  };

  const handleImportComplete = () => {
    fetchStudents();
  };

  useEffect(() => {
    setPage(0);
  }, [debouncedSearchTerm, gradeFilter, sectionFilter]);

  useEffect(() => {
    if (!loading && students.length === 0 && totalStudents > 0 && page > 0) {
      setPage((prev) => Math.max(prev - 1, 0));
    }
  }, [loading, students.length, totalStudents, page]);

  const getDuesColor = (dues) => {
    if (dues === 0) return "success";
    if (dues > 0 && dues <= 100) return "warning";
    return "error";
  };

  const formatCurrency = (amount) => {
    return new Intl.NumberFormat("en-PH", {
      style: "currency",
      currency: "PHP",
    }).format(amount || 0);
  };

  if (loading && students.length === 0) {
    return <PageLoading message="Loading students..." />;
  }

  return (
    <main>
      <Box>
      {}
      <Box
        display="flex"
        justifyContent="space-between"
        alignItems="center"
        mb={3}
      >
        <Typography
          variant="h4"
          component="h1"
          sx={{ fontWeight: 600, color: "#ffffffff" }}
        >
          Students Management{" "}
        </Typography>{" "}
        <Box display="flex" gap={2} alignItems="center">
          {loading && students.length > 0 && (
            <CircularProgress size={18} sx={{ mr: 1 }} />
          )}
          {canBatchPrintCards && (
            <Button
              variant="contained"
              startIcon={<Print />}
              onClick={handleOpenBatchDialog}
              sx={printActionButtonSx}
              aria-label="Batch print library cards"
            >
              Batch Print Cards
            </Button>
          )}
          {canCreateStudents && (
            <>
              <Button
                variant="outlined"
                startIcon={<GetApp />}
                onClick={() => {
                  setImportDialogOpen(true);
                }}
                sx={importActionButtonSx}
              >
                Import
              </Button>
              <Button
                variant="contained"
                startIcon={<PersonAdd />}
                onClick={() => {
                  navigate("/students/new");
                }}
                sx={addActionButtonSx}
              >
                Add Student
              </Button>
            </>
          )}
        </Box>{" "}
      </Box>
  {}
      <Box mb={3}>
        <Box display="flex" gap={2} flexWrap="wrap" alignItems="center">
          <TextField
            placeholder="Search Students"
            value={searchTerm}
            onChange={(e) => setSearchTerm(e.target.value)}
            sx={{ flex: 1, minWidth: 300 }}
            inputProps={{ id: searchInputId }}
            InputProps={{
              startAdornment: (
                <InputAdornment position="start">
                  <Search />
                </InputAdornment>
              ),
            }}
          />
          <MobileScanButton
            label="Scan to Search"
            onClick={() => setSearchScannerOpen(true)}
          />
          {}
          <IconButton
            aria-label="Open filters"
            onClick={handleOpenFilters}
            size="small"
            sx={{ border: "1px solid #E2E8F0", backgroundColor: "#F8FAFC" }}
          >
            <FilterList />
          </IconButton>

          <Popover
            anchorEl={filterAnchorEl}
            open={filterOpen}
            onClose={handleCloseFilters}
            anchorOrigin={{ vertical: "bottom", horizontal: "right" }}
            transformOrigin={{ vertical: "top", horizontal: "right" }}
            disableAutoFocus
            disableEnforceFocus
            PaperProps={{ sx: { p: 2, minWidth: 220 } }}
          >
            <Box sx={{ display: "flex", flexDirection: "column", gap: 1 }}>
              <FormControl fullWidth size="small">
                <InputLabel> Grade </InputLabel>
                <Select
                  value={gradeFilter}
                  onChange={(e) => setGradeFilter(e.target.value)}
                  label="Grade"
                  disabled={!hasGradeOptions}
                >
                  <MenuItem value=""> All Grades </MenuItem>
                  {hasGradeOptions ? (
                    gradeOptions.map((grade) => (
                      <MenuItem key={grade} value={grade}>
                        {grade}
                      </MenuItem>
                    ))
                  ) : (
                    <MenuItem value="" disabled>
                      No grade options available
                    </MenuItem>
                  )}
                </Select>
              </FormControl>

              <FormControl fullWidth size="small">
                <InputLabel> Section </InputLabel>
                <Select
                  value={sectionFilter}
                  onChange={(e) => setSectionFilter(e.target.value)}
                  label="Section"
                  disabled={availableSections.length === 0}
                >
                  <MenuItem value=""> All Sections </MenuItem>
                  {availableSections.length === 0 ? (
                    <MenuItem value="" disabled>
                      No sections configured
                    </MenuItem>
                  ) : (
                    availableSections.map((section) => (
                      <MenuItem key={section} value={section}>
                        Section {section}
                      </MenuItem>
                    ))
                  )}
                </Select>
              </FormControl>

              <Box display="flex" justifyContent="flex-end" gap={1} mt={1}>
                <Button
                  size="small"
                  onClick={() => {
                    setGradeFilter("");
                    setSectionFilter("");
                    handleCloseFilters();
                  }}
                >
                  Clear
                </Button>
                <Button size="small" variant="contained" onClick={handleCloseFilters}>
                  Apply
                </Button>
              </Box>
            </Box>
          </Popover>
        </Box>
        {attributeError && (
          <Alert severity="warning" sx={{ mt: 2 }}>
            {attributeError}
          </Alert>
        )}
      </Box>
  {}
      {!loading && totalStudents === 0 ? (
        <Box textAlign="center" py={8}>
          <Typography variant="h6" color="text.secondary" gutterBottom>
            {" "}
            {searchTerm || gradeFilter || sectionFilter
              ? "No students found matching your criteria"
              : "No students available"}{" "}
          </Typography>{" "}
          <Typography variant="body2" color="text.secondary" gutterBottom>
            {" "}
            {!searchTerm &&
              !gradeFilter &&
              !sectionFilter &&
              "Start by adding your first student to the system"}{" "}
          </Typography>{" "}
          {!searchTerm && !gradeFilter && !sectionFilter && (
            <Button
              variant="contained"
              startIcon={<PersonAdd />}
              onClick={() => navigate("/students/new")}
              sx={{ ...addActionButtonSx, mt: 2 }}
            >
              Add First Student{" "}
            </Button>
          )}{" "}
        </Box>
      ) : (
        <TableContainer
          component={Paper}
          sx={{ boxShadow: "0 4px 20px rgba(0, 0, 0, 0.08)" }}
        >
          <Table>
            <caption>Students List</caption>
            <TableHead sx={{ backgroundColor: "#F8FAFC" }}>
              <TableRow>
                <TableCell scope="col" sx={{ fontWeight: 600, color: "#475569" }}>
                  Grade
                </TableCell>
                <TableCell scope="col" sx={{ fontWeight: 600, color: "#475569" }}>
                  Student
                </TableCell>
                <TableCell scope="col" sx={{ fontWeight: 600, color: "#475569" }}>
                  Section
                </TableCell>
                <TableCell scope="col" sx={{ fontWeight: 600, color: "#475569" }}>
                  Library Card
                </TableCell>
                <TableCell scope="col" sx={{ fontWeight: 600, color: "#475569" }}>
                  Contact
                </TableCell>
                {finesEnabled ? (
                  <TableCell scope="col" sx={{ fontWeight: 600, color: "#475569" }}>
                    Dues
                  </TableCell>
                ) : null}
                <TableCell scope="col" align="right" sx={{ fontWeight: 600, color: "#475569" }}>
                  Action
                </TableCell>
              </TableRow>
            </TableHead>
            <TableBody>
              {students.map((student, index) => {
                const avatarSrc = resolveEntityAvatar(student);
                const fallbackInitial = [student.firstName, student.lastName, student.username, student.email]
                  .map((value) => (typeof value === "string" && value.trim() ? value.trim().charAt(0).toUpperCase() : ""))
                  .find(Boolean);
                const avatarAlt = student.fullName ||
                  [student.firstName, student.lastName]
                    .filter((value) => typeof value === "string" && value.trim())
                    .join(" ") ||
                  student.username ||
                  student.studentId ||
                  "Student avatar";
                const studentEntityId = getStudentEntityId(student);
                const studentIdentifier =
                  student.studentId ||
                  student.libraryCardNumber ||
                  student.username ||
                  student.lrn ||
                  studentEntityId ||
                  "Not set";
                const studentLrn = student.lrn || student.username || "Not provided";
                const rowKey =
                  studentEntityId ||
                  studentIdentifier ||
                  student.email ||
                  student.phoneNumber ||
                  student.createdAt ||
                  student.updatedAt ||
                  `student-row-${index}`;

                return (
                  <TableRow
                    key={rowKey}
                    hover
                    onDoubleClick={() => handleNavigateToProfile(student)}
                    sx={{ cursor: "pointer" }}
                  >
                    <TableCell>
                      <Typography variant="body2" fontWeight="medium">
                        {student.grade}
                      </Typography>
                    </TableCell>
                    <TableCell>
                      <Box display="flex" alignItems="center" gap={2}>
                        <Avatar
                          src={avatarSrc || undefined}
                          alt={avatarAlt}
                          sx={{
                            bgcolor: avatarSrc ? "transparent" : "primary.main",
                            color: avatarSrc ? "inherit" : "primary.contrastText",
                            width: 32,
                            height: 32,
                          }}
                        >
                          {fallbackInitial || <Person fontSize="small" />}
                        </Avatar>
                        <Box>
                          <Typography variant="body2" fontWeight="medium">
                            {student.fullName ||
                              `${student.firstName || ""} ${student.middleName ? student.middleName + " " : ""}${student.lastName || ""}`}
                          </Typography>
                          <Typography variant="caption" color="text.secondary" display="block">
                            LRN: {studentLrn}
                          </Typography>
                          {student.email && (
                            <Typography
                              variant="caption"
                              color="text.secondary"
                              display="block"
                            >
                              {student.email}
                            </Typography>
                          )}
                        </Box>
                      </Box>
                    </TableCell>
                  <TableCell>
                    <Typography variant="body2">
                      {student.section}
                    </Typography>
                  </TableCell>
                  <TableCell>
                    <Box>
                      <Typography
                        variant="body2"
                        fontWeight="bold"
                        sx={{
                          color: student.libraryCardNumber
                            ? "#1976d2"
                            : "#9e9e9e",
                          fontFamily: "monospace",
                          fontSize: "0.875rem",
                        }}
                      >
                        {student.libraryCardNumber || "Not assigned"}
                      </Typography>
                    </Box>
                  </TableCell>
                  <TableCell>
                    <Box>
                      {student.phoneNumber && (
                        <Typography variant="body2" fontSize="0.75rem">
                          üì± {student.phoneNumber}
                        </Typography>
                      )}
                      {student.barangay && student.municipality && (
                        <Typography
                          variant="caption"
                          color="text.secondary"
                          display="block"
                        >
                          üìç {student.barangay}, {student.municipality}
                        </Typography>
                      )}
                      {student.parentGuardianName && (
                        <Typography
                          variant="caption"
                          color="text.secondary"
                          display="block"
                        >
                          üë§ {student.parentGuardianName}
                        </Typography>
                      )}
                    </Box>
                  </TableCell>
                  {finesEnabled ? (
                    <TableCell>
                      <Chip
                        label={formatCurrency(student.dues)}
                        size="small"
                        color={getDuesColor(student.dues)}
                        variant={student.dues === 0 ? "outlined" : "filled"}
                      />
                    </TableCell>
                  ) : null}
                  <TableCell align="right">
                    <Box display="flex" justifyContent="flex-end">
                      <IconButton
                        size="small"
                        onClick={(e) => handleOpenMenu(e, student)}
                        onDoubleClick={(event) => event.stopPropagation()}
                        aria-controls={menuAnchorEl ? "student-action-menu" : undefined}
                        aria-haspopup="true"
                        aria-expanded={Boolean(menuAnchorEl)}
                      >
                        <MoreVert />
                      </IconButton>

                      <Menu
                        anchorEl={menuAnchorEl}
                        open={
                          Boolean(menuAnchorEl) &&
                          (menuStudent
                            ? (menuStudent._id || menuStudent.id || menuStudent.uid || menuStudent.studentId) ===
                              (student._id || student.id || student.uid || student.studentId)
                            : false)
                        }
                        onClose={handleCloseMenu}
                        anchorOrigin={{ vertical: "bottom", horizontal: "right" }}
                        transformOrigin={{ vertical: "top", horizontal: "right" }}
                      >
                        {finesEnabled && student.dues > 0 && (
                          <MenuItem
                            onClick={() => {
                              setSelectedStudent(student);
                              setPaymentDialogOpen(true);
                              handleCloseMenu();
                            }}
                          >
                            <ListItemIcon>
                              <Payments fontSize="small" />
                            </ListItemIcon>
                            Pay Dues
                          </MenuItem>
                        )}

                        {student.libraryCardNumber && (
                          <MenuItem
                            onClick={() => {
                              handlePrintCard(student);
                              handleCloseMenu();
                            }}
                          >
                            <ListItemIcon>
                              <Print fontSize="small" />
                            </ListItemIcon>
                            Print Card
                          </MenuItem>
                        )}

                        {canEditStudents && (
                          <MenuItem
                            onClick={() => {
                              navigate(`/students/${student._id || student.id}/edit`);
                              handleCloseMenu();
                            }}
                          >
                            <ListItemIcon>
                              <Edit fontSize="small" />
                            </ListItemIcon>
                            Edit
                          </MenuItem>
                        )}

                        {canDeleteStudents && (
                          <MenuItem
                            onClick={() => {
                              setSelectedStudent(student);
                              setDeleteDialogOpen(true);
                              handleCloseMenu();
                            }}
                          >
                            <ListItemIcon>
                              <DeleteIcon fontSize="small" />
                            </ListItemIcon>
                            Delete
                          </MenuItem>
                        )}
                      </Menu>
                    </Box>
                  </TableCell>
                  </TableRow>
                );
              })}
            </TableBody>
          </Table>
          <TablePagination
            component="div"
            count={totalStudents}
            page={page}
            onPageChange={(event, newPage) => {
              setPage(newPage);
            }}
            rowsPerPage={rowsPerPage}
            onRowsPerPageChange={(event) => {
              const value = parseInt(event.target.value, 10);
              const nextLimit = Number.isNaN(value) ? 10 : value;
              setRowsPerPage(nextLimit);
              setPage(0);
            }}
            rowsPerPageOptions={[10, 25, 50, 100, { label: "All", value: -1 }]}
            labelRowsPerPage="Rows per page"
            sx={{ borderTop: "1px solid", borderColor: "divider" }}
          />
        </TableContainer>
      )}
      <MobileScanDialog
        open={searchScannerOpen}
        onClose={() => setSearchScannerOpen(false)}
        onDetected={(value) => setSearchTerm(value || "")}
        title="Scan to Search Students"
        elementId="students-search-qr"
        targetSelector={`#${searchInputId}`}
      />
      <Dialog
        open={batchPrintDialogOpen}
        onClose={() => {
          if (!batchPrintLoading) {
            setBatchPrintDialogOpen(false);
          }
        }}
        fullWidth
        maxWidth="sm"
      >
        <DialogTitle>Print Library Cards</DialogTitle>
        <DialogContent sx={{ display: "flex", flexDirection: "column", gap: 2, pt: 1 }}>
          <Typography variant="body2" color="text.secondary">
            Select grade, section, and school year to generate cards for newly enrolled students.
          </Typography>
          <FormControl fullWidth size="small">
            <InputLabel>Grade</InputLabel>
            <Select
              value={batchFilters.grade}
              onChange={(event) => handleBatchFilterChange("grade", event.target.value)}
              label="Grade"
              disabled={!hasGradeOptions}
            >
              <MenuItem value="">All Grades</MenuItem>
              {hasGradeOptions ? (
                gradeOptions.map((grade) => (
                  <MenuItem key={`batch-grade-${grade}`} value={grade}>
                    {grade}
                  </MenuItem>
                ))
              ) : (
                <MenuItem value="" disabled>
                  No grade options available
                </MenuItem>
              )}
            </Select>
          </FormControl>
          <FormControl fullWidth size="small">
            <InputLabel>Section</InputLabel>
            <Select
              value={batchFilters.section}
              onChange={(event) => handleBatchFilterChange("section", event.target.value)}
              label="Section"
              disabled={batchAvailableSections.length === 0}
            >
              <MenuItem value="">All Sections</MenuItem>
              {batchAvailableSections.length === 0 ? (
                <MenuItem value="" disabled>
                  No sections configured
                </MenuItem>
              ) : (
                batchAvailableSections.map((section) => (
                  <MenuItem key={`batch-section-${section}`} value={section}>
                    Section {section}
                  </MenuItem>
                ))
              )}
            </Select>
          </FormControl>
          <Autocomplete
            freeSolo
            loading={schoolYearLoading}
            options={schoolYearOptions}
            value={batchFilters.schoolYear}
            onInputChange={(event, value) => handleBatchFilterChange("schoolYear", value || "")}
            renderInput={(params) => (
              <TextField
                {...params}
                label="School Year"
                required
                helperText="Example: 2025-2026"
              />
            )}
          />
          {batchPrintError && (
            <Alert severity="error">{batchPrintError}</Alert>
          )}
        </DialogContent>
        <DialogActions>
          <Button onClick={() => setBatchPrintDialogOpen(false)} disabled={batchPrintLoading}>
            Cancel
          </Button>
          <Button
            onClick={handleBatchPrintCards}
            variant="contained"
            disabled={batchPrintLoading}
            startIcon={!batchPrintLoading ? <Print /> : undefined}
          >
            {batchPrintLoading ? <CircularProgress size={18} color="inherit" /> : "Print Library Cards"}
          </Button>
        </DialogActions>
      </Dialog>
  {}
      <Dialog
        open={deleteDialogOpen}
        onClose={() => setDeleteDialogOpen(false)}
      >
        <DialogTitle> Delete Student </DialogTitle>{" "}
        <DialogContent>
          <Typography>
            Are you sure you want to delete student "
            {selectedStudent?.firstName} {selectedStudent?.lastName}" ? This
            action cannot be undone and will remove all associated data.{" "}
          </Typography>{" "}
        </DialogContent>{" "}
        <DialogActions>
          <Button variant="outlined" onClick={() => setDeleteDialogOpen(false)}> Cancel </Button>{" "}
          <Button
            onClick={handleDeleteStudent}
            color="error"
            variant="contained"
          >
            Delete{" "}
          </Button>{" "}
        </DialogActions>{" "}
      </Dialog>
  {}
      {finesEnabled ? (
        <Dialog
          open={paymentDialogOpen}
          onClose={() => setPaymentDialogOpen(false)}
        >
          <DialogTitle> Pay Dues </DialogTitle>{" "}
          <DialogContent>
            <Typography>
              Confirm payment of {formatCurrency(selectedStudent?.dues)}
              for student "{selectedStudent?.firstName}{" "}
              {selectedStudent?.lastName}" ?
            </Typography>{" "}
          </DialogContent>{" "}
          <DialogActions>
            <Button variant="outlined" onClick={() => setPaymentDialogOpen(false)}> Cancel </Button>{" "}
            <Button onClick={handlePayDues} color="success" variant="contained">
              Pay Dues{" "}
            </Button>{" "}
          </DialogActions>{" "}
        </Dialog>
      ) : null}
  {}
      <StudentImportDialog
        open={importDialogOpen}
        onClose={() => setImportDialogOpen(false)}
        onImportComplete={handleImportComplete}
      />{" "}
    </Box>
    </main>
  );
};

export default StudentsList;
```

## TransactionDetails.js

| Field | Details |
| --- | --- |
| Program Name | TransactionDetails.js |
| Description | Frontend page view for routing and page-level UI. |
| Called by | App.js |
| Table used | transactions |
|  |  |
| Programmer | Nazel Asca√±o |
| Date created | 12/14/2025 |
| Revision Date | TBD |
| Revision / description of change | None |

```javascript
import React, { useState, useEffect, useCallback } from "react";
import { useParams, useNavigate, useLocation } from "react-router-dom";
import {
  Box,
  Typography,
  Grid,
  Card,
  CardContent,
  Button,
  Chip,
  Divider,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  Alert,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  TextField,
  IconButton,
  List,
  ListItem,
  ListItemText,
  ListItemIcon,
} from "@mui/material";
import {
  ArrowBack,
  Assignment,
  AssignmentReturn,
  Person,
  Book,
  CalendarToday,
  Schedule,
  CurrencyExchange,
  Edit,
  Print,
  QrCode,
  Warning,
  CheckCircle,
  Cancel,
  Note,
} from "@mui/icons-material";
import { DateTimePicker } from "@mui/x-date-pickers/DateTimePicker";
import { LocalizationProvider } from "@mui/x-date-pickers/LocalizationProvider";
import { AdapterDateFns } from "@mui/x-date-pickers/AdapterDateFns";
import { useAuth } from "../../contexts/AuthContext";
import { useSettings } from "../../contexts/SettingsContext";
import { api } from "../../utils/api";
import { formatCurrency } from "../../utils/currency";
import ApproveRequestDialog from "../../components/Transactions/ApproveRequestDialog";

const TransactionDetails = () => {
  const { id } = useParams();
  const navigate = useNavigate();
  const location = useLocation();
  const { user } = useAuth();
  const { finesEnabled } = useSettings();
  const [transaction, setTransaction] = useState(null);
  const [book, setBook] = useState(null);
  const [borrower, setBorrower] = useState(null);
  const [history, setHistory] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState("");
  const [success, setSuccess] = useState("");
  const [returnDialog, setReturnDialog] = useState(false);
  const [editNotesDialog, setEditNotesDialog] = useState(false);
  const [returnDate, setReturnDate] = useState(new Date());
  const [notes, setNotes] = useState("");
  const [actionLoading, setActionLoading] = useState(false);
  const [approveDialogOpen, setApproveDialogOpen] = useState(false);
  const [markMissingDialogOpen, setMarkMissingDialogOpen] = useState(false);
  const [missingReason, setMissingReason] = useState("");
  const [markMissingLoading, setMarkMissingLoading] = useState(false);

  const fetchTransactionDetails = useCallback(async () => {
    try {
      setLoading(true);
      const response = await api.get(`/transactions/${id}`);
      setTransaction(response.data);
      setNotes(response.data.notes || "");
    } catch (error) {
      setError("Failed to fetch transaction details");
      console.error("Error fetching transaction details:", error);
    } finally {
      setLoading(false);
    }
  }, [id]);

  const fetchTransactionHistory = useCallback(async () => {
    try {
      const response = await api.get(`/transactions/${id}/history`);
      setHistory(response.data || []);
    } catch (error) {
      console.error("Error fetching transaction history:", error);
      setHistory([]);
    }
  }, [id]);

  useEffect(() => {
    fetchTransactionDetails();
    fetchTransactionHistory();
  }, [fetchTransactionDetails, fetchTransactionHistory]);

  useEffect(() => {
    if (!transaction) return;

    const firstItem = Array.isArray(transaction.items) && transaction.items.length > 0
      ? transaction.items[0]
      : null;

    const fetchBook = async (bookId) => {
      try {
        if (!bookId) return;
        const res = await api.get(`/books/${bookId}`);
        setBook(res.data || null);
      } catch (err) {

        console.debug('Could not fetch book', bookId, err?.message || err);
      }
    };

    const fetchBorrower = async (userId) => {
      try {
        if (!userId) return;
        const res = await api.get(`/users/${userId}`);
        setBorrower(res.data || null);
      } catch (err) {
        console.debug('Could not fetch user', userId, err?.message || err);
      }
    };

    if (firstItem && firstItem.bookId) {
      fetchBook(firstItem.bookId);
    }

    if (transaction.userId) {
      fetchBorrower(transaction.userId);
    }
  }, [transaction]);

  const handleReturnBook = async () => {
    try {
      setActionLoading(true);
      await api.post(`/transactions/${id}/return`, {
        returnDate: returnDate.toISOString(),
      });
      setSuccess("Book returned successfully");
      setReturnDialog(false);
      fetchTransactionDetails();
      fetchTransactionHistory();
      setTimeout(() => setSuccess(""), 3000);
    } catch (error) {
      setError(error.response?.data?.message || "Failed to return book");
      console.error("Error returning book:", error);
    } finally {
      setActionLoading(false);
    }
  };

  const handleUpdateNotes = async () => {
    try {
      setActionLoading(true);
      await api.put(`/transactions/${id}/notes`, { notes });
      setSuccess("Notes updated successfully");
      setEditNotesDialog(false);
      fetchTransactionDetails();
      setTimeout(() => setSuccess(""), 3000);
    } catch (error) {
      setError("Failed to update notes");
      console.error("Error updating notes:", error);
    } finally {
      setActionLoading(false);
    }
  };

  const handleApproveSuccess = () => {
    setSuccess("Request approved successfully");
    setApproveDialogOpen(false);
    fetchTransactionDetails();
    fetchTransactionHistory();
    setTimeout(() => setSuccess(""), 3000);
  };

  const handleApproveClose = () => {
    setApproveDialogOpen(false);
  };

  const handleMarkMissing = async () => {
    try {
      setMarkMissingLoading(true);
      setError("");
      await api.post(`/transactions/${id}/missing`, {
        reason: missingReason.trim() || undefined,
      });
      setSuccess("Transaction flagged as missing");
      setMarkMissingDialogOpen(false);
      setMissingReason("");
      fetchTransactionDetails();
      fetchTransactionHistory();
      setTimeout(() => setSuccess(""), 3000);
    } catch (error) {
      const message = error.response?.data?.message || "Failed to mark transaction as missing";
      setError(message);
      console.error("Error marking missing:", error);
    } finally {
      setMarkMissingLoading(false);
    }
  };

  const getStatusColor = (status) => {
    switch (status) {
      case "active":
        return "primary";
      case "returned":
        return "success";
      case "overdue":
        return "error";
      case "renewed":
        return "warning";
      case "lost":
      case "missing":
        return "error";
      default:
        return "default";
    }
  };

  const getStatusIcon = (status) => {
    switch (status) {
      case "active":
        return <CheckCircle />;
      case "returned":
        return <AssignmentReturn />;
      case "overdue":
        return <Warning />;
      case "renewed":
        return <Schedule />;
      case "lost":
      case "missing":
        return <Cancel />;
      default:
        return <Assignment />;
    }
  };

  const calculateDaysOverdue = () => {
    if (!transaction || transaction.status !== "active") return 0;
    const now = new Date();
    const dueDate = new Date(transaction.dueDate);
    return Math.max(0, Math.ceil((now - dueDate) / (1000 * 60 * 60 * 24)));
  };

  const calculateFine = () => {
    if (!finesEnabled) {
      return 0;
    }
    const daysOverdue = calculateDaysOverdue();
    return daysOverdue * (transaction?.finePerDay || 0.5);
  };

  const renderDetails = (entry) => {
    const data = entry.details || entry.metadata;
    if (!data) return null;

    if (typeof data === "string") {
      return <Typography variant="body2">{data}</Typography>;
    }

    if (data.result || data.returnedItems !== undefined || data.returnedItems === 0) {
      const result = data.result || data;
      return (
        <Box>
          {result.returnedItems !== undefined && (
            <Typography variant="body2">{`Returned ${result.returnedItems} item${result.returnedItems === 1 ? '' : 's'}.`}</Typography>
          )}
          {result.fineAmount !== undefined && (
            <Typography variant="body2">{`A fine of ${formatCurrency(result.fineAmount)} was applied.`}</Typography>
          )}
          {result.daysOverdue !== undefined && (
            <Typography variant="body2">{`The item was overdue by ${result.daysOverdue} day${result.daysOverdue === 1 ? '' : 's'}.`}</Typography>
          )}
        </Box>
      );
    }

    if (data.borrower || data.borrowerId) {
      const b = data.borrower || {};
      const borrowerIdValue = b.id || data.borrowerId || null;
      return (
        <Box>
          {b.name && <Typography variant="body2">{`Borrower: ${b.name}`}</Typography>}
          {borrowerIdValue && <Typography variant="body2">{`Borrower ID: ${borrowerIdValue}`}</Typography>}
        </Box>
      );
    }

    if (data.transaction || data.transactionId || data.id) {
      const t = data.transaction || data;
      const transactionIdValue = data.transactionId || t.transactionId || t.id || data.id || null;
      return (
        <Box>
          {transactionIdValue && (
            <Typography variant="body2">{`Related Transaction: #${transactionIdValue}`}</Typography>
          )}
          {Array.isArray(t.items) && t.items.length > 0 && (
            <Box>
              <Typography variant="body2">Involved Items:</Typography>
              {t.items.map((it, i) => (
                <Typography variant="caption" key={i} display="block">
                  {`‚Ä¢ Copy/Book: ${it.copyId || it.copy || it.bookId || ''}${it.isbn ? ` (ISBN: ${it.isbn})` : ''}`}
                </Typography>
              ))}
            </Box>
          )}
        </Box>
      );
    }

    if (data.copyId || data.bookId || data.isbn) {
      return (
        <Box>
          {data.bookId && <Typography variant="body2">{`Book ID: ${data.bookId}`}</Typography>}
          {data.copyId && <Typography variant="body2">{`Reference ID: ${data.copyId}`}</Typography>}
          {data.isbn && <Typography variant="body2">{`ISBN: ${data.isbn}`}</Typography>}
        </Box>
      );
    }

    return (
      <Box sx={{ background: '#f6f8fa', borderRadius: 2, p: 1 }}>
        <Typography variant="body2" color="textSecondary" sx={{ fontStyle: 'italic', mb: 0.5 }}>
          Details:
        </Typography>
        <ul style={{ margin: 0, paddingLeft: 18 }}>
          {Object.entries(data).map(([key, value]) => (
            <li key={key} style={{ marginBottom: 2 }}>
              <strong style={{ textTransform: 'capitalize' }}>{key.replace(/([A-Z])/g, ' $1')}</strong>: {formatDetailValue(value)}
            </li>
          ))}
        </ul>
      </Box>
    );

  function formatDetailValue(value) {
    if (value === null || value === undefined) return 'N/A';
    if (typeof value === 'object') {
      if (Array.isArray(value)) {
        return value.length === 0
          ? 'None'
          : value.map((v, i) => <span key={i}>{formatDetailValue(v)}{i < value.length - 1 ? ', ' : ''}</span>);
      }

      const entries = Object.entries(value);
      if (entries.length === 0) return 'None';
      return (
        <ul style={{ margin: 0, paddingLeft: 18 }}>
          {entries.map(([k, v]) => (
            <li key={k} style={{ marginBottom: 2 }}>
              <strong style={{ textTransform: 'capitalize' }}>{k.replace(/([A-Z])/g, ' $1')}</strong>: {formatDetailValue(v)}
            </li>
          ))}
        </ul>
      );
    }
    if (typeof value === 'boolean') return value ? 'Yes' : 'No';
    return String(value);
  }
  };

  const canManageTransaction =
    user?.role === "admin" ||
    user?.role === "librarian" ||
    user?.role === "staff";

  const normalizedStatus = (transaction?.status || "").toLowerCase();
  const returnableStatuses = ["active", "borrowed", "overdue", "renewed", "missing"];
  const canProcessReturn = returnableStatuses.includes(normalizedStatus);
  const canMarkMissing = ["active", "borrowed", "overdue", "renewed"].includes(normalizedStatus);

  const printReceipt = () => {
    window.print();
  };

  if (loading) {
    return (
      <Box
        display="flex"
        justifyContent="center"
        alignItems="center"
        minHeight="200px"
      >
        <Typography> Loading transaction details... </Typography>{" "}
      </Box>
    );
  }

  if (!transaction) {
    return (
      <Box>
        <Alert severity="error"> Transaction not found </Alert>{" "}
      </Box>
    );
  }

  const daysOverdue = calculateDaysOverdue();
  const fine = calculateFine();

  const firstItem = Array.isArray(transaction?.items) && transaction.items.length > 0 ? transaction.items[0] : null;

  return (
    <LocalizationProvider dateAdapter={AdapterDateFns}>
      <Box>
        <Box display="flex" alignItems="center" mb={3}>
          <IconButton
            onClick={() => {
              if (location.state?.from) navigate(location.state.from);
              else navigate(-1);
            }}
            sx={{ mr: 2 }}
          >
            <ArrowBack />
          </IconButton>{" "}
          <Typography variant="h4" gutterBottom sx={{ flexGrow: 1, mb: 0, color:'white'}}>
            Transaction Details{" "}
          </Typography>{" "}
          <Box>
            <Button
              variant="outlined"
              startIcon={<Print />}
              onClick={printReceipt}
              sx={{ mr: 2 }}
            >
              Print Receipt{" "}
            </Button>{" "}
            {canManageTransaction && canProcessReturn && (
              <Button
                variant="contained"
                startIcon={<AssignmentReturn />}
                onClick={() => setReturnDialog(true)}
              >
                Return Book{" "}
              </Button>
            )}{" "}
          </Box>{" "}
        </Box>
        {error && (
          <Alert severity="error" sx={{ mb: 2 }}>
            {" "}
            {error}{" "}
          </Alert>
        )}
        {success && (
          <Alert severity="success" sx={{ mb: 2 }}>
            {" "}
            {success}{" "}
          </Alert>
        )}

        {}
        {transaction && transaction.status === 'rejected' && (
          <Alert severity="error" sx={{ mb: 2 }}>
            <Typography variant="body2">
              This request was rejected{transaction.rejectReason ? `: ${transaction.rejectReason}` : ''}
            </Typography>
            {transaction.rejectedBy && (
              <Typography variant="caption" display="block">Rejected by: {transaction.rejectedBy}</Typography>
            )}
            {transaction.rejectedAt && (
              <Typography variant="caption" display="block">At: {new Date(transaction.rejectedAt).toLocaleString()}</Typography>
            )}
          </Alert>
        )}
        <Grid container spacing={3}>
          {" "}
          {}{" "}
          <Grid item xs={12} lg={8}>
            <Card sx={{ mb: 3 }}>
              <CardContent>
                <Box
                  display="flex"
                  justifyContent="space-between"
                  alignItems="center"
                  mb={2}
                >
                  <Typography variant="h6">Transaction Overview </Typography>{" "}
                  <Chip
                    icon={getStatusIcon(transaction.status)}
                    label={transaction.status.toUpperCase()}
                    color={getStatusColor(transaction.status)}
                    size="large"
                  />
                </Box>
                <Grid container spacing={3}>
                  <Grid item xs={12} md={6}>
                    <Box display="flex" alignItems="center" mb={2}>
                      <Book sx={{ mr: 2, color: "primary.main" }} />{" "}
                      <Box>
                        <Typography variant="subtitle2" color="textSecondary">
                          Book{" "}
                        </Typography>{" "}
                        <Typography variant="h6">
                          {book?.title || transaction.bookTitle || firstItem?.bookId || firstItem?.copyId || ''}
                        </Typography>
                        <Typography variant="body2" color="textSecondary">
                          {`by ${book?.author || transaction.author || ''}`}
                        </Typography>
                        <Typography variant="body2" color="textSecondary">
                          {`Reference ID: ${firstItem?.copyId || transaction.copyId || ''}`}
                        </Typography>
                      </Box>{" "}
                    </Box>{" "}
                  </Grid>
                  <Grid item xs={12} md={6}>
                    <Box display="flex" alignItems="center" mb={2}>
                      <Person sx={{ mr: 2, color: "primary.main" }} />{" "}
                      <Box>
                        <Typography variant="subtitle2" color="textSecondary">
                          Borrower{" "}
                        </Typography>{" "}
                        <Typography variant="h6">
                          {borrower
                            ? `${borrower.firstName || ''} ${borrower.lastName || ''}`.trim()
                            : transaction.borrowerName || transaction.userId || ''}
                        </Typography>
                        <Typography variant="body2" color="textSecondary">
                          {borrower?.email || transaction.borrowerEmail || ''}
                        </Typography>
                        {(borrower?.studentId || transaction.borrowerStudentId || borrower?.library?.cardNumber) && (
                          <Typography variant="body2" color="textSecondary">
                            {`Student ID: ${borrower?.studentId || transaction.borrowerStudentId || borrower?.library?.cardNumber || ''}`}
                          </Typography>
                        )}
                      </Box>{" "}
                    </Box>{" "}
                  </Grid>{" "}
                </Grid>
                <Divider sx={{ my: 2 }} />
                <Grid container spacing={2}>
                  <Grid item xs={6} md={3}>
                    <Typography variant="subtitle2" color="textSecondary">
                      Borrow Date{" "}
                    </Typography>{" "}
                    <Typography variant="body1">
                      {" "}
                      {new Date(
                        transaction.borrowDate,
                      ).toLocaleDateString()}{" "}
                    </Typography>{" "}
                  </Grid>{" "}
                  <Grid item xs={6} md={3}>
                    <Typography variant="subtitle2" color="textSecondary">
                      Due Date{" "}
                    </Typography>{" "}
                    <Typography variant="body1">
                      {" "}
                      {new Date(transaction.dueDate).toLocaleDateString()}{" "}
                    </Typography>{" "}
                  </Grid>{" "}
                  <Grid item xs={6} md={3}>
                    <Typography variant="subtitle2" color="textSecondary">
                      Return Date{" "}
                    </Typography>{" "}
                    <Typography variant="body1">
                      {" "}
                      {transaction.returnDate
                        ? new Date(transaction.returnDate).toLocaleDateString()
                        : "Not returned"}{" "}
                    </Typography>{" "}
                  </Grid>{" "}
                  <Grid item xs={6} md={3}>
                    <Typography variant="subtitle2" color="textSecondary">
                      Transaction Type{" "}
                    </Typography>{" "}
                    <Typography
                      variant="body1"
                      sx={{ textTransform: "capitalize" }}
                    >
                      {" "}
                      {transaction.type || "Regular"}{" "}
                    </Typography>{" "}
                  </Grid>{" "}
                </Grid>
                {finesEnabled && daysOverdue > 0 && (
                  <Alert severity="warning" sx={{ mt: 2 }}>
                    <Typography variant="body2">
                      This book is{" "}
                      <strong>
                        {" "}
                        {daysOverdue}
                        days overdue{" "}
                      </strong>
                        . {fine > 0 && ` Current fine: ${formatCurrency(fine)}`}{" "}
                    </Typography>{" "}
                  </Alert>
                )}
                {transaction.notes && (
                  <Box mt={2}>
                    <Box
                      display="flex"
                      justifyContent="space-between"
                      alignItems="center"
                    >
                      <Typography variant="subtitle2" color="textSecondary">
                        Notes{" "}
                      </Typography>{" "}
                      {canManageTransaction && (
                        <IconButton
                          size="small"
                          onClick={() => setEditNotesDialog(true)}
                        >
                          <Edit />
                        </IconButton>
                      )}{" "}
                    </Box>{" "}
                    <Typography variant="body2">
                      {" "}
                      {transaction.notes}{" "}
                    </Typography>{" "}
                  </Box>
                )}{" "}
              </CardContent>{" "}
            </Card>
            {}{" "}
            <Card>
              <CardContent>
                <Typography variant="h6" gutterBottom>
                  Transaction History{" "}
                </Typography>{" "}
                <TableContainer>
                  <Table size="small">
                    <TableHead>
                      <TableRow>
                        <TableCell>Date</TableCell>
                        <TableCell>Action</TableCell>
                        <TableCell>Details</TableCell>
                        <TableCell>Processed By</TableCell>
                      </TableRow>
                    </TableHead>
                    <TableBody>
                      {history.map((entry, index) => (
                        <TableRow key={index}>
                          <TableCell>{new Date(entry.timestamp).toLocaleString()}</TableCell>
                          <TableCell>
                            <Chip label={formatActionLabel(entry.action)} size="small" variant="outlined" />
                          </TableCell>
                          <TableCell>{renderDetails(entry)}</TableCell>
                          <TableCell>{entry.staffName || 'System'}</TableCell>
                        </TableRow>
                      ))}
                    </TableBody>
                  </Table>
                </TableContainer>
              </CardContent>{" "}
            </Card>{" "}
          </Grid>
          {}{" "}
          <Grid item xs={12} lg={4}>
            {" "}
            {}{" "}
            <Card sx={{ mb: 3 }}>
              <CardContent>
                <Typography variant="h6" gutterBottom>
                  Summary{" "}
                </Typography>{" "}
                <List>
                  <ListItem>
                    <ListItemIcon>
                      <Assignment />
                    </ListItemIcon>{" "}
                    <ListItemText
                      primary="Transaction ID"
                      secondary={transaction.id || transaction._id}
                    />
                  </ListItem>{" "}
                  <ListItem>
                    <ListItemIcon>
                      <QrCode />
                    </ListItemIcon>
                    <ListItemText
                      primary="Copy Barcode"
                      secondary={firstItem?.copyId || transaction.copyId}
                    />
                  </ListItem>
                  <ListItem>
                    <ListItemIcon>
                      <CalendarToday />
                    </ListItemIcon>{" "}
                    <ListItemText
                      primary="Days Borrowed"
                      secondary={
                        transaction.returnDate
                          ? Math.ceil(
                              (new Date(transaction.returnDate) -
                                new Date(transaction.borrowDate)) /
                                (1000 * 60 * 60 * 24),
                            )
                          : Math.ceil(
                              (new Date() - new Date(transaction.borrowDate)) /
                                (1000 * 60 * 60 * 24),
                            )
                      }
                    />{" "}
                  </ListItem>{" "}
                  {finesEnabled && fine > 0 && (
                    <ListItem>
                      <ListItemIcon>
                        <CurrencyExchange />
                      </ListItemIcon>{" "}
                      <ListItemText
                        primary="Fine Amount"
                          secondary={formatCurrency(fine)}
                      />{" "}
                    </ListItem>
                  )}{" "}
                </List>{" "}
              </CardContent>{" "}
            </Card>
            {}{" "}
            {canManageTransaction && (
              <Card>
                <CardContent>
                  <Typography variant="h6" gutterBottom>
                    Quick Actions{" "}
                  </Typography>{" "}
                  <Box display="flex" flexDirection="column" gap={1}>
                    <Button
                      fullWidth
                      variant="outlined"
                      startIcon={<Note />}
                      onClick={() => setEditNotesDialog(true)}
                    >
                      Edit Notes{" "}
                    </Button>{" "}
                    {transaction.status === "requested" && (
                      <Button
                        fullWidth
                        variant="contained"
                        startIcon={<CheckCircle />}
                        onClick={() => setApproveDialogOpen(true)}
                      >
                        Approve Request
                      </Button>
                    )}
                    {canProcessReturn && (
                      <Button
                        fullWidth
                        variant="contained"
                        startIcon={<AssignmentReturn />}
                        onClick={() => setReturnDialog(true)}
                      >
                        Process Return{" "}
                      </Button>
                    )}{" "}
                    {canMarkMissing && (
                      <Button
                        fullWidth
                        color="error"
                        variant="outlined"
                        startIcon={<Warning />}
                        onClick={() => setMarkMissingDialogOpen(true)}
                      >
                        Mark Missing{" "}
                      </Button>
                    )}{" "}
                  </Box>{" "}
                </CardContent>{" "}
              </Card>
            )}{" "}
          </Grid>{" "}
        </Grid>
        {}{" "}
        <Dialog open={returnDialog} onClose={() => setReturnDialog(false)}>
          <DialogTitle> Return Book </DialogTitle>{" "}
          <DialogContent>
            <DateTimePicker
              label="Return Date"
              value={returnDate}
              onChange={(newValue) => setReturnDate(newValue)}
              slotProps={{
                textField: {
                  fullWidth: true,
                  margin: "normal",
                },
              }}
              maxDate={new Date()}
            />{" "}
                {finesEnabled && fine > 0 && (
              <Alert severity="warning" sx={{ mt: 2 }}>
                      Late return fine: {formatCurrency(fine)}{" "}
              </Alert>
            )}{" "}
          </DialogContent>{" "}
          <DialogActions>
            <Button variant="outlined" onClick={() => setReturnDialog(false)}> Cancel </Button>{" "}
            <Button
              onClick={handleReturnBook}
              variant="contained"
              disabled={actionLoading}
            >
              {actionLoading ? "Processing..." : "Return Book"}{" "}
            </Button>{" "}
          </DialogActions>{" "}
        </Dialog>
        {}{" "}
        <Dialog
          open={editNotesDialog}
          onClose={() => setEditNotesDialog(false)}
          maxWidth="sm"
          fullWidth
        >
          <DialogTitle> Edit Transaction Notes </DialogTitle>{" "}
          <DialogContent>
            <TextField
              fullWidth
              multiline
              rows={4}
              label="Notes"
              value={notes}
              onChange={(e) => setNotes(e.target.value)}
              margin="normal"
              placeholder="Add any notes about this transaction..."
            />
          </DialogContent>{" "}
          <DialogActions>
            <Button variant="outlined" onClick={() => setEditNotesDialog(false)}> Cancel </Button>{" "}
            <Button
              onClick={handleUpdateNotes}
              variant="contained"
              disabled={actionLoading}
            >
              {actionLoading ? "Updating..." : "Update Notes"}{" "}
            </Button>{" "}
          </DialogActions>{" "}
        </Dialog>{" "}
        <ApproveRequestDialog
          open={approveDialogOpen}
          transactionId={id}
          onClose={handleApproveClose}
          onApproved={handleApproveSuccess}
          onNavigateToRequests={() => {
            setApproveDialogOpen(false);
            navigate("/transactions/requests");
          }}
        />
        <Dialog
          open={markMissingDialogOpen}
          onClose={() => {
            if (!markMissingLoading) {
              setMarkMissingDialogOpen(false);
            }
          }}
          maxWidth="sm"
          fullWidth
        >
          <DialogTitle>Mark Transaction as Missing</DialogTitle>{" "}
          <DialogContent>
            <Typography variant="body2" color="textSecondary" gutterBottom>
              Flag all outstanding items on this transaction as missing. This action notifies the borrower and updates reports.
            </Typography>
            <TextField
              fullWidth
              multiline
              rows={3}
              margin="normal"
              label="Reason (optional)"
              value={missingReason}
              onChange={(e) => setMissingReason(e.target.value)}
              placeholder="Provide additional context for the borrower"
            />
          </DialogContent>{" "}
          <DialogActions>
            <Button
              variant="outlined"
              onClick={() => {
                if (!markMissingLoading) {
                  setMarkMissingDialogOpen(false);
                  setMissingReason("");
                }
              }}
              disabled={markMissingLoading}
            >
              Cancel
            </Button>{" "}
            <Button
              color="error"
              variant="contained"
              onClick={handleMarkMissing}
              disabled={markMissingLoading}
            >
              {markMissingLoading ? "Marking..." : "Confirm Missing"}
            </Button>{" "}
          </DialogActions>{" "}
        </Dialog>
      </Box>{" "}
    </LocalizationProvider>
  );
};

function formatActionLabel(action) {
  if (!action) return '';
  switch (action) {
    case 'create':
      return 'Transaction Created';
    case 'approve':
      return 'Approved';
    case 'reject':
      return 'Rejected';
    case 'return':
      return 'Returned';
    case 'renew':
      return 'Renewed';
    case 'update':
      return 'Updated';
    case 'fine':
      return 'Fine Issued';
    default:

      return action.charAt(0).toUpperCase() + action.slice(1);
  }
}

export default TransactionDetails;
```

## TransactionsList.js

| Field | Details |
| --- | --- |
| Program Name | TransactionsList.js |
| Description | Frontend page view for routing and page-level UI. |
| Called by | App.js |
| Table used | transactions |
|  |  |
| Programmer | Nazel Asca√±o |
| Date created | 12/14/2025 |
| Revision Date | TBD |
| Revision / description of change | None |

```javascript
import React, { useState, useEffect, useCallback, useRef } from "react";
import { useNavigate, useLocation } from "react-router-dom";
import {
  Alert,
  Box,
  Button,
  Card,
  CardContent,
  Chip,
  Dialog,
  DialogActions,
  DialogContent,
  DialogTitle,
  FormControl,
  Grid,
  IconButton,
  InputLabel,
  LinearProgress,
  Menu,
  MenuItem,
  Paper,
  Select,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TablePagination,
  TableRow,
  TextField,
  Typography,
} from "@mui/material";
import {
  MoreVert,
  Visibility,
  Assignment,
  AssignmentReturn,
  Search,
  Warning,
  CheckCircle,
  Schedule,
  Cancel,
  History,
  AutoStories,
  Print,
  FilterList,
  ListAlt,
} from "@mui/icons-material";
import QRScanner from "../../components/QRScanner";
import MobileScanButton from "../../components/MobileScanButton";
import MobileScanDialog from "../../components/MobileScanDialog";
import ApproveRequestDialog from "../../components/Transactions/ApproveRequestDialog";
import { useAuth } from "../../contexts/AuthContext";
import { useSettings } from "../../contexts/SettingsContext";
import { api, settingsAPI } from "../../utils/api";
import { generateTransactionReceipt, downloadPDF } from "../../utils/pdfGenerator";
import toast from "react-hot-toast";
import { addActionButtonSx, importActionButtonSx } from "../../theme/actionButtons";

const RETURNABLE_STATUSES = new Set(["active", "borrowed", "overdue", "renewed", "missing"]);

const isReturnableStatus = (status) => {
  if (!status) {
    return false;
  }
  return RETURNABLE_STATUSES.has(String(status).toLowerCase());
};

const TransactionsList = () => {
  const navigate = useNavigate();
  const { user } = useAuth();
  const { finesEnabled } = useSettings();
  const location = useLocation();
  const [transactions, setTransactions] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState("");
  const [searchTerm, setSearchTerm] = useState("");
  const [searchScannerOpen, setSearchScannerOpen] = useState(false);
  const searchInputId = "transactions-search-input";
  const [statusFilter, setStatusFilter] = useState(() => {
    const params = new URLSearchParams(location.search || "");
    const rawStatus = (params.get("status") || "").toLowerCase();
    const allowedStatuses = new Set(["requested", "active", "returned", "overdue", "lost", "missing"]);
    return allowedStatuses.has(rawStatus) ? rawStatus : "all";
  });
  const [typeFilter, setTypeFilter] = useState(() => {
    const params = new URLSearchParams(location.search || "");
    const rawType = (params.get("type") || "").toLowerCase();
    const allowedTypes = new Set(["regular", "annual"]);
    return allowedTypes.has(rawType) ? rawType : "all";
  });
  const [page, setPage] = useState(0);
  const [rowsPerPage, setRowsPerPage] = useState(10);
  const [totalCount, setTotalCount] = useState(0);
  const [anchorEl, setAnchorEl] = useState(null);
  const [selectedTransaction, setSelectedTransaction] = useState(null);

  const [stats, setStats] = useState({
    total: 0,
    borrowed: 0,
    overdue: 0,
    returned: 0,
  });

  const [borrowingSettings, setBorrowingSettings] = useState({
    annualBorrowingEnabled: true,
    overnightBorrowingEnabled: false,
  });

  const [returnDialogOpen, setReturnDialogOpen] = useState(false);
  const [returnCopyInput, setReturnCopyInput] = useState("");
  const [returnError, setReturnError] = useState("");

  const [scannerOpen, setScannerOpen] = useState(false);

  const [approveDialogOpen, setApproveDialogOpen] = useState(false);
  const [approveTransactionId, setApproveTransactionId] = useState(null);
  const [rejectDialogOpen, setRejectDialogOpen] = useState(false);
  const [rejectTransactionId, setRejectTransactionId] = useState(null);
  const [rejectReason, setRejectReason] = useState("");
  const [rejectSubmitting, setRejectSubmitting] = useState(false);
  const [rejectError, setRejectError] = useState("");
  const copyIdInputRef = useRef(null);
  const hasAppliedUrlFiltersRef = useRef(false);

  const [filterAnchorEl, setFilterAnchorEl] = useState(null);
  const filtersOpen = Boolean(filterAnchorEl);
  const openFilters = (e) => setFilterAnchorEl(e.currentTarget);
  const closeFilters = () => setFilterAnchorEl(null);

  useEffect(() => {
    if (returnDialogOpen) {

      const t = setTimeout(() => {
        try {
          copyIdInputRef.current?.focus?.();
          if (copyIdInputRef.current?.select) copyIdInputRef.current.select();
        } catch (err) {

        }
      }, 100);
      return () => clearTimeout(t);
    }
    return undefined;
  }, [returnDialogOpen]);

  useEffect(() => {
    if (!scannerOpen && returnDialogOpen) {

      const t = setTimeout(() => {
        try {
          copyIdInputRef.current?.focus?.();
          if (copyIdInputRef.current?.select) copyIdInputRef.current.select();
        } catch (err) {}
      }, 100);
      return () => clearTimeout(t);
    }
    return undefined;
  }, [scannerOpen, returnDialogOpen]);

  useEffect(() => {
    const params = new URLSearchParams(location.search || "");
    const rawStatus = (params.get("status") || "").toLowerCase();
    const allowedStatuses = new Set(["requested", "active", "returned", "overdue", "lost", "missing", "all"]);
    const nextStatus = allowedStatuses.has(rawStatus) ? rawStatus : "all";
    setStatusFilter((prev) => (prev === nextStatus ? prev : nextStatus));

    const rawType = (params.get("type") || "").toLowerCase();
    const allowedTypes = new Set(["regular", "annual", "all"]);
    const nextType = allowedTypes.has(rawType) ? rawType : "all";
    setTypeFilter((prev) => (prev === nextType ? prev : nextType));

    hasAppliedUrlFiltersRef.current = true;
  }, [location.search]);

  useEffect(() => {
    if (!hasAppliedUrlFiltersRef.current) {
      return;
    }

    const params = new URLSearchParams(location.search || "");
    let shouldUpdate = false;

    if (statusFilter === "all") {
      if (params.has("status")) {
        params.delete("status");
        shouldUpdate = true;
      }
    } else if (params.get("status") !== statusFilter) {
      params.set("status", statusFilter);
      shouldUpdate = true;
    }

    if (typeFilter === "all") {
      if (params.has("type")) {
        params.delete("type");
        shouldUpdate = true;
      }
    } else if (params.get("type") !== typeFilter) {
      params.set("type", typeFilter);
      shouldUpdate = true;
    }

    if (shouldUpdate) {
      const nextSearch = params.toString();
      navigate(
        {
          pathname: location.pathname,
          search: nextSearch ? `?${nextSearch}` : "",
        },
        { replace: true },
      );
    }
  }, [statusFilter, typeFilter, navigate, location.pathname, location.search]);

  const handleScannedCopy = async (value) => {
    const scanned = String(value || '').trim();
    setReturnCopyInput(scanned);
    setReturnError('');

    const items = Array.isArray(selectedTransaction?.items)
      ? selectedTransaction.items
      : [];
    const expectedCopyIds = items.length > 0
      ? items.map((it) => String(it.copyId || it.copyid || it.copyID || '').trim().toLowerCase()).filter(Boolean)
      : (selectedTransaction?.copyId ? [String(selectedTransaction.copyId).trim().toLowerCase()] : []);

    if (expectedCopyIds.length > 0) {
      if (!expectedCopyIds.includes(scanned.toLowerCase())) {
        setReturnError('Scanned Reference ID does not match the expected item(s).');
        toast.error('Scanned Reference ID does not match.');
        return; // don't proceed
      }
    }

    toast.loading('Processing return...');
    try {
      await handleReturnBook();
      toast.dismiss();
      toast.success('Return processed successfully');
      setScannerOpen(false);
      setReturnDialogOpen(false);
      setReturnCopyInput('');
      setReturnError('');
    } catch (err) {
      toast.dismiss();
      setReturnError('Failed to process return.');
      toast.error('Failed to process return');
      console.error('Error processing scanned return:', err);
    }
  };

  const fetchTransactions = useCallback(async () => {
    try {
      setLoading(true);
      setError("");
      const response = await api.get("/transactions", {
        params: {
          search: searchTerm || undefined,
          status: statusFilter !== "all" ? statusFilter : undefined,
          type: typeFilter !== "all" ? typeFilter : undefined,
          page: page + 1,
          limit: rowsPerPage,
        },
      });

      const data = Array.isArray(response.data)
        ? response.data
        : response.data?.transactions || [];

      setTransactions(data);
      const total = response.data?.pagination?.total ?? data.length;
      setTotalCount(total);
    } catch (error) {
      console.error("Error fetching transactions:", error);
      setTransactions([]);
      setTotalCount(0);
      setError("Failed to fetch transactions");
    } finally {
      setLoading(false);
    }
  }, [searchTerm, statusFilter, typeFilter, page, rowsPerPage]);

  const fetchStats = useCallback(async () => {
    try {
      const response = await api.get("/transactions/stats");
      setStats(response.data);
    } catch (error) {
      console.error("Error fetching transaction stats:", error);
    }
  }, []);

  const fetchBorrowingSettings = useCallback(async () => {
    try {
      const response = await api.get("/settings/borrowing-rules");
      setBorrowingSettings(response.data);
    } catch (error) {
      console.error("Error fetching borrowing settings:", error);
    }
  }, []);

  useEffect(() => {
    fetchTransactions();
  }, [fetchTransactions]);

  useEffect(() => {
    fetchStats();
  }, [fetchStats]);

  useEffect(() => {
    fetchBorrowingSettings();
  }, [fetchBorrowingSettings]);

  useEffect(() => {
    setPage(0);
  }, [searchTerm, statusFilter, typeFilter]);

  useEffect(() => {
    const totalPages = Math.max(1, Math.ceil(totalCount / rowsPerPage));
    if (page >= totalPages) {
      setPage(Math.max(0, totalPages - 1));
    }
  }, [totalCount, rowsPerPage, page]);

  const handleMenuClick = (event, transaction) => {
    setAnchorEl(event.currentTarget);
    setSelectedTransaction(transaction);
  };

  const handleMenuClose = (clearSelection = true) => {
    setAnchorEl(null);
    if (clearSelection) {
      setSelectedTransaction(null);
    }
  };

  const navigateToTransactionDetails = useCallback((transaction) => {
    if (!transaction) {
      setError("Transaction identifier is missing");
      return false;
    }
    const transactionId = getTransactionIdentifier(transaction);
    if (!transactionId) {
      setError("Transaction identifier is missing");
      return false;
    }
    navigate(`/transactions/${transactionId}`, { state: { from: location.pathname } });
    return true;
  }, [navigate, location.pathname]);

  const handleViewDetails = () => {

    const success = navigateToTransactionDetails(selectedTransaction);
    handleMenuClose();
    if (!success) {
      return;
    }
  };

  const getTransactionIdentifier = (transaction) =>
    transaction?.transactionId ||
    transaction?.id ||
    transaction?.documentId ||
    transaction?._id ||
    null;

  const getDisplayTransactionId = (transaction) =>
    getTransactionIdentifier(transaction) || "-";

  const resolveDueDateValue = (transaction) =>
    transaction?.dueDate || transaction?.metadata?.providedDueDate || null;

  const formatDate = (value) => {
    if (!value) {
      return "-";
    }
    const parsed = new Date(value);
    if (Number.isNaN(parsed.getTime())) {
      return "-";
    }
    return parsed.toLocaleDateString();
  };

  const handleReturnBook = async () => {
    const transactionId = getTransactionIdentifier(selectedTransaction);
    if (!transactionId) {
      setError("Transaction identifier is missing");
      return;
    }

    try {
      await api.post(`/transactions/${transactionId}/return`);
      await fetchTransactions();
      await fetchStats();
      handleMenuClose();
    } catch (error) {
      const message = error.response?.data?.message || "Failed to return book";
      setError(message);
      console.error("Error returning book:", error);
    }
  };

  const handlePrintReceiptFor = async (transaction) => {
    const toastId = toast.loading("Generating receipt...");
    try {
      const transactionId = getTransactionIdentifier(transaction);
      if (!transactionId) {
        setError("Transaction identifier is missing");
        toast.error("Missing transaction identifier", { id: toastId });
        return;
      }

      const { data: transactionData } = await api.get(
        `/transactions/${transactionId.trim()}`
      );

      const normalizeBorrower = (profile, fallbackName = "") => {
        if (!profile) {
          return null;
        }

        const extractedName = (() => {
          const full = profile.fullName || fallbackName || profile.name || "";
          if (profile.firstName || profile.lastName) {
            return {
              firstName: profile.firstName || "",
              lastName: profile.lastName || "",
              fullName: `${profile.firstName || ""} ${profile.lastName || ""}`.trim() || full,
            };
          }
          if (!full) {
            return { firstName: "", lastName: "", fullName: "" };
          }

          const parts = full.split(" ").filter(Boolean);
          if (parts.length === 1) {
            return { firstName: parts[0], lastName: "", fullName: full };
          }
          const lastName = parts.pop();
          return { firstName: parts.join(" "), lastName, fullName: full };
        })();

        return {
          firstName: extractedName.firstName,
          lastName: extractedName.lastName,
          fullName: extractedName.fullName,
          studentId:
            profile.studentId ||
            profile.id ||
            profile.uid ||
            profile.userId ||
            transactionData?.userId ||
            "",
          libraryCardNumber:
            profile.libraryCardNumber ||
            profile.libraryCard ||
            profile.library?.cardNumber ||
            transaction.borrowerLibraryCardNumber ||
            "",
        };
      };

      let borrowerProfile = normalizeBorrower(
        transactionData?.user || transactionData?.student,
        transactionData?.borrowerName
      );

      if (!borrowerProfile && transactionData?.userId) {
        try {
          const { data: studentResponse } = await api.get(
            `/students/${transactionData.userId}`
          );
          borrowerProfile = normalizeBorrower(
            studentResponse?.student || studentResponse,
            transactionData?.borrowerName
          );
        } catch (studentError) {
          console.debug("Failed to load student profile", studentError);
        }
      }

      if (!borrowerProfile) {
        borrowerProfile = normalizeBorrower(
          {
            firstName: transaction.borrowerFirstName,
            lastName: transaction.borrowerLastName,
            fullName:
              transaction.borrowerName ||
              transactionData?.borrowerName ||
              transactionData?.userId ||
              "",
            studentId: transaction.borrowerStudentId,
            libraryCardNumber: transaction.borrowerLibraryCardNumber,
          },
          transaction.borrowerName || transactionData?.borrowerName || ""
        );
      }

      if (!borrowerProfile) {
        borrowerProfile = {
          firstName: transactionData?.userId || "",
          lastName: "",
          fullName: transactionData?.userId || "",
          studentId: transactionData?.userId || "",
          libraryCardNumber: "",
        };
      }

      const items = Array.isArray(transactionData?.items)
        ? transactionData.items
        : [];

      const booksData = items.length > 0
        ? items.map((item) => ({
            title: item?.book?.title || item?.title || transaction.bookTitle || "Unknown",
            isbn: item?.isbn || item?.book?.isbn || item?.bookId || "N/A",
            copyId: item?.copyId || "N/A",
          }))
        : [
            {
              title: transaction.bookTitle || "Unknown",
              isbn: transaction.isbn || "N/A",
              copyId: transaction.copyId || "N/A",
            },
          ];

      const libraryResponse = await settingsAPI.getByCategory('library');
      const librarySettings = libraryResponse.data || {};

      const transactionPDF = await generateTransactionReceipt(
        transactionData,
        borrowerProfile,
        booksData,
        librarySettings
      );

      const filenameId = transactionData?.id || transactionData?._id || transactionId;
      downloadPDF(transactionPDF, `receipt_${filenameId}.pdf`);
      setError("");
      toast.success("Receipt generated successfully!", { id: toastId });
    } catch (error) {
      console.error("Error generating receipt:", error);
      setError("Failed to generate receipt");
      toast.error("Failed to generate receipt", { id: toastId });
    }
  };

  const handleApproveRequest = () => {
    const transactionId = getTransactionIdentifier(selectedTransaction);
    if (!transactionId) {
      setError("Transaction identifier is missing");
      return;
    }
    setApproveTransactionId(transactionId);
    setApproveDialogOpen(true);
  };

  const handleApproveDialogClose = () => {
    setApproveDialogOpen(false);
    setApproveTransactionId(null);
  };

  const handleApproveDialogApproved = async () => {
    await fetchTransactions();
    await fetchStats();
    handleMenuClose();
  };

  const handleRejectRequest = () => {
    const transactionId = getTransactionIdentifier(selectedTransaction);
    if (!transactionId) {
      setError("Transaction identifier is missing");
      return;
    }
    setRejectTransactionId(transactionId);
    setRejectReason("");
    setRejectError("");
    setRejectDialogOpen(true);
  };

  const handleRejectDialogClose = () => {
    if (rejectSubmitting) {
      return;
    }
    setRejectDialogOpen(false);
    setRejectTransactionId(null);
    setRejectReason("");
    setRejectError("");
  };

  const handleRejectDialogConfirm = async () => {
    if (!rejectTransactionId) {
      setRejectError("Transaction identifier is missing");
      return;
    }

    setRejectSubmitting(true);
    setRejectError("");
    const toastId = toast.loading("Rejecting request...");
    try {
      await api.post(`/transactions/reject/${rejectTransactionId}`, {
        reason: rejectReason.trim() || undefined,
      });
      toast.success("Request rejected", { id: toastId });
      await fetchTransactions();
      await fetchStats();
      setRejectDialogOpen(false);
      setRejectTransactionId(null);
      setRejectReason("");
      setRejectError("");
      handleMenuClose();
    } catch (err) {
      const message = err.response?.data?.message || "Failed to reject request";
      setRejectError(message);
      toast.error(message, { id: toastId });
    } finally {
      setRejectSubmitting(false);
    }
  };

  const handleConfirmReturn = async () => {

    const items = Array.isArray(selectedTransaction?.items)
      ? selectedTransaction.items
      : [];
    const expectedCopyIds = items.length > 0
      ? items.map((it) => String(it.copyId || it.copyid || it.copyID || '').trim().toLowerCase()).filter(Boolean)
      : (selectedTransaction?.copyId ? [String(selectedTransaction.copyId).trim().toLowerCase()] : []);

    if (expectedCopyIds.length > 0) {
      if (!returnCopyInput || !expectedCopyIds.includes(returnCopyInput.trim().toLowerCase())) {
        setReturnError("Reference ID does not match. Please enter the correct Reference ID to confirm return.");
        return;
      }
    }

    try {
      await handleReturnBook();
      setReturnDialogOpen(false);
      setReturnCopyInput("");
      setReturnError("");
    } catch (err) {
      setReturnError("Failed to return book. Try again.");
      console.error(err);
    }
  };

  const getStatusColor = (status) => {
    switch (status) {
      case "active":
        return "primary";
      case "returned":
        return "success";
      case "overdue":
        return "error";
      case "renewed":
        return "warning";
      case "lost":
      case "missing":
        return "error";
      default:
        return "default";
    }
  };

  const getStatusIcon = (status) => {
    switch (status) {
      case "active":
        return <CheckCircle />;
      case "returned":
        return <AssignmentReturn />;
      case "overdue":
        return <Warning />;
      case "renewed":
        return <Schedule />;
      case "lost":
      case "missing":
        return <Cancel />;
      default:
        return <History />;
    }
  };

  const isOverdue = (transaction) => {
    const dueValue = resolveDueDateValue(transaction);
    if (!dueValue) {
      return false;
    }
    const dueDate = new Date(dueValue);
    return transaction.status === "active" && dueDate < new Date();
  };

  const canManageTransactions =
    user?.role === "admin" ||
    user?.role === "librarian" ||
    user?.role === "staff";

  const canManageAnnualBorrowing =
    user?.role === "admin" || user?.role === "librarian";

  const displayedTransactions = transactions;
  return (
    <Box>
      <Box
        display="flex"
        justifyContent="space-between"
        alignItems={{ xs: "flex-start", sm: "center" }}
        flexWrap="wrap"
        gap={2}
        mb={3}
      >
        <Typography variant="h4" sx={{ flexGrow: 1 }} color={"white"}>
          Transaction Management
        </Typography>
        {(canManageTransactions || canManageAnnualBorrowing) && (
          <Box
            display="flex"
            gap={2}
            flexWrap="wrap"
            justifyContent="flex-end"
          >
            {canManageAnnualBorrowing && borrowingSettings.annualBorrowingEnabled && (
              <Button
                variant="outlined"
                startIcon={<AutoStories />}
                onClick={() => navigate("/annual-borrowing")}
                sx={{ ...importActionButtonSx, minWidth: 160 }}
              >
                Annual Borrowing
              </Button>
            )}
            <Button
              variant="outlined"
              startIcon={<ListAlt />}
              onClick={() => navigate("/transactions/requests")}
              sx={{ ...importActionButtonSx, minWidth: 170 }}
            >
              Borrow Requests
            </Button>
            <Button
              variant="outlined"
              startIcon={<Assignment />}
              onClick={() => navigate("/transactions/borrow")}
              sx={{ ...importActionButtonSx, minWidth: 140 }}
            >
              New Borrow
            </Button>
            <Button
              variant="contained"
              startIcon={<AssignmentReturn />}
              onClick={() => navigate("/transactions/return")}
              sx={{ ...addActionButtonSx, minWidth: 150 }}
            >
              Return Books
            </Button>
          </Box>
        )}
      </Box>
      {error && (
        <Alert severity="error" sx={{ mb: 2 }}>
          {error}
        </Alert>
      )}
      {}
      <Grid container spacing={2} sx={{ mb: 3 }}>
        <Grid item xs={12} sm={6} md={3}>
          <Card>
            <CardContent>
              <Box display="flex" alignItems="center">
                <History color="primary" sx={{ mr: 2 }} />
                <Box>
                  <Typography variant="h6">{stats.total}</Typography>
                  <Typography variant="body2" color="textSecondary">
                    Total Transactions
                  </Typography>
                </Box>
              </Box>
            </CardContent>
          </Card>
        </Grid>
        <Grid item xs={12} sm={6} md={3}>
          <Card>
            <CardContent>
              <Box display="flex" alignItems="center">
                <CheckCircle color="primary" sx={{ mr: 2 }} />
                <Box>
                  <Typography variant="h6">{stats.borrowed}</Typography>
                  <Typography variant="body2" color="textSecondary">
                    Borrowed Transactions
                  </Typography>
                </Box>
              </Box>
            </CardContent>
          </Card>
        </Grid>
        {finesEnabled ? (
          <Grid item xs={12} sm={6} md={3}>
            <Card>
              <CardContent>
                <Box display="flex" alignItems="center">
                  <Warning color="error" sx={{ mr: 2 }} />
                  <Box>
                    <Typography variant="h6">{stats.overdue}</Typography>
                    <Typography variant="body2" color="textSecondary">
                      Overdue Books
                    </Typography>
                  </Box>
                </Box>
              </CardContent>
            </Card>
          </Grid>
        ) : null}
        <Grid item xs={12} sm={6} md={3}>
          <Card>
            <CardContent>
              <Box display="flex" alignItems="center">
                <AssignmentReturn color="success" sx={{ mr: 2 }} />
                <Box>
                  <Typography variant="h6">{stats.returned}</Typography>
                  <Typography variant="body2" color="textSecondary">
                    Total Returns
                  </Typography>
                </Box>
              </Box>
            </CardContent>
          </Card>
        </Grid>
      </Grid>
      {}
      <Box mb={3}>
        <Box display="flex" gap={2} flexWrap="wrap" alignItems="center">
          <TextField
            placeholder="Search books by title, author, or ISBN..."
            value={searchTerm}
            onChange={(e) => setSearchTerm(e.target.value)}
            sx={{ flex: 1, minWidth: 300 }}
            inputProps={{ id: searchInputId }}
            InputProps={{
              startAdornment: (
                <Search sx={{ mr: 1, color: "text.secondary" }} />
              ),
            }}
          />
          <MobileScanButton
            label="Scan to Search"
            onClick={() => setSearchScannerOpen(true)}
          />
          <IconButton
            aria-label="Open filters"
            onClick={openFilters}
            size="small"
            sx={{ border: "1px solid #E2E8F0", backgroundColor: "#F8FAFC" }}
          >
            <FilterList />
          </IconButton>
        </Box>
        <Menu
          anchorEl={filterAnchorEl}
          open={filtersOpen}
          onClose={closeFilters}
          anchorOrigin={{ vertical: "bottom", horizontal: "right" }}
          transformOrigin={{ vertical: "top", horizontal: "right" }}
          PaperProps={{ sx: { p: 2, minWidth: 220 } }}
        >
          <Box sx={{ display: "flex", flexDirection: "column", gap: 1 }}>
            <FormControl fullWidth size="small">
              <InputLabel>Status</InputLabel>
              <Select
                value={statusFilter}
                onChange={(e) => setStatusFilter(e.target.value)}
                label="Status"
              >
                <MenuItem value="all">All Status</MenuItem>
                <MenuItem value="requested">Requested</MenuItem>
                <MenuItem value="active">Borrowed</MenuItem>
                <MenuItem value="returned">Returned</MenuItem>
                <MenuItem value="overdue">Overdue</MenuItem>
                <MenuItem value="lost">Lost</MenuItem>
                <MenuItem value="missing">Missing</MenuItem>
              </Select>
            </FormControl>

            <FormControl fullWidth size="small">
              <InputLabel>Type</InputLabel>
              <Select
                value={typeFilter}
                onChange={(e) => setTypeFilter(e.target.value)}
                label="Type"
              >
                <MenuItem value="all">All Types</MenuItem>
                <MenuItem value="regular">Regular</MenuItem>
                <MenuItem value="annual">Annual</MenuItem>
              </Select>
            </FormControl>
            <Box display="flex" justifyContent="flex-end" gap={1} mt={1}>
              <Button size="small" onClick={() => { setStatusFilter("all"); setTypeFilter("all"); closeFilters(); }}>
                Clear
              </Button>
              <Button size="small" variant="contained" onClick={closeFilters}>
                Apply
              </Button>
            </Box>
          </Box>
        </Menu>
      </Box>
      {}
      <Paper>
        {loading && <LinearProgress />}
        <TableContainer sx={{ overflowX: "auto" }}>
          <Table size="small" stickyHeader>
            <TableHead>
              <TableRow>
                <TableCell>Transaction ID</TableCell>
                <TableCell>Book Title</TableCell>
                <TableCell>Reference ID</TableCell>
                <TableCell>Borrower</TableCell>
                <TableCell>Borrow Date</TableCell>
                <TableCell>Due Date</TableCell>
                <TableCell>Return Date</TableCell>
                <TableCell>Status</TableCell>
                <TableCell>Type</TableCell>
                <TableCell align="center">Actions</TableCell>
              </TableRow>
            </TableHead>
            <TableBody>
              {loading ? (
                <TableRow>
                  <TableCell colSpan={10} align="center">
                    <Typography variant="body2" color="text.secondary">
                      Loading transactions...
                    </Typography>
                  </TableCell>
                </TableRow>
              ) : displayedTransactions.length === 0 ? (
                <TableRow>
                  <TableCell colSpan={10} align="center">
                    <Typography variant="body2" color="text.secondary">
                      No transactions found
                    </Typography>
                  </TableCell>
                </TableRow>
              ) : (
                displayedTransactions.map((transaction) => (
                  <TableRow
                    hover
                    key={
                      transaction._id ||
                      transaction.documentId ||
                      transaction.id ||
                      transaction.copyId
                    }
                    onDoubleClick={() => navigateToTransactionDetails(transaction)}
                    sx={{ cursor: 'pointer' }}
                  >
                    <TableCell sx={{ maxWidth: 220 }}>
                      <Typography
                        variant="body2"
                        sx={{ fontFamily: "monospace", wordBreak: "break-all" }}
                      >
                        {getDisplayTransactionId(transaction)}
                      </Typography>
                    </TableCell>
                    <TableCell sx={{ maxWidth: 220 }}>
                      <Typography
                        variant="body2"
                        fontWeight="medium"
                        sx={{ whiteSpace: "normal" }}
                      >
                        {transaction.bookTitle || "Unknown Book"}
                      </Typography>
                      <Typography variant="caption" color="textSecondary">
                        {transaction.author || ""}
                      </Typography>
                    </TableCell>
                    <TableCell sx={{ whiteSpace: "nowrap", wordBreak: "break-all" }}>
                      {transaction.copyId || "-"}
                    </TableCell>
                    <TableCell sx={{ maxWidth: 200 }}>
                      <Typography variant="body2">
                        {transaction.borrowerName || "Unknown Borrower"}
                      </Typography>
                    </TableCell>
                    <TableCell>
                      {formatDate(transaction.borrowDate)}
                    </TableCell>
                    <TableCell>
                      <Box display="flex" alignItems="center">
                        {finesEnabled && isOverdue(transaction) && (
                          <Warning color="error" sx={{ mr: 1, fontSize: 16 }} />
                        )}
                        {formatDate(resolveDueDateValue(transaction))}
                      </Box>
                    </TableCell>
                    <TableCell sx={{ whiteSpace: "nowrap" }}>
                      {formatDate(transaction.returnDate)}
                    </TableCell>
                    <TableCell>
                      <Chip
                        icon={getStatusIcon(transaction.status)}
                        label={transaction.status}
                        color={getStatusColor(transaction.status)}
                        size="small"
                      />
                    </TableCell>
                    <TableCell>
                      <Chip
                        label={transaction.type || "regular"}
                        variant="outlined"
                        size="small"
                      />
                    </TableCell>
                    <TableCell align="center">
                      <Box display="flex" justifyContent="center" gap={1}>
                        {canManageTransactions && (
                          <IconButton
                            size="small"
                            aria-label={`Print receipt for ${getDisplayTransactionId(transaction)}`}
                            onClick={() => handlePrintReceiptFor(transaction)}
                          >
                            <Print />
                          </IconButton>
                        )}
                        <IconButton
                          onClick={(e) => handleMenuClick(e, transaction)}
                          size="small"
                          aria-label={`Actions for transaction ${getDisplayTransactionId(transaction)}`}
                        >
                          <MoreVert />
                        </IconButton>
                      </Box>
                    </TableCell>
                  </TableRow>
                ))
              )}
            </TableBody>
          </Table>
        </TableContainer>
        <TablePagination
          rowsPerPageOptions={[5, 10, 25, 50]}
          component="div"
          count={totalCount}
          rowsPerPage={rowsPerPage}
          page={page}
          onPageChange={(event, newPage) => setPage(newPage)}
          onRowsPerPageChange={(event) => {
            setRowsPerPage(parseInt(event.target.value, 10));
            setPage(0);
          }}
        />
      </Paper>
      {}
      <Menu
        anchorEl={anchorEl}
        open={Boolean(anchorEl)}
        onClose={handleMenuClose}
      >
        <MenuItem onClick={handleViewDetails}>
          <Visibility sx={{ mr: 1 }} />
          View Details
        </MenuItem>
        {canManageTransactions && isReturnableStatus(selectedTransaction?.status) && (
          <MenuItem onClick={() => { handleMenuClose(false); setReturnCopyInput(""); setReturnError(""); setReturnDialogOpen(true); }}>
            <AssignmentReturn sx={{ mr: 1 }} />
            Return Book
          </MenuItem>
        )}
        {canManageTransactions && selectedTransaction?.status === "requested" && (
          <>
            <MenuItem onClick={() => { handleMenuClose(false); handleApproveRequest(); }}>
              <CheckCircle sx={{ mr: 1 }} />
              Approve Request
            </MenuItem>
            <MenuItem onClick={() => { handleMenuClose(false); handleRejectRequest(); }}>
              <Cancel sx={{ mr: 1 }} />
              Reject Request
            </MenuItem>
          </>
        )}
      </Menu>
      {}
      {}
      <Dialog
        open={returnDialogOpen}
        onClose={() => setReturnDialogOpen(false)}
        maxWidth="xs"
        fullWidth
      >
        <DialogTitle>Confirm Return</DialogTitle>
        <DialogContent>
          <Typography gutterBottom>
            To confirm the return, please enter the Reference ID of the book being returned.
          </Typography>
          <Box display="flex" gap={1} alignItems="center">
            <TextField
              label="Reference ID"
              value={returnCopyInput}
              onChange={(e) => { setReturnCopyInput(e.target.value); setReturnError(""); }}
              fullWidth
              margin="dense"
              autoFocus
              inputRef={copyIdInputRef}
            />
            <Button
              variant="outlined"
              size="small"
              onClick={() => setScannerOpen(true)}
              sx={{ height: 40, display: { xs: "none", sm: "inline-flex" } }}
            >
              Scan QR
            </Button>
          </Box>
          <MobileScanButton
            label="Scan Reference QR"
            onClick={() => setScannerOpen(true)}
          />
          {returnError && (
            <Typography color="error" variant="caption" display="block" sx={{ mt: 1 }}>
              {returnError}
            </Typography>
          )}
        </DialogContent>
        <DialogActions>
          <Button variant="outlined" onClick={() => setReturnDialogOpen(false)}>Cancel</Button>
          <Button onClick={handleConfirmReturn} variant="contained" color="primary">
            Confirm Return
          </Button>
        </DialogActions>
      </Dialog>
      <Dialog
        open={rejectDialogOpen}
        onClose={handleRejectDialogClose}
        maxWidth="xs"
        fullWidth
      >
        <DialogTitle>Reject Request</DialogTitle>
        <DialogContent>
          <Typography gutterBottom>
            Optionally include a note so the borrower knows why the request was rejected.
          </Typography>
          {rejectError && (
            <Alert severity="error" sx={{ mb: 2 }}>
              {rejectError}
            </Alert>
          )}
          <TextField
            label="Reason"
            value={rejectReason}
            onChange={(e) => setRejectReason(e.target.value)}
            multiline
            minRows={3}
            fullWidth
            placeholder="Optional"
            autoFocus
          />
        </DialogContent>
        <DialogActions>
          <Button variant="outlined" onClick={handleRejectDialogClose} disabled={rejectSubmitting}>
            Cancel
          </Button>
          <Button
            onClick={handleRejectDialogConfirm}
            variant="contained"
            color="error"
            disabled={rejectSubmitting}
          >
            {rejectSubmitting ? "Rejecting..." : "Reject Request"}
          </Button>
        </DialogActions>
      </Dialog>
      <ApproveRequestDialog
        open={approveDialogOpen}
        transactionId={approveTransactionId}
        onClose={handleApproveDialogClose}
        onApproved={handleApproveDialogApproved}
        onNavigateToRequests={() => {
          handleApproveDialogClose();
          handleMenuClose();
          navigate("/transactions/requests");
        }}
      />

        <MobileScanDialog
          open={searchScannerOpen}
          onClose={() => setSearchScannerOpen(false)}
          onDetected={(value) => setSearchTerm(value || "")}
          title="Scan to Search Transactions"
          elementId="transactions-search-qr"
          targetSelector={`#${searchInputId}`}
        />

      {}
      <Dialog open={scannerOpen} onClose={() => setScannerOpen(false)} maxWidth="xs" fullWidth>
        <DialogTitle>Scan QR Code</DialogTitle>
        <DialogContent>
          <QRScanner
            elementId="transaction-qr-scanner"
            onDetected={(value) => {

              handleScannedCopy(value);
            }}
            onClose={() => setScannerOpen(false)}
          />
        </DialogContent>
        <DialogActions>
          <Button variant="outlined" onClick={() => setScannerOpen(false)}>Cancel</Button>
        </DialogActions>
      </Dialog>
    </Box>
  );
};

export default TransactionsList;
```

## UnauthorizedPage.js

| Field | Details |
| --- | --- |
| Program Name | UnauthorizedPage.js |
| Description | Frontend page view for routing and page-level UI. |
| Called by | App.js |
| Table used | None |
|  |  |
| Programmer | Nazel Asca√±o |
| Date created | 12/14/2025 |
| Revision Date | TBD |
| Revision / description of change | None |

```javascript
import React from "react";
import { Box, Typography, Paper, Button } from "@mui/material";
import { useNavigate } from "react-router-dom";

const UnauthorizedPage = () => {
  const navigate = useNavigate();

  return (
    <Box
      display="flex"
      justifyContent="center"
      alignItems="center"
      minHeight="60vh"
    >
      <Paper sx={{ p: 4, textAlign: "center" }}>
        <Typography variant="h1" color="error" gutterBottom>
          403{" "}
        </Typography>{" "}
        <Typography variant="h5" gutterBottom>
          Access Denied{" "}
        </Typography>{" "}
        <Typography variant="body1" color="text.secondary" gutterBottom>
          You don 't have permission to access this page.{" "}
        </Typography>{" "}
        <Button
          variant="contained"
          onClick={() => navigate("/")}
          sx={{ mt: 2 }}
        >
          Go Back{" "}
        </Button>{" "}
      </Paper>{" "}
    </Box>
  );
};

export default UnauthorizedPage;
```

## UserForm.js

| Field | Details |
| --- | --- |
| Program Name | UserForm.js |
| Description | Frontend page view for routing and page-level UI. |
| Called by | App.js |
| Table used | users |
|  |  |
| Programmer | Nazel Asca√±o |
| Date created | 12/14/2025 |
| Revision Date | TBD |
| Revision / description of change | None |

```javascript
import React, { useEffect, useMemo, useState } from "react";
import { useNavigate, useParams } from "react-router-dom";
import {
  Alert,
  Avatar,
  Box,
  Button,
  Card,
  CardContent,
  Checkbox,
  Autocomplete,
  FormControl,
  FormControlLabel,
  Grid,
  IconButton,
  InputAdornment,
  InputLabel,
  MenuItem,
  Select,
  TextField,
  Typography,
} from "@mui/material";
import {
  ArrowBack,
  Cancel,
  Email,
  Person,
  Phone,
  Save,
  Visibility,
  VisibilityOff,
} from "@mui/icons-material";
import { useAuth } from "../../contexts/AuthContext";
import { api, settingsAPI } from "../../utils/api";
import { ensureUserAttributes } from "../../utils/userAttributes";
import {
  getProvinces,
  getMunicipalities,
  getBarangays,
} from "../../utils/addressService";

const ROLE_OPTIONS = [
  { value: "staff", label: "Staff" },
  { value: "librarian", label: "Librarian" },
  { value: "admin", label: "Administrator" },
];

const PHONE_FIELD_NAMES = new Set(["phoneNumber"]);

const sanitizePhoneInput = (value = "") =>
  String(value ?? "").replace(/\D/g, "").slice(0, 11);

const composeFullAddress = ({ street = "", barangay = "", municipality = "", province = "" }) =>
  [street, barangay, municipality, province]
    .map((segment) => segment?.trim())
    .filter(Boolean)
    .join(", ");

const resolveAddressComponents = (raw = "") => {
  if (!raw) {
    return {
      street: "",
      barangay: "",
      municipality: "",
      province: "",
    };
  }

  const parts = raw
    .split(",")
    .map((part) => part.trim())
    .filter(Boolean);

  if (parts.length === 0) {
    return {
      street: raw,
      barangay: "",
      municipality: "",
      province: "",
    };
  }

  const province = parts.pop() || "";
  const municipality = parts.pop() || "";
  const barangay = parts.pop() || "";
  const street = parts.join(", ");

  return { street, barangay, municipality, province };
};

const DEFAULT_FORM_DATA = {
  username: "",
  email: "",
  firstName: "",
  lastName: "",
  password: "",
  confirmPassword: "",
  role: "student",
  studentId: "",
  curriculum: "",
  gradeLevel: "",
  phoneNumber: "",
  address: "",
  province: "",
  provinceCode: "",
  municipality: "",
  municipalityCode: "",
  barangay: "",
  barangayCode: "",
  isActive: true,
};

const UserForm = () => {
  const navigate = useNavigate();
  const { id } = useParams();
  const { user } = useAuth();
  const isEditing = Boolean(id);

  const [formData, setFormData] = useState({ ...DEFAULT_FORM_DATA });
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState("");
  const [success, setSuccess] = useState("");
  const [showPassword, setShowPassword] = useState(false);
  const [showConfirmPassword, setShowConfirmPassword] = useState(false);
  const [validationErrors, setValidationErrors] = useState({});
  const [userAttributes, setUserAttributes] = useState(() =>
    ensureUserAttributes(),
  );
  const [userAttributesError, setUserAttributesError] = useState("");
  const [provinceOptions, setProvinceOptions] = useState([]);
  const [municipalityOptions, setMunicipalityOptions] = useState([]);
  const [barangayOptions, setBarangayOptions] = useState([]);
  const [addressLoading, setAddressLoading] = useState({
    provinces: false,
    municipalities: false,
    barangays: false,
  });
  const [addressError, setAddressError] = useState("");

  const selectedProvinceOption = useMemo(
    () =>
      provinceOptions.find((option) => option.code === formData.provinceCode) ||
      null,
    [provinceOptions, formData.provinceCode],
  );

  const selectedMunicipalityOption = useMemo(
    () =>
      municipalityOptions.find(
        (option) => option.code === formData.municipalityCode,
      ) || null,
    [municipalityOptions, formData.municipalityCode],
  );

  const selectedBarangayOption = useMemo(
    () =>
      barangayOptions.find((option) => option.code === formData.barangayCode) ||
      null,
    [barangayOptions, formData.barangayCode],
  );

  useEffect(() => {
    let isMounted = true;

    const loadAttributes = async () => {
      try {
        const response = await settingsAPI.getUserAttributes();
        if (isMounted) {
          setUserAttributes(ensureUserAttributes(response.data));
          setUserAttributesError("");
        }
      } catch (attributesError) {
        console.error("Failed to load user attribute options:", attributesError);
        if (isMounted) {
          setUserAttributes(ensureUserAttributes());
          setUserAttributesError("Failed to load latest curriculum and grade options. Using defaults.");
        }
      }
    };

    loadAttributes();

    return () => {
      isMounted = false;
    };
  }, []);

  useEffect(() => {
    if (!isEditing) {
      return;
    }

    const loadUser = async () => {
      try {
        setLoading(true);
        const response = await api.get(`/users/${id}`);
        const userData = response.data || {};
        const resolvedAddress = resolveAddressComponents(
          userData.address || userData.profile?.address || userData.fullAddress || "",
        );

        setFormData({
          username: userData.username || "",
          email: userData.email || "",
          firstName: userData.firstName || "",
          lastName: userData.lastName || "",
          password: "",
          confirmPassword: "",
          curriculum: userData.curriculum || "",
          phoneNumber: sanitizePhoneInput(
            userData.phoneNumber || userData.profile?.phone,
          ),
          address:
            resolvedAddress.street ||
            userData.address ||
            userData.profile?.address ||
            "",
          province:
            userData.province ||
            resolvedAddress.province ||
            userData.profile?.province ||
            "",
          provinceCode: userData.provinceCode || "",
          municipality:
            userData.municipality ||
            resolvedAddress.municipality ||
            userData.profile?.municipality ||
            "",
          municipalityCode: userData.municipalityCode || "",
          barangay:
            userData.barangay ||
            resolvedAddress.barangay ||
            userData.profile?.barangay ||
            "",
          barangayCode: userData.barangayCode || "",
          isActive:
            typeof userData.isActive === "boolean" ? userData.isActive : true,
        });
        setError("");
        setSuccess("");
      } catch (loadError) {
        setError("Failed to fetch user details");
        console.error("Error fetching user:", loadError);
      } finally {
        setLoading(false);
      }
    };

    loadUser();
  }, [id, isEditing]);

  useEffect(() => {
  }, [formData.role]);

  useEffect(() => {
    setFormData((prev) => {
      const allowedCurriculum = userAttributes.curriculum || [];
      const allowedGradeLevels = userAttributes.gradeLevels || [];

      let nextCurriculum = prev.curriculum;
      let nextGradeLevel = prev.gradeLevel;

      if (
        nextCurriculum &&
        allowedCurriculum.length > 0 &&
        !allowedCurriculum.includes(nextCurriculum)
      ) {
        nextCurriculum = "";
      }

      if (
        nextGradeLevel &&
        allowedGradeLevels.length > 0 &&
        !allowedGradeLevels.includes(nextGradeLevel)
      ) {
        nextGradeLevel = "";
      }

      if (
        nextCurriculum !== prev.curriculum ||
        nextGradeLevel !== prev.gradeLevel
      ) {
        return {
          ...prev,
          curriculum: nextCurriculum,
          gradeLevel: nextGradeLevel,
        };
      }

      return prev;
    });
  }, [userAttributes]);

  useEffect(() => {
    let isMounted = true;

    const loadProvinces = async () => {
      setAddressLoading((prev) => ({ ...prev, provinces: true }));
      setAddressError("");
      try {
        const provinces = await getProvinces();
        if (isMounted) {
          setProvinceOptions(provinces);
        }
      } catch (provinceError) {
        console.error("Failed to load provinces:", provinceError);
        if (isMounted) {
          setAddressError("Unable to load provinces from PSGC API.");
        }
      } finally {
        if (isMounted) {
          setAddressLoading((prev) => ({ ...prev, provinces: false }));
        }
      }
    };

    loadProvinces();
    return () => {
      isMounted = false;
    };
  }, []);

  useEffect(() => {
    if (!formData.provinceCode) {
      setMunicipalityOptions([]);
      return;
    }

    let isMounted = true;
    setAddressLoading((prev) => ({ ...prev, municipalities: true }));

    const loadMunicipalities = async () => {
      try {
        const municipalities = await getMunicipalities(formData.provinceCode);
        if (isMounted) {
          setMunicipalityOptions(municipalities);
        }
      } catch (municipalityError) {
        console.error("Failed to load municipalities:", municipalityError);
        if (isMounted) {
          setAddressError("Unable to load municipalities for the selected province.");
        }
      } finally {
        if (isMounted) {
          setAddressLoading((prev) => ({ ...prev, municipalities: false }));
        }
      }
    };

    loadMunicipalities();
    return () => {
      isMounted = false;
    };
  }, [formData.provinceCode]);

  useEffect(() => {
    if (!formData.municipalityCode) {
      setBarangayOptions([]);
      return;
    }

    let isMounted = true;
    setAddressLoading((prev) => ({ ...prev, barangays: true }));

    const loadBarangays = async () => {
      try {
        const barangays = await getBarangays(formData.municipalityCode);
        if (isMounted) {
          setBarangayOptions(barangays);
        }
      } catch (barangayError) {
        console.error("Failed to load barangays:", barangayError);
        if (isMounted) {
          setAddressError("Unable to load barangays for the selected municipality.");
        }
      } finally {
        if (isMounted) {
          setAddressLoading((prev) => ({ ...prev, barangays: false }));
        }
      }
    };

    loadBarangays();
    return () => {
      isMounted = false;
    };
  }, [formData.municipalityCode]);

  useEffect(() => {
    if (
      !formData.province ||
      formData.provinceCode ||
      provinceOptions.length === 0
    ) {
      return;
    }
    const match = provinceOptions.find(
      (option) => option.name.toLowerCase() === formData.province.toLowerCase(),
    );
    if (match) {
      setFormData((prev) => ({
        ...prev,
        provinceCode: match.code,
      }));
    }
  }, [formData.province, formData.provinceCode, provinceOptions]);

  useEffect(() => {
    if (
      !formData.municipality ||
      formData.municipalityCode ||
      municipalityOptions.length === 0
    ) {
      return;
    }
    const match = municipalityOptions.find(
      (option) => option.name.toLowerCase() === formData.municipality.toLowerCase(),
    );
    if (match) {
      setFormData((prev) => ({
        ...prev,
        municipalityCode: match.code,
      }));
    }
  }, [
    formData.municipality,
    formData.municipalityCode,
    municipalityOptions,
  ]);

  useEffect(() => {
    if (!formData.barangay || formData.barangayCode || barangayOptions.length === 0) {
      return;
    }
    const match = barangayOptions.find(
      (option) => option.name.toLowerCase() === formData.barangay.toLowerCase(),
    );
    if (match) {
      setFormData((prev) => ({
        ...prev,
        barangayCode: match.code,
      }));
    }
  }, [formData.barangay, formData.barangayCode, barangayOptions]);

  const handleChange = (event) => {
    const { name, value, type, checked } = event.target;
    const isCheckbox = type === "checkbox";
    const sanitizedValue =
      !isCheckbox && PHONE_FIELD_NAMES.has(name)
        ? sanitizePhoneInput(value)
        : value;

    setFormData((prev) => ({
      ...prev,
      [name]: isCheckbox ? checked : sanitizedValue,
    }));

    if (validationErrors[name]) {
      setValidationErrors((prev) => ({
        ...prev,
        [name]: "",
      }));
    }
  };

  const clearMunicipalityFields = () => ({
    municipality: "",
    municipalityCode: "",
    barangay: "",
    barangayCode: "",
  });

  const clearBarangayFields = () => ({
    barangay: "",
    barangayCode: "",
  });

  const handleProvinceSelect = (_, option) => {
    if (!option) {
      setFormData((prev) => ({
        ...prev,
        province: "",
        provinceCode: "",
        ...clearMunicipalityFields(),
      }));
      return;
    }

    setFormData((prev) => ({
      ...prev,
      province: option.name,
      provinceCode: option.code,
      ...clearMunicipalityFields(),
    }));
  };

  const handleProvinceInput = (_, value, reason) => {
    if (reason === "input") {
      setFormData((prev) => ({
        ...prev,
        province: value,
        provinceCode: "",
        ...clearMunicipalityFields(),
      }));
    }
    if (reason === "clear") {
      setFormData((prev) => ({
        ...prev,
        province: "",
        provinceCode: "",
        ...clearMunicipalityFields(),
      }));
    }
  };

  const handleMunicipalitySelect = (_, option) => {
    if (!option) {
      setFormData((prev) => ({
        ...prev,
        municipality: "",
        municipalityCode: "",
        ...clearBarangayFields(),
      }));
      return;
    }

    setFormData((prev) => ({
      ...prev,
      municipality: option.name,
      municipalityCode: option.code,
      ...clearBarangayFields(),
    }));
  };

  const handleMunicipalityInput = (_, value, reason) => {
    if (reason === "input") {
      setFormData((prev) => ({
        ...prev,
        municipality: value,
        municipalityCode: "",
        ...clearBarangayFields(),
      }));
    }
    if (reason === "clear") {
      setFormData((prev) => ({
        ...prev,
        municipality: "",
        municipalityCode: "",
        ...clearBarangayFields(),
      }));
    }
  };

  const handleBarangaySelect = (_, option) => {
    if (!option) {
      setFormData((prev) => ({
        ...prev,
        barangay: "",
        barangayCode: "",
      }));
      return;
    }

    setFormData((prev) => ({
      ...prev,
      barangay: option.name,
      barangayCode: option.code,
    }));
  };

  const handleBarangayInput = (_, value, reason) => {
    if (reason === "input") {
      setFormData((prev) => ({
        ...prev,
        barangay: value,
        barangayCode: "",
      }));
    }
    if (reason === "clear") {
      setFormData((prev) => ({
        ...prev,
        barangay: "",
        barangayCode: "",
      }));
    }
  };

  const previewAddress = useMemo(
    () =>
      composeFullAddress({
        street: formData.address,
        barangay: formData.barangay,
        municipality: formData.municipality,
        province: formData.province,
      }),
    [
      formData.address,
      formData.barangay,
      formData.municipality,
      formData.province,
    ],
  );

  const validateForm = () => {
    const errors = {};

    if (!formData.username.trim()) errors.username = "Username is required";
    if (!formData.firstName.trim()) errors.firstName = "First name is required";
    if (!formData.lastName.trim()) errors.lastName = "Last name is required";

    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    const trimmedEmail = formData.email.trim();
    if (trimmedEmail && !emailRegex.test(trimmedEmail)) {
      errors.email = "Please enter a valid email address";
    }
    if (!isEditing || formData.password) {
      if (!formData.password) {
        errors.password = "Password is required";
      } else if (formData.password.length < 6) {
        errors.password = "Password must be at least 6 characters";
      }

      if (formData.password !== formData.confirmPassword) {
        errors.confirmPassword = "Passwords do not match";
      }
    }

    if (formData.username && formData.username.length < 3) {
      errors.username = "Username must be at least 3 characters";
    }

    if (formData.role === "student" && !formData.studentId) {
      errors.studentId = "Student ID is required for students";
    }

    setValidationErrors(errors);
    return Object.keys(errors).length === 0;
  };

  const handleSubmit = async (event) => {
    event.preventDefault();

    if (!validateForm()) {
      setError("Please fix the validation errors");
      return;
    }

    setLoading(true);
    try {
      setError("");
      setSuccess("");

      const payload = { ...formData };
      payload.phoneNumber = sanitizePhoneInput(payload.phoneNumber);
      delete payload.confirmPassword;

      payload.address = composeFullAddress({
        street: payload.address,
        barangay: payload.barangay,
        municipality: payload.municipality,
        province: payload.province,
      });

      payload.email = (payload.email || "").trim();
      if (!payload.email) {
        delete payload.email;
      }

      if (isEditing && !payload.password) {
        delete payload.password;
      }

      if (isEditing) {
        await api.put(`/users/${id}`, payload);
        setSuccess("User updated successfully");
      } else {
        await api.post("/users", payload);
        setSuccess("User created successfully");
      }

      setTimeout(() => {
        navigate("/users");
      }, 2000);
    } catch (submitError) {
      setError(submitError.response?.data?.message || "Failed to save user");
      console.error("Error saving user:", submitError);
    } finally {
      setLoading(false);
    }
  };

  const canManageUsers = user?.role === "admin" || user?.role === "librarian";

  if (!canManageUsers) {
    return (
      <Box>
        <Alert severity="error">
          Access denied. You do not have permission to manage users.
        </Alert>
      </Box>
    );
  }

  return (
    <Box>
      <Box display="flex" alignItems="center" mb={3}>
        <IconButton onClick={() => navigate("/users")} sx={{ mr: 2 }}>
          <ArrowBack />
        </IconButton>
        <Typography variant="h4" gutterBottom sx={{ flexGrow: 1, mb: 0, color: "white" }}>
          {isEditing ? "Edit User" : "Add New User"}
        </Typography>
      </Box>

      {error && (
        <Alert severity="error" sx={{ mb: 2 }}>
          {error}
        </Alert>
      )}

      {userAttributesError && (
        <Alert severity="warning" sx={{ mb: 2 }}>
          {userAttributesError}
        </Alert>
      )}
      {addressError && (
        <Alert severity="warning" sx={{ mb: 2 }}>
          {addressError}
        </Alert>
      )}

      {success && (
        <Alert severity="success" sx={{ mb: 2 }}>
          {success}
        </Alert>
      )}

      <form onSubmit={handleSubmit}>
        <Grid container spacing={3}>
          <Grid item xs={12}>
            <Card>
              <CardContent>
                <Typography variant="h6" gutterBottom>
                  Basic Information
                </Typography>
                <Grid container spacing={2}>
                  <Grid item xs={12} display="flex" mb={2}>
                    <Avatar
                      sx={{
                        width: 80,
                        height: 80,
                        bgcolor: "primary.main",
                        fontSize: "2rem",
                      }}
                    >
                      {formData.firstName?.[0] || formData.username?.[0] || (
                        <Person />
                      )}
                    </Avatar>
                  </Grid>

                  <Grid item xs={12} md={6}>
                    <TextField
                      fullWidth
                      label="Username"
                      name="username"
                      value={formData.username}
                      onChange={handleChange}
                      error={Boolean(validationErrors.username)}
                      helperText={validationErrors.username}
                      required
                      disabled={isEditing}
                      FormHelperTextProps={{ id: "username-error" }}
                      aria-describedby={validationErrors.username ? "username-error" : undefined}
                      InputProps={{
                        startAdornment: (
                          <InputAdornment position="start">
                            <Person />
                          </InputAdornment>
                        ),
                      }}
                    />
                  </Grid>

                  <Grid item xs={12} md={6}>
                    <TextField
                      fullWidth
                      label="Email"
                      name="email"
                      type="email"
                      value={formData.email}
                      onChange={handleChange}
                      error={Boolean(validationErrors.email)}
                      helperText={
                        validationErrors.email || "Optional; leave blank if unavailable"
                      }
                      FormHelperTextProps={{ id: "email-error" }}
                      aria-describedby={validationErrors.email ? "email-error" : undefined}
                      InputProps={{
                        startAdornment: (
                          <InputAdornment position="start">
                            <Email />
                          </InputAdornment>
                        ),
                      }}
                    />
                  </Grid>

                  <Grid item xs={12} md={6}>
                    <TextField
                      fullWidth
                      label="First Name"
                      name="firstName"
                      value={formData.firstName}
                      onChange={handleChange}
                      error={Boolean(validationErrors.firstName)}
                      helperText={validationErrors.firstName}
                      required
                    />
                  </Grid>

                  <Grid item xs={12} md={6}>
                    <TextField
                      fullWidth
                      label="Last Name"
                      name="lastName"
                      value={formData.lastName}
                      onChange={handleChange}
                      error={Boolean(validationErrors.lastName)}
                      helperText={validationErrors.lastName}
                      required
                    />
                  </Grid>

                  <Grid item xs={12} md={6}>
                    <FormControl
                      fullWidth
                      error={Boolean(validationErrors.role)}
                    >
                      <InputLabel>Role</InputLabel>
                      <Select
                        name="role"
                        value={formData.role}
                        onChange={handleChange}
                        label="Role"
                      >
                        {ROLE_OPTIONS.map((role) => (
                          <MenuItem key={role.value} value={role.value}>
                            {role.label}
                          </MenuItem>
                        ))}
                      </Select>
                    </FormControl>
                  </Grid>

                  <Grid item xs={12} md={6}>
                    <TextField
                      fullWidth
                      label="Phone Number"
                      name="phoneNumber"
                      value={formData.phoneNumber}
                      onChange={handleChange}
                      inputProps={{ inputMode: "numeric", pattern: "[0-9]*", maxLength: 11 }}
                      InputProps={{
                        startAdornment: (
                          <InputAdornment position="start">
                            <Phone />
                          </InputAdornment>
                        ),
                      }}
                    />
                  </Grid>

                  <Grid item xs={12}>
                    <FormControlLabel
                      control={
                        <Checkbox
                          checked={formData.isActive}
                          onChange={handleChange}
                          name="isActive"
                        />
                      }
                      label="Active User"
                    />
                  </Grid>
                </Grid>
              </CardContent>
            </Card>
          </Grid>

          <Grid item xs={12}>
            <Card>
              <CardContent>
                <Typography variant="h6" gutterBottom>
                  {isEditing
                    ? "Change Password (leave blank to keep current)"
                    : "Password"}
                </Typography>
                <Grid container spacing={2}>
                  <Grid item xs={12} md={6}>
                    <TextField
                      fullWidth
                      label="Password"
                      name="password"
                      autoComplete="new-password"
                      type={showPassword ? "text" : "password"}
                      value={formData.password}
                      onChange={handleChange}
                      error={Boolean(validationErrors.password)}
                      helperText={validationErrors.password}
                      required={!isEditing}
                      InputProps={{
                        endAdornment: (
                          <InputAdornment position="end">
                            <IconButton
                              onClick={() => setShowPassword((prev) => !prev)}
                              edge="end"
                            >
                              {showPassword ? <VisibilityOff /> : <Visibility />}
                            </IconButton>
                          </InputAdornment>
                        ),
                      }}
                    />
                  </Grid>

                  <Grid item xs={12} md={6}>
                    <TextField
                      fullWidth
                      label="Confirm Password"
                      name="confirmPassword"
                      autoComplete="new-password"
                      type={showConfirmPassword ? "text" : "password"}
                      value={formData.confirmPassword}
                      onChange={handleChange}
                      error={Boolean(validationErrors.confirmPassword)}
                      helperText={validationErrors.confirmPassword}
                      required={!isEditing || formData.password}
                      InputProps={{
                        endAdornment: (
                          <InputAdornment position="end">
                            <IconButton
                              onClick={() =>
                                setShowConfirmPassword((prev) => !prev)
                              }
                              edge="end"
                            >
                              {showConfirmPassword ? (
                                <VisibilityOff />
                              ) : (
                                <Visibility />
                              )}
                            </IconButton>
                          </InputAdornment>
                        ),
                      }}
                    />
                  </Grid>
                </Grid>
              </CardContent>
            </Card>
          </Grid>

          <Grid item xs={12}>
            <Card>
              <CardContent>
                <Typography variant="h6" gutterBottom>
                  Additional Information
                </Typography>
                <Grid container spacing={2}>
                  <Grid item xs={12} sm={4}>
                    <Autocomplete
                      freeSolo
                      loading={addressLoading.provinces}
                      options={provinceOptions}
                      getOptionLabel={(option) =>
                        typeof option === "string" ? option : option.name
                      }
                      value={selectedProvinceOption}
                      inputValue={formData.province}
                      onChange={handleProvinceSelect}
                      onInputChange={handleProvinceInput}
                      loadingText="Loading provinces..."
                      renderInput={(params) => (
                        <TextField
                          {...params}
                          label="Province"
                          placeholder="Select or type province"
                        />
                      )}
                    />
                  </Grid>
                  <Grid item xs={12} sm={4}>
                    <Autocomplete
                      freeSolo
                      loading={addressLoading.municipalities}
                      options={municipalityOptions}
                      getOptionLabel={(option) =>
                        typeof option === "string" ? option : option.name
                      }
                      value={selectedMunicipalityOption}
                      inputValue={formData.municipality}
                      onChange={handleMunicipalitySelect}
                      onInputChange={handleMunicipalityInput}
                      loadingText="Loading municipalities..."
                      renderInput={(params) => (
                        <TextField
                          {...params}
                          label="Municipality"
                          placeholder="Select or type municipality"
                        />
                      )}
                    />
                  </Grid>
                  <Grid item xs={12} sm={4}>
                    <Autocomplete
                      freeSolo
                      loading={addressLoading.barangays}
                      options={barangayOptions}
                      getOptionLabel={(option) =>
                        typeof option === "string" ? option : option.name
                      }
                      value={selectedBarangayOption}
                      inputValue={formData.barangay}
                      onChange={handleBarangaySelect}
                      onInputChange={handleBarangayInput}
                      loadingText="Loading barangays..."
                      renderInput={(params) => (
                        <TextField
                          {...params}
                          label="Barangay"
                          placeholder="Select or type barangay"
                        />
                      )}
                    />
                  </Grid>
                  <Grid item xs={12}>
                    <TextField
                      fullWidth
                      label="House No. / Street"
                      name="address"
                      multiline
                      rows={2}
                      value={formData.address}
                      onChange={handleChange}
                      placeholder="e.g., 123 Library Street"
                    />
                  </Grid>
                  <Grid item xs={12}>
                    <TextField
                      fullWidth
                      label="Full Address (auto-generated)"
                      value={previewAddress}
                      InputProps={{ readOnly: true }}
                      helperText="This is what will be saved with the user account"
                    />
                  </Grid>
                </Grid>
              </CardContent>
            </Card>
          </Grid>

          <Grid item xs={12}>
            <Box display="flex" gap={2} justifyContent="flex-end">
              <Button
                onClick={() => navigate("/users")}
                disabled={loading}
                startIcon={<Cancel />}
              >
                Cancel
              </Button>
              <Button
                type="submit"
                variant="contained"
                disabled={loading}
                startIcon={<Save />}
              >
                {loading
                  ? "Saving..."
                  : isEditing
                  ? "Update User"
                  : "Create User"}
              </Button>
            </Box>
          </Grid>
        </Grid>
      </form>
    </Box>
  );
};

export default UserForm;
```

## UserProfile.js

| Field | Details |
| --- | --- |
| Program Name | UserProfile.js |
| Description | Frontend page view for routing and page-level UI. |
| Called by | App.js |
| Table used | users |
|  |  |
| Programmer | Nazel Asca√±o |
| Date created | 12/14/2025 |
| Revision Date | TBD |
| Revision / description of change | None |

```javascript
import React, { useCallback, useEffect, useMemo, useRef, useState } from "react";
import {
  Box,
  Typography,
  Grid,
  Card,
  CardContent,
  Avatar,
  Button,
  TextField,
  Chip,
  IconButton,
  List,
  ListItem,
  ListItemText,
  ListItemIcon,
  CircularProgress,
  Alert,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  Divider,
  InputAdornment,
  Tooltip,
  LinearProgress,
  Slider,
  MenuItem,
} from "@mui/material";
import {
  Person,
  Email,
  School,
  Assignment,
  Warning,
  Edit,
  Cancel,
  LibraryBooks,
  Visibility,
  VisibilityOff,
  Security,
  ArrowBack,
  Phone,
  Save,
  PhotoCamera,
  LocationOn,
} from "@mui/icons-material";
import Cropper from "react-easy-crop";
import { useAuth } from "../../contexts/AuthContext";
import { useSettings } from "../../contexts/SettingsContext";
import { api, usersAPI, booksAPI, auditAPI } from "../../utils/api";
import { formatCurrency } from "../../utils/currency";
import { ensureUserAttributes, getSectionsForGrade } from "../../utils/userAttributes";
import { useNavigate, useParams } from "react-router-dom";

const createImage = (url) =>
  new Promise((resolve, reject) => {
    const image = new Image();
    image.addEventListener("load", () => resolve(image));
    image.addEventListener("error", (error) => reject(error));
    image.setAttribute("crossOrigin", "anonymous");
    image.src = url;
  });

const getCroppedImage = async (file, cropArea) => {
  if (!cropArea) {
    return { file, blob: file };
  }

  const imageUrl = URL.createObjectURL(file);
  try {
    const image = await createImage(imageUrl);
    const canvas = document.createElement("canvas");
    const ctx = canvas.getContext("2d");
    const pixelRatio = window.devicePixelRatio || 1;
    const { width, height, x, y } = cropArea;

    canvas.width = width * pixelRatio;
    canvas.height = height * pixelRatio;

    ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
    ctx.imageSmoothingQuality = "high";

    ctx.drawImage(image, x, y, width, height, 0, 0, width, height);

    const mimeType = file.type === "image/png" ? "image/png" : "image/jpeg";

    return await new Promise((resolve, reject) => {
      canvas.toBlob(
        (blob) => {
          if (!blob) {
            reject(new Error("Failed to crop image"));
            return;
          }
          const croppedFile = new File([blob], `avatar-${Date.now()}.${mimeType === "image/png" ? "png" : "jpg"}`, {
            type: mimeType,
          });
          resolve({ blob, file: croppedFile });
        },
        mimeType,
        0.95,
      );
    });
  } finally {
    URL.revokeObjectURL(imageUrl);
  }
};

const normalizeRoleValue = (value) => (value ? String(value).trim().toLowerCase() : "");
const ADMIN_ROLE_TOKENS = new Set(["admin", "super admin", "super-admin", "superadmin"]);
const isAdminRoleValue = (role) => ADMIN_ROLE_TOKENS.has(normalizeRoleValue(role));

const sanitizePhoneInput = (value = "") =>
  String(value ?? "").replace(/\D/g, "").slice(0, 11);

const withSanitizedPhone = (data = {}) => {
  if (!data || typeof data !== "object") {
    return {};
  }

  const normalizedPhone =
    data.phoneNumber != null
      ? sanitizePhoneInput(data.phoneNumber)
      : sanitizePhoneInput(data.profile?.phone);

  return {
    ...data,
    phoneNumber: normalizedPhone,
  };
};

const hydrateProfileData = (data = {}) => {
  const sanitized = withSanitizedPhone(data);
  const resolvedGrade =
    sanitized.grade ||
    sanitized.gradeLevel ||
    sanitized.student?.grade ||
    "";
  const resolvedSection =
    sanitized.section ||
    sanitized.student?.section ||
    sanitized.studentProfile?.section ||
    "";

  return {
    ...sanitized,
    grade: resolvedGrade,
    gradeLevel: resolvedGrade || sanitized.gradeLevel || "",
    section: resolvedSection,
  };
};

const PASSWORD_MIN_LENGTH = 6;

const createPasswordFormState = () => ({
  currentPassword: "",
  newPassword: "",
  confirmPassword: "",
});

const createPasswordErrorState = () => ({
  current: "",
  new: "",
  confirm: "",
  general: "",
});

const derivePasswordChangeError = (error) => {
  const fallback = "Failed to change password. Please try again.";
  if (!error) {
    return fallback;
  }
  if (error.response) {
    return error.response.data?.message || fallback;
  }
  if (error.request) {
    return "Unable to reach the server. Please check your connection and try again.";
  }
  return error.message || fallback;
};

const UserProfile = () => {
  const { user, updateUserData, hasPermission } = useAuth();
  const { finesEnabled } = useSettings();
  const { id } = useParams();
  const navigate = useNavigate();
  const [profileData, setProfileData] = useState({});
  const [borrowingHistory, setBorrowingHistory] = useState([]);
  const [editMode, setEditMode] = useState(false);
  const [changePasswordDialog, setChangePasswordDialog] = useState(false);
  const [passwordData, setPasswordData] = useState(() => createPasswordFormState());
  const [passwordErrors, setPasswordErrors] = useState(() => createPasswordErrorState());
  const canEditStudentRecords = hasPermission("students.update");
  const [showPasswords, setShowPasswords] = useState({
    current: false,
    new: false,
    confirm: false,
  });
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState("");
  const [success, setSuccess] = useState("");
  const [stats, setStats] = useState({
    totalBorrowings: 0,
    currentlyBorrowed: 0,
    overdueBorrowings: 0,
    totalFines: 0,
  });
  const [isSelfProfile, setIsSelfProfile] = useState(true);
  const [profileLoading, setProfileLoading] = useState(false);
  const [avatarUploading, setAvatarUploading] = useState(false);
  const [avatarProgress, setAvatarProgress] = useState(0);
  const [selectedAvatarFile, setSelectedAvatarFile] = useState(null);
  const [avatarPreviewUrl, setAvatarPreviewUrl] = useState("");
  const [avatarDialogOpen, setAvatarDialogOpen] = useState(false);
  const [crop, setCrop] = useState({ x: 0, y: 0 });
  const [zoom, setZoom] = useState(1);
  const [croppedAreaPixels, setCroppedAreaPixels] = useState(null);
  const fileInputRef = useRef(null);
  const [bookLookups, setBookLookups] = useState(null);
  const [booksLoading, setBooksLoading] = useState(false);
  const [booksError, setBooksError] = useState("");
  const [attributeOptions, setAttributeOptions] = useState(() => ensureUserAttributes());
  const [attributeLoading, setAttributeLoading] = useState(false);
  const [attributeError, setAttributeError] = useState("");
  const [auditHistory, setAuditHistory] = useState([]);
  const [auditLoading, setAuditLoading] = useState(false);
  const [auditError, setAuditError] = useState("");
  const resolvedProfileRole = normalizeRoleValue(profileData?.role || user?.role || "");
  const isStudentProfileView = resolvedProfileRole === "student";
  const viewerIsAdmin = isAdminRoleValue(user?.role);
  const shouldShowAuditHistory = viewerIsAdmin;

  useEffect(() => {
    if (!avatarPreviewUrl) {
      return undefined;
    }
    return () => {
      URL.revokeObjectURL(avatarPreviewUrl);
    };
  }, [avatarPreviewUrl]);

  const resolveApiOrigin = () => {
    const base = api.defaults.baseURL || "";
    if (!base) {
      if (typeof window === "undefined") {
        return "";
      }
      return window.location.origin.replace(/\/$/, "");
    }
    const sanitized = base.replace(/\/api$/i, "");
    return sanitized || base;
  };

  const getAvatarUrl = (data) => {
    if (!data || typeof data !== "object") {
      return "";
    }

    const raw = data.avatar?.url || data.avatarUrl;
    if (!raw) {
      return "";
    }

    if (/^https?:\/\//i.test(raw) || raw.startsWith("data:")) {
      return raw;
    }

    const origin = resolveApiOrigin();
    const normalizedPath = raw.startsWith("/") ? raw : `/${raw}`;
    return `${origin}${normalizedPath}`;
  };

  const getUserIdentifier = (value) => value?._id || value?.id || value?.uid;

  const resolveInitial = (value) => {
    if (!value || (typeof value !== "string" && typeof value !== "number")) {
      return "";
    }

    const normalized = String(value).trim();
    if (!normalized) {
      return "";
    }

    return normalized.charAt(0).toUpperCase();
  };

  const getAvatarInitial = (data) => {
    if (!data || typeof data !== "object") {
      return "";
    }

    return (
      [data.firstName, data.lastName, data.username, data.email]
        .map(resolveInitial)
        .find(Boolean) || ""
    );
  };

  const computeStatsFromHistory = (history = []) => {
    const now = new Date();
    return {
      totalBorrowings: history.length,
      currentlyBorrowed: history.filter((t) => t.status === "borrowed").length,
      overdueBorrowings: history.filter((t) => {
        if (t.status !== "borrowed") return false;
        if (!t.dueDate) return false;
        return new Date(t.dueDate) < now;
      }).length,
      totalFines: history.reduce((sum, t) => sum + (t.fineAmount || t.fine || 0), 0),
    };
  };

  const formatAuditTimestamp = (value) => {
    if (!value) {
      return "‚Äî";
    }
    const date = new Date(value);
    if (Number.isNaN(date.getTime())) {
      return "‚Äî";
    }
    try {
      return date.toLocaleString(undefined, {
        dateStyle: "medium",
        timeStyle: "short",
      });
    } catch (error) {
      return date.toISOString();
    }
  };

  const formatAuditDetails = (log = {}) => {
    if (!log || typeof log !== "object") {
      return "‚Äî";
    }

    const textCandidates = [
      log.description,
      typeof log.details === "string" ? log.details : null,
      typeof log.details === "object" && log.details
        ? log.details.summary || log.details.description || log.details.message
        : null,
      typeof log.metadata === "object" && log.metadata
        ? log.metadata.summary || log.metadata.description
        : null,
      log.status ? `Status: ${log.status}` : null,
      log.entityId ? `Entity ID: ${log.entityId}` : null,
    ];

    const resolved = textCandidates.find((value) => typeof value === "string" && value.trim());
    return resolved ? resolved.trim() : "No additional details";
  };

  const dedupeValues = (values = []) => {
    const normalizedList = Array.isArray(values) ? values : [];
    const seen = new Set();
    const result = [];

    normalizedList.forEach((value) => {
      if (!value) return;
      const trimmed = typeof value === "string" ? value.trim() : value;
      if (!trimmed) return;
      const key = typeof trimmed === "string" ? trimmed.toLowerCase() : trimmed;
      if (seen.has(key)) return;
      seen.add(key);
      result.push(trimmed);
    });

    return result;
  };

  const summarizeValues = (values = []) => {
    const deduped = dedupeValues(values);
    if (deduped.length === 0) return "";
    if (deduped.length === 1) return deduped[0];
    if (deduped.length === 2) return deduped.join(", ");
    return `${deduped[0]}, ${deduped[1]} (+${deduped.length - 2} more)`;
  };

  const buildBookLookups = (books = []) => {
    const byBookId = new Map();
    const byCopyId = new Map();
    const byIsbn = new Map();

    books.forEach((book = {}) => {
      const normalized = {
        id: book._id || book.id || book.bookId,
        title: book.title,
        author: book.author,
        isbn: book.isbn,
      };

      [book._id, book.id, book.bookId]
        .map((value) => (value ? String(value) : ""))
        .filter(Boolean)
        .forEach((key) => {
          byBookId.set(key, normalized);
        });

      if (book.isbn) {
        byIsbn.set(String(book.isbn).toLowerCase(), normalized);
      }

      (book.copies || []).forEach((copy = {}) => {
        if (copy.copyId) {
          byCopyId.set(String(copy.copyId), normalized);
        }
      });
    });

    return { byBookId, byCopyId, byIsbn };
  };

  const loadBookLookups = useCallback(async () => {
    if (bookLookups) {
      return bookLookups;
    }

    try {
      setBooksLoading(true);
      const response = await booksAPI.getAll({ limit: -1 });
      const list = response.data?.books || response.data || [];
      const lookups = buildBookLookups(Array.isArray(list) ? list : []);
      setBookLookups(lookups);
      setBooksError("");
      return lookups;
    } catch (error) {
      console.error("Failed to load book metadata", error);
      const message =
        error?.response?.data?.message || "Unable to load book details for transactions.";
      setBooksError(message);
      return null;
    } finally {
      setBooksLoading(false);
    }
  }, [bookLookups]);

  const loadStudentAttributeOptions = useCallback(async () => {
    try {
      setAttributeLoading(true);
      setAttributeError("");
      const response = await usersAPI.getProfileAttributes();
      const normalized = ensureUserAttributes(response.data);
      setAttributeOptions(normalized);
      setProfileData((prev) => {
        if (!prev || typeof prev !== "object") {
          return prev;
        }

        const rawGrade = prev.grade || prev.gradeLevel || "";
        const normalizedGrade = typeof rawGrade === "string" ? rawGrade.trim() : "";
        const gradeExists = normalized.gradeStructure.some((entry = {}) => {
          const gradeName = typeof entry.grade === "string" ? entry.grade.trim().toLowerCase() : "";
          return gradeName && normalizedGrade && gradeName === normalizedGrade.toLowerCase();
        });
        const nextGrade = gradeExists ? normalizedGrade : "";
        const availableSections = getSectionsForGrade(normalized.gradeStructure, nextGrade);
        const sectionExists = availableSections.includes(prev.section);

        return {
          ...prev,
          grade: nextGrade,
          gradeLevel: nextGrade || prev.gradeLevel || "",
          section: sectionExists ? prev.section : "",
        };
      });
    } catch (error) {
      console.error("Failed to load profile attribute options", error);
      setAttributeError("Unable to load grade and section options.");
    } finally {
      setAttributeLoading(false);
    }
  }, []);

  const resolveBookDetailsFromTransaction = (transaction = {}, lookups = null) => {
    const fallbackTitle =
      transaction.bookTitle ||
      transaction.title ||
      transaction.book?.title ||
      "Unknown Book";
    const fallbackAuthor =
      transaction.author ||
      transaction.bookAuthor ||
      transaction.book?.author ||
      "";

    const items = Array.isArray(transaction.items) ? transaction.items : [];
    const lookupTitles = [];
    const lookupAuthors = [];

    const registerLookupRecord = (record) => {
      if (!record) return;
      if (record.title) {
        lookupTitles.push(record.title);
      }
      if (record.author) {
        lookupAuthors.push(record.author);
      }
    };

    const tryLookupByBookId = (value) => {
      if (!value || !lookups?.byBookId) return;
      const record = lookups.byBookId.get(String(value));
      registerLookupRecord(record);
    };

    const tryLookupByCopyId = (value) => {
      if (!value || !lookups?.byCopyId) return;
      const record = lookups.byCopyId.get(String(value));
      registerLookupRecord(record);
    };

    const tryLookupByIsbn = (value) => {
      if (!value || !lookups?.byIsbn) return;
      const record = lookups.byIsbn.get(String(value).toLowerCase());
      registerLookupRecord(record);
    };

    if (transaction.bookId) {
      tryLookupByBookId(transaction.bookId);
    }
    if (transaction.isbn) {
      tryLookupByIsbn(transaction.isbn);
    }

    items.forEach((item) => {
      tryLookupByBookId(item?.bookId);
      tryLookupByCopyId(item?.copyId);
      tryLookupByIsbn(item?.isbn);
    });

    const itemDerivedTitles = items
      .map((item) =>
        item?.book?.title || item?.title || item?.isbn || item?.copyId || "",
      )
      .filter(Boolean);
    const itemDerivedAuthors = items
      .map((item) => item?.book?.author || item?.author || "")
      .filter(Boolean);

    const combinedTitles = [...lookupTitles, ...itemDerivedTitles];
    const combinedAuthors = [...lookupAuthors, ...itemDerivedAuthors];

    return {
      title:
        combinedTitles.length > 0
          ? summarizeValues(combinedTitles)
          : fallbackTitle,
      author:
        combinedAuthors.length > 0
          ? summarizeValues(combinedAuthors)
          : fallbackAuthor,
    };
  };

  const normalizeBorrowingHistoryRecords = (records = [], lookups = null) => {
    if (!Array.isArray(records)) {
      return [];
    }

    return records.map((transaction) => {
      const { title, author } = resolveBookDetailsFromTransaction(transaction, lookups);
      return {
        ...transaction,
        bookTitle: title,
        author,
      };
    });
  };

  useEffect(() => {
    const initializeProfile = async () => {
      if (!user) return;

      setError("");
      setSuccess("");

      const currentUserId = getUserIdentifier(user);
      const viewingSelf = !id || id === currentUserId;
      setIsSelfProfile(viewingSelf);

      if (!viewingSelf) {
        setEditMode(false);
        setChangePasswordDialog(false);
      }

      if (viewingSelf) {
        const hydratedProfile = hydrateProfileData(user);
        setProfileData(hydratedProfile);
        if (viewerIsAdmin) {
          await fetchAuditHistory(currentUserId);
          setStats(computeStatsFromHistory([]));
        } else {
          const history = await fetchBorrowingHistory(currentUserId, true);
          await fetchUserStats(currentUserId, true, history);
        }
      } else {
        await loadProfileById(id);
      }
    };

    initializeProfile();

  }, [user, id]);

  useEffect(() => {
    if (!user || !isStudentProfileView) {
      return;
    }
    loadStudentAttributeOptions();
  }, [user, isStudentProfileView, loadStudentAttributeOptions]);

  const fetchAuditHistory = useCallback(
    async (targetUserId) => {
      if (!targetUserId) {
        return [];
      }

      if (!viewerIsAdmin) {
        setAuditHistory([]);
        setAuditError("You do not have permission to view audit history.");
        return [];
      }

      try {
        setAuditLoading(true);
        setAuditError("");
        const response = await auditAPI.getByUser(targetUserId, { limit: 25 });
        const logs = Array.isArray(response.data)
          ? response.data
          : Array.isArray(response.data?.logs)
            ? response.data.logs
            : [];
        setBorrowingHistory([]);
        setAuditHistory(logs);
        return logs;
      } catch (err) {
        console.error("Error fetching audit history:", err);
        const message = err?.response?.data?.message || "Failed to fetch audit history.";
        setAuditError(message);
        setAuditHistory([]);
        return [];
      } finally {
        setAuditLoading(false);
      }
    },
    [viewerIsAdmin]
  );

  const loadProfileById = async (targetUserId) => {
    try {
      setProfileLoading(true);
      const response = await api.get(`/users/${targetUserId}`);
      const hydratedProfile = hydrateProfileData(response.data);
      setProfileData(hydratedProfile);
      if (viewerIsAdmin) {
        await fetchAuditHistory(targetUserId);
        setStats(computeStatsFromHistory([]));
      } else {
        await fetchBorrowingHistory(targetUserId, false);
      }
    } catch (err) {
      console.error("Error loading user profile:", err);
      setError("Failed to load user profile");
    } finally {
      setProfileLoading(false);
    }
  };

  const fetchBorrowingHistory = async (targetUserId, viewingSelf) => {
    try {
      setAuditHistory([]);
      setAuditError("");
      let response;
      if (viewingSelf) {
        response = await api.get("/users/profile/borrowing-history");
      } else {
        response = await api.get(`/transactions/user/${targetUserId}`);
      }

      const historyData = Array.isArray(response.data)
        ? response.data
        : response.data?.transactions || [];

      const lookups = await loadBookLookups();
      const normalizedHistory = normalizeBorrowingHistoryRecords(historyData, lookups);

      setBorrowingHistory(normalizedHistory);

      if (!viewingSelf) {
        setStats(computeStatsFromHistory(normalizedHistory));
      }

      return normalizedHistory;
    } catch (err) {
      console.error("Error fetching borrowing history:", err);
      if (!viewingSelf) {
        setStats(computeStatsFromHistory([]));
      }
      return [];
    }
  };

  const fetchUserStats = async (targetUserId, viewingSelf, historyData) => {
    if (!viewingSelf) {
      setStats(computeStatsFromHistory(historyData || []));
      return;
    }

    try {
      const response = await api.get("/users/profile/stats");
      setStats(response.data);
    } catch (err) {
      console.error("Error fetching user stats:", err);
    }
  };

  const availableGradeOptions = useMemo(() => {
    const structureGrades = (attributeOptions.gradeStructure || [])
      .map((entry = {}) => entry.grade)
      .filter(Boolean);
    if (structureGrades.length > 0) {
      return structureGrades;
    }
    return attributeOptions.gradeLevels || [];
  }, [attributeOptions]);

  const selectedGrade = profileData.grade || "";
  const availableSections = useMemo(
    () => getSectionsForGrade(attributeOptions.gradeStructure, selectedGrade),
    [attributeOptions, selectedGrade]
  );
  const hasGradeOptions = availableGradeOptions.length > 0;
  const hasSectionOptions = availableSections.length > 0;
  const shouldRenderSectionSelect = Boolean(selectedGrade) && hasSectionOptions;
  const selectedSection = profileData.section || "";

  const handleGradeSelectChange = (value) => {
    const normalizedValue = typeof value === "string" ? value : "";
    setProfileData((prev) => {
      const allowedSections = getSectionsForGrade(attributeOptions.gradeStructure, normalizedValue);
      const nextSection = normalizedValue && allowedSections.includes(prev.section) ? prev.section : "";
      return {
        ...prev,
        grade: normalizedValue,
        gradeLevel: normalizedValue,
        section: nextSection,
      };
    });
  };

  const handleSectionSelectChange = (value) => {
    setProfileData((prev) => ({
      ...prev,
      section: typeof value === "string" ? value : "",
    }));
  };

  const handleProfileUpdate = async () => {
    if (!isSelfProfile) return;

    try {
      setLoading(true);
      const targetId = getUserIdentifier(profileData);
      if (!targetId) {
        setError("Unable to determine user identifier");
        return;
      }

      const updatePayload = {
        firstName: profileData.firstName,
        lastName: profileData.lastName,
        phoneNumber: sanitizePhoneInput(profileData.phoneNumber),
        address: profileData.address,
      };

      if (isStudentProfileView) {
        const hasGradeField = Object.prototype.hasOwnProperty.call(profileData || {}, "grade");
        const hasSectionField = Object.prototype.hasOwnProperty.call(profileData || {}, "section");

        if (hasGradeField) {
          const trimmedGrade =
            typeof profileData.grade === "string"
              ? profileData.grade.trim()
              : profileData.grade ?? "";
          updatePayload.grade = trimmedGrade;
          updatePayload.gradeLevel = trimmedGrade;
        }

        if (hasSectionField) {
          const trimmedSection =
            typeof profileData.section === "string"
              ? profileData.section.trim()
              : profileData.section ?? "";
          updatePayload.section = trimmedSection;
        }
      }

      await api.put(`/users/${targetId}`, updatePayload);
      setSuccess("Profile updated successfully");
      setProfileData((prev) => ({
        ...prev,
        ...updatePayload,
        gradeLevel:
          updatePayload.grade !== undefined
            ? updatePayload.grade
            : prev?.gradeLevel,
      }));
      if (isSelfProfile) {
        updateUserData((prev) => {
          const base = prev || {};
          return {
            ...base,
            ...updatePayload,
            gradeLevel:
              updatePayload.grade !== undefined ? updatePayload.grade : base.gradeLevel,
            grade:
              updatePayload.grade !== undefined ? updatePayload.grade : base.grade,
            section:
              updatePayload.section !== undefined ? updatePayload.section : base.section,
          };
        });
      }
      setEditMode(false);
      setTimeout(() => setSuccess(""), 3000);
    } catch (err) {
      setError("Failed to update profile");
      console.error("Error updating profile:", err);
    } finally {
      setLoading(false);
    }
  };

  const resetPasswordDialogState = useCallback(() => {
    setPasswordData(createPasswordFormState());
    setPasswordErrors(createPasswordErrorState());
  }, []);

  const handlePasswordFieldChange = (field) => (event) => {
    const value = event.target.value;
    setPasswordData((prev) => ({ ...prev, [field]: value }));
    setPasswordErrors((prev) => {
      const next = { ...prev, general: "" };
      if (field === "currentPassword") {
        next.current = "";
      } else if (field === "newPassword") {
        next.new = "";
      } else {
        next.confirm = "";
      }
      return next;
    });
  };

  const handlePasswordDialogOpen = () => {
    resetPasswordDialogState();
    setChangePasswordDialog(true);
  };

  const handlePasswordDialogClose = () => {
    setChangePasswordDialog(false);
    resetPasswordDialogState();
  };

  const handlePasswordChange = async () => {
    if (!isSelfProfile) return;

    const trimmedCurrent = passwordData.currentPassword.trim();
    const trimmedNew = passwordData.newPassword.trim();
    const trimmedConfirm = passwordData.confirmPassword.trim();

    const nextErrors = createPasswordErrorState();

    if (!trimmedCurrent) {
      nextErrors.current = "Current password is required.";
    }

    if (!trimmedNew) {
      nextErrors.new = "New password is required.";
    }

    if (!trimmedConfirm) {
      nextErrors.confirm = "Please confirm the new password.";
    }

    if (!nextErrors.new && trimmedNew.length < PASSWORD_MIN_LENGTH) {
      nextErrors.new = `Password must be at least ${PASSWORD_MIN_LENGTH} characters.`;
    }

    if (!nextErrors.confirm && trimmedNew && trimmedConfirm && trimmedNew !== trimmedConfirm) {
      nextErrors.confirm = "New passwords do not match.";
    }

    if (nextErrors.current || nextErrors.new || nextErrors.confirm) {
      setPasswordErrors(nextErrors);
      return;
    }

    try {
      setLoading(true);
      await api.post("/auth/change-password", {
        currentPassword: trimmedCurrent,
        newPassword: trimmedNew,
      });
      setSuccess("Password changed successfully");
      setChangePasswordDialog(false);
      resetPasswordDialogState();
      setTimeout(() => setSuccess(""), 3000);
    } catch (err) {
      const derivedMessage = derivePasswordChangeError(err);
      setPasswordErrors((prev) => ({
        ...prev,
        general: derivedMessage,
      }));
      console.error("Error changing password:", err);
    } finally {
      setLoading(false);
    }
  };

  const resetAvatarSelection = () => {
    setAvatarPreviewUrl("");
    setSelectedAvatarFile(null);
    setCroppedAreaPixels(null);
    setCrop({ x: 0, y: 0 });
    setZoom(1);
    if (fileInputRef.current) {
      fileInputRef.current.value = "";
    }
  };

  const handleAvatarFileSelect = (event) => {
    const file = event.target.files?.[0];
    if (!file || avatarUploading) {
      return;
    }

    setError("");
    setSuccess("");

    if (!file.type.startsWith("image/")) {
      setError("Please select a valid image file.");
      if (event.target) {
        event.target.value = "";
      }
      return;
    }

    if (file.size > 5 * 1024 * 1024) {
      setError("Please upload an image that is 5 MB or smaller.");
      if (event.target) {
        event.target.value = "";
      }
      return;
    }

    if (avatarPreviewUrl) {
      URL.revokeObjectURL(avatarPreviewUrl);
    }

    const previewUrl = URL.createObjectURL(file);
    setSelectedAvatarFile(file);
    setAvatarPreviewUrl(previewUrl);
    setAvatarProgress(0);
    setAvatarDialogOpen(true);
    setCrop({ x: 0, y: 0 });
    setZoom(1);
    setCroppedAreaPixels(null);

    if (fileInputRef.current) {
      fileInputRef.current.value = "";
    }
  };

  const handleAvatarDialogClose = () => {
    if (avatarUploading) {
      return;
    }
    setAvatarDialogOpen(false);
    resetAvatarSelection();
    setAvatarProgress(0);
  };

  const handleCropComplete = useCallback((_, areaPixels) => {
    setCroppedAreaPixels(areaPixels);
  }, []);

  const uploadSelectedAvatar = async () => {
    if (!selectedAvatarFile) {
      return;
    }

    const targetId = getUserIdentifier(profileData) || getUserIdentifier(user);
    if (!targetId) {
      setError("Unable to determine the user identifier for this profile.");
      return;
    }

    try {
      setError("");
      setSuccess("");
      setAvatarUploading(true);
      setAvatarProgress(0);

      let fileToUpload = selectedAvatarFile;
      if (croppedAreaPixels) {
        try {
          const { file: croppedFile } = await getCroppedImage(selectedAvatarFile, croppedAreaPixels);
          fileToUpload = croppedFile;
        } catch (cropError) {
          console.error("Error cropping avatar:", cropError);
          setError("Failed to crop image. Please try again or choose a different photo.");
          setAvatarUploading(false);
          return;
        }
      }

      const response = await usersAPI.uploadAvatar(
        targetId,
        fileToUpload,
        (value) => setAvatarProgress(value || 0),
      );

      const updatedAvatar = response.data?.avatar;
      const updatedAvatarUrl = response.data?.avatarUrl || updatedAvatar?.url || "";

      setProfileData((prev) => ({
        ...prev,
        avatar: updatedAvatar,
        avatarUrl: updatedAvatarUrl,
      }));

      if (isSelfProfile) {
        updateUserData((prev) => ({
          ...(prev || {}),
          avatar: updatedAvatar,
          avatarUrl: updatedAvatarUrl,
        }));
      }

      setSuccess("Profile photo updated successfully");
      setTimeout(() => setSuccess(""), 3000);
      setAvatarDialogOpen(false);
      resetAvatarSelection();
      setAvatarProgress(0);
    } catch (err) {
      const message = err?.response?.data?.message || "Failed to upload profile photo";
      setError(message);
      console.error("Error uploading avatar:", err);
    } finally {
      setAvatarUploading(false);
      setAvatarProgress(0);
    }
  };

  const getStatusColor = (status) => {
    switch (status) {
      case "active":
        return "primary";
      case "returned":
        return "success";
      case "overdue":
        return "error";
      default:
        return "default";
    }
  };

  const togglePasswordVisibility = (field) => {
    setShowPasswords((prev) => ({
      ...prev,
      [field]: !prev[field],
    }));
  };

  const avatarUrl = getAvatarUrl(profileData);
  const isPasswordSubmitDisabled =
    loading ||
    !passwordData.currentPassword.trim() ||
    !passwordData.newPassword.trim() ||
    !passwordData.confirmPassword.trim();

  return (
    <Box>
      <Box display="flex" alignItems="center" gap={1.5} mb={2}>
        <IconButton aria-label="Go back" onClick={() => navigate(-1)}>
          <ArrowBack />
        </IconButton>
        <Typography variant="h4" gutterBottom sx={{ mb: 0 ,color: 'white'}}>
          {isSelfProfile ? "My Profile" : "User Profile"} {" "}
        </Typography>
      </Box>
      {profileLoading && (
        <Box
          display="flex"
          alignItems="center"
          gap={1}
          color="text.secondary"
          sx={{ mb: 2 }}
        >
          <CircularProgress size={20} />
          <Typography variant="body2">Loading user profile...</Typography>
        </Box>
      )}
      {error && (
        <Alert severity="error" sx={{ mb: 2 }}>
          {" "}
          {error}{" "}
        </Alert>
      )}
      {success && (
        <Alert severity="success" sx={{ mb: 2 }}>
          {" "}
          {success}{" "}
        </Alert>
      )}
      <Grid container spacing={3}>
        {" "}
        {}{" "}
        <Grid item xs={12} md={4}>
          <Card>
            <CardContent>
              <Box
                display="flex"
                flexDirection="column"
                alignItems="center"
                mb={3}
              >
                <Box position="relative" display="inline-flex">
                  <Avatar
                    src={avatarUrl || undefined}
                    alt={profileData?.firstName || profileData?.username || "Profile"}
                    sx={{
                      width: 100,
                      height: 100,
                      mb: 2,
                      bgcolor: avatarUrl ? "transparent" : "primary.main",
                      fontSize: "2.5rem",
                      color: "primary.contrastText",
                    }}
                  >
                    {getAvatarInitial(profileData) || <Person />} {" "}
                  </Avatar>
                  {avatarUploading && (
                    <Box
                      position="absolute"
                      top={0}
                      left={0}
                      width="100%"
                      height="100%"
                      display="flex"
                      alignItems="center"
                      justifyContent="center"
                      borderRadius="50%"
                      sx={{ bgcolor: "rgba(15, 23, 42, 0.45)" }}
                    >
                      <CircularProgress size={42} sx={{ color: "#ffffff" }} />
                    </Box>
                  )}
                  {isSelfProfile && (
                    <>
                      <input
                        ref={fileInputRef}
                        type="file"
                        accept="image}
                {profileData.role === "student" && (
                  <>
                    {profileData.libraryCardNumber && (
                      <ListItem>
                        <ListItemIcon>
                          <Assignment />
                        </ListItemIcon>
                        <ListItemText primary="Library Card" secondary={profileData.libraryCardNumber} />
                      </ListItem>
                    )}
                    {profileData.studentId && (
                      <ListItem>
                        <ListItemIcon>
                          <School />
                        </ListItemIcon>
                        <ListItemText primary="Student ID" secondary={profileData.studentId} />
                      </ListItem>
                    )}
                    {profileData.lrn && (
                      <ListItem>
                        <ListItemIcon>
                          <Assignment />
                        </ListItemIcon>
                        <ListItemText primary="LRN" secondary={profileData.lrn} />
                      </ListItem>
                    )}
                    {(profileData.grade || profileData.section) && (
                      <ListItem>
                        <ListItemIcon>
                          <LibraryBooks />
                        </ListItemIcon>
                        <ListItemText
                          primary="Grade / Section"
                          secondary={`${profileData.grade || ""}${profileData.grade && profileData.section ? " ‚Ä¢ " : ""}${profileData.section || ""}`}
                        />
                      </ListItem>
                    )}
                    {profileData.fullAddress && (
                      <ListItem>
                      <ListItemIcon>
                          <LocationOn />
                        </ListItemIcon>
                        <ListItemText primary="Address" secondary={profileData.fullAddress} />
                      </ListItem>
                    )}
                  </>
                )}
                {profileData.phoneNumber && (
                  <ListItem>
                    <ListItemIcon>
                      <Phone />
                    </ListItemIcon>{" "}
                    <ListItemText
                      primary="Phone"
                      secondary={profileData.phoneNumber}
                    />{" "}
                  </ListItem>
                )}{" "}
                {profileData.curriculum && (
                  <ListItem>
                    <ListItemIcon>
                      <School />
                    </ListItemIcon>
                    <ListItemText
                      primary="Curriculum"
                      secondary={profileData.curriculum}
                    />{" "}
                  </ListItem>
                )}{" "}
              </List>
              <Box mt={2}>
                {isSelfProfile && (
                  <Box>
                    <Button
                      fullWidth
                      variant="outlined"
                      startIcon={<Edit />}
                      onClick={() => setEditMode(true)}
                      sx={{ mb: 1 }}
                    >
                      Edit Profile{" "}
                    </Button>{" "}
                    <Button
                      fullWidth
                      variant="outlined"
                      startIcon={<Security />}
                      onClick={handlePasswordDialogOpen}
                    >
                      Change Password{" "}
                    </Button>{" "}
                  </Box>
                )}
                {!isSelfProfile && profileData.role === "student" && canEditStudentRecords && (
                  <Box mt={2}>
                    <Button
                      fullWidth
                      variant="contained"
                      onClick={() => {
                        const targetId = profileData._id || profileData.id;
                        if (targetId) navigate(`/students/${targetId}/edit`);
                      }}
                    >
                      Edit Student Record
                    </Button>
                  </Box>
                )}
              </Box>{" "}
            </CardContent>{" "}
          </Card>
        </Grid>
        {}
        <Grid item xs={12} md={8}>
          {}
          {!shouldShowAuditHistory && (
            <Grid container spacing={2} sx={{ mb: 3 }}>
              <Grid item xs={6} md={3}>
                <Card>
                  <CardContent sx={{ textAlign: "center" }}>
                    <LibraryBooks color="primary" sx={{ fontSize: 40, mb: 1 }} />
                    <Typography variant="h6">{stats.totalBorrowings}</Typography>
                    <Typography variant="body2" color="textSecondary">
                      Total Borrowed
                    </Typography>
                  </CardContent>
                </Card>
              </Grid>
              <Grid item xs={6} md={3}>
                <Card>
                  <CardContent sx={{ textAlign: "center" }}>
                    <Assignment color="info" sx={{ fontSize: 40, mb: 1 }} />
                    <Typography variant="h6">{stats.currentlyBorrowed}</Typography>
                    <Typography variant="body2" color="textSecondary">
                      Currently Borrowed
                    </Typography>
                  </CardContent>
                </Card>
              </Grid>
              {finesEnabled ? (
                <Grid item xs={6} md={3}>
                  <Card>
                    <CardContent sx={{ textAlign: "center" }}>
                      <Warning color="error" sx={{ fontSize: 40, mb: 1 }} />
                      <Typography variant="h6">{stats.overdueBorrowings}</Typography>
                      <Typography variant="body2" color="textSecondary">
                        Overdue
                      </Typography>
                    </CardContent>
                  </Card>
                </Grid>
              ) : null}
              {finesEnabled ? (
                <Grid item xs={6} md={3}>
                  <Card>
                    <CardContent sx={{ textAlign: "center" }}>
                      <Typography variant="h6" color="error">
                        {formatCurrency(stats.totalFines)}
                      </Typography>
                      <Typography variant="body2" color="textSecondary">
                        Total Fines
                      </Typography>
                    </CardContent>
                  </Card>
                </Grid>
              ) : null}
            </Grid>
          )}
          {}
          <Card>
            <CardContent>
              <Typography variant="h6" gutterBottom>
                {shouldShowAuditHistory ? "Recent Audit History" : "Recent Borrowing History"}
              </Typography>
              {shouldShowAuditHistory ? (
                auditLoading && (
                  <Typography variant="caption" color="text.secondary" sx={{ display: "block", mb: 1 }}>
                    Loading audit entries...
                  </Typography>
                )
              ) : (
                booksLoading && (
                  <Typography variant="caption" color="text.secondary" sx={{ display: "block", mb: 1 }}>
                    Resolving book titles...
                  </Typography>
                )
              )}
              {shouldShowAuditHistory ? (
                auditError && (
                  <Alert severity="warning" sx={{ mb: 1 }}>
                    {auditError}
                  </Alert>
                )
              ) : (
                booksError && (
                  <Alert severity="warning" sx={{ mb: 1 }}>
                    {booksError}
                  </Alert>
                )
              )}
              <TableContainer>
                <Table>
                  <TableHead>
                    <TableRow>
                      {shouldShowAuditHistory ? (
                        <>
                          <TableCell>Timestamp</TableCell>
                          <TableCell>Action</TableCell>
                          <TableCell>Entity</TableCell>
                          <TableCell>Details</TableCell>
                        </>
                      ) : (
                        <>
                          <TableCell>Book Title</TableCell>
                          <TableCell>Borrow Date</TableCell>
                          <TableCell>Due Date</TableCell>
                          <TableCell>Status</TableCell>
                        </>
                      )}
                    </TableRow>
                  </TableHead>
                  <TableBody>
                    {shouldShowAuditHistory
                      ? (auditHistory.length > 0
                          ? auditHistory.slice(0, 10).map((log) => (
                              <TableRow key={log.id || log._id || log.timestamp}>
                                <TableCell>
                                  {formatAuditTimestamp(log.timestamp || log.createdAt)}
                                </TableCell>
                                <TableCell>{log.action || "‚Äî"}</TableCell>
                                <TableCell>{log.entity || log.resource || "‚Äî"}</TableCell>
                                <TableCell>{formatAuditDetails(log)}</TableCell>
                              </TableRow>
                            ))
                          : (
                              <TableRow>
                                <TableCell colSpan={4} align="center">
                                  {auditLoading
                                    ? "Loading audit history..."
                                    : auditError || "No audit history found"}
                                </TableCell>
                              </TableRow>
                            ))
                      : borrowingHistory.slice(0, 10).map((transaction) => (
                          <TableRow key={transaction._id}>
                            <TableCell>
                              <Typography variant="body2" fontWeight="medium">
                                {transaction.bookTitle || "Unknown Book"}
                              </Typography>
                              {transaction.author && (
                                <Typography variant="caption" color="textSecondary">
                                  {transaction.author}
                                </Typography>
                              )}
                            </TableCell>
                            <TableCell>
                              {new Date(transaction.borrowDate).toLocaleDateString()}
                            </TableCell>
                            <TableCell>
                              {new Date(transaction.dueDate).toLocaleDateString()}
                            </TableCell>
                            <TableCell>
                              <Chip
                                label={transaction.status}
                                color={getStatusColor(transaction.status)}
                                size="small"
                              />
                            </TableCell>
                          </TableRow>
                        ))}
                  </TableBody>
                </Table>
              </TableContainer>
              {!shouldShowAuditHistory && borrowingHistory.length === 0 && (
                <Typography
                  textAlign="center"
                  color="textSecondary"
                  sx={{ py: 3 }}
                >
                  No borrowing history found
                </Typography>
              )}
            </CardContent>
          </Card>
        </Grid>
      </Grid>
      {isSelfProfile && (
        <>
          {}
          <Dialog
            open={avatarDialogOpen}
            onClose={handleAvatarDialogClose}
            maxWidth="xs"
            fullWidth
          >
            <DialogTitle>Preview Profile Photo</DialogTitle>
            <DialogContent>
              {avatarPreviewUrl ? (
                <>
                  <Typography variant="body2" color="text.secondary" sx={{ mb: 2 }}>
                    Drag the image to reposition and use the slider to adjust zoom. The cropped area will be saved as your profile photo.
                  </Typography>
                  <Box
                    sx={{
                      position: "relative",
                      width: "100%",
                      height: 280,
                      bgcolor: "#0F172A0A",
                      borderRadius: 2,
                      overflow: "hidden",
                    }}
                  >
                    <Cropper
                      image={avatarPreviewUrl}
                      crop={crop}
                      zoom={zoom}
                      aspect={1}
                      cropShape="round"
                      showGrid={false}
                      onCropChange={setCrop}
                      onZoomChange={setZoom}
                      onCropComplete={handleCropComplete}
                      objectFit="cover"
                    />
                  </Box>
                  <Box mt={3}>
                    <Typography variant="body2" color="text.secondary" gutterBottom>
                      Zoom
                    </Typography>
                    <Slider
                      value={zoom}
                      min={1}
                      max={3}
                      step={0.05}
                      onChange={(_, value) => {
                        if (typeof value === "number") {
                          setZoom(value);
                        }
                      }}
                      disabled={avatarUploading}
                      aria-label="Zoom"
                    />
                  </Box>
                </>
              ) : (
                <Typography variant="body2" color="text.secondary">
                  Select an image to preview it before uploading.
                </Typography>
              )}
              {avatarUploading && (
                <Box mt={2}>
                  <LinearProgress
                    variant={avatarProgress > 0 ? "determinate" : "indeterminate"}
                    value={avatarProgress}
                  />
                </Box>
              )}
            </DialogContent>
            <DialogActions>
              <Button onClick={handleAvatarDialogClose} disabled={avatarUploading}>
                Cancel
              </Button>
              <Button
                onClick={uploadSelectedAvatar}
                variant="contained"
                disabled={!selectedAvatarFile || avatarUploading}
              >
                {avatarUploading ? "Uploading..." : "Upload"}
              </Button>
            </DialogActions>
          </Dialog>
          {}
          <Dialog
            open={editMode}
            onClose={() => setEditMode(false)}
            maxWidth="sm"
            fullWidth
          >
            <DialogTitle> Edit Profile </DialogTitle>
            <DialogContent>
              {isStudentProfileView && attributeError && (
                <Alert severity="warning" sx={{ mb: 2 }}>
                  {attributeError}
                </Alert>
              )}
              <Grid container spacing={2}>
                <Grid item xs={12} sm={6}>
                  <TextField
                    fullWidth
                    label="First Name"
                    value={profileData.firstName || ""}
                    onChange={(e) =>
                      setProfileData({
                        ...profileData,
                        firstName: e.target.value,
                      })
                    }
                    margin="normal"
                  />
                </Grid>
                <Grid item xs={12} sm={6}>
                  <TextField
                    fullWidth
                    label="Last Name"
                    value={profileData.lastName || ""}
                    onChange={(e) =>
                      setProfileData({
                        ...profileData,
                        lastName: e.target.value,
                      })
                    }
                    margin="normal"
                  />
                </Grid>
                <Grid item xs={12}>
                  <TextField
                    fullWidth
                    label="Phone Number"
                    value={profileData.phoneNumber || ""}
                    onChange={(e) =>
                      setProfileData({
                        ...profileData,
                        phoneNumber: sanitizePhoneInput(e.target.value),
                      })
                    }
                    margin="normal"
                    inputProps={{ inputMode: "numeric", pattern: "[0-9]*", maxLength: 11 }}
                  />
                </Grid>
                {isStudentProfileView && (
                  <>
                    <Grid item xs={12} sm={6}>
                      {hasGradeOptions ? (
                        <TextField
                          select
                          fullWidth
                          label="Grade Level"
                          value={selectedGrade}
                          onChange={(e) => handleGradeSelectChange(e.target.value)}
                          margin="normal"
                          disabled={attributeLoading}
                        >
                          <MenuItem value="">
                            <em>Select grade</em>
                          </MenuItem>
                          {availableGradeOptions.map((gradeOption) => (
                            <MenuItem key={gradeOption} value={gradeOption}>
                              {gradeOption}
                            </MenuItem>
                          ))}
                        </TextField>
                      ) : (
                        <TextField
                          fullWidth
                          label="Grade Level"
                          value={selectedGrade}
                          onChange={(e) => handleGradeSelectChange(e.target.value)}
                          margin="normal"
                          disabled={attributeLoading}
                          helperText="Enter grade level"
                        />
                      )}
                    </Grid>
                    <Grid item xs={12} sm={6}>
                      {shouldRenderSectionSelect ? (
                        <TextField
                          select
                          fullWidth
                          label="Section"
                          value={selectedSection}
                          onChange={(e) => handleSectionSelectChange(e.target.value)}
                          margin="normal"
                          disabled={attributeLoading}
                        >
                          <MenuItem value="">
                            <em>Select section</em>
                          </MenuItem>
                          {availableSections.map((sectionOption) => (
                            <MenuItem key={sectionOption} value={sectionOption}>
                              {sectionOption}
                            </MenuItem>
                          ))}
                        </TextField>
                      ) : (
                        <TextField
                          fullWidth
                          label="Section"
                          value={selectedSection}
                          onChange={(e) => handleSectionSelectChange(e.target.value)}
                          margin="normal"
                          disabled={
                            attributeLoading || (hasSectionOptions && !selectedGrade)
                          }
                          helperText={
                            !selectedGrade && hasSectionOptions
                              ? "Select a grade to choose a section"
                              : selectedGrade && !hasSectionOptions
                              ? "No sections configured for this grade"
                              : "Enter section"
                          }
                        />
                      )}
                    </Grid>
                  </>
                )}
                <Grid item xs={12}>
                  <TextField
                    fullWidth
                    label="Address"
                    multiline
                    rows={3}
                    value={profileData.address || ""}
                    onChange={(e) =>
                      setProfileData({
                        ...profileData,
                        address: e.target.value,
                      })
                    }
                    margin="normal"
                  />
                </Grid>
              </Grid>
            </DialogContent>
            <DialogActions>
              <Button onClick={() => setEditMode(false)} startIcon={<Cancel />}>
                Cancel
              </Button>
              <Button
                onClick={handleProfileUpdate}
                variant="contained"
                disabled={loading}
                startIcon={<Save />}
              >
                {loading ? "Saving..." : "Save Changes"}
              </Button>
            </DialogActions>
          </Dialog>
          {}
          <Dialog
            open={changePasswordDialog}
            onClose={handlePasswordDialogClose}
            maxWidth="sm"
            fullWidth
          >
            <DialogTitle> Change Password </DialogTitle>
            <DialogContent>
              {passwordErrors.general && (
                <Alert severity="error" sx={{ mb: 2 }}>
                  {passwordErrors.general}
                </Alert>
              )}
              <TextField
                fullWidth
                label="Current Password"
                autoComplete="off"
                type={showPasswords.current ? "text" : "password"}
                value={passwordData.currentPassword}
                onChange={handlePasswordFieldChange("currentPassword")}
                margin="normal"
                error={Boolean(passwordErrors.current)}
                helperText={passwordErrors.current || " "}
                InputProps={{
                  endAdornment: (
                    <InputAdornment position="end">
                      <IconButton
                        onClick={() => togglePasswordVisibility("current")}
                        edge="end"
                      >
                        {showPasswords.current ? <VisibilityOff /> : <Visibility />}
                      </IconButton>
                    </InputAdornment>
                  ),
                }}
              />
              <TextField
                fullWidth
                label="New Password"
                autoComplete="new-password"
                type={showPasswords.new ? "text" : "password"}
                value={passwordData.newPassword}
                onChange={handlePasswordFieldChange("newPassword")}
                margin="normal"
                error={Boolean(passwordErrors.new)}
                helperText={
                  passwordErrors.new ||
                  `Minimum of ${PASSWORD_MIN_LENGTH} characters.`
                }
                InputProps={{
                  endAdornment: (
                    <InputAdornment position="end">
                      <IconButton
                        onClick={() => togglePasswordVisibility("new")}
                        edge="end"
                      >
                        {showPasswords.new ? <VisibilityOff /> : <Visibility />}
                      </IconButton>
                    </InputAdornment>
                  ),
                }}
              />
              <TextField
                fullWidth
                label="Confirm New Password"
                autoComplete="new-password"
                type={showPasswords.confirm ? "text" : "password"}
                value={passwordData.confirmPassword}
                onChange={handlePasswordFieldChange("confirmPassword")}
                margin="normal"
                error={Boolean(passwordErrors.confirm)}
                helperText={passwordErrors.confirm || "Must match the new password."}
                InputProps={{
                  endAdornment: (
                    <InputAdornment position="end">
                      <IconButton
                        onClick={() => togglePasswordVisibility("confirm")}
                        edge="end"
                      >
                        {showPasswords.confirm ? <VisibilityOff /> : <Visibility />}
                      </IconButton>
                    </InputAdornment>
                  ),
                }}
              />
            </DialogContent>
            <DialogActions>
              <Button
                onClick={handlePasswordDialogClose}
                startIcon={<Cancel />}
              >
                Cancel
              </Button>
              <Button
                onClick={handlePasswordChange}
                variant="contained"
                disabled={isPasswordSubmitDisabled}
                startIcon={<Save />}
              >
                {loading ? "Changing..." : "Change Password"}
              </Button>
            </DialogActions>
          </Dialog>
        </>
      )}
    </Box>
  );
};

export default UserProfile;
```

## UsersList.js

| Field | Details |
| --- | --- |
| Program Name | UsersList.js |
| Description | Frontend page view for routing and page-level UI. |
| Called by | App.js |
| Table used | users |
|  |  |
| Programmer | Nazel Asca√±o |
| Date created | 12/14/2025 |
| Revision Date | TBD |
| Revision / description of change | None |

```javascript
import React, { useState, useEffect, useCallback, useRef } from "react";
import {
  Box,
  Typography,
  Button,
  TextField,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  Paper,
  Chip,
  TablePagination,
  IconButton,
  Menu,
  MenuItem,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  Fab,
  InputAdornment,
  CircularProgress,
  FormControl,
  InputLabel,
  Select,
  Avatar,
  ListItemIcon,
  Alert,
} from "@mui/material";
import {
  Search,
  Add,
  MoreVert,
  FilterList,
  Edit,
  Visibility,
  Delete,
  CheckCircle,
  Block,
  Person,
  LockReset,
} from "@mui/icons-material";
import { useNavigate, useLocation } from "react-router-dom";
import { useAuth } from "../../contexts/AuthContext";
import { api, usersAPI } from "../../utils/api";
import { resolveEntityAvatar } from "../../utils/media";
import toast from "react-hot-toast";
import MobileScanButton from "../../components/MobileScanButton";
import MobileScanDialog from "../../components/MobileScanDialog";
import { addActionButtonSx, floatingAddFabSx } from "../../theme/actionButtons";

const MIN_PASSWORD_LENGTH = 6;
const ROLE_OPTIONS = ["admin", "librarian", "staff", "student"];

const deriveRoleFilterFromSearch = (search) => {
  if (typeof search !== "string") {
    return "";
  }
  const params = new URLSearchParams(search);
  const rawRole = (params.get("role") || "").toLowerCase();
  return ROLE_OPTIONS.includes(rawRole) ? rawRole : "";
};

const deriveResetPasswordError = (error) => {
  const fallback = "Failed to reset password. Please try again.";
  if (!error) {
    return fallback;
  }
  if (error.response) {
    return error.response.data?.message || fallback;
  }
  if (error.request) {
    return "Unable to reach the server. Please check your connection.";
  }
  return error.message || fallback;
};

const UsersList = () => {
  const navigate = useNavigate();
  const location = useLocation();
  const { hasPermission, hasRole } = useAuth();

  const [users, setUsers] = useState([]);
  const [loading, setLoading] = useState(true);
  const [searchTerm, setSearchTerm] = useState("");
  const [roleFilter, setRoleFilter] = useState(() => deriveRoleFilterFromSearch(location.search));
  const [page, setPage] = useState(0);
  const [rowsPerPage, setRowsPerPage] = useState(10);
  const [totalUsers, setTotalUsers] = useState(0);
  const [debouncedSearchTerm, setDebouncedSearchTerm] = useState("");
  const [searchScannerOpen, setSearchScannerOpen] = useState(false);
  const searchInputId = "users-search-input";

  const [selectedUser, setSelectedUser] = useState(null);
  const [deleteDialogOpen, setDeleteDialogOpen] = useState(false);
  const [statusDialogOpen, setStatusDialogOpen] = useState(false);
  const [passwordDialogOpen, setPasswordDialogOpen] = useState(false);
  const [passwordDialogUser, setPasswordDialogUser] = useState(null);
  const [newPassword, setNewPassword] = useState("");
  const [passwordSaving, setPasswordSaving] = useState(false);
  const [passwordDialogErrors, setPasswordDialogErrors] = useState(() => ({
    field: "",
    general: "",
  }));

  const resetPasswordDialogState = useCallback(() => {
    setPasswordDialogErrors({ field: "", general: "" });
    setNewPassword("");
  }, []);

  const closePasswordDialog = useCallback(() => {
    setPasswordDialogOpen(false);
    setPasswordDialogUser(null);
    resetPasswordDialogState();
  }, [resetPasswordDialogState]);

  const [menuAnchor, setMenuAnchor] = useState(null);
  const queryInitializedRef = useRef(false);

  const [filterAnchorEl, setFilterAnchorEl] = useState(null);
  const filtersOpen = Boolean(filterAnchorEl);
  const openFilters = (e) => setFilterAnchorEl(e.currentTarget);
  const closeFilters = () => setFilterAnchorEl(null);

  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedSearchTerm(searchTerm);
    }, 400);
    return () => clearTimeout(handler);
  }, [searchTerm]);

  useEffect(() => {
    const nextRole = deriveRoleFilterFromSearch(location.search);
    setRoleFilter((prev) => (prev === nextRole ? prev : nextRole));
    queryInitializedRef.current = true;
  }, [location.search]);

  useEffect(() => {
    if (!queryInitializedRef.current) {
      return;
    }

    const params = new URLSearchParams(location.search || "");
    let changed = false;

    if (!roleFilter) {
      if (params.has("role")) {
        params.delete("role");
        changed = true;
      }
    } else if (params.get("role") !== roleFilter) {
      params.set("role", roleFilter);
      changed = true;
    }

    if (changed) {
      const nextSearch = params.toString();
      navigate(
        {
          pathname: location.pathname,
          search: nextSearch ? `?${nextSearch}` : "",
        },
        { replace: true },
      );
    }
  }, [roleFilter, location.pathname, location.search, navigate]);

  const loadUsers = useCallback(
    async (override = {}) => {
      const pageToFetch = override.page ?? page;
      const limitToFetch = override.limit ?? rowsPerPage;
      const limitValue = typeof limitToFetch === "string" ? limitToFetch.toLowerCase() : limitToFetch;
      const isAllMode = limitValue === "all" || limitValue === -1;
      const roleToFetch = override.role ?? roleFilter;
      const searchToFetch = override.search ?? debouncedSearchTerm;

      try {
        setLoading(true);
        const limitParam = isAllMode ? "all" : limitToFetch;
        const pageParam = isAllMode ? 1 : pageToFetch + 1;
        const params = {
          page: pageParam,
          limit: limitParam,
        };
        if (roleToFetch) params.role = roleToFetch;
        if (searchToFetch) params.search = searchToFetch;

        const response = await api.get("/users", { params });
        const payload = response.data || {};
        const userList = payload.users || payload.data || [];
        const total = payload.pagination?.total ?? payload.total ?? userList.length ?? 0;

        setUsers(userList);
        setTotalUsers(total);
      } catch (error) {
        console.error("Failed to fetch users:", error);
        toast.error("Failed to load users");
      } finally {
        setLoading(false);
      }
    },
    [page, rowsPerPage, roleFilter, debouncedSearchTerm]
  );

  useEffect(() => {
    loadUsers();
  }, [loadUsers]);

  useEffect(() => {
    if (!menuAnchor) return;
    const anchorDisconnected = typeof menuAnchor.isConnected === "boolean" && !menuAnchor.isConnected;
    if (loading || anchorDisconnected) {
      setMenuAnchor(null);
    }
  }, [loading, menuAnchor]);

  useEffect(() => {
    if (!filterAnchorEl) return;
    const anchorDisconnected = typeof filterAnchorEl.isConnected === "boolean" && !filterAnchorEl.isConnected;
    if (loading || anchorDisconnected) {
      setFilterAnchorEl(null);
    }
  }, [loading, filterAnchorEl]);

  const getUserId = (user) => user?._id || user?.id || user?.userId || null;

  const handleMenuClick = (e, user) => {
    setSelectedUser(user);
    setMenuAnchor(e.currentTarget);
  };

  const handleMenuClose = (clearSelected = false) => {
    setMenuAnchor(null);
    if (clearSelected) setSelectedUser(null);
  };

  const handleRowDoubleClick = (user) => {
    const id = getUserId(user);
    if (id) navigate(`/users/${id}`);
  };

  const handleDeleteUser = async () => {
    try {
      setLoading(true);
      const userId = getUserId(selectedUser);
      if (!userId) return;
      await api.delete(`/users/${userId}`);
      await loadUsers();
      toast.success("User deleted successfully");
      setDeleteDialogOpen(false);
      setSelectedUser(null);
    } catch (error) {
      console.error("Failed to delete user:", error);
      toast.error("Failed to delete user");
    } finally {
      setLoading(false);
    }
  };

  const handleToggleStatus = async () => {
    try {
      setLoading(true);
      const userId = getUserId(selectedUser);
      if (!userId) return;
      const newStatus = !selectedUser?.isActive;
      await api.patch(`/users/${userId}`, { isActive: newStatus });
      setUsers((prev) => prev.map((u) => (getUserId(u) === userId ? { ...u, isActive: newStatus } : u)));
      toast.success("User status updated");
      setStatusDialogOpen(false);
      setSelectedUser(null);
    } catch (error) {
      console.error("Failed to update status:", error);
      toast.error("Failed to update user status");
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    setPage(0);
  }, [debouncedSearchTerm, roleFilter]);

  useEffect(() => {
    if (!loading && users.length === 0 && totalUsers > 0 && page > 0) {
      setPage((prev) => Math.max(prev - 1, 0));
    }
  }, [loading, users.length, totalUsers, page]);

  const getRoleColor = (role) => {
    switch (role) {
      case "admin":
        return "error";
      case "librarian":
        return "warning";
      case "staff":
        return "info";
      case "student":
        return "success";
      default:
        return "default";
    }
  };

  const getStatusColor = (isActive) => (isActive ? "success" : "error");

  if (loading) {
    return (
      <Box display="flex" justifyContent="center" alignItems="center" minHeight="60vh">
        <CircularProgress />
      </Box>
    );
  }

  return (
    <Box>
      <Box display="flex" justifyContent="space-between" alignItems="center" mb={3}>
        <Typography variant="h4" component="h1" color={"white"}>
          Users Management
        </Typography>
        {hasPermission("users.create") && (
          <Button
            variant="contained"
            startIcon={<Add />}
            onClick={() => navigate("/users/new")}
            sx={addActionButtonSx}
          >
            Add New User
          </Button>
        )}
      </Box>

      <Box mb={3}>
        <Box display="flex" gap={2} flexWrap="wrap" alignItems="center">
          <TextField
            placeholder="Search users by name, email, username, or student ID..."
            value={searchTerm}
            onChange={(e) => setSearchTerm(e.target.value)}
            sx={{ flex: 1, minWidth: 300 }}
            inputProps={{ id: searchInputId }}
            InputProps={{
              startAdornment: (
                <InputAdornment position="start">
                  <Search />
                </InputAdornment>
              ),
            }}
          />

          <MobileScanButton
            label="Scan to Search"
            onClick={() => setSearchScannerOpen(true)}
          />

          {}
          <IconButton aria-label="Open filters" onClick={openFilters} size="small" sx={{ border: "1px solid #E2E8F0", backgroundColor: "#F8FAFC" }}>
            <FilterList />
          </IconButton>

          <Menu
            anchorEl={filterAnchorEl}
            open={filtersOpen}
            onClose={closeFilters}
            anchorOrigin={{ vertical: "bottom", horizontal: "right" }}
            transformOrigin={{ vertical: "top", horizontal: "right" }}
            PaperProps={{ sx: { p: 2, minWidth: 220 } }}
            disableAutoFocus
            disableAutoFocusItem
            disableEnforceFocus
          >
            <Box sx={{ display: "flex", flexDirection: "column", gap: 1 }}>
              <FormControl fullWidth size="small">
                <InputLabel>Role</InputLabel>
                <Select
                  value={roleFilter}
                  onChange={(e) => setRoleFilter(e.target.value)}
                  label="Role"
                  MenuProps={{ disablePortal: true, disableScrollLock: true }}
                >
                  <MenuItem value="">All Roles</MenuItem>
                  {ROLE_OPTIONS.map((role) => (
                    <MenuItem key={role} value={role}>
                      {role.charAt(0).toUpperCase() + role.slice(1)}
                    </MenuItem>
                  ))}
                </Select>
              </FormControl>

              <Box display="flex" justifyContent="flex-end" gap={1} mt={1}>
                <Button size="small" onClick={() => { setRoleFilter(""); closeFilters(); }}>Clear</Button>
                <Button size="small" variant="contained" onClick={closeFilters}>Apply</Button>
              </Box>
            </Box>
          </Menu>
        </Box>
      </Box>

      {!loading && totalUsers === 0 ? (
        <Box textAlign="center" py={8}>
          <Typography variant="h6" color="text.secondary" gutterBottom>
            {searchTerm || roleFilter ? "No users found matching your criteria" : "No users available"}
          </Typography>
          <Typography variant="body2" color="text.secondary" gutterBottom>
            {hasPermission("users.create") && "Start by adding your first user to the system"}
          </Typography>
          {hasPermission("users.create") && (
            <Button variant="contained" startIcon={<Add />} onClick={() => navigate("/users/new")} sx={{ ...addActionButtonSx, mt: 2 }}>
              Add First User
            </Button>
          )}
        </Box>
      ) : (
        <TableContainer component={Paper}>
          <Table>
            <TableHead>
              <TableRow>
                <TableCell>User</TableCell>
                <TableCell>Email</TableCell>
                <TableCell>Role</TableCell>
                <TableCell>Student ID</TableCell>
                <TableCell>Curriculum</TableCell>
                <TableCell>Status</TableCell>
                <TableCell>Last Login</TableCell>
                <TableCell align="right">Actions</TableCell>
              </TableRow>
            </TableHead>
            <TableBody>
              {users.map((user) => {
                const avatarSrc = resolveEntityAvatar(user);
                const fallbackInitial = [user.firstName, user.lastName, user.username, user.email]
                  .map((value) => (typeof value === "string" && value.trim() ? value.trim().charAt(0).toUpperCase() : ""))
                  .find(Boolean);
                const avatarAlt = [user.firstName, user.lastName]
                  .filter((value) => typeof value === "string" && value.trim())
                  .join(" ") || user.username || user.email || "User avatar";

                return (
                  <TableRow key={getUserId(user)} hover onDoubleClick={() => handleRowDoubleClick(user)} sx={{ cursor: "pointer" }}>
                    <TableCell>
                      <Box display="flex" alignItems="center" gap={2}>
                        <Avatar
                          src={avatarSrc || undefined}
                          alt={avatarAlt}
                          sx={{
                            bgcolor: avatarSrc ? "transparent" : "primary.main",
                            color: avatarSrc ? "inherit" : "primary.contrastText",
                          }}
                        >
                          {fallbackInitial || <Person fontSize="small" />}
                        </Avatar>
                        <Box>
                          <Typography variant="body2" fontWeight="medium">{user.firstName} {user.lastName}</Typography>
                          <Typography variant="caption" color="text.secondary">@ {user.username}</Typography>
                        </Box>
                      </Box>
                    </TableCell>
                  <TableCell>{user.email}</TableCell>
                  <TableCell>
                    <Chip label={user.role} size="small" color={getRoleColor(user.role)} />
                  </TableCell>
                  <TableCell>{user.studentId || user.libraryCardNumber || (user.library && user.library.cardNumber) || "-"}</TableCell>
                  <TableCell>{user.curriculum || "-"}</TableCell>
                  <TableCell>
                    <Chip label={user.isActive ? "Active" : "Inactive"} size="small" color={getStatusColor(user.isActive)} icon={user.isActive ? <CheckCircle /> : <Block />} />
                  </TableCell>
                  <TableCell>{user.lastLoginAt ? new Date(user.lastLoginAt).toLocaleDateString() : "Never"}</TableCell>
                  <TableCell align="right">
                    <IconButton size="small" onClick={(e) => handleMenuClick(e, user)}>
                      <MoreVert />
                    </IconButton>
                  </TableCell>
                  </TableRow>
                );
              })}
            </TableBody>
          </Table>
          <TablePagination
            component="div"
            count={totalUsers}
            page={page}
            onPageChange={(event, newPage) => setPage(newPage)}
            rowsPerPage={rowsPerPage}
            onRowsPerPageChange={(event) => {
              const value = parseInt(event.target.value, 10);
              setRowsPerPage(Number.isNaN(value) ? 10 : value);
              setPage(0);
            }}
            rowsPerPageOptions={[10, 25, 50, 100, { label: "All", value: -1 }]}
            labelRowsPerPage="Rows per page"
            sx={{ borderTop: "1px solid", borderColor: "divider" }}
          />
        </TableContainer>
      )}

        <MobileScanDialog
          open={searchScannerOpen}
          onClose={() => setSearchScannerOpen(false)}
          onDetected={(value) => setSearchTerm(value || "")}
          title="Scan to Search Users"
          elementId="users-search-qr"
          targetSelector={`#${searchInputId}`}
        />

      {}
      <Menu
        anchorEl={menuAnchor}
        open={Boolean(menuAnchor)}
        onClose={() => handleMenuClose(true)}
        anchorOrigin={{ vertical: "bottom", horizontal: "right" }}
        transformOrigin={{ vertical: "top", horizontal: "right" }}
      >
        <MenuItem
          onClick={() => {
            const selectedUserId = getUserId(selectedUser);
            if (!selectedUserId) {
              handleMenuClose();
              return;
            }
            navigate(`/users/${selectedUserId}`);
            handleMenuClose(true);
          }}
        >
          <ListItemIcon>
            <Visibility fontSize="small" />
          </ListItemIcon>
          View Profile
        </MenuItem>
        {hasPermission("users.update") && (
          <MenuItem
            onClick={() => {
              const selectedUserId = getUserId(selectedUser);
              if (!selectedUserId) {
                handleMenuClose();
                return;
              }
              navigate(`/users/${selectedUserId}/edit`);
              handleMenuClose(true);
            }}
          >
            <ListItemIcon>
              <Edit fontSize="small" />
            </ListItemIcon>
            Edit User
          </MenuItem>
        )}
        {hasPermission("users.update") && (
          <MenuItem
            onClick={() => {
              setStatusDialogOpen(true);
              handleMenuClose(false);
            }}
          >
            <ListItemIcon>{selectedUser?.isActive ? <Block fontSize="small" /> : <CheckCircle fontSize="small" />}</ListItemIcon>
            {selectedUser?.isActive ? "Deactivate" : "Activate"}
          </MenuItem>
        )}
        {(hasRole("admin") || hasPermission("users.resetPassword")) && (
          <MenuItem
            onClick={() => {
              if (selectedUser) {
                setPasswordDialogUser(selectedUser);
                resetPasswordDialogState();
                setPasswordDialogOpen(true);
              }
              handleMenuClose(false);
            }}
          >
            <ListItemIcon>
              <LockReset fontSize="small" />
            </ListItemIcon>
            Reset Password
          </MenuItem>
        )}
        {hasPermission("users.delete") && (
          <MenuItem
            onClick={() => {
              setDeleteDialogOpen(true);
              handleMenuClose(false);
            }}
          >
            <ListItemIcon>
              <Delete fontSize="small" />
            </ListItemIcon>
            Delete User
          </MenuItem>
        )}
      </Menu>

      {}
      <Dialog open={deleteDialogOpen} onClose={() => setDeleteDialogOpen(false)}>
        <DialogTitle>Delete User</DialogTitle>
        <DialogContent>
          <Typography>
            Are you sure you want to delete user "{selectedUser?.firstName} {selectedUser?.lastName}"? This action cannot be undone and will remove all associated data.
          </Typography>
        </DialogContent>
        <DialogActions>
          <Button variant="outlined" onClick={() => setDeleteDialogOpen(false)}>Cancel</Button>
          <Button onClick={handleDeleteUser} color="error" variant="contained">Delete</Button>
        </DialogActions>
      </Dialog>

      {}
      <Dialog open={statusDialogOpen} onClose={() => setStatusDialogOpen(false)}>
        <DialogTitle>{selectedUser?.isActive ? "Deactivate" : "Activate"} User</DialogTitle>
        <DialogContent>
          <Typography>
            Are you sure you want to {selectedUser?.isActive ? "deactivate" : "activate"} user "{selectedUser?.firstName} {selectedUser?.lastName}"?
          </Typography>
        </DialogContent>
        <DialogActions>
          <Button variant="outlined" onClick={() => setStatusDialogOpen(false)}>Cancel</Button>
          <Button onClick={handleToggleStatus} color={selectedUser?.isActive ? "error" : "success"} variant="contained">
            {selectedUser?.isActive ? "Deactivate" : "Activate"}
          </Button>
        </DialogActions>
      </Dialog>

      <Dialog
        open={passwordDialogOpen}
        onClose={closePasswordDialog}
      >
        <DialogTitle>Reset Password</DialogTitle>
        <DialogContent sx={{ pt: 1 }}>
          <Typography variant="body2" color="text.secondary" sx={{ mb: 2 }}>
            Enter a new password for {passwordDialogUser?.firstName} {passwordDialogUser?.lastName}. The user will be required to use this password on next login.
          </Typography>
          {passwordDialogErrors.general && (
            <Alert severity="error" sx={{ mb: 2 }}>
              {passwordDialogErrors.general}
            </Alert>
          )}
          <TextField
            autoFocus
            fullWidth
            type="password"
            label="New Password"
            value={newPassword}
            onChange={(event) => {
              setNewPassword(event.target.value);
              setPasswordDialogErrors({ field: "", general: "" });
            }}
            error={Boolean(passwordDialogErrors.field)}
            helperText={
              passwordDialogErrors.field ||
              `Minimum of ${MIN_PASSWORD_LENGTH} characters.`
            }
            disabled={passwordSaving}
          />
        </DialogContent>
        <DialogActions>
          <Button
            onClick={closePasswordDialog}
            disabled={passwordSaving}
          >
            Cancel
          </Button>
          <Button
            onClick={async () => {
              const targetUser = passwordDialogUser || selectedUser;
              const userId = getUserId(targetUser);
              if (!userId) {
                closePasswordDialog();
                return;
              }
              const trimmed = newPassword.trim();
              if (trimmed.length < MIN_PASSWORD_LENGTH) {
                setPasswordDialogErrors({
                  field: `Password must be at least ${MIN_PASSWORD_LENGTH} characters long.`,
                  general: "",
                });
                return;
              }
              try {
                setPasswordSaving(true);
                setPasswordDialogErrors({ field: "", general: "" });
                await usersAPI.resetPassword(userId, trimmed);
                toast.success("Password reset successfully.");
                closePasswordDialog();
                setSelectedUser(null);
              } catch (error) {
                console.error("Failed to reset password:", error);
                const message = deriveResetPasswordError(error);
                toast.error(message);
                setPasswordDialogErrors({ field: "", general: message });
              } finally {
                setPasswordSaving(false);
              }
            }}
            variant="contained"
            disabled={passwordSaving}
          >
            {passwordSaving ? "Saving..." : "Reset Password"}
          </Button>
        </DialogActions>
      </Dialog>

      {}
      {hasPermission("users.create") && (
        <Fab color="primary" aria-label="add user" sx={{ ...floatingAddFabSx, position: "fixed", bottom: 16, right: 16, display: { xs: "flex", sm: "none" } }} onClick={() => navigate("/users/new")}>
          <Add />
        </Fab>
      )}
    </Box>
  );
};

export default UsersList;
```

# Frontend - Theme

## actionButtons.js

| Field | Details |
| --- | --- |
| Program Name | actionButtons.js |
| Description | Frontend theming and UI configuration. |
| Called by | BooksList.js, StudentsList.js, TransactionsList.js, UsersList.js |
| Table used | None |
|  |  |
| Programmer | Nazel Asca√±o |
| Date created | 12/14/2025 |
| Revision Date | TBD |
| Revision / description of change | None |

```javascript
const sharedButtonSx = {
  textTransform: "none",
  fontWeight: 600,
  letterSpacing: 0.2,
  borderRadius: 12,
  whiteSpace: "nowrap",
  transition: "box-shadow 0.2s ease, transform 0.2s ease, background-color 0.2s ease, border-color 0.2s ease",
};

export const addActionButtonSx = {
  ...sharedButtonSx,
  color: "#ffffff",
  backgroundColor: "#16a34a",
  border: "1px solid #15803d",
  boxShadow: "0 8px 18px rgba(21, 128, 61, 0.35)",
  "&:hover": {
    backgroundColor: "#15803d",
    borderColor: "#166534",
    boxShadow: "0 10px 20px rgba(21, 128, 61, 0.4)",
    transform: "translateY(-1px)",
  },
  "&:active": {
    boxShadow: "0 4px 10px rgba(21, 128, 61, 0.4)",
    transform: "translateY(0)",
  },
  "&:focus-visible": {
    outline: "3px solid rgba(34, 197, 94, 0.35)",
    outlineOffset: "2px",
  },
};

export const importActionButtonSx = {
  ...sharedButtonSx,
  color: "#ffffff",
  backgroundColor: "#0ea5e9",
  border: "1px solid #0284c7",
  boxShadow: "0 6px 16px rgba(2, 132, 199, 0.35)",
  "&:hover": {
    backgroundColor: "#0284c7",
    borderColor: "#0369a1",
    boxShadow: "0 10px 20px rgba(2, 132, 199, 0.4)",
    transform: "translateY(-1px)",
  },
  "&:active": {
    boxShadow: "0 4px 10px rgba(2, 132, 199, 0.4)",
    transform: "translateY(0)",
  },
  "&:focus-visible": {
    outline: "3px solid rgba(56, 189, 248, 0.6)",
    outlineOffset: "2px",
  },
};

export const printActionButtonSx = {
  ...sharedButtonSx,
  color: "#0f172a",
  backgroundColor: "#fde047",
  border: "1px solid #facc15",
  "&:hover": {
    backgroundColor: "#facc15",
    borderColor: "#eab308",
    transform: "translateY(-1px)",
  },
  "&:active": {
    transform: "translateY(0)",
  },
  "&:focus-visible": {
    outline: "3px solid rgba(250, 204, 21, 0.45)",
    outlineOffset: "2px",
  },
};

export const floatingAddFabSx = {
  backgroundColor: "#16a34a",
  color: "#ffffff",
  boxShadow: "0 12px 26px rgba(21, 128, 61, 0.45)",
  "&:hover": {
    backgroundColor: "#15803d",
    boxShadow: "0 16px 30px rgba(21, 128, 61, 0.5)",
  },
};
```

## customTheme.js

| Field | Details |
| --- | --- |
| Program Name | customTheme.js |
| Description | Frontend theming and UI configuration. |
| Called by | App.js |
| Table used | None |
|  |  |
| Programmer | Nazel Asca√±o |
| Date created | 12/14/2025 |
| Revision Date | TBD |
| Revision / description of change | None |

```javascript
import { createTheme } from "@mui/material/styles";

const customTheme = createTheme({
  palette: {
    mode: "light",
    primary: {
      main: "#305FB7", // Updated blue from Figma
      light: "#4F7BC9",
      dark: "#1E4A8C",
      contrastText: "#FFFFFF",
    },
    secondary: {
      main: "#22C55E", // Green for active nav items
      light: "#4ADE80",
      dark: "#16A34A",
      contrastText: "#FFFFFF",
    },
    background: {
      default: "#305FB7", // Updated blue gradient background
      paper: "#FFFFFF",
      secondary: "#F8FAFC", // Light background for content
    },
    text: {
      primary: "#000000", // 21:1 contrast ratio (AAA compliant)
      secondary: "#2D3748", // 7.1:1 contrast ratio (AAA compliant)
      disabled: "#6B7280", // 4.5:1 contrast ratio (AA compliant)
    },
    divider: "#E2E8F0",
    success: {
      main: "#22C55E",
      light: "#4ADE80",
      dark: "#16A34A",
    },
    info: {
      main: "#3B82F6",
      light: "#60A5FA",
      dark: "#2563EB",
    },
    warning: {
      main: "#F59E0B",
      light: "#FBBF24",
      dark: "#D97706",
    },
    error: {
      main: "#EF4444",
      light: "#F87171",
      dark: "#DC2626",
    },
  },
  spacing: 4, // Reduce default spacing from 8px to 4px
  typography: {
    fontFamily: '"Inter", "Roboto", "Helvetica", "Arial", sans-serif',
    h1: {
      fontSize: "2rem",
      fontWeight: 700,
      color: "#000000", // AAA compliant
    },
    h2: {
      fontSize: "1.75rem",
      fontWeight: 600,
      color: "#000000", // AAA compliant
    },
    h3: {
      fontSize: "1.5rem",
      fontWeight: 600,
      color: "#000000", // AAA compliant
    },
    h4: {
      fontSize: "1.25rem",
      fontWeight: 600,
      color: "#000000", // AAA compliant
    },
    h5: {
      fontSize: "1.125rem",
      fontWeight: 600,
      color: "#000000", // AAA compliant
    },
    h6: {
      fontSize: "1rem",
      fontWeight: 600,
      color: "#000000", // AAA compliant
    },
    body1: {
      fontSize: "0.875rem",
      color: "#2D3748", // AAA compliant
    },
    body2: {
      fontSize: "0.75rem",
      color: "#2D3748", // AAA compliant
    },
    button: {
      textTransform: "none",
      fontWeight: 600,
      fontSize: "0.875rem",
    },
  },
  components: {
    MuiCssBaseline: {
      styleOverrides: {
        body: {
          background: "linear-gradient(135deg, #305FB7 0%, #4F7BC9 100%)",
          minHeight: "100vh",
        },
      },
    },
    MuiPaper: {
      styleOverrides: {
        root: {
          borderRadius: "4px", // Sharp corners like Figma
          boxShadow:
            "0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06)",
        },
      },
    },
    MuiCard: {
      styleOverrides: {
        root: {
          borderRadius: "4px", // Sharp corners like Figma
          boxShadow:
            "0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06)",
          border: "1px solid #E2E8F0",
        },
      },
    },
    MuiButton: {
      styleOverrides: {
        root: {
          borderRadius: "8px",
          textTransform: "none",
          fontWeight: 500,
          padding: "6px 12px",
          minHeight: "32px",
          fontSize: "0.75rem",
        },
        contained: {
          boxShadow: "0 3px 8px rgba(0, 0, 0, 0.12)",
          "&:hover": {
            boxShadow: "0 6px 18px rgba(0, 0, 0, 0.16)",
            transform: "translateY(-1px)",
          },
          "&.Mui-disabled": {
            opacity: 0.6,
            boxShadow: "none",
          },
          "&:focus-visible": {
            outline: "2px solid #305FB7",
            outlineOffset: "2px",
          },
        },
        outlined: {
          borderWidth: "1.5px",
          borderColor: "#E2E8F0",
          "&:hover": {
            borderColor: "#305FB7",
            backgroundColor: "rgba(48, 95, 183, 0.04)",
          },
        },
        text: {
          "&:hover": {
            backgroundColor: "rgba(48, 95, 183, 0.04)",
          },
        },
        small: {
          padding: "6px 10px",
          minHeight: "32px",
          fontSize: "0.8rem",
        },
        containedPrimary: {
          backgroundColor: "#305FB7",
          color: "#FFFFFF",
          '&:hover': {
            backgroundColor: '#1E4A8C',
          }
        },
        containedSecondary: {
          backgroundColor: '#22C55E',
          color: '#FFFFFF',
          '&:hover': {
            backgroundColor: '#16A34A',
          }
        },
        outlinedPrimary: {
          borderColor: '#305FB7',
          color: '#305FB7',
        },
        outlinedSecondary: {
          borderColor: '#22C55E',
          color: '#22C55E',
        },
      },
    },
    MuiFab: {
      styleOverrides: {
        root: {
          boxShadow: '0 6px 18px rgba(0,0,0,0.16)',
          '&:hover': {
            boxShadow: '0 10px 26px rgba(0,0,0,0.18)',
            transform: 'translateY(-2px)'
          }
        }
      }
    },
    MuiIconButton: {
      styleOverrides: {
        root: {
          padding: 8,
          borderRadius: 8,
          color: "#374151",
          backgroundColor: "transparent",
          '&:hover': {
            backgroundColor: '#F1F5F9',
          },
          '&.Mui-disabled': {
            color: '#9CA3AF',
          },
          '&:focus-visible': {
            outline: '3px solid rgba(48, 95, 183, 0.18)',
            outlineOffset: '2px',
          }
        }
      }
    },
    MuiTextField: {
      styleOverrides: {
        root: {
          "& .MuiOutlinedInput-root": {
            borderRadius: "4px", // Sharp corners like Figma
            backgroundColor: "#FFFFFF",
            "& fieldset": {
              borderColor: "#E2E8F0",
            },
            "&:hover fieldset": {
              borderColor: "#305FB7",
            },
            "&.Mui-focused fieldset": {
              borderColor: "#305FB7",
            },
          },
        },
      },
    },
    MuiTableContainer: {
      styleOverrides: {
        root: {
          borderRadius: "4px", // Sharp corners like Figma
          border: "1px solid #E2E8F0",
        },
      },
    },
    MuiTableHead: {
      styleOverrides: {
        root: {
          "& .MuiTableCell-head": {
            backgroundColor: "#F8FAFC",
            fontWeight: 600,
            color: "#374151",
            borderBottom: "1px solid #E2E8F0",
          },
        },
      },
    },
    MuiTableCell: {
      styleOverrides: {
        root: {
          borderBottom: "1px solid #F1F5F9",
        },
      },
    },
    MuiDrawer: {
      styleOverrides: {
        paper: {
          backgroundColor: "#FFFFFF",
          borderRight: "1px solid #E2E8F0",
          boxShadow:
            "0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06)",
        },
      },
    },
    MuiListItemButton: {
      styleOverrides: {
        root: {
          borderRadius: "8px",
          margin: "4px 8px",
          "&.Mui-selected": {
            backgroundColor: "#22C55E",
            color: "#FFFFFF",
            "& .MuiListItemIcon-root": {
              color: "#FFFFFF",
            },
            "&:hover": {
              backgroundColor: "#16A34A",
            },
          },
          "&:hover": {
            backgroundColor: "#F1F5F9",
          },
        },
      },
    },
    MuiChip: {
      styleOverrides: {
        root: {
          borderRadius: "6px",
        },
      },
    },
  },
  shape: {
    borderRadius: 8,
  },
});

export default customTheme;
```

# Frontend - Utils

## addressService.js

| Field | Details |
| --- | --- |
| Program Name | addressService.js |
| Description | Frontend utility helper for shared logic. |
| Called by | StudentForm.js, UserForm.js |
| Table used | None |
|  |  |
| Programmer | Nazel Asca√±o |
| Date created | 12/14/2025 |
| Revision Date | TBD |
| Revision / description of change | None |

```javascript
import { api } from "./api";

const DEFAULT_CACHE_TTL = 1000 * 60 * 60; // 1 hour
const PSGC_BASE_URL = "https://psgc.gitlab.io/api";
const FALLBACK_HTTP_ERROR_CODES = new Set([404, 500, 502, 503, 504]);

const createCacheEntry = (data, ttl = DEFAULT_CACHE_TTL) => ({
  data,
  expiresAt: Date.now() + ttl,
});

const isCacheValid = (entry) => entry && entry.expiresAt > Date.now();

const provinceCache = { entry: null };
const municipalityCache = new Map();
const barangayCache = new Map();

const shouldFallbackToPsgc = (error) => {
  if (!error || !error.response) {

    return true;
  }

  const status = error.response.status;
  return FALLBACK_HTTP_ERROR_CODES.has(status);
};

const fetchFromPsgc = async (relativePath) => {
  const fetchImpl =
    (typeof window !== "undefined" && window.fetch)
      ? window.fetch.bind(window)
      : typeof fetch !== "undefined"
        ? fetch
        : null;

  if (!fetchImpl) {
    throw new Error("Fetch API is not available in this environment.");
  }

  const response = await fetchImpl(`${PSGC_BASE_URL}${relativePath}`);
  if (!response.ok) {
    throw new Error(`PSGC request failed with status ${response.status}`);
  }
  return response.json();
};

const projectProvince = (province = {}) => ({
  code: province.code,
  name: province.name,
  regionCode: province.regionCode,
  regionName: province.regionName,
});

const projectMunicipality = (municipality = {}) => ({
  code: municipality.code,
  name: municipality.name,
  provinceCode: municipality.provinceCode,
});

const projectBarangay = (barangay = {}) => ({
  code: barangay.code,
  name: barangay.name,
  municipalityCode: barangay.municipalityCode,
});

const loadProvinces = async () => {
  try {
    const response = await api.get("/locations/provinces");
    const { provinces = [] } = response?.data || {};
    return provinces;
  } catch (error) {
    if (!shouldFallbackToPsgc(error)) {
      throw error;
    }
    return fetchFromPsgc("/provinces/");
  }
};

const loadMunicipalities = async (provinceCode) => {
  if (!provinceCode) {
    return [];
  }

  try {
    const response = await api.get(
      `/locations/provinces/${provinceCode}/municipalities`,
    );
    const { municipalities = [] } = response?.data || {};
    return municipalities;
  } catch (error) {
    if (!shouldFallbackToPsgc(error)) {
      throw error;
    }
    return fetchFromPsgc(`/provinces/${provinceCode}/cities-municipalities/`);
  }
};

const loadBarangays = async (municipalityCode) => {
  if (!municipalityCode) {
    return [];
  }

  try {
    const response = await api.get(
      `/locations/municipalities/${municipalityCode}/barangays`,
    );
    const { barangays = [] } = response?.data || {};
    return barangays;
  } catch (error) {
    if (!shouldFallbackToPsgc(error)) {
      throw error;
    }
    return fetchFromPsgc(
      `/cities-municipalities/${municipalityCode}/barangays/`,
    );
  }
};

export const getProvinces = async () => {
  if (isCacheValid(provinceCache.entry)) {
    return provinceCache.entry.data;
  }

  const provinces = await loadProvinces();
  const mapped = provinces.map(projectProvince);
  provinceCache.entry = createCacheEntry(mapped);
  return mapped;
};

export const getMunicipalities = async (provinceCode) => {
  if (!provinceCode) {
    return [];
  }

  const cacheEntry = municipalityCache.get(provinceCode);
  if (isCacheValid(cacheEntry)) {
    return cacheEntry.data;
  }

  const municipalities = await loadMunicipalities(provinceCode);
  const mapped = municipalities.map(projectMunicipality);

  municipalityCache.set(provinceCode, createCacheEntry(mapped));
  return mapped;
};

export const getBarangays = async (municipalityCode) => {
  if (!municipalityCode) {
    return [];
  }

  const cacheEntry = barangayCache.get(municipalityCode);
  if (isCacheValid(cacheEntry)) {
    return cacheEntry.data;
  }

  const barangays = await loadBarangays(municipalityCode);
  const mapped = barangays.map(projectBarangay);

  barangayCache.set(municipalityCode, createCacheEntry(mapped));
  return mapped;
};

export const clearAddressCaches = () => {
  provinceCache.entry = null;
  municipalityCache.clear();
  barangayCache.clear();
};
```

## api.js

| Field | Details |
| --- | --- |
| Program Name | api.js |
| Description | Frontend utility helper for shared logic. |
| Called by | addressService.js, AdminDashboard.js, AnnualBorrowing.js, ApproveRequestDialog.js, AuditLogs.js, AuthContext.js, BookCopies.js, BookDetails.js, BookForm.js, BookImportDialog.js, BooksList.js, BorrowForm.js, Layout.js, LibrarianDashboard.js, LoginPage.js, media.js, NotificationsPage.js, ReportsPage.js, RequestsPage.js, ReturnForm.js, SettingsContext.js, SettingsPage.js, StudentDashboard.js, StudentForm.js, StudentImportDialog.js, StudentsList.js, TransactionDetails.js, TransactionsList.js, UserForm.js, UserProfile.js, UsersList.js |
| Table used | None |
|  |  |
| Programmer | Nazel Asca√±o |
| Date created | 12/14/2025 |
| Revision Date | TBD |
| Revision / description of change | None |

```javascript
import axios from "axios";
import toast from "react-hot-toast";

const DEFAULT_BASE_URL = "http://localhost:5001/api";
const DEV_SERVER_PORTS = new Set(["3000", "3001", "5173"]);
const SESSION_REFRESH_HEADER = "x-session-refresh";

const dispatchTokenRefresh = (token) => {
  if (typeof window === "undefined") {
    return;
  }

  window.dispatchEvent(
    new CustomEvent("olms-token-refresh", {
      detail: { token },
    }),
  );
};

const persistRefreshedToken = (token) => {
  if (typeof window === "undefined") {
    return;
  }

  if (token) {
    window.localStorage.setItem("authToken", token);
  }
  dispatchTokenRefresh(token);
  try {
    if (token) {
      window.sessionStorage.setItem("authToken", token);
    } else {
      window.sessionStorage.removeItem("authToken");
    }
  } catch (error) {
    console.warn("Failed to persist session token copy", error);
  }
};

const handleSessionRefreshHeader = (response) => {
  if (!response || typeof window === "undefined") {
    return;
  }
  const headerToken = response.headers?.[SESSION_REFRESH_HEADER];
  if (headerToken) {
    persistRefreshedToken(headerToken);
    window.sessionStorage.setItem("authTokenRefreshedAt", Date.now().toString());
  }
};

const attachAuthHeader = (config, token) => {
  if (!config || !token) {
    return config;
  }
  if (config.headers && typeof config.headers.set === "function") {
    config.headers.set("Authorization", `Bearer ${token}`);
  } else {
    config.headers = config.headers || {};
    config.headers.Authorization = `Bearer ${token}`;
  }
  return config;
};

let silentVerifyPromise = null;
const runSilentSessionCheck = async () => {
  if (silentVerifyPromise) {
    return silentVerifyPromise;
  }
  silentVerifyPromise = api
    .get("/auth/verify", { __skipAuthHandler: true })
    .then((response) => {
      const sessionToken = response?.data?.token;
      if (sessionToken) {
        persistRefreshedToken(sessionToken);
      }
      return true;
    })
    .catch((probeError) => {
      if (probeError?.response?.status === 401) {
        return false;
      }
      console.warn("Silent session check failed", probeError);
      return null;
    })
    .finally(() => {
      silentVerifyPromise = null;
    });
  return silentVerifyPromise;
};

const resolveAutomaticBaseUrl = () => {
  if (typeof window === "undefined") {
    return DEFAULT_BASE_URL;
  }

  const { protocol, hostname, port } = window.location;
  const normalizedPort = (port || "").trim();
  const backendPort =
    process.env.REACT_APP_API_PORT ||
    process.env.REACT_APP_BACKEND_PORT ||
    "5001";

  const isLoopbackHost = /localhost|127\.0\.0\.1|0\.0\.0\.0/i.test(hostname);
  if (isLoopbackHost) {
    return DEFAULT_BASE_URL;
  }

  if (!normalizedPort || normalizedPort === "80" || normalizedPort === "443") {
    return `${protocol}//${hostname}/api`;
  }

  if (DEV_SERVER_PORTS.has(normalizedPort)) {
    return `${protocol}//${hostname}:${backendPort}/api`;
  }

  return `${protocol}//${hostname}:${normalizedPort}/api`;
};

const shouldUseFallback = (candidate) => {
  if (typeof window === "undefined") {
    return false;
  }

  const loopbackPattern = /^https?:\/\/(localhost|127\.0\.0\.1|0\.0\.0\.0)(?::\d+)?/i;
  const isLoopbackCandidate = loopbackPattern.test(candidate);
  const isViewerLoopback = /localhost|127\.0\.0\.1|0\.0\.0\.0/i.test(
    window.location.hostname,
  );

  return isLoopbackCandidate && !isViewerLoopback;
};

const normalizeBaseUrl = (value) => {
  const fallback = resolveAutomaticBaseUrl();
  if (!value) {
    return fallback;
  }

  const trimmed = value.trim().replace(/\/+$/, "");

  if (shouldUseFallback(trimmed)) {
    return fallback;
  }
  if (trimmed.toLowerCase().endsWith("/api")) {
    return trimmed;
  }

  return `${trimmed}/api`;
};

const readBrowserToken = () => {
  if (typeof window === "undefined") {
    return null;
  }
  try {
    return (
      window.localStorage.getItem("authToken") ||
      window.sessionStorage.getItem("authToken") ||
      null
    );
  } catch (error) {
    console.warn("Failed to read stored auth token", error);
    return null;
  }
};

const api = axios.create({
  baseURL: normalizeBaseUrl(process.env.REACT_APP_API_URL),
  timeout: 30000,
  withCredentials: true,
});

api.interceptors.request.use(
  (config) => {
    const token = readBrowserToken();
    if (token) {
      attachAuthHeader(config, token);
    }
    return config;
  },
  (error) => {
    return Promise.reject(error);
  },
);

api.interceptors.response.use(
  (response) => {
    handleSessionRefreshHeader(response);
    return response;
  },
  async (error) => {
    const { response, config } = error;
    const skipAuthHandler = Boolean(config?.__skipAuthHandler);

    if (response) {
      handleSessionRefreshHeader(response);
      const { status, data } = response;

      switch (status) {
        case 401: {
          if (!skipAuthHandler) {
            const storedToken = readBrowserToken();
            const alreadyRetried = Boolean(config?.__authRetryAttempted);

            if (storedToken && config && !alreadyRetried) {
              config.__authRetryAttempted = true;
              attachAuthHeader(config, storedToken);
              return api.request(config);
            }

            const sessionValid = await runSilentSessionCheck();
            if (sessionValid) {
              const refreshedToken = readBrowserToken();
              if (config) {
                config.__authRetryAttempted = true;
                attachAuthHeader(config, refreshedToken);
                return api.request(config);
              }
            }

            if (typeof window !== "undefined") {
              window.localStorage.removeItem("authToken");
              window.localStorage.removeItem("userData");
              try {
                window.sessionStorage.removeItem("authToken");
                window.sessionStorage.removeItem("userData");
              } catch (storageError) {
                console.warn("Failed to clear session storage copy", storageError);
              }
            }
            if (window.location.pathname !== "/login") {
              toast.error("Session expired. Please login again.");
              window.location.href = "/login";
            }
          }
          break;
        }
        case 403:
          toast.error("Access denied. Insufficient permissions.");
          break;
        case 404:
          toast.error("Resource not found.");
          break;
        case 422:

          if (data.errors) {
            data.errors.forEach((err) => toast.error(err.message));
          } else {
            toast.error(data.message || "Validation error");
          }
          break;
        case 429:
          toast.error("Too many requests. Please try again later.");
          break;
        case 500:
          toast.error("Server error. Please try again later.");
          break;
        default:
          toast.error(data.message || "An error occurred");
      }
    } else if (error.request) {

      toast.error("Network error. Please check your connection.");
    } else {

      toast.error("An unexpected error occurred.");
    }

    return Promise.reject(error);
  },
);

const SETTINGS_CATEGORY_ENDPOINTS = {
  library: "/settings/library",
  borrowing: "/settings/borrowing-rules",
  "borrowing-rules": "/settings/borrowing-rules",
  notifications: "/settings/notifications",
  system: "/settings/system",
  user: "/settings/user-attributes",
  "user-attributes": "/settings/user-attributes",
};

const resolveSettingsCategoryPath = (category) => {
  const normalized = String(category || "")
    .trim()
    .toLowerCase();

  if (!normalized) {
    throw new Error("Settings category is required");
  }

  return SETTINGS_CATEGORY_ENDPOINTS[normalized] || `/settings/${normalized}`;
};

export const authAPI = {
  login: (usernameOrEmail, password) =>
    api.post(
      "/auth/login",
      { usernameOrEmail, password },
      { __skipAuthHandler: true },
    ),
  logout: () => api.post("/auth/logout", undefined, { __skipAuthHandler: true }),
  getProfile: () => api.get("/auth/profile"),
  updateProfile: (data) => api.put("/auth/profile", data),
  verifyToken: () => api.get("/auth/verify"),
  getPreferences: () => api.get("/auth/preferences"),
  updatePreferences: (preferences) =>
    api.put("/auth/preferences", { preferences }),
};

export const verifySession = (config = {}) => api.get("/auth/verify", config);

export const usersAPI = {
  getAll: (params) => api.get("/users", { params }),
  getById: (id) => api.get(`/users/${id}`),
  getRoles: () => api.get("/users/roles"),
  getProfileAttributes: () => api.get("/users/profile/user-attributes"),
  create: (data) => api.post("/users", data),
  update: (id, data) => api.put(`/users/${id}`, data),
  updateStatus: (id, isActive) => api.put(`/users/${id}/status`, { isActive }),
  resetPassword: (id, newPassword) =>
    api.post(`/users/${id}/reset-password`, { newPassword }),
  uploadAvatar: (id, file, onProgress) => {
    const formData = new FormData();
    formData.append("avatar", file);

    return api.post(`/users/${id}/avatar`, formData, {
      headers: {
        "Content-Type": "multipart/form-data",
      },
      onUploadProgress: (event) => {
        if (onProgress && event.total) {
          const percent = Math.round((event.loaded * 100) / event.total);
          onProgress(percent);
        }
      },
    });
  },
  delete: (id) => api.delete(`/users/${id}`),
  bulkImport: (students) => api.post("/users/bulk-import", { students }),
};

export const studentsAPI = {
  getAll: (params) => api.get("/students", { params }),
  getSchoolYears: () => api.get("/students/school-years"),
  getById: (id) => api.get(`/students/${id}`),
  create: (data) => api.post("/students", data),
  update: (id, data) => api.put(`/students/${id}`, data),
  delete: (id) => api.delete(`/students/${id}`),
  payDues: (id, data) => api.post(`/students/${id}/pay-dues`, data),
  getTransactions: (id, params) =>
    api.get(`/students/${id}/transactions`, { params }),
  bulkImport: (students) => api.post("/students/bulk-import", { students }),
};

export const booksAPI = {
  getAll: (params) => api.get("/books", { params }),
  getById: (id) => api.get(`/books/${id}`),
  create: (data) => api.post("/books", data),
  update: (id, data) => api.put(`/books/${id}`, data),
  delete: (id) => api.delete(`/books/${id}`),
  bulkImport: (books) => api.post("/books/bulk-import", { books }),
  downloadBarcodes: (bookId, params) =>
    api.get(`/books/${bookId}/copies/barcodes`, {
      params,
      responseType: "blob",
    }),
  getCopies: (bookId, params) => api.get(`/books/${bookId}/copies`, { params }),
  createCopy: (bookId, data) => api.post(`/books/${bookId}/copies`, data),
  updateCopy: (bookId, copyId, data) =>
    api.put(`/books/${bookId}/copies/${copyId}`, data),
  deleteCopy: (bookId, copyId) =>
    api.delete(`/books/${bookId}/copies/${copyId}`),
};

export const transactionsAPI = {
  getAll: (params) => api.get("/transactions", { params }),
  getById: (id) => api.get(`/transactions/${id}`),
  create: (data) => api.post("/transactions", data),
  update: (id, data) => api.put(`/transactions/${id}`, data),
  getStats: () => api.get("/transactions/stats"),
  return: (id, data) => api.post(`/transactions/${id}/return`, data),
  cancelRequest: (id, data) => api.post(`/transactions/cancel/${id}`, data),
  bulkReturn: (data) => api.post("/transactions/bulk-return", data),
  bulkAssign: (data) => api.post("/transactions/bulk-assign", data),
  generateReceipt: (id) => api.get(`/transactions/${id}/receipt`),
  getOverdue: (params) => api.get("/transactions/overdue", { params }),
  getAnnual: (params) => api.get("/transactions/annual", { params }),
};

export const annualSetsAPI = {
  getAll: (params) => api.get("/annual-sets", { params }),
  getById: (id) => api.get(`/annual-sets/${id}`),
  create: (data) => api.post("/annual-sets", data),
  update: (id, data) => api.put(`/annual-sets/${id}`, data),
  remove: (id) => api.delete(`/annual-sets/${id}`),
  preview: (data) => api.post("/annual-sets/preview", data),
  getIssueContext: (id, params) =>
    api.get(`/annual-sets/${id}/issue-context`, { params }),
  issue: (id, data) => api.post(`/annual-sets/${id}/issue`, data),
};

export const reportsAPI = {
  getStats: () => api.get("/reports/stats"),
  getDailyTrends: () => api.get("/reports/trends/daily"),
  getRecentOverdue: () => api.get("/reports/overdue/recent"),
  getRecentCheckouts: () => api.get("/reports/transactions/recent"),
  getDashboard: (params) => api.get("/reports/dashboard", { params }),
  getCirculation: (params) => api.get("/reports/circulation", { params }),
  getPopularBooks: (params) => api.get("/reports/popular-books", { params }),
  getUserActivity: (params) => api.get("/reports/user-activity", { params }),
  getFines: (params) => api.get("/reports/fines", { params }),
  getInventory: (params) => api.get("/reports/inventory", { params }),
  getMostBorrowed: (params) => api.get("/reports/most-borrowed", { params }),
  getActiveUsers: (params) => api.get("/reports/active-users", { params }),
  getTrends: (params) => api.get("/reports/trends", { params }),
  getOverdue: (params) => api.get("/reports/overdue", { params }),
  getAnnualCompliance: (params) =>
    api.get("/reports/annual-compliance", { params }),
  export: (type, params) =>
    api.get(`/reports/export/${type}`, {
      params,
      responseType: "blob",
    }),
};

export const settingsAPI = {
  getAll: () => api.get("/settings"),
  getByCategory: (category) => api.get(resolveSettingsCategoryPath(category)),
  update: (key, value) => api.put(`/settings/${key}`, { value }),
  updateMultiple: (settings) => api.put("/settings/bulk", { settings }),
  getUserAttributes: () => api.get("/settings/user-attributes"),
  updateUserAttributes: (data) => api.put("/settings/user-attributes", data),
  uploadBrandingAsset: (slot, file, onProgress) => {
    const normalizedSlot = (slot || "logo").toLowerCase();
    const formData = new FormData();
    formData.append("slot", normalizedSlot);
    formData.append("brandingAsset", file);

    return api.post("/settings/library/branding/upload", formData, {
      headers: {
        "Content-Type": "multipart/form-data",
      },
      onUploadProgress: (event) => {
        if (onProgress && event.total) {
          const percent = Math.round((event.loaded * 100) / event.total);
          onProgress(percent);
        }
      },
    });
  },
};

export const auditAPI = {
  getLogs: (params) => api.get("/audit", { params }),
  getStats: (params) => api.get("/audit/stats", { params }),
  getSummary: (params) => api.get("/audit/stats/summary", { params }),
  getRecentActivity: (params) => api.get("/audit/recent/activity", { params }),
  getByUser: (userId, params) => api.get(`/audit/user/${userId}`, { params }),
  getByAction: (action, params) =>
    api.get(`/audit/action/${action}`, { params }),
  getById: (id) => api.get(`/audit/${id}`),
  exportCsv: (params) =>
    api.get("/audit/export/csv", {
      params,
      responseType: "blob",
    }),
};

export const searchAPI = {
  global: (params) => api.get("/search", { params }),
};

export const notificationsAPI = {
  getAll: (params) => api.get("/notifications", { params }),
  markRead: (id, read = true) => {
    const normalizedId = id === undefined || id === null ? "" : String(id).trim();
    if (!normalizedId) {
      return Promise.reject(new Error("Notification id is required"));
    }
    const encodedId = encodeURIComponent(normalizedId);
    return api.put(`/notifications/${encodedId}/read`, { read });
  },
  delete: (id) => api.delete(`/notifications/${id}`),
};

export const uploadFile = async (file, endpoint, onProgress) => {
  const formData = new FormData();
  formData.append("file", file);

  return api.post(endpoint, formData, {
    headers: {
      "Content-Type": "multipart/form-data",
    },
    onUploadProgress: (progressEvent) => {
      if (onProgress) {
        const percentCompleted = Math.round(
          (progressEvent.loaded * 100) / progressEvent.total,
        );
        onProgress(percentCompleted);
      }
    },
  });
};

export const downloadFile = (blob, filename) => {
  const url = window.URL.createObjectURL(blob);
  const link = document.createElement("a");
  link.href = url;
  link.setAttribute("download", filename);
  document.body.appendChild(link);
  link.click();
  link.remove();
  window.URL.revokeObjectURL(url);
};

export { api };
```

## authorDisplay.js

| Field | Details |
| --- | --- |
| Program Name | authorDisplay.js |
| Description | Frontend utility helper for shared logic. |
| Called by | BookDetails.js, BookImportDialog.js, BooksList.js |
| Table used | None |
|  |  |
| Programmer | Nazel Asca√±o |
| Date created | 12/14/2025 |
| Revision Date | TBD |
| Revision / description of change | None |

```javascript
const normalizeAuthorName = (value) => {
  if (typeof value !== "string") {
    return "";
  }
  return value.replace(/\s+/g, " ").trim();
};

const splitAuthorValue = (value) => {
  if (typeof value !== "string") {
    return [];
  }
  if (/[;,|]/.test(value)) {
    return value
      .split(/[,;|]/)
      .map((entry) => normalizeAuthorName(entry))
      .filter(Boolean);
  }
  const normalized = normalizeAuthorName(value);
  return normalized ? [normalized] : [];
};

const addUniqueAuthor = (author, seen, list) => {
  const normalized = normalizeAuthorName(author);
  if (!normalized) {
    return;
  }
  const key = normalized.toLowerCase();
  if (seen.has(key)) {
    return;
  }
  seen.add(key);
  list.push(normalized);
};

export const extractUniqueAuthors = (record) => {
  if (!record) {
    return [];
  }

  const seen = new Set();
  const authors = [];

  const addFromValue = (value) => {
    splitAuthorValue(value).forEach((entry) => addUniqueAuthor(entry, seen, authors));
  };

  if (Array.isArray(record.authors)) {
    record.authors.forEach(addFromValue);
  }

  if (typeof record.author === "string") {
    addFromValue(record.author);
  }

  return authors;
};

export const formatAuthorsList = (record, fallback = "Unknown Author") => {
  const authors = extractUniqueAuthors(record);
  if (authors.length === 0) {
    return fallback;
  }
  return authors.join(", ");
};
```

## currency.js

| Field | Details |
| --- | --- |
| Program Name | currency.js |
| Description | Frontend utility helper for shared logic. |
| Called by | BorrowForm.js, pdfGenerator.js, ReportsPage.js, ReturnForm.js, TransactionDetails.js, UserProfile.js |
| Table used | None |
|  |  |
| Programmer | Nazel Asca√±o |
| Date created | 12/14/2025 |
| Revision Date | TBD |
| Revision / description of change | None |

```javascript
const pesoFormatter = new Intl.NumberFormat("en-PH", {
  style: "currency",
  currency: "PHP",
  minimumFractionDigits: 2,
  maximumFractionDigits: 2,
});

export const formatCurrency = (value) => {
  const amount = Number(value);
  if (!Number.isFinite(amount)) {
    return "‚Ç±0.00";
  }
  return pesoFormatter.format(amount);
};
```

## media.js

| Field | Details |
| --- | --- |
| Program Name | media.js |
| Description | Frontend utility helper for shared logic. |
| Called by | LoginPage.js, pdfGenerator.js, SettingsContext.js, StudentDashboard.js, StudentsList.js, UsersList.js |
| Table used | None |
|  |  |
| Programmer | Nazel Asca√±o |
| Date created | 12/14/2025 |
| Revision Date | TBD |
| Revision / description of change | None |

```javascript
import { api } from "./api";

const absoluteUrlPattern = /^https?:\/\//i;
const dataUrlPattern = /^data:/i;

const extractUrlCandidate = (value) => {
  if (!value) {
    return "";
  }

  if (typeof value === "string") {
    return value;
  }

  if (typeof value === "object") {
    const nested = value.url || value.href || value.path;
    if (typeof nested === "string") {
      return nested;
    }
  }

  return "";
};

export const resolveApiOrigin = () => {
  const base = api.defaults.baseURL || "";
  if (base) {
    const sanitized = base.replace(/\/api$/i, "");
    return sanitized || base;
  }

  if (typeof window !== "undefined" && window.location?.origin) {
    return window.location.origin.replace(/\/$/, "");
  }

  return "";
};

export const resolveAssetUrl = (value) => {
  const raw = (value || "").trim();
  if (!raw) {
    return "";
  }

  if (absoluteUrlPattern.test(raw) || dataUrlPattern.test(raw)) {
    return raw;
  }

  const origin = resolveApiOrigin();
  if (!origin) {
    return raw;
  }

  const normalizedPath = raw.startsWith("/") ? raw : `/${raw}`;
  return `${origin}${normalizedPath}`;
};

export const resolveEntityAvatar = (entity) => {
  if (!entity || typeof entity !== "object") {
    return "";
  }

  const candidates = [
    entity.profilePictureUrl,
    extractUrlCandidate(entity.profilePicture),
    entity.profileImageUrl,
    extractUrlCandidate(entity.profileImage),
    entity.photoUrl,
    extractUrlCandidate(entity.photo),
    entity.avatarUrl,
    extractUrlCandidate(entity.avatar),
    entity.imageUrl,
    extractUrlCandidate(entity.image),
  ];

  const raw = candidates.find((candidate) => {
    if (typeof candidate !== "string") {
      return false;
    }
    const trimmed = candidate.trim();
    return trimmed.length > 0;
  });

  if (!raw) {
    return "";
  }

  const trimmed = raw.trim();

  return resolveAssetUrl(trimmed);
};
```

## pdfGenerator.js

| Field | Details |
| --- | --- |
| Program Name | pdfGenerator.js |
| Description | Frontend utility helper for shared logic. |
| Called by | BorrowForm.js, ReportsPage.js, ReturnForm.js, StudentForm.js, StudentImportDialog.js, StudentsList.js, TransactionsList.js |
| Table used | None |
|  |  |
| Programmer | Nazel Asca√±o |
| Date created | 12/14/2025 |
| Revision Date | TBD |
| Revision / description of change | None |

```javascript
import jsPDF from 'jspdf';
import QRCode from 'qrcode';
import { formatCurrency } from './currency';
import { resolveEntityAvatar } from './media';

const MM = 'mm';
const DEFAULT_STRIPE_COLOR = '#C62828';

const sanitizeHexColor = (value, fallback = DEFAULT_STRIPE_COLOR) => {
  if (typeof value !== 'string') {
    return fallback;
  }
  const normalized = value.trim().replace(/^#/u, '').toUpperCase();
  if (/^[0-9A-F]{6}$/u.test(normalized)) {
    return `#${normalized}`;
  }
  return fallback;
};

const hexToRgb = (hexColor = DEFAULT_STRIPE_COLOR) => {
  const normalized = sanitizeHexColor(hexColor).slice(1);
  return [
    parseInt(normalized.slice(0, 2), 16) || 0,
    parseInt(normalized.slice(2, 4), 16) || 0,
    parseInt(normalized.slice(4, 6), 16) || 0
  ];
};

const deriveStripeColor = (student = {}, gradeColorMap = {}) => {
  const direct = student.gradeColor || student.cardColor || student.stripeColor;
  if (direct) {
    return sanitizeHexColor(direct);
  }

  const gradeName = student.grade || student.gradeLevel;
  if (typeof gradeName === 'string') {
    const key = gradeName.trim().toLowerCase();
    if (key && gradeColorMap && gradeColorMap[key]) {
      return sanitizeHexColor(gradeColorMap[key]);
    }
  }

  return DEFAULT_STRIPE_COLOR;
};

const createDoc = (opts = {}) => {
  const { orientation = 'portrait', format = 'letter' } = opts;
  return new jsPDF({ orientation, unit: MM, format });
};

const getValidDateLabel = (value) => {
  if (!value) return null;
  const date = value instanceof Date ? value : new Date(value);
  if (Number.isNaN(date.getTime())) return null;
  return date.toLocaleDateString();
};

const formatStudentFullName = (student = {}) => {
  const parts = [student.firstName, student.middleName, student.lastName]
    .map((p) => (p || '').trim())
    .filter(Boolean);
  if (parts.length > 0) {
    return parts.join(' ');
  }
  return student.name || 'Unknown';
};

const deriveStudentLibraryId = (student = {}) => {
  return (
    student.libraryId ||
    student.libraryCardNumber ||
    (student.library && student.library.cardNumber) ||
    student.studentId ||
    'N/A'
  );
};

const studentPhotoCache = new Map();

const readBlobAsDataUrl = (blob) => {
  return new Promise((resolve, reject) => {
    if (typeof FileReader === 'undefined') {
      reject(new Error('FileReader is not available in this environment.'));
      return;
    }
    const reader = new FileReader();
    reader.onloadend = () => resolve(reader.result);
    reader.onerror = reject;
    reader.readAsDataURL(blob);
  });
};

const downloadImageAsDataUrl = async (url) => {
  if (!url || typeof fetch !== 'function') {
    return null;
  }
  try {
    const response = await fetch(url, {
      mode: 'cors',
      credentials: 'include'
    });
    if (!response.ok) {
      return null;
    }
    const blob = await response.blob();
    return await readBlobAsDataUrl(blob);
  } catch (error) {
    console.warn('Unable to download student photo for PDF generation.', error);
    return null;
  }
};

const getImageDimensions = async (dataUrl) => {
  if (!dataUrl || typeof Image === 'undefined') {
    return null;
  }
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.onload = () => {
      resolve({
        width: img.naturalWidth || img.width || 0,
        height: img.naturalHeight || img.height || 0
      });
    };
    img.onerror = reject;
    img.src = dataUrl;
  });
};

const getStudentPhotoPayload = async (student = {}) => {
  const resolvedUrl = resolveEntityAvatar(student);
  if (!resolvedUrl) {
    return null;
  }

  if (studentPhotoCache.has(resolvedUrl)) {
    return studentPhotoCache.get(resolvedUrl);
  }

  let dataUrl = null;
  if (resolvedUrl.startsWith('data:')) {
    dataUrl = resolvedUrl;
  } else {
    try {
      dataUrl = await downloadImageAsDataUrl(resolvedUrl);
    } catch (error) {
      dataUrl = null;
    }
  }

  if (!dataUrl) {
    return null;
  }

  let dimensions = null;
  try {
    dimensions = await getImageDimensions(dataUrl);
  } catch (error) {
    dimensions = null;
  }

  const payload = {
    dataUrl,
    format: dataUrl.startsWith('data:image/png') ? 'PNG' : 'JPEG',
    width: dimensions?.width || 0,
    height: dimensions?.height || 0
  };

  studentPhotoCache.set(resolvedUrl, payload);
  return payload;
};

const drawStudentPhoto = async (doc, student, x, y, size) => {
  const drawPlaceholder = () => {
    doc.setFontSize(9);
    doc.setFont('helvetica', 'normal');
    doc.text('PHOTO', x + size / 2, y + size / 2 + 1, { align: 'center' });
  };

  const drawFrame = () => {
    doc.setDrawColor(0);
    doc.setLineWidth(0.5);
    doc.rect(x, y, size, size);
  };

  drawFrame();

  let photoPayload = null;
  try {
    photoPayload = await getStudentPhotoPayload(student);
  } catch (error) {
    photoPayload = null;
  }

  if (!photoPayload) {
    drawPlaceholder();
    return;
  }

  const hasDimensions = Number.isFinite(photoPayload.width) && Number.isFinite(photoPayload.height) && photoPayload.width > 0 && photoPayload.height > 0;
  const ratio = hasDimensions ? (photoPayload.width / photoPayload.height) : null;

  let renderWidth = size;
  let renderHeight = size;
  if (ratio && ratio > 0) {
    if (ratio >= 1) {
      renderHeight = size / ratio;
    } else {
      renderWidth = size * ratio;
    }
  }

  const offsetX = x + (size - renderWidth) / 2;
  const offsetY = y + (size - renderHeight) / 2;

  try {
    doc.addImage(photoPayload.dataUrl, photoPayload.format, offsetX, offsetY, renderWidth, renderHeight);
  } catch (error) {
    console.warn('Failed to render student photo on library card.', error);
    drawPlaceholder();
    return;
  }

  drawFrame();
};

const drawCardFront = async (doc, student, librarySettings = {}, options = {}) => {
  const pageWidth = doc.internal.pageSize.getWidth();
  const pageHeight = doc.internal.pageSize.getHeight();
  const margin = 3;
  const gradeColor = deriveStripeColor(student, options.gradeColorMap || {});
  const [stripeR, stripeG, stripeB] = hexToRgb(gradeColor);

  const libraryName = librarySettings.libraryName || 'Odiongan National High School';
  const libraryAddress = librarySettings.libraryAddress || 'Dapawan, Odiongan, Romblon';

  let photoSize = 25;
  let photoX = margin;
  let photoY = (pageHeight / 2 - photoSize / 2) + 5;
  const idX = photoX + photoSize + 3 ; // 3mm gap after photo
  const idY = photoY + photoSize - 10 ;
  doc.setFontSize(7);
  doc.setFont('helvetica', 'bold');
  doc.setTextColor(120,120,120);
  doc.text('LIBRARY ID', idX, idY, {align:'left'});
  doc.setFontSize(10);
  doc.setFont('helvetica', 'bold');
  doc.setTextColor(0,0,0);
  doc.text(student.libraryCardNumber || '', idX, idY + 7, {align:'left'});

  try {
    const logoImg = await import('../assets/images/logo.png');
    const logoW = 14, logoH = 14;
    const logoX = pageWidth - margin - logoW;
    const logoY = margin;
    doc.addImage(logoImg.default || logoImg, 'PNG', logoX, logoY, logoW, logoH);

    const textRight = logoX - 2;
    doc.setFontSize(11);
    doc.setFont('helvetica', 'bold');
    doc.setTextColor(0,0,0);
    doc.text(libraryName, textRight, logoY + 6, {align:'right'});
    doc.setFontSize(7);
    doc.setFont('helvetica', 'normal');
    doc.setTextColor(80,80,80);
    doc.text(libraryAddress, textRight, logoY + 11, {align:'right'});
  } catch (e) {

    doc.setFontSize(11);
    doc.setFont('helvetica', 'bold');
    doc.setTextColor(0,0,0,0);
    doc.text(libraryName, pageWidth - margin, margin + 6, {align:'right'});
    doc.setFontSize(7);
    doc.setFont('helvetica', 'normal');
    doc.setTextColor(80,80,80);
    doc.text(libraryAddress, pageWidth - margin, margin + 11, {align:'right'});
  }

  const barH = 8;
  doc.setFillColor(stripeR, stripeG, stripeB);
  doc.rect(0, pageHeight-barH, pageWidth, barH, 'F');
  doc.setFontSize(12);
  doc.setFont('helvetica', 'bold');
  doc.setTextColor(255,255,255);
  const fullName = `${student.firstName || ''} ${student.middleName || ''} ${student.lastName || ''}`.trim() || 'Name Surname';
  doc.text(fullName, margin+2, pageHeight-barH/3, {align:'left'});

  const qrSizeMm = 15;
  const qrX = pageWidth - margin - qrSizeMm;
  const qrY = pageHeight - qrSizeMm - 2;
  try {
    const qrData = (student.libraryCardNumber || '');
    const dataUrl = await QRCode.toDataURL(String(qrData));
    doc.addImage(dataUrl, 'PNG', qrX, qrY, qrSizeMm, qrSizeMm);
  } catch (err) {

  }
  doc.setTextColor(0);

  await drawStudentPhoto(doc, student, photoX, photoY, photoSize);

  doc.setFontSize(10);
  doc.setFont('helvetica', 'bold');

};

const drawCardBack = (doc, librarySettings = {}) => {
  const pageWidth = doc.internal.pageSize.getWidth();
  const pageHeight = doc.internal.pageSize.getHeight();
  const margin = 5;
  const finesDisabled =
    librarySettings?.enableFines === false ||
    librarySettings?.borrowingRules?.enableFines === false;
  const finePerDay =
    librarySettings?.borrowingRules?.finePerDay ??
    librarySettings?.finePerDay ??
    5;
  const normalizedFinePerDay = Number(finePerDay);
  const fineDisplay = Number.isFinite(normalizedFinePerDay)
    ? normalizedFinePerDay
    : 5;
  const baseRules = [
    'This card is non-transferable and must be presented when borrowing books.',
    'Handle books with care. Report any damage immediately.',
    'Return books on or before the due date.',
    !finesDisabled ? `Overdue books: PHP ${fineDisplay.toFixed(2)} fine per day.` : null,
    'Lost books must be replaced or paid for.',
    'Report lost cards immediately.',
    'Respect library quiet zones.'
  ].filter(Boolean);
  const rules = baseRules.map((text, index) => `${index + 1}. ${text}`);

  doc.setFontSize(10);
  doc.setFont('helvetica', 'bold');
  doc.text('LIBRARY RULES & REGULATIONS', pageWidth / 2, margin, { align: 'center' });

  doc.setFontSize(5);
  doc.setFont('helvetica', 'normal');
  const maxWidth = pageWidth - (margin * 2);

  const lineSpacing = 3;
  const boxSizeWidth = (pageWidth / 2) - margin;
  const boxSizeHeight = pageHeight - (margin * 2) - 2;
  const boxX = margin;
  const boxY = (pageHeight / 2 - boxSizeHeight / 2) + 2;
  doc.setDrawColor(0);
  doc.setLineWidth(0.5);
  doc.rect(boxX, boxY, boxSizeWidth, boxSizeHeight);
  let y = boxY + 3
  rules.forEach((r) => {
    const lines = doc.splitTextToSize(r, boxSizeWidth - 6);
    doc.text(lines, boxX + 2, y);
    y += lines.length + lineSpacing;
  });

  const footerY1 = (pageHeight/2) + 5;
  const footerY2 = footerY1 + 8;
  const footerY3 = footerY2 + 8;
  doc.setFontSize(6);
  doc.setFont('helvetica', 'normal');
  const footerX = (maxWidth / 2) + 6;
  doc.text('Valid until: _____________________', footerX, footerY1);
  doc.text('Student Signature: ______________', footerX, footerY2);
  doc.text('Librarian: ______________________', footerX, footerY3);
};

export const generateLibraryCard = async (studentData = {}, librarySettings = {}, options = {}) => {

  const doc = createDoc({ orientation: 'landscape', format: [85.6, 54] });
  await drawCardFront(doc, studentData, librarySettings, options);
  doc.addPage();
  drawCardBack(doc, librarySettings);
  return doc;
};

export const generateLibraryCardsPDF = async (students = [], librarySettings = {}, options = {}) => {
  const firstDoc = createDoc({ orientation: 'landscape', format: [85.6, 54] });
  let doc = firstDoc;
  for (let i = 0; i < students.length; i += 1) {
    const s = students[i] || {};
    if (i === 0) {
      await drawCardFront(doc, s, librarySettings, options);
      doc.addPage();
      drawCardBack(doc, librarySettings);
    } else {
      doc.addPage();
      await drawCardFront(doc, s, librarySettings, options);
      doc.addPage();
      drawCardBack(doc, librarySettings);
    }
  }
  return doc;
};

export const generateTransactionReceipt = async (transactionData = {}, studentData = {}, booksData = [], librarySettings = {}) => {
  const doc = createDoc({ format: 'letter', orientation: 'portrait'});
  const pageWidth = doc.internal.pageSize.getWidth();
  const lineSpacing = 2;
  const margin = 5;
  const centerText = (pageWidth / 2) - margin;
  const headerLine = margin + 2;
  const addressLine = headerLine + lineSpacing;
  const textLine1 = addressLine + lineSpacing + 3;
  const textLine2 = textLine1 + lineSpacing + 3;

  const libraryName = librarySettings.libraryName || 'Odiongan National High School';
  const libraryAddress = librarySettings.libraryAddress || 'Dapawan, Odiongan, Romblon';

  doc.setFontSize(12);
  doc.setFont('helvetica', 'bold');
  doc.text(libraryName, centerText, headerLine, { align: 'center' });

  doc.setFontSize(6);
  doc.setFont('helvetica', 'normal');
  doc.text(libraryAddress, centerText, addressLine, { align: 'center' });

  doc.setFontSize(10);
  doc.setFont('helvetica', 'normal');
  doc.text('LIBRARY', centerText, textLine1, { align: 'center' });
  doc.text('TRANSACTION RECEIPT', centerText, textLine2, { align: 'center' });

  doc.setFontSize(8);
  const drawLabelValue = (label, value, x, y, align = 'left') => {
    const printableValue = String(value ?? '').trim() || 'N/A';

    const labelString = `${label} `;
    doc.setFont('helvetica', 'normal');
    const labelWidth = doc.getTextWidth(labelString);

    doc.setFont('helvetica', 'bold');
    const valueWidth = doc.getTextWidth(printableValue);

    if (align === 'center') {
      const gap = 1.5;
      doc.setFont('helvetica', 'normal');
      doc.text(labelString, x, y, { align: 'center' });
      doc.setFont('helvetica', 'bold');
      doc.text(printableValue, x + labelWidth / 2 + gap, y);
      return;
    }

    let startX = x;
    if (align === 'right') {
      startX = x - (labelWidth + valueWidth);
    }

    doc.setFont('helvetica', 'normal');
    doc.text(labelString, startX, y);

    doc.setFont('helvetica', 'bold');
    doc.text(printableValue, startX + labelWidth, y);
  };

  drawLabelValue('Receipt #:', transactionData.id || 'N/A', centerText + 3, 30, 'center');
  drawLabelValue(
    'Date:',
    new Date(transactionData.createdAt || Date.now()).toLocaleDateString(),
    centerText,
    34,
    'center'
  );
  drawLabelValue('Type:', transactionData.type || 'Borrow', centerText, 38, 'center');

  if (transactionData.status) {
    drawLabelValue('Status:', transactionData.status, margin, 42);
  }
  const qrSizeMm = 25;
  try {
    const qrData = (transactionData.id || 'N/A');
    const dataUrl = await QRCode.toDataURL(String(qrData));
    doc.addImage(dataUrl, 'PNG', pageWidth - qrSizeMm, 0, qrSizeMm, qrSizeMm);
  } catch (err) {
    console.warn('QR generation failed', err);
  }
  const borrowerName = `${studentData?.firstName || ''} ${studentData?.lastName || ''}`.trim()
    || studentData?.fullName
    || 'N/A';
  const borrowerId = studentData?.libraryCardNumber || studentData?.studentId || 'N/A';

  drawLabelValue('Borrower:', borrowerName, 5, 30);
  drawLabelValue('ID:', borrowerId, 5, 34);

  doc.setFont('helvetica', 'normal');

  doc.setFont('helvetica', 'normal');

  doc.text('Books:', 5, 50);
  doc.text('ISBN', margin + pageWidth - ((pageWidth/3)*2), 50);
  doc.text('Reference ID:', margin + pageWidth - ((pageWidth/3)), 50);

  let y = 58;
  booksData.forEach((book, index) => {
    if (y > 140) {
      doc.addPage();
      y = 10;
    }
    doc.text(`${index + 1}. ${book.title || 'Unknown'}`, 5, y);
    doc.text(` ${book.isbn || 'Unknown'}`, margin + pageWidth - ((pageWidth/3)*2), y);
    doc.text(` ${book.copyId || 'Unknown'}`, margin + pageWidth - ((pageWidth/3)), y);
    y += 6;
  });

  let infoY = y + 4;
  if (transactionData.dueDate) {
    doc.text(`Due Date: ${new Date(transactionData.dueDate).toLocaleDateString()}`, 5, infoY);
    infoY += 6;
  }

  if (transactionData.returnDate) {

    doc.text(`Return Date: ${new Date(transactionData.returnDate).toLocaleDateString()}`, 5, infoY);
    infoY += 6;
  }

  if (transactionData.fineAmount) {
    doc.text(`Fine: ${formatCurrency(transactionData.fineAmount)}`, 5, infoY);
  }

  return doc;
};

const addStudentListHeader = (doc, options = {}) => {
  const margin = 15;
  const pageWidth = doc.internal.pageSize.getWidth();
  const headerY = margin;
  doc.setFont('helvetica', 'bold');
  doc.setFontSize(18);
  doc.text('Student List Report', margin, headerY);

  const dateRange = [];
  const startLabel = getValidDateLabel(options.startDate);
  const endLabel = getValidDateLabel(options.endDate);
  if (startLabel || endLabel) {
    dateRange.push(`Date Range: ${startLabel || 'N/A'} - ${endLabel || 'N/A'}`);
  }

  const filterParts = [];
  const filters = options.studentFilters || {};
  if (filters.grade) filterParts.push(`Grade: ${filters.grade}`);
  if (filters.section) filterParts.push(`Section: ${filters.section}`);
  if (filters.schoolYear) filterParts.push(`School Year: ${filters.schoolYear}`);
  if (filterParts.length > 0) {
    dateRange.push(filterParts.join(' | '));
  }

  if (dateRange.length > 0) {
    doc.setFont('helvetica', 'italic');
    doc.setFontSize(10);
    doc.text(dateRange, margin, headerY + 8);
  }

  doc.setFont('helvetica', 'normal');
  doc.setFontSize(10);
  doc.text(`Generated: ${new Date().toLocaleString()}`, pageWidth - 15, headerY, { align: 'right' });
};

const drawStudentListTable = (doc, students = [], options = {}) => {
  const margin = 15;
  const pageHeight = doc.internal.pageSize.getHeight();
  const columns = [
    { key: 'libraryId', label: 'Library ID', width: 28 },
    { key: 'name', label: 'Name', width: 55 },
    { key: 'gradeSection', label: 'Grade & Section', width: 35 },
    { key: 'email', label: 'Email', width: 55 },
    { key: 'phone', label: 'Phone', width: 32 },
  ];

  const lineHeight = 6;
  let y = margin + 20;

  const drawTableHeader = () => {
    doc.setFont('helvetica', 'bold');
    doc.setFontSize(10);
    let x = margin;
    columns.forEach((col) => {
      doc.text(col.label, x, y);
      x += col.width;
    });
    doc.setLineWidth(0.3);
    doc.line(margin, y + 1, margin + columns.reduce((sum, col) => sum + col.width, 0), y + 1);
    y += lineHeight;
  };

  const ensureSpace = (rowHeight) => {
    if (y + rowHeight <= pageHeight - margin) {
      return;
    }
    doc.addPage();
    y = margin;
    addStudentListHeader(doc, options);
    y += 20;
    drawTableHeader();
  };

  drawTableHeader();

  doc.setFont('helvetica', 'normal');
  doc.setFontSize(9);

  students.forEach((student, index) => {
    const rowData = {
      libraryId: deriveStudentLibraryId(student),
      name: formatStudentFullName(student),
      gradeSection:
        student.grade && student.section
          ? `${student.grade} - ${student.section}`
          : student.grade || student.section || 'N/A',
      email: student.email || 'N/A',
      phone: student.phoneNumber || student.parentPhone || 'N/A',
    };

    const wrapped = columns.map((col) => {
      const text = String(rowData[col.key] ?? '') || 'N/A';
      const lines = doc.splitTextToSize(text, col.width - 2);
      return { lines, height: Math.max(lines.length * (lineHeight - 2), lineHeight) };
    });

    const rowHeight = Math.max(...wrapped.map((w) => w.height)) + 2;
    ensureSpace(rowHeight);

    let x = margin;
    wrapped.forEach(({ lines }, colIndex) => {
      doc.text(lines, x, y, { baseline: 'top' });
      x += columns[colIndex].width;
    });

    y += rowHeight;

    if ((index + 1) % 15 === 0) {
      doc.setDrawColor(200);
      doc.setLineWidth(0.1);
      doc.line(margin, y - 1, margin + columns.reduce((sum, col) => sum + col.width, 0), y - 1);
    }
  });

  doc.setFont('helvetica', 'italic');
  doc.setFontSize(9);
  y += 4;
  ensureSpace(lineHeight);
  doc.text(`Total Students: ${students.length}`, margin, y);
};

const generateStudentListReportPDF = async (students = [], options = {}) => {
  const doc = createDoc({ orientation: 'portrait', format: 'letter' });
  addStudentListHeader(doc, options);
  drawStudentListTable(doc, students, options);
  return doc;
};

export const generateReportPDF = async (reportType, data = [], options = {}) => {
  if (reportType === 'student-list') {
    return generateStudentListReportPDF(data, options);
  }

  const doc = createDoc();
  doc.setFontSize(14);
  doc.setFont('helvetica', 'bold');
  doc.text(reportType ? String(reportType).toUpperCase() : 'REPORT', 20, 20);
  doc.setFontSize(9);
  doc.setFont('helvetica', 'normal');
  let y = 30;
  data.forEach((row) => {
    const line = JSON.stringify(row);
    const lines = doc.splitTextToSize(line, 180);
    doc.text(lines, 10, y);
    y += lines.length * 4 + 4;
    if (y > 270) {
      doc.addPage();
      y = 20;
    }
  });
  return doc;
};

export const downloadPDF = (pdfDoc, filename = 'document.pdf') => {
  try {
    if (!pdfDoc) return;

    if (typeof pdfDoc.save === 'function') {
      pdfDoc.save(filename);
      return;
    }

    if (typeof pdfDoc.output === 'function') {
      const blob = pdfDoc.output('blob');
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = filename;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
    }
  } catch (err) {
    console.error('Failed to download PDF', err);
  }
};

export const printPDF = (pdfDoc) => {
  try {
    if (!pdfDoc) return;
    if (typeof pdfDoc.output === 'function') {
      const blob = pdfDoc.output('blob');
      const url = URL.createObjectURL(blob);
      const w = window.open(url, '_blank');
      if (w) w.onload = () => w.print();
    }
  } catch (err) {
    console.error('Failed to print PDF', err);
  }
};
```

## scanEvents.js

| Field | Details |
| --- | --- |
| Program Name | scanEvents.js |
| Description | Frontend utility helper for shared logic. |
| Called by | Layout.js, QRScanner.js |
| Table used | None |
|  |  |
| Programmer | Nazel Asca√±o |
| Date created | 12/14/2025 |
| Revision Date | TBD |
| Revision / description of change | None |

```javascript
const SCAN_EVENT_NAME = "qrscan:detected";

const toPlainObject = (value) => {
  if (!value || typeof value !== "object") {
    return undefined;
  }
  const plain = {};
  Object.keys(value).forEach((key) => {
    const candidate = value[key];
    if (typeof candidate === "number" && Number.isFinite(candidate)) {
      plain[key] = candidate;
    }
  });
  return Object.keys(plain).length > 0 ? plain : undefined;
};

export const dispatchScanEvent = (rawValue, meta = {}) => {
  if (typeof window === "undefined") {
    return;
  }

  const normalized = rawValue == null ? "" : String(rawValue);
  const detail = {
    value: normalized,
    meta: {
      ...meta,
      pointer: toPlainObject(meta.pointer),
      rect: toPlainObject(meta.rect),
    },
  };

  window.dispatchEvent(new CustomEvent(SCAN_EVENT_NAME, { detail }));
};

export const SCAN_EVENT = SCAN_EVENT_NAME;
```

## userAttributes.js

| Field | Details |
| --- | --- |
| Program Name | userAttributes.js |
| Description | Frontend utility helper for shared logic. |
| Called by | curriculum.js, settings.js, SettingsPage.js, StudentForm.js, StudentImportDialog.js, StudentsList.js, userAttributes.test.js, UserForm.js, UserProfile.js, users.js |
| Table used | None |
|  |  |
| Programmer | Nazel Asca√±o |
| Date created | 12/14/2025 |
| Revision Date | TBD |
| Revision / description of change | None |

```javascript
export const DEFAULT_CURRICULA = [
  "Computer Science",
  "Engineering",
  "Mathematics",
  "Science",
  "Arts",
  "Business",
  "Education",
  "Medicine",
  "Law",
  "Other",
];

export const DEFAULT_GRADE_LEVELS = [
  "Grade 7",
  "Grade 8",
  "Grade 9",
  "Grade 10",
  "Grade 11",
  "Grade 12",
  "College Freshman",
  "College Sophomore",
  "College Junior",
  "College Senior",
  "Graduate",
];

export const DEFAULT_GRADE_COLORS = [
  "#C62828",
  "#AD1457",
  "#6A1B9A",
  "#4527A0",
  "#283593",
  "#1565C0",
  "#0277BD",
  "#00838F",
  "#00695C",
  "#2E7D32",
  "#558B2F",
];

export const DEFAULT_GRADE_COLOR = DEFAULT_GRADE_COLORS[0];

export const getDefaultGradeColor = (index = 0) =>
  DEFAULT_GRADE_COLORS[index % DEFAULT_GRADE_COLORS.length] || DEFAULT_GRADE_COLOR;

export const sanitizeHexColor = (value, fallback = DEFAULT_GRADE_COLOR) => {
  if (typeof value !== "string") {
    return fallback;
  }

  const normalized = value.trim().replace(/^#/u, "").toUpperCase();
  if (/^[0-9A-F]{6}$/u.test(normalized)) {
    return `#${normalized}`;
  }
  return fallback;
};

export const DEFAULT_GRADE_STRUCTURE = DEFAULT_GRADE_LEVELS.map((grade, index) => ({
  grade,
  sections: [],
  color: getDefaultGradeColor(index),
}));

export const normalizeStringList = (input, fallback = []) => {
  const source = Array.isArray(input) ? input : [];
  const normalized = source
    .map((value) => (typeof value === "string" ? value.trim() : ""))
    .filter((value) => value.length > 0);

  const unique = [];
  normalized.forEach((value) => {
    if (!unique.includes(value)) {
      unique.push(value);
    }
  });

  return unique.length > 0 ? unique : [...fallback];
};

export const normalizeGradeStructure = (
  input,
  fallback = DEFAULT_GRADE_STRUCTURE,
  { useFallbackWhenEmpty = true } = {}
) => {
  const source = Array.isArray(input) ? input : [];
  const normalized = [];
  const seenGrades = new Set();
  const fallbackColorMap = new Map();

  (Array.isArray(fallback) ? fallback : []).forEach((entry = {}, index) => {
    if (!entry || typeof entry !== "object") {
      return;
    }
    const key = typeof entry.grade === "string" ? entry.grade.trim().toLowerCase() : "";
    if (!key) {
      return;
    }
    fallbackColorMap.set(key, sanitizeHexColor(entry.color, getDefaultGradeColor(index)));
  });

  source.forEach((entry) => {
    let gradeName = "";
    let sections = [];
    let rawColor = "";

    if (typeof entry === "string") {
      gradeName = entry.trim();
    } else if (entry && typeof entry === "object") {
      if (typeof entry.grade === "string") {
        gradeName = entry.grade.trim();
      } else if (typeof entry.name === "string") {
        gradeName = entry.name.trim();
      }

      if (Array.isArray(entry.sections)) {
        sections = entry.sections;
      } else if (Array.isArray(entry.sectionList)) {
        sections = entry.sectionList;
      }
      if (typeof entry.color === "string") {
        rawColor = entry.color;
      } else if (typeof entry.barColor === "string") {
        rawColor = entry.barColor;
      } else if (typeof entry.stripeColor === "string") {
        rawColor = entry.stripeColor;
      }
    }

    if (!gradeName || seenGrades.has(gradeName.toLowerCase())) {
      return;
    }

    const gradeKey = gradeName.toLowerCase();
    const normalizedColor = sanitizeHexColor(
      rawColor,
      fallbackColorMap.get(gradeKey) || getDefaultGradeColor(normalized.length),
    );

    normalized.push({
      grade: gradeName,
      sections: normalizeStringList(sections),
      color: normalizedColor,
    });
    seenGrades.add(gradeKey);
    fallbackColorMap.set(gradeKey, normalizedColor);
  });

  if (normalized.length === 0) {
    if (useFallbackWhenEmpty && Array.isArray(fallback) && fallback.length > 0) {
      return fallback.map((entry = {}, index) => ({
        grade: entry.grade,
        sections: Array.isArray(entry.sections) ? [...entry.sections] : [],
        color: sanitizeHexColor(entry.color, getDefaultGradeColor(index)),
      }));
    }
    return [];
  }

  return normalized;
};

export const buildGradeColorMap = (gradeStructure = []) => {
  const entries = Array.isArray(gradeStructure) ? gradeStructure : [];
  return entries.reduce((acc, entry = {}, index) => {
    const key = typeof entry.grade === "string" ? entry.grade.trim().toLowerCase() : "";
    if (!key) {
      return acc;
    }
    acc[key] = sanitizeHexColor(entry.color, getDefaultGradeColor(index));
    return acc;
  }, {});
};

export const getSectionsForGrade = (gradeStructure = [], gradeName) => {
  if (!gradeName) {
    return [];
  }
  const match = (gradeStructure || []).find(
    (entry) => entry.grade && entry.grade.toLowerCase() === gradeName.toLowerCase()
  );
  return match ? [...match.sections] : [];
};

export const collectAllSections = (gradeStructure = []) => {
  const sectionSet = new Set();
  (gradeStructure || []).forEach((entry = {}) => {
    (entry.sections || []).forEach((section) => {
      const trimmed = typeof section === "string" ? section.trim() : "";
      if (trimmed) {
        sectionSet.add(trimmed);
      }
    });
  });
  return Array.from(sectionSet);
};

export const ensureUserAttributes = (attributes = {}) => {
  const curriculum = normalizeStringList(
    attributes.curriculum ?? attributes.curricula,
    DEFAULT_CURRICULA
  );

  const gradeStructureSource =
    attributes.gradeStructure ?? attributes.gradeStructures ?? attributes.gradeLevels;
  const gradeStructure = normalizeGradeStructure(
    gradeStructureSource,
    DEFAULT_GRADE_STRUCTURE
  );
  const structureGrades = gradeStructure.map((entry) => entry.grade);
  const gradeLevels = normalizeStringList(
    attributes.gradeLevels,
    structureGrades.length > 0 ? structureGrades : DEFAULT_GRADE_LEVELS
  );

  return {
    curriculum,
    gradeLevels,
    gradeStructure,
  };
};
```

## userAttributes.test.js

| Field | Details |
| --- | --- |
| Program Name | userAttributes.test.js |
| Description | Frontend utility helper for shared logic. |
| Called by | None |
| Table used | None |
|  |  |
| Programmer | Nazel Asca√±o |
| Date created | 12/14/2025 |
| Revision Date | TBD |
| Revision / description of change | None |

```javascript
import {
  DEFAULT_GRADE_LEVELS,
  DEFAULT_GRADE_STRUCTURE,
  normalizeGradeStructure,
  getSectionsForGrade,
  collectAllSections,
  ensureUserAttributes,
} from "../userAttributes";

describe("normalizeGradeStructure", () => {
  it("normalizes strings, objects, and section lists while removing duplicates", () => {
    const raw = [
      "Grade 7",
      { grade: "Grade 8", sections: ["Alpha", "alpha", " Beta "] },
      { name: "Grade 9", sectionList: ["Gamma", "", "Gamma", "Delta"] },
      { grade: "grade 7", sections: ["Zeta"] },
      null,
      42,
    ];

    const normalized = normalizeGradeStructure(raw);

    expect(normalized).toHaveLength(3);
    expect(normalized[0]).toMatchObject({ grade: "Grade 7", sections: [] });
    expect(normalized[1]).toMatchObject({ grade: "Grade 8", sections: ["Alpha", "alpha", "Beta"] });
    expect(normalized[2]).toMatchObject({ grade: "Grade 9", sections: ["Gamma", "Delta"] });
    normalized.forEach((entry) => {
      expect(entry.color).toMatch(/^#[0-9A-F]{6}$/);
    });
  });

  it("returns fallback copy when input is empty", () => {
    const fallback = [
      { grade: "Special Grade", sections: ["S1"] },
      { grade: "Special Grade 2", sections: [] },
    ];

    const normalized = normalizeGradeStructure([], fallback);

    expect(normalized).toHaveLength(2);
    normalized.forEach((entry, index) => {
      expect(entry).toMatchObject({ grade: fallback[index].grade, sections: fallback[index].sections });
      expect(entry.color).toMatch(/^#[0-9A-F]{6}$/);
    });
    expect(normalized).not.toBe(fallback);
  });

  it("allows returning an empty list when requested", () => {
    const normalized = normalizeGradeStructure([], DEFAULT_GRADE_STRUCTURE, {
      useFallbackWhenEmpty: false,
    });

    expect(normalized).toEqual([]);
  });
});

describe("getSectionsForGrade", () => {
  const structure = [
    { grade: "Grade 11", sections: ["STEM-A", "STEM-B"] },
    { grade: "Grade 12", sections: ["ABM-A"] },
  ];

  it("matches grade names case-insensitively", () => {
    expect(getSectionsForGrade(structure, "grade 11")).toEqual(["STEM-A", "STEM-B"]);
    expect(getSectionsForGrade(structure, "GRADE 12")).toEqual(["ABM-A"]);
  });

  it("falls back to empty array when grade missing", () => {
    expect(getSectionsForGrade(structure, "Grade 10")).toEqual([]);
    expect(getSectionsForGrade(structure, "")).toEqual([]);
    expect(getSectionsForGrade(null, "Grade 11")).toEqual([]);
  });
});

describe("collectAllSections", () => {
  it("collects unique, trimmed sections across the structure", () => {
    const gradeStructure = [
      { grade: "Grade 7", sections: ["Alpha", "Beta"] },
      { grade: "Grade 8", sections: [" Beta ", "Gamma"] },
      { grade: "Grade 9", sections: ["gamma", "delta", ""] },
    ];

    expect(collectAllSections(gradeStructure)).toEqual([
      "Alpha",
      "Beta",
      "Gamma",
      "gamma",
      "delta",
    ]);
  });
});

describe("ensureUserAttributes", () => {
  it("derives gradeLevels from the normalized gradeStructure when not provided", () => {
    const attributes = {
      gradeStructure: [
        { grade: "Grade X", sections: ["Section 1"] },
        { grade: "Grade Y", sections: [] },
      ],
      curriculum: ["STEM"],
    };

    const result = ensureUserAttributes(attributes);

    expect(result.gradeStructure).toHaveLength(2);
    expect(result.gradeStructure[0]).toMatchObject({ grade: "Grade X", sections: ["Section 1"] });
    expect(result.gradeStructure[1]).toMatchObject({ grade: "Grade Y", sections: [] });
    result.gradeStructure.forEach((entry) => {
      expect(entry.color).toMatch(/^#[0-9A-F]{6}$/);
    });
    expect(result.gradeLevels).toEqual(["Grade X", "Grade Y"]);
    expect(result.curriculum).toEqual(["STEM"]);
  });

  it("falls back to defaults when nothing is provided", () => {
    const result = ensureUserAttributes();

    expect(result.gradeStructure).toEqual(DEFAULT_GRADE_STRUCTURE);
    expect(result.gradeLevels).toEqual(DEFAULT_GRADE_LEVELS);
    expect(result.curriculum.length).toBeGreaterThan(0);
  });
});
```

# Other

## debug-routes.js

| Field | Details |
| --- | --- |
| Program Name | debug-routes.js |
| Description | Source file located at debug-routes.js. |
| Called by | None |
| Table used | None |
|  |  |
| Programmer | Nazel Asca√±o |
| Date created | 12/14/2025 |
| Revision Date | TBD |
| Revision / description of change | None |

```javascript
const http = require('http');

function makeRequest(options, data) {
    return new Promise((resolve, reject) => {
        const req = http.request(options, (res) => {
            let body = '';
            res.on('data', chunk => body += chunk);
            res.on('end', () => {
                try {
                    const parsed = JSON.parse(body);
                    resolve({ status: res.statusCode, data: parsed, headers: res.headers });
                } catch (e) {
                    resolve({ status: res.statusCode, data: body, headers: res.headers });
                }
            });
        });

        req.on('error', reject);

        if (data) {
            req.write(JSON.stringify(data));
        }
        req.end();
    });
}

async function debugTransactionRoute() {
    try {

        console.log('1. Logging in...');
        const loginResponse = await makeRequest({
            hostname: 'localhost',
            port: 5001,
            path: '/api/auth/login',
            method: 'POST',
            headers: { 'Content-Type': 'application/json' }
        }, {
            usernameOrEmail: 'admin',
            password: 'admin123456'
        });

        if (loginResponse.status !== 200) {
            console.log('‚ùå Login failed:', loginResponse);
            return;
        }

        const token = loginResponse.data.token;
        console.log('‚úÖ Login successful, token obtained');

        console.log('2. Testing GET /api/transactions...');
        const transactionsResponse = await makeRequest({
            hostname: 'localhost',
            port: 5001,
            path: '/api/transactions',
            method: 'GET',
            headers: { Authorization: `Bearer ${token}` }
        });
        console.log('‚úÖ Transactions endpoint accessible, status:', transactionsResponse.status);

        console.log('3. Testing POST /api/transactions/borrow...');
        const borrowResponse = await makeRequest({
            hostname: 'localhost',
            port: 5001,
            path: '/api/transactions/borrow',
            method: 'POST',
            headers: {
                Authorization: `Bearer ${token}`,
                'Content-Type': 'application/json'
            }
        }, {
            userId: 'mgg4voti2m1t0',
            items: [{
                copyId: '978-0123456789-MGG4VON8-ZZD4'
            }],
            type: 'regular',
            notes: 'Test borrow'
        });

        console.log('Borrow response status:', borrowResponse.status);
        console.log('Borrow response data:', borrowResponse.data);

    } catch (error) {
        console.error('Debug error:', error.message);
    }
}

debugTransactionRoute();
```

## package.json

| Field | Details |
| --- | --- |
| Program Name | package.json |
| Description | Project configuration or data file. |
| Called by | None |
| Table used | None |
|  |  |
| Programmer | Nazel Asca√±o |
| Date created | 12/14/2025 |
| Revision Date | TBD |
| Revision / description of change | None |

```json
{
    "name": "olms-online-library-management",
    "version": "1.0.0",
    "description": "Online Library Management System with React frontend and Node.js backend",
    "main": "index.js",
    "scripts": {
        "start": "node start.js",
        "dev": "concurrently \"npm run server:dev\" \"npm run client:dev\"",
    "dev:offline": "cross-env USE_OFFLINE_DB=true npm run dev",
    "dev:auto": "node scripts/start-auto.js --target=both",
        "server:dev": "cd backend && npm run dev",
        "client:dev": "cd frontend && npm run dev",
        "server:start": "cd backend && npm start",
        "client:build": "cd frontend && npm run build",
        "install:all": "npm install && cd frontend && npm install && cd ../backend && npm install",
        "build": "cd frontend && npm run build",
    "test": "cd frontend && npm test",
        "server:dev:auto": "node scripts/start-auto.js --target=backend",
        "client:dev:auto": "node scripts/start-auto.js --target=frontend",
        "keep-alive": "node scripts/keep-alive.js"
    },
    "keywords": [
        "library-management",
        "react",
        "nodejs",
        "mongodb",
        "jwt-auth"
    ],
    "author": "OLMS Development Team",
    "license": "MIT",
    "devDependencies": {
        "concurrently": "^8.2.2",
        "cross-env": "^7.0.3"
    }
}
```

## render.yaml

| Field | Details |
| --- | --- |
| Program Name | render.yaml |
| Description | Deployment or configuration file. |
| Called by | None |
| Table used | None |
|  |  |
| Programmer | Nazel Asca√±o |
| Date created | 12/14/2025 |
| Revision Date | TBD |
| Revision / description of change | None |

```yaml
services:
  - type: web
    name: olms-backend
    env: node
    plan: free
    rootDir: backend
    buildCommand: npm install
    startCommand: npm start
    envVars:
      - key: NODE_VERSION
        value: "18"
      - key: NPM_VERSION
        value: "10"
      - key: FRONTEND_URL
        value: "https://olms-blush.vercel.app"
      - key: MONGODB_URI
        sync: false
      - key: MONGO_DB_NAME
        value: "olms"
      - key: JWT_SECRET
        sync: false
      - key: EMAIL_SERVICE
        value: "gmail"
      - key: EMAIL_USER
        sync: false
      - key: EMAIL_PASS
        sync: false
      - key: USE_OFFLINE_DB
        value: "false"
    healthCheckPath: /health
    autoDeploy: true
```

## START_OLMS.bat

| Field | Details |
| --- | --- |
| Program Name | START_OLMS.bat |
| Description | Automation or startup script. |
| Called by | None |
| Table used | None |
|  |  |
| Programmer | Nazel Asca√±o |
| Date created | 12/14/2025 |
| Revision Date | TBD |
| Revision / description of change | None |

```bat
@echo off

title OLMS - Offline Library Management System

echo.
echo ========================================================
echo  OLMS - Offline Library Management System
echo  Single File Launcher
echo ========================================================
echo.

if not exist "backend\server.js" (
    echo ERROR: Please run this file from the OLMS root directory
    echo Expected: backend\server.js should exist
    pause
    exit /b 1
)

if not exist "frontend\package.json" (
    echo ERROR: Please run this file from the OLMS root directory
    echo Expected: frontend\package.json should exist
    pause
    exit /b 1
)

echo [1/6] Checking Node.js installation...
node --version >nul 2>&1
if errorlevel 1 (
    echo ERROR: Node.js is not installed!
    echo Please download and install Node.js from: https://nodejs.org/
    pause
    exit /b 1
)
echo ‚úì Node.js found

echo.
echo [2/6] Stopping any existing servers...
taskkill /F /IM node.exe >nul 2>&1
timeout /t 2 /nobreak >nul

echo.
echo [3/6] Installing backend dependencies...
cd backend
if not exist "node_modules" (
    echo Installing backend packages...
    npm install
) else (
    echo ‚úì Backend dependencies already installed
)

echo.
echo [4/6] Installing frontend dependencies...
cd ..\frontend
if not exist "node_modules" (
    echo Installing frontend packages...
    npm install
) else (
    echo ‚úì Frontend dependencies already installed
)

cd ..

echo.
echo [5/6] Starting backend server...
start /B "OLMS Backend" cmd /c "cd backend && node server.js"
timeout /t 3 /nobreak >nul

echo.
echo [6/6] Starting frontend server...
set "HOST=0.0.0.0"
set "PORT=3001"
set "BROWSER=none"
start /B "OLMS Frontend" cmd /c "cd frontend && npm start"
set "HOST="
set "PORT="
set "BROWSER="

echo.
echo ========================================================
echo  OLMS System Starting...
echo ========================================================
echo.
echo  Backend API:     http://localhost:5001
echo  Frontend App:    http://localhost:3001
echo  Admin Login:     admin / admin123456
echo.
echo  The system is starting up...
echo  Your browser will open automatically in a few seconds.
echo.
echo  Press any key to open the application now, or
echo  wait 15 seconds for automatic opening...
echo ========================================================

timeout /t 15 /nobreak
start http://localhost:3001

echo.
echo OLMS is now running!
echo.
echo To stop the system:
echo 1. Close this window
echo 2. Or press Ctrl+C in the server windows
echo.
pause
```

## tmp_replace.py

| Field | Details |
| --- | --- |
| Program Name | tmp_replace.py |
| Description | Source file located at tmp_replace.py. |
| Called by | None |
| Table used | None |
|  |  |
| Programmer | Nazel Asca√±o |
| Date created | 12/14/2025 |
| Revision Date | TBD |
| Revision / description of change | None |

```python
from pathlib import Path

root = Path(__file__).resolve().parent
extensions = {'.js', '.jsx', '.ts', '.tsx', '.json', '.md', '.ps1', '.yml', '.yaml', '.txt', '.html', '.css'}
skip_prefixes = [
    Path('frontend/build'),
    Path('frontend/node_modules'),
    Path('node_modules'),
    Path('.git'),
    Path('backend/uploads'),
]
allowed_prefixes = [
    Path('frontend/src'),
    Path('frontend/public'),
    Path('backend/routes'),
    Path('backend/test'),
]
replacements = [
    ('Copy IDs', 'Reference IDs'),
    ('copy IDs', 'Reference IDs'),
    ('copy ids', 'Reference IDs'),
    ('Copy Ids', 'Reference IDs'),
    ('copy Ids', 'Reference IDs'),
    ('Copy ID', 'Reference ID'),
    ('copy ID', 'Reference ID'),
    ('Copy id', 'Reference ID'),
    ('copy id', 'Reference ID'),
]

modified = []

for file_path in root.rglob('*'):
    if not file_path.is_file():
        continue
    rel = file_path.relative_to(root)
    skip = False
    for prefix in skip_prefixes:
        try:
            rel.relative_to(prefix)
            skip = True
            break
        except ValueError:
            continue
    if skip:
        continue

    if allowed_prefixes:
        permitted = False
        for prefix in allowed_prefixes:
            try:
                rel.relative_to(prefix)
                permitted = True
                break
            except ValueError:
                continue
        if not permitted:
            continue
    if file_path.suffix.lower() not in extensions:
        continue
    try:
        text = file_path.read_text(encoding='utf-8')
    except UnicodeDecodeError:
        continue
    new_text = text
    for old, new in replacements:
        new_text = new_text.replace(old, new)
    if new_text != text:
        file_path.write_text(new_text, encoding='utf-8')
        modified.append(str(rel).replace('\\', '/'))

print('Modified files:')
for path in modified:
    print(path)
print(f'Total: {len(modified)} files updated')
```

## vercel.json

| Field | Details |
| --- | --- |
| Program Name | vercel.json |
| Description | Project configuration or data file. |
| Called by | None |
| Table used | None |
|  |  |
| Programmer | Nazel Asca√±o |
| Date created | 12/14/2025 |
| Revision Date | TBD |
| Revision / description of change | None |

```json
{
  "$schema": "https://openapi.vercel.sh/vercel.json",
  "framework": "create-react-app",
  "installCommand": "cd frontend && npm install",
  "buildCommand": "cd frontend && npm run build",
  "outputDirectory": "frontend/build"
}
```
-->
